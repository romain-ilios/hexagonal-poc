"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@babel+parser@7.27.0";
exports.ids = ["vendor-chunks/@babel+parser@7.27.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@babel+parser@7.27.0/node_modules/@babel/parser/lib/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/@babel+parser@7.27.0/node_modules/@babel/parser/lib/index.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (-1 !== e.indexOf(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\nclass Position {\n  constructor(line, col, index) {\n    this.line = void 0;\n    this.column = void 0;\n    this.index = void 0;\n    this.line = line;\n    this.column = col;\n    this.index = index;\n  }\n}\nclass SourceLocation {\n  constructor(start, end) {\n    this.start = void 0;\n    this.end = void 0;\n    this.filename = void 0;\n    this.identifierName = void 0;\n    this.start = start;\n    this.end = end;\n  }\n}\nfunction createPositionWithColumnOffset(position, columnOffset) {\n  const {\n    line,\n    column,\n    index\n  } = position;\n  return new Position(line, column + columnOffset, index + columnOffset);\n}\nconst code = \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\";\nvar ModuleErrors = {\n  ImportMetaOutsideModule: {\n    message: `import.meta may appear only with 'sourceType: \"module\"'`,\n    code\n  },\n  ImportOutsideModule: {\n    message: `'import' and 'export' may appear only with 'sourceType: \"module\"'`,\n    code\n  }\n};\nconst NodeDescriptions = {\n  ArrayPattern: \"array destructuring pattern\",\n  AssignmentExpression: \"assignment expression\",\n  AssignmentPattern: \"assignment expression\",\n  ArrowFunctionExpression: \"arrow function expression\",\n  ConditionalExpression: \"conditional expression\",\n  CatchClause: \"catch clause\",\n  ForOfStatement: \"for-of statement\",\n  ForInStatement: \"for-in statement\",\n  ForStatement: \"for-loop\",\n  FormalParameters: \"function parameter list\",\n  Identifier: \"identifier\",\n  ImportSpecifier: \"import specifier\",\n  ImportDefaultSpecifier: \"import default specifier\",\n  ImportNamespaceSpecifier: \"import namespace specifier\",\n  ObjectPattern: \"object destructuring pattern\",\n  ParenthesizedExpression: \"parenthesized expression\",\n  RestElement: \"rest element\",\n  UpdateExpression: {\n    true: \"prefix operation\",\n    false: \"postfix operation\"\n  },\n  VariableDeclarator: \"variable declaration\",\n  YieldExpression: \"yield expression\"\n};\nconst toNodeDescription = node => node.type === \"UpdateExpression\" ? NodeDescriptions.UpdateExpression[`${node.prefix}`] : NodeDescriptions[node.type];\nvar StandardErrors = {\n  AccessorIsGenerator: ({\n    kind\n  }) => `A ${kind}ter cannot be a generator.`,\n  ArgumentsInClass: \"'arguments' is only allowed in functions and class methods.\",\n  AsyncFunctionInSingleStatementContext: \"Async functions can only be declared at the top level or inside a block.\",\n  AwaitBindingIdentifier: \"Can not use 'await' as identifier inside an async function.\",\n  AwaitBindingIdentifierInStaticBlock: \"Can not use 'await' as identifier inside a static block.\",\n  AwaitExpressionFormalParameter: \"'await' is not allowed in async function parameters.\",\n  AwaitUsingNotInAsyncContext: \"'await using' is only allowed within async functions and at the top levels of modules.\",\n  AwaitNotInAsyncContext: \"'await' is only allowed within async functions and at the top levels of modules.\",\n  BadGetterArity: \"A 'get' accessor must not have any formal parameters.\",\n  BadSetterArity: \"A 'set' accessor must have exactly one formal parameter.\",\n  BadSetterRestParameter: \"A 'set' accessor function argument must not be a rest parameter.\",\n  ConstructorClassField: \"Classes may not have a field named 'constructor'.\",\n  ConstructorClassPrivateField: \"Classes may not have a private field named '#constructor'.\",\n  ConstructorIsAccessor: \"Class constructor may not be an accessor.\",\n  ConstructorIsAsync: \"Constructor can't be an async function.\",\n  ConstructorIsGenerator: \"Constructor can't be a generator.\",\n  DeclarationMissingInitializer: ({\n    kind\n  }) => `Missing initializer in ${kind} declaration.`,\n  DecoratorArgumentsOutsideParentheses: \"Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.\",\n  DecoratorBeforeExport: \"Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.\",\n  DecoratorsBeforeAfterExport: \"Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.\",\n  DecoratorConstructor: \"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\",\n  DecoratorExportClass: \"Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.\",\n  DecoratorSemicolon: \"Decorators must not be followed by a semicolon.\",\n  DecoratorStaticBlock: \"Decorators can't be used with a static block.\",\n  DeferImportRequiresNamespace: 'Only `import defer * as x from \"./module\"` is valid.',\n  DeletePrivateField: \"Deleting a private field is not allowed.\",\n  DestructureNamedImport: \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n  DuplicateConstructor: \"Duplicate constructor in the same class.\",\n  DuplicateDefaultExport: \"Only one default export allowed per module.\",\n  DuplicateExport: ({\n    exportName\n  }) => `\\`${exportName}\\` has already been exported. Exported identifiers must be unique.`,\n  DuplicateProto: \"Redefinition of __proto__ property.\",\n  DuplicateRegExpFlags: \"Duplicate regular expression flag.\",\n  DynamicImportPhaseRequiresImportExpressions: ({\n    phase\n  }) => `'import.${phase}(...)' can only be parsed when using the 'createImportExpressions' option.`,\n  ElementAfterRest: \"Rest element must be last element.\",\n  EscapedCharNotAnIdentifier: \"Invalid Unicode escape.\",\n  ExportBindingIsString: ({\n    localName,\n    exportName\n  }) => `A string literal cannot be used as an exported binding without \\`from\\`.\\n- Did you mean \\`export { '${localName}' as '${exportName}' } from 'some-module'\\`?`,\n  ExportDefaultFromAsIdentifier: \"'from' is not allowed as an identifier after 'export default'.\",\n  ForInOfLoopInitializer: ({\n    type\n  }) => `'${type === \"ForInStatement\" ? \"for-in\" : \"for-of\"}' loop variable declaration may not have an initializer.`,\n  ForInUsing: \"For-in loop may not start with 'using' declaration.\",\n  ForOfAsync: \"The left-hand side of a for-of loop may not be 'async'.\",\n  ForOfLet: \"The left-hand side of a for-of loop may not start with 'let'.\",\n  GeneratorInSingleStatementContext: \"Generators can only be declared at the top level or inside a block.\",\n  IllegalBreakContinue: ({\n    type\n  }) => `Unsyntactic ${type === \"BreakStatement\" ? \"break\" : \"continue\"}.`,\n  IllegalLanguageModeDirective: \"Illegal 'use strict' directive in function with non-simple parameter list.\",\n  IllegalReturn: \"'return' outside of function.\",\n  ImportAttributesUseAssert: \"The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.\",\n  ImportBindingIsString: ({\n    importName\n  }) => `A string literal cannot be used as an imported binding.\\n- Did you mean \\`import { \"${importName}\" as foo }\\`?`,\n  ImportCallArity: `\\`import()\\` requires exactly one or two arguments.`,\n  ImportCallNotNewExpression: \"Cannot use new with import(...).\",\n  ImportCallSpreadArgument: \"`...` is not allowed in `import()`.\",\n  ImportJSONBindingNotDefault: \"A JSON module can only be imported with `default`.\",\n  ImportReflectionHasAssertion: \"`import module x` cannot have assertions.\",\n  ImportReflectionNotBinding: 'Only `import module x from \"./module\"` is valid.',\n  IncompatibleRegExpUVFlags: \"The 'u' and 'v' regular expression flags cannot be enabled at the same time.\",\n  InvalidBigIntLiteral: \"Invalid BigIntLiteral.\",\n  InvalidCodePoint: \"Code point out of bounds.\",\n  InvalidCoverInitializedName: \"Invalid shorthand property initializer.\",\n  InvalidDecimal: \"Invalid decimal.\",\n  InvalidDigit: ({\n    radix\n  }) => `Expected number in radix ${radix}.`,\n  InvalidEscapeSequence: \"Bad character escape sequence.\",\n  InvalidEscapeSequenceTemplate: \"Invalid escape sequence in template.\",\n  InvalidEscapedReservedWord: ({\n    reservedWord\n  }) => `Escape sequence in keyword ${reservedWord}.`,\n  InvalidIdentifier: ({\n    identifierName\n  }) => `Invalid identifier ${identifierName}.`,\n  InvalidLhs: ({\n    ancestor\n  }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,\n  InvalidLhsBinding: ({\n    ancestor\n  }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,\n  InvalidLhsOptionalChaining: ({\n    ancestor\n  }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,\n  InvalidNumber: \"Invalid number.\",\n  InvalidOrMissingExponent: \"Floating-point numbers require a valid exponent after the 'e'.\",\n  InvalidOrUnexpectedToken: ({\n    unexpected\n  }) => `Unexpected character '${unexpected}'.`,\n  InvalidParenthesizedAssignment: \"Invalid parenthesized assignment pattern.\",\n  InvalidPrivateFieldResolution: ({\n    identifierName\n  }) => `Private name #${identifierName} is not defined.`,\n  InvalidPropertyBindingPattern: \"Binding member expression.\",\n  InvalidRecordProperty: \"Only properties and spread elements are allowed in record definitions.\",\n  InvalidRestAssignmentPattern: \"Invalid rest operator's argument.\",\n  LabelRedeclaration: ({\n    labelName\n  }) => `Label '${labelName}' is already declared.`,\n  LetInLexicalBinding: \"'let' is disallowed as a lexically bound name.\",\n  LineTerminatorBeforeArrow: \"No line break is allowed before '=>'.\",\n  MalformedRegExpFlags: \"Invalid regular expression flag.\",\n  MissingClassName: \"A class name is required.\",\n  MissingEqInAssignment: \"Only '=' operator can be used for specifying default value.\",\n  MissingSemicolon: \"Missing semicolon.\",\n  MissingPlugin: ({\n    missingPlugin\n  }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map(name => JSON.stringify(name)).join(\", \")}.`,\n  MissingOneOfPlugins: ({\n    missingPlugin\n  }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map(name => JSON.stringify(name)).join(\", \")}.`,\n  MissingUnicodeEscape: \"Expecting Unicode escape sequence \\\\uXXXX.\",\n  MixingCoalesceWithLogical: \"Nullish coalescing operator(??) requires parens when mixing with logical operators.\",\n  ModuleAttributeDifferentFromType: \"The only accepted module attribute is `type`.\",\n  ModuleAttributeInvalidValue: \"Only string literals are allowed as module attribute values.\",\n  ModuleAttributesWithDuplicateKeys: ({\n    key\n  }) => `Duplicate key \"${key}\" is not allowed in module attributes.`,\n  ModuleExportNameHasLoneSurrogate: ({\n    surrogateCharCode\n  }) => `An export name cannot include a lone surrogate, found '\\\\u${surrogateCharCode.toString(16)}'.`,\n  ModuleExportUndefined: ({\n    localName\n  }) => `Export '${localName}' is not defined.`,\n  MultipleDefaultsInSwitch: \"Multiple default clauses.\",\n  NewlineAfterThrow: \"Illegal newline after throw.\",\n  NoCatchOrFinally: \"Missing catch or finally clause.\",\n  NumberIdentifier: \"Identifier directly after number.\",\n  NumericSeparatorInEscapeSequence: \"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.\",\n  ObsoleteAwaitStar: \"'await*' has been removed from the async functions proposal. Use Promise.all() instead.\",\n  OptionalChainingNoNew: \"Constructors in/after an Optional Chain are not allowed.\",\n  OptionalChainingNoTemplate: \"Tagged Template Literals are not allowed in optionalChain.\",\n  OverrideOnConstructor: \"'override' modifier cannot appear on a constructor declaration.\",\n  ParamDupe: \"Argument name clash.\",\n  PatternHasAccessor: \"Object pattern can't contain getter or setter.\",\n  PatternHasMethod: \"Object pattern can't contain methods.\",\n  PrivateInExpectedIn: ({\n    identifierName\n  }) => `Private names are only allowed in property accesses (\\`obj.#${identifierName}\\`) or in \\`in\\` expressions (\\`#${identifierName} in obj\\`).`,\n  PrivateNameRedeclaration: ({\n    identifierName\n  }) => `Duplicate private name #${identifierName}.`,\n  RecordExpressionBarIncorrectEndSyntaxType: \"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionBarIncorrectStartSyntaxType: \"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionHashIncorrectStartSyntaxType: \"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  RecordNoProto: \"'__proto__' is not allowed in Record expressions.\",\n  RestTrailingComma: \"Unexpected trailing comma after rest element.\",\n  SloppyFunction: \"In non-strict mode code, functions can only be declared at top level or inside a block.\",\n  SloppyFunctionAnnexB: \"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.\",\n  SourcePhaseImportRequiresDefault: 'Only `import source x from \"./module\"` is valid.',\n  StaticPrototype: \"Classes may not have static property named prototype.\",\n  SuperNotAllowed: \"`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?\",\n  SuperPrivateField: \"Private fields can't be accessed on super.\",\n  TrailingDecorator: \"Decorators must be attached to a class element.\",\n  TupleExpressionBarIncorrectEndSyntaxType: \"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionBarIncorrectStartSyntaxType: \"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionHashIncorrectStartSyntaxType: \"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  UnexpectedArgumentPlaceholder: \"Unexpected argument placeholder.\",\n  UnexpectedAwaitAfterPipelineBody: 'Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal.',\n  UnexpectedDigitAfterHash: \"Unexpected digit after hash token.\",\n  UnexpectedImportExport: \"'import' and 'export' may only appear at the top level.\",\n  UnexpectedKeyword: ({\n    keyword\n  }) => `Unexpected keyword '${keyword}'.`,\n  UnexpectedLeadingDecorator: \"Leading decorators must be attached to a class declaration.\",\n  UnexpectedLexicalDeclaration: \"Lexical declaration cannot appear in a single-statement context.\",\n  UnexpectedNewTarget: \"`new.target` can only be used in functions or class properties.\",\n  UnexpectedNumericSeparator: \"A numeric separator is only allowed between two digits.\",\n  UnexpectedPrivateField: \"Unexpected private name.\",\n  UnexpectedReservedWord: ({\n    reservedWord\n  }) => `Unexpected reserved word '${reservedWord}'.`,\n  UnexpectedSuper: \"'super' is only allowed in object methods and classes.\",\n  UnexpectedToken: ({\n    expected,\n    unexpected\n  }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : \"\"}${expected ? `, expected \"${expected}\"` : \"\"}`,\n  UnexpectedTokenUnaryExponentiation: \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\",\n  UnexpectedUsingDeclaration: \"Using declaration cannot appear in the top level when source type is `script`.\",\n  UnsupportedBind: \"Binding should be performed on object property.\",\n  UnsupportedDecoratorExport: \"A decorated export must export a class declaration.\",\n  UnsupportedDefaultExport: \"Only expressions, functions or classes are allowed as the `default` export.\",\n  UnsupportedImport: \"`import` can only be used in `import()` or `import.meta`.\",\n  UnsupportedMetaProperty: ({\n    target,\n    onlyValidPropertyName\n  }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,\n  UnsupportedParameterDecorator: \"Decorators cannot be used to decorate parameters.\",\n  UnsupportedPropertyDecorator: \"Decorators cannot be used to decorate object literal properties.\",\n  UnsupportedSuper: \"'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).\",\n  UnterminatedComment: \"Unterminated comment.\",\n  UnterminatedRegExp: \"Unterminated regular expression.\",\n  UnterminatedString: \"Unterminated string constant.\",\n  UnterminatedTemplate: \"Unterminated template.\",\n  UsingDeclarationExport: \"Using declaration cannot be exported.\",\n  UsingDeclarationHasBindingPattern: \"Using declaration cannot have destructuring patterns.\",\n  VarRedeclaration: ({\n    identifierName\n  }) => `Identifier '${identifierName}' has already been declared.`,\n  YieldBindingIdentifier: \"Can not use 'yield' as identifier inside a generator.\",\n  YieldInParameter: \"Yield expression is not allowed in formal parameters.\",\n  YieldNotInGeneratorFunction: \"'yield' is only allowed within generator functions.\",\n  ZeroDigitNumericSeparator: \"Numeric separator can not be used after leading 0.\"\n};\nvar StrictModeErrors = {\n  StrictDelete: \"Deleting local variable in strict mode.\",\n  StrictEvalArguments: ({\n    referenceName\n  }) => `Assigning to '${referenceName}' in strict mode.`,\n  StrictEvalArgumentsBinding: ({\n    bindingName\n  }) => `Binding '${bindingName}' in strict mode.`,\n  StrictFunction: \"In strict mode code, functions can only be declared at top level or inside a block.\",\n  StrictNumericEscape: \"The only valid numeric escape in strict mode is '\\\\0'.\",\n  StrictOctalLiteral: \"Legacy octal literals are not allowed in strict mode.\",\n  StrictWith: \"'with' in strict mode.\"\n};\nconst UnparenthesizedPipeBodyDescriptions = new Set([\"ArrowFunctionExpression\", \"AssignmentExpression\", \"ConditionalExpression\", \"YieldExpression\"]);\nvar PipelineOperatorErrors = Object.assign({\n  PipeBodyIsTighter: \"Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.\",\n  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.',\n  PipeTopicUnbound: \"Topic reference is unbound; it must be inside a pipe body.\",\n  PipeTopicUnconfiguredToken: ({\n    token\n  }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { \"proposal\": \"hack\", \"topicToken\": \"${token}\" }.`,\n  PipeTopicUnused: \"Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.\",\n  PipeUnparenthesizedBody: ({\n    type\n  }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({\n    type\n  })}; please wrap it in parentheses.`\n}, {\n  PipelineBodyNoArrow: 'Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized.',\n  PipelineBodySequenceExpression: \"Pipeline body may not be a comma-separated sequence expression.\",\n  PipelineHeadSequenceExpression: \"Pipeline head should not be a comma-separated sequence expression.\",\n  PipelineTopicUnused: \"Pipeline is in topic style but does not use topic reference.\",\n  PrimaryTopicNotAllowed: \"Topic reference was used in a lexical context without topic binding.\",\n  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.'\n});\nconst _excluded = [\"message\"];\nfunction defineHidden(obj, key, value) {\n  Object.defineProperty(obj, key, {\n    enumerable: false,\n    configurable: true,\n    value\n  });\n}\nfunction toParseErrorConstructor({\n  toMessage,\n  code,\n  reasonCode,\n  syntaxPlugin\n}) {\n  const hasMissingPlugin = reasonCode === \"MissingPlugin\" || reasonCode === \"MissingOneOfPlugins\";\n  {\n    const oldReasonCodes = {\n      AccessorCannotDeclareThisParameter: \"AccesorCannotDeclareThisParameter\",\n      AccessorCannotHaveTypeParameters: \"AccesorCannotHaveTypeParameters\",\n      ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: \"ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference\",\n      SetAccessorCannotHaveOptionalParameter: \"SetAccesorCannotHaveOptionalParameter\",\n      SetAccessorCannotHaveRestParameter: \"SetAccesorCannotHaveRestParameter\",\n      SetAccessorCannotHaveReturnType: \"SetAccesorCannotHaveReturnType\"\n    };\n    if (oldReasonCodes[reasonCode]) {\n      reasonCode = oldReasonCodes[reasonCode];\n    }\n  }\n  return function constructor(loc, details) {\n    const error = new SyntaxError();\n    error.code = code;\n    error.reasonCode = reasonCode;\n    error.loc = loc;\n    error.pos = loc.index;\n    error.syntaxPlugin = syntaxPlugin;\n    if (hasMissingPlugin) {\n      error.missingPlugin = details.missingPlugin;\n    }\n    defineHidden(error, \"clone\", function clone(overrides = {}) {\n      var _overrides$loc;\n      const {\n        line,\n        column,\n        index\n      } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;\n      return constructor(new Position(line, column, index), Object.assign({}, details, overrides.details));\n    });\n    defineHidden(error, \"details\", details);\n    Object.defineProperty(error, \"message\", {\n      configurable: true,\n      get() {\n        const message = `${toMessage(details)} (${loc.line}:${loc.column})`;\n        this.message = message;\n        return message;\n      },\n      set(value) {\n        Object.defineProperty(this, \"message\", {\n          value,\n          writable: true\n        });\n      }\n    });\n    return error;\n  };\n}\nfunction ParseErrorEnum(argument, syntaxPlugin) {\n  if (Array.isArray(argument)) {\n    return parseErrorTemplates => ParseErrorEnum(parseErrorTemplates, argument[0]);\n  }\n  const ParseErrorConstructors = {};\n  for (const reasonCode of Object.keys(argument)) {\n    const template = argument[reasonCode];\n    const _ref = typeof template === \"string\" ? {\n        message: () => template\n      } : typeof template === \"function\" ? {\n        message: template\n      } : template,\n      {\n        message\n      } = _ref,\n      rest = _objectWithoutPropertiesLoose(_ref, _excluded);\n    const toMessage = typeof message === \"string\" ? () => message : message;\n    ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({\n      code: \"BABEL_PARSER_SYNTAX_ERROR\",\n      reasonCode,\n      toMessage\n    }, syntaxPlugin ? {\n      syntaxPlugin\n    } : {}, rest));\n  }\n  return ParseErrorConstructors;\n}\nconst Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));\nfunction createDefaultOptions() {\n  return {\n    sourceType: \"script\",\n    sourceFilename: undefined,\n    startIndex: 0,\n    startColumn: 0,\n    startLine: 1,\n    allowAwaitOutsideFunction: false,\n    allowReturnOutsideFunction: false,\n    allowNewTargetOutsideFunction: false,\n    allowImportExportEverywhere: false,\n    allowSuperOutsideMethod: false,\n    allowUndeclaredExports: false,\n    allowYieldOutsideFunction: false,\n    plugins: [],\n    strictMode: null,\n    ranges: false,\n    tokens: false,\n    createImportExpressions: false,\n    createParenthesizedExpressions: false,\n    errorRecovery: false,\n    attachComment: true,\n    annexB: true\n  };\n}\nfunction getOptions(opts) {\n  const options = createDefaultOptions();\n  if (opts == null) {\n    return options;\n  }\n  if (opts.annexB != null && opts.annexB !== false) {\n    throw new Error(\"The `annexB` option can only be set to `false`.\");\n  }\n  for (const key of Object.keys(options)) {\n    if (opts[key] != null) options[key] = opts[key];\n  }\n  if (options.startLine === 1) {\n    if (opts.startIndex == null && options.startColumn > 0) {\n      options.startIndex = options.startColumn;\n    } else if (opts.startColumn == null && options.startIndex > 0) {\n      options.startColumn = options.startIndex;\n    }\n  } else if (opts.startColumn == null || opts.startIndex == null) {\n    if (opts.startIndex != null) {\n      throw new Error(\"With a `startLine > 1` you must also specify `startIndex` and `startColumn`.\");\n    }\n  }\n  return options;\n}\nconst {\n  defineProperty\n} = Object;\nconst toUnenumerable = (object, key) => {\n  if (object) {\n    defineProperty(object, key, {\n      enumerable: false,\n      value: object[key]\n    });\n  }\n};\nfunction toESTreeLocation(node) {\n  toUnenumerable(node.loc.start, \"index\");\n  toUnenumerable(node.loc.end, \"index\");\n  return node;\n}\nvar estree = superClass => class ESTreeParserMixin extends superClass {\n  parse() {\n    const file = toESTreeLocation(super.parse());\n    if (this.optionFlags & 256) {\n      file.tokens = file.tokens.map(toESTreeLocation);\n    }\n    return file;\n  }\n  parseRegExpLiteral({\n    pattern,\n    flags\n  }) {\n    let regex = null;\n    try {\n      regex = new RegExp(pattern, flags);\n    } catch (_) {}\n    const node = this.estreeParseLiteral(regex);\n    node.regex = {\n      pattern,\n      flags\n    };\n    return node;\n  }\n  parseBigIntLiteral(value) {\n    let bigInt;\n    try {\n      bigInt = BigInt(value);\n    } catch (_unused) {\n      bigInt = null;\n    }\n    const node = this.estreeParseLiteral(bigInt);\n    node.bigint = String(node.value || value);\n    return node;\n  }\n  parseDecimalLiteral(value) {\n    const decimal = null;\n    const node = this.estreeParseLiteral(decimal);\n    node.decimal = String(node.value || value);\n    return node;\n  }\n  estreeParseLiteral(value) {\n    return this.parseLiteral(value, \"Literal\");\n  }\n  parseStringLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  parseNumericLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  parseNullLiteral() {\n    return this.estreeParseLiteral(null);\n  }\n  parseBooleanLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  directiveToStmt(directive) {\n    const expression = directive.value;\n    delete directive.value;\n    expression.type = \"Literal\";\n    expression.raw = expression.extra.raw;\n    expression.value = expression.extra.expressionValue;\n    const stmt = directive;\n    stmt.type = \"ExpressionStatement\";\n    stmt.expression = expression;\n    stmt.directive = expression.extra.rawValue;\n    delete expression.extra;\n    return stmt;\n  }\n  initFunction(node, isAsync) {\n    super.initFunction(node, isAsync);\n    node.expression = false;\n  }\n  checkDeclaration(node) {\n    if (node != null && this.isObjectProperty(node)) {\n      this.checkDeclaration(node.value);\n    } else {\n      super.checkDeclaration(node);\n    }\n  }\n  getObjectOrClassMethodParams(method) {\n    return method.value.params;\n  }\n  isValidDirective(stmt) {\n    var _stmt$expression$extr;\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && typeof stmt.expression.value === \"string\" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);\n  }\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);\n    const directiveStatements = node.directives.map(d => this.directiveToStmt(d));\n    node.body = directiveStatements.concat(node.body);\n    delete node.directives;\n  }\n  parsePrivateName() {\n    const node = super.parsePrivateName();\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return node;\n      }\n    }\n    return this.convertPrivateNameToPrivateIdentifier(node);\n  }\n  convertPrivateNameToPrivateIdentifier(node) {\n    const name = super.getPrivateNameSV(node);\n    node = node;\n    delete node.id;\n    node.name = name;\n    node.type = \"PrivateIdentifier\";\n    return node;\n  }\n  isPrivateName(node) {\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return super.isPrivateName(node);\n      }\n    }\n    return node.type === \"PrivateIdentifier\";\n  }\n  getPrivateNameSV(node) {\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return super.getPrivateNameSV(node);\n      }\n    }\n    return node.name;\n  }\n  parseLiteral(value, type) {\n    const node = super.parseLiteral(value, type);\n    node.raw = node.extra.raw;\n    delete node.extra;\n    return node;\n  }\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    super.parseFunctionBody(node, allowExpression, isMethod);\n    node.expression = node.body.type !== \"BlockStatement\";\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    let funcNode = this.startNode();\n    funcNode.kind = node.kind;\n    funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    funcNode.type = \"FunctionExpression\";\n    delete funcNode.kind;\n    node.value = funcNode;\n    const {\n      typeParameters\n    } = node;\n    if (typeParameters) {\n      delete node.typeParameters;\n      funcNode.typeParameters = typeParameters;\n      this.resetStartLocationFromNode(funcNode, typeParameters);\n    }\n    if (type === \"ClassPrivateMethod\") {\n      node.computed = false;\n    }\n    return this.finishNode(node, \"MethodDefinition\");\n  }\n  nameIsConstructor(key) {\n    if (key.type === \"Literal\") return key.value === \"constructor\";\n    return super.nameIsConstructor(key);\n  }\n  parseClassProperty(...args) {\n    const propertyNode = super.parseClassProperty(...args);\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return propertyNode;\n      }\n    }\n    {\n      propertyNode.type = \"PropertyDefinition\";\n    }\n    return propertyNode;\n  }\n  parseClassPrivateProperty(...args) {\n    const propertyNode = super.parseClassPrivateProperty(...args);\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return propertyNode;\n      }\n    }\n    {\n      propertyNode.type = \"PropertyDefinition\";\n    }\n    propertyNode.computed = false;\n    return propertyNode;\n  }\n  parseClassAccessorProperty(node) {\n    const accessorPropertyNode = super.parseClassAccessorProperty(node);\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return accessorPropertyNode;\n      }\n    }\n    accessorPropertyNode.type = \"AccessorProperty\";\n    return accessorPropertyNode;\n  }\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);\n    if (node) {\n      node.type = \"Property\";\n      if (node.kind === \"method\") {\n        node.kind = \"init\";\n      }\n      node.shorthand = false;\n    }\n    return node;\n  }\n  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {\n    const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);\n    if (node) {\n      node.kind = \"init\";\n      node.type = \"Property\";\n    }\n    return node;\n  }\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    return type === \"Property\" ? \"value\" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);\n  }\n  isAssignable(node, isBinding) {\n    if (node != null && this.isObjectProperty(node)) {\n      return this.isAssignable(node.value, isBinding);\n    }\n    return super.isAssignable(node, isBinding);\n  }\n  toAssignable(node, isLHS = false) {\n    if (node != null && this.isObjectProperty(node)) {\n      const {\n        key,\n        value\n      } = node;\n      if (this.isPrivateName(key)) {\n        this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\n      }\n      this.toAssignable(value, isLHS);\n    } else {\n      super.toAssignable(node, isLHS);\n    }\n  }\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.type === \"Property\" && (prop.kind === \"get\" || prop.kind === \"set\")) {\n      this.raise(Errors.PatternHasAccessor, prop.key);\n    } else if (prop.type === \"Property\" && prop.method) {\n      this.raise(Errors.PatternHasMethod, prop.key);\n    } else {\n      super.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n    }\n  }\n  finishCallExpression(unfinished, optional) {\n    const node = super.finishCallExpression(unfinished, optional);\n    if (node.callee.type === \"Import\") {\n      var _ref, _ref2;\n      node.type = \"ImportExpression\";\n      node.source = node.arguments[0];\n      node.options = (_ref = node.arguments[1]) != null ? _ref : null;\n      node.attributes = (_ref2 = node.arguments[1]) != null ? _ref2 : null;\n      delete node.arguments;\n      delete node.callee;\n    }\n    return node;\n  }\n  toReferencedArguments(node) {\n    if (node.type === \"ImportExpression\") {\n      return;\n    }\n    super.toReferencedArguments(node);\n  }\n  parseExport(unfinished, decorators) {\n    const exportStartLoc = this.state.lastTokStartLoc;\n    const node = super.parseExport(unfinished, decorators);\n    switch (node.type) {\n      case \"ExportAllDeclaration\":\n        node.exported = null;\n        break;\n      case \"ExportNamedDeclaration\":\n        if (node.specifiers.length === 1 && node.specifiers[0].type === \"ExportNamespaceSpecifier\") {\n          node.type = \"ExportAllDeclaration\";\n          node.exported = node.specifiers[0].exported;\n          delete node.specifiers;\n        }\n      case \"ExportDefaultDeclaration\":\n        {\n          var _declaration$decorato;\n          const {\n            declaration\n          } = node;\n          if ((declaration == null ? void 0 : declaration.type) === \"ClassDeclaration\" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) {\n            this.resetStartLocation(node, exportStartLoc);\n          }\n        }\n        break;\n    }\n    return node;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    const node = super.parseSubscript(base, startLoc, noCalls, state);\n    if (state.optionalChainMember) {\n      if (node.type === \"OptionalMemberExpression\" || node.type === \"OptionalCallExpression\") {\n        node.type = node.type.substring(8);\n      }\n      if (state.stop) {\n        const chain = this.startNodeAtNode(node);\n        chain.expression = node;\n        return this.finishNode(chain, \"ChainExpression\");\n      }\n    } else if (node.type === \"MemberExpression\" || node.type === \"CallExpression\") {\n      node.optional = false;\n    }\n    return node;\n  }\n  isOptionalMemberExpression(node) {\n    if (node.type === \"ChainExpression\") {\n      return node.expression.type === \"MemberExpression\";\n    }\n    return super.isOptionalMemberExpression(node);\n  }\n  hasPropertyAsPrivateName(node) {\n    if (node.type === \"ChainExpression\") {\n      node = node.expression;\n    }\n    return super.hasPropertyAsPrivateName(node);\n  }\n  isObjectProperty(node) {\n    return node.type === \"Property\" && node.kind === \"init\" && !node.method;\n  }\n  isObjectMethod(node) {\n    return node.type === \"Property\" && (node.method || node.kind === \"get\" || node.kind === \"set\");\n  }\n  finishNodeAt(node, type, endLoc) {\n    return toESTreeLocation(super.finishNodeAt(node, type, endLoc));\n  }\n  resetStartLocation(node, startLoc) {\n    super.resetStartLocation(node, startLoc);\n    toESTreeLocation(node);\n  }\n  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {\n    super.resetEndLocation(node, endLoc);\n    toESTreeLocation(node);\n  }\n};\nclass TokContext {\n  constructor(token, preserveSpace) {\n    this.token = void 0;\n    this.preserveSpace = void 0;\n    this.token = token;\n    this.preserveSpace = !!preserveSpace;\n  }\n}\nconst types = {\n  brace: new TokContext(\"{\"),\n  j_oTag: new TokContext(\"<tag\"),\n  j_cTag: new TokContext(\"</tag\"),\n  j_expr: new TokContext(\"<tag>...</tag>\", true)\n};\n{\n  types.template = new TokContext(\"`\", true);\n}\nconst beforeExpr = true;\nconst startsExpr = true;\nconst isLoop = true;\nconst isAssign = true;\nconst prefix = true;\nconst postfix = true;\nclass ExportedTokenType {\n  constructor(label, conf = {}) {\n    this.label = void 0;\n    this.keyword = void 0;\n    this.beforeExpr = void 0;\n    this.startsExpr = void 0;\n    this.rightAssociative = void 0;\n    this.isLoop = void 0;\n    this.isAssign = void 0;\n    this.prefix = void 0;\n    this.postfix = void 0;\n    this.binop = void 0;\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.rightAssociative = !!conf.rightAssociative;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop != null ? conf.binop : null;\n    {\n      this.updateContext = null;\n    }\n  }\n}\nconst keywords$1 = new Map();\nfunction createKeyword(name, options = {}) {\n  options.keyword = name;\n  const token = createToken(name, options);\n  keywords$1.set(name, token);\n  return token;\n}\nfunction createBinop(name, binop) {\n  return createToken(name, {\n    beforeExpr,\n    binop\n  });\n}\nlet tokenTypeCounter = -1;\nconst tokenTypes = [];\nconst tokenLabels = [];\nconst tokenBinops = [];\nconst tokenBeforeExprs = [];\nconst tokenStartsExprs = [];\nconst tokenPrefixes = [];\nfunction createToken(name, options = {}) {\n  var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;\n  ++tokenTypeCounter;\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);\n  tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);\n  tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);\n  tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);\n  tokenTypes.push(new ExportedTokenType(name, options));\n  return tokenTypeCounter;\n}\nfunction createKeywordLike(name, options = {}) {\n  var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;\n  ++tokenTypeCounter;\n  keywords$1.set(name, tokenTypeCounter);\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);\n  tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);\n  tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);\n  tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);\n  tokenTypes.push(new ExportedTokenType(\"name\", options));\n  return tokenTypeCounter;\n}\nconst tt = {\n  bracketL: createToken(\"[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketHashL: createToken(\"#[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketBarL: createToken(\"[|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketR: createToken(\"]\"),\n  bracketBarR: createToken(\"|]\"),\n  braceL: createToken(\"{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceBarL: createToken(\"{|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceHashL: createToken(\"#{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceR: createToken(\"}\"),\n  braceBarR: createToken(\"|}\"),\n  parenL: createToken(\"(\", {\n    beforeExpr,\n    startsExpr\n  }),\n  parenR: createToken(\")\"),\n  comma: createToken(\",\", {\n    beforeExpr\n  }),\n  semi: createToken(\";\", {\n    beforeExpr\n  }),\n  colon: createToken(\":\", {\n    beforeExpr\n  }),\n  doubleColon: createToken(\"::\", {\n    beforeExpr\n  }),\n  dot: createToken(\".\"),\n  question: createToken(\"?\", {\n    beforeExpr\n  }),\n  questionDot: createToken(\"?.\"),\n  arrow: createToken(\"=>\", {\n    beforeExpr\n  }),\n  template: createToken(\"template\"),\n  ellipsis: createToken(\"...\", {\n    beforeExpr\n  }),\n  backQuote: createToken(\"`\", {\n    startsExpr\n  }),\n  dollarBraceL: createToken(\"${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  templateTail: createToken(\"...`\", {\n    startsExpr\n  }),\n  templateNonTail: createToken(\"...${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  at: createToken(\"@\"),\n  hash: createToken(\"#\", {\n    startsExpr\n  }),\n  interpreterDirective: createToken(\"#!...\"),\n  eq: createToken(\"=\", {\n    beforeExpr,\n    isAssign\n  }),\n  assign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  slashAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  xorAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  moduloAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  incDec: createToken(\"++/--\", {\n    prefix,\n    postfix,\n    startsExpr\n  }),\n  bang: createToken(\"!\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  tilde: createToken(\"~\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  doubleCaret: createToken(\"^^\", {\n    startsExpr\n  }),\n  doubleAt: createToken(\"@@\", {\n    startsExpr\n  }),\n  pipeline: createBinop(\"|>\", 0),\n  nullishCoalescing: createBinop(\"??\", 1),\n  logicalOR: createBinop(\"||\", 1),\n  logicalAND: createBinop(\"&&\", 2),\n  bitwiseOR: createBinop(\"|\", 3),\n  bitwiseXOR: createBinop(\"^\", 4),\n  bitwiseAND: createBinop(\"&\", 5),\n  equality: createBinop(\"==/!=/===/!==\", 6),\n  lt: createBinop(\"</>/<=/>=\", 7),\n  gt: createBinop(\"</>/<=/>=\", 7),\n  relational: createBinop(\"</>/<=/>=\", 7),\n  bitShift: createBinop(\"<</>>/>>>\", 8),\n  bitShiftL: createBinop(\"<</>>/>>>\", 8),\n  bitShiftR: createBinop(\"<</>>/>>>\", 8),\n  plusMin: createToken(\"+/-\", {\n    beforeExpr,\n    binop: 9,\n    prefix,\n    startsExpr\n  }),\n  modulo: createToken(\"%\", {\n    binop: 10,\n    startsExpr\n  }),\n  star: createToken(\"*\", {\n    binop: 10\n  }),\n  slash: createBinop(\"/\", 10),\n  exponent: createToken(\"**\", {\n    beforeExpr,\n    binop: 11,\n    rightAssociative: true\n  }),\n  _in: createKeyword(\"in\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _instanceof: createKeyword(\"instanceof\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _break: createKeyword(\"break\"),\n  _case: createKeyword(\"case\", {\n    beforeExpr\n  }),\n  _catch: createKeyword(\"catch\"),\n  _continue: createKeyword(\"continue\"),\n  _debugger: createKeyword(\"debugger\"),\n  _default: createKeyword(\"default\", {\n    beforeExpr\n  }),\n  _else: createKeyword(\"else\", {\n    beforeExpr\n  }),\n  _finally: createKeyword(\"finally\"),\n  _function: createKeyword(\"function\", {\n    startsExpr\n  }),\n  _if: createKeyword(\"if\"),\n  _return: createKeyword(\"return\", {\n    beforeExpr\n  }),\n  _switch: createKeyword(\"switch\"),\n  _throw: createKeyword(\"throw\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _try: createKeyword(\"try\"),\n  _var: createKeyword(\"var\"),\n  _const: createKeyword(\"const\"),\n  _with: createKeyword(\"with\"),\n  _new: createKeyword(\"new\", {\n    beforeExpr,\n    startsExpr\n  }),\n  _this: createKeyword(\"this\", {\n    startsExpr\n  }),\n  _super: createKeyword(\"super\", {\n    startsExpr\n  }),\n  _class: createKeyword(\"class\", {\n    startsExpr\n  }),\n  _extends: createKeyword(\"extends\", {\n    beforeExpr\n  }),\n  _export: createKeyword(\"export\"),\n  _import: createKeyword(\"import\", {\n    startsExpr\n  }),\n  _null: createKeyword(\"null\", {\n    startsExpr\n  }),\n  _true: createKeyword(\"true\", {\n    startsExpr\n  }),\n  _false: createKeyword(\"false\", {\n    startsExpr\n  }),\n  _typeof: createKeyword(\"typeof\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _void: createKeyword(\"void\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _delete: createKeyword(\"delete\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _do: createKeyword(\"do\", {\n    isLoop,\n    beforeExpr\n  }),\n  _for: createKeyword(\"for\", {\n    isLoop\n  }),\n  _while: createKeyword(\"while\", {\n    isLoop\n  }),\n  _as: createKeywordLike(\"as\", {\n    startsExpr\n  }),\n  _assert: createKeywordLike(\"assert\", {\n    startsExpr\n  }),\n  _async: createKeywordLike(\"async\", {\n    startsExpr\n  }),\n  _await: createKeywordLike(\"await\", {\n    startsExpr\n  }),\n  _defer: createKeywordLike(\"defer\", {\n    startsExpr\n  }),\n  _from: createKeywordLike(\"from\", {\n    startsExpr\n  }),\n  _get: createKeywordLike(\"get\", {\n    startsExpr\n  }),\n  _let: createKeywordLike(\"let\", {\n    startsExpr\n  }),\n  _meta: createKeywordLike(\"meta\", {\n    startsExpr\n  }),\n  _of: createKeywordLike(\"of\", {\n    startsExpr\n  }),\n  _sent: createKeywordLike(\"sent\", {\n    startsExpr\n  }),\n  _set: createKeywordLike(\"set\", {\n    startsExpr\n  }),\n  _source: createKeywordLike(\"source\", {\n    startsExpr\n  }),\n  _static: createKeywordLike(\"static\", {\n    startsExpr\n  }),\n  _using: createKeywordLike(\"using\", {\n    startsExpr\n  }),\n  _yield: createKeywordLike(\"yield\", {\n    startsExpr\n  }),\n  _asserts: createKeywordLike(\"asserts\", {\n    startsExpr\n  }),\n  _checks: createKeywordLike(\"checks\", {\n    startsExpr\n  }),\n  _exports: createKeywordLike(\"exports\", {\n    startsExpr\n  }),\n  _global: createKeywordLike(\"global\", {\n    startsExpr\n  }),\n  _implements: createKeywordLike(\"implements\", {\n    startsExpr\n  }),\n  _intrinsic: createKeywordLike(\"intrinsic\", {\n    startsExpr\n  }),\n  _infer: createKeywordLike(\"infer\", {\n    startsExpr\n  }),\n  _is: createKeywordLike(\"is\", {\n    startsExpr\n  }),\n  _mixins: createKeywordLike(\"mixins\", {\n    startsExpr\n  }),\n  _proto: createKeywordLike(\"proto\", {\n    startsExpr\n  }),\n  _require: createKeywordLike(\"require\", {\n    startsExpr\n  }),\n  _satisfies: createKeywordLike(\"satisfies\", {\n    startsExpr\n  }),\n  _keyof: createKeywordLike(\"keyof\", {\n    startsExpr\n  }),\n  _readonly: createKeywordLike(\"readonly\", {\n    startsExpr\n  }),\n  _unique: createKeywordLike(\"unique\", {\n    startsExpr\n  }),\n  _abstract: createKeywordLike(\"abstract\", {\n    startsExpr\n  }),\n  _declare: createKeywordLike(\"declare\", {\n    startsExpr\n  }),\n  _enum: createKeywordLike(\"enum\", {\n    startsExpr\n  }),\n  _module: createKeywordLike(\"module\", {\n    startsExpr\n  }),\n  _namespace: createKeywordLike(\"namespace\", {\n    startsExpr\n  }),\n  _interface: createKeywordLike(\"interface\", {\n    startsExpr\n  }),\n  _type: createKeywordLike(\"type\", {\n    startsExpr\n  }),\n  _opaque: createKeywordLike(\"opaque\", {\n    startsExpr\n  }),\n  name: createToken(\"name\", {\n    startsExpr\n  }),\n  placeholder: createToken(\"%%\", {\n    startsExpr: true\n  }),\n  string: createToken(\"string\", {\n    startsExpr\n  }),\n  num: createToken(\"num\", {\n    startsExpr\n  }),\n  bigint: createToken(\"bigint\", {\n    startsExpr\n  }),\n  decimal: createToken(\"decimal\", {\n    startsExpr\n  }),\n  regexp: createToken(\"regexp\", {\n    startsExpr\n  }),\n  privateName: createToken(\"#name\", {\n    startsExpr\n  }),\n  eof: createToken(\"eof\"),\n  jsxName: createToken(\"jsxName\"),\n  jsxText: createToken(\"jsxText\", {\n    beforeExpr: true\n  }),\n  jsxTagStart: createToken(\"jsxTagStart\", {\n    startsExpr: true\n  }),\n  jsxTagEnd: createToken(\"jsxTagEnd\")\n};\nfunction tokenIsIdentifier(token) {\n  return token >= 93 && token <= 133;\n}\nfunction tokenKeywordOrIdentifierIsKeyword(token) {\n  return token <= 92;\n}\nfunction tokenIsKeywordOrIdentifier(token) {\n  return token >= 58 && token <= 133;\n}\nfunction tokenIsLiteralPropertyName(token) {\n  return token >= 58 && token <= 137;\n}\nfunction tokenComesBeforeExpression(token) {\n  return tokenBeforeExprs[token];\n}\nfunction tokenCanStartExpression(token) {\n  return tokenStartsExprs[token];\n}\nfunction tokenIsAssignment(token) {\n  return token >= 29 && token <= 33;\n}\nfunction tokenIsFlowInterfaceOrTypeOrOpaque(token) {\n  return token >= 129 && token <= 131;\n}\nfunction tokenIsLoop(token) {\n  return token >= 90 && token <= 92;\n}\nfunction tokenIsKeyword(token) {\n  return token >= 58 && token <= 92;\n}\nfunction tokenIsOperator(token) {\n  return token >= 39 && token <= 59;\n}\nfunction tokenIsPostfix(token) {\n  return token === 34;\n}\nfunction tokenIsPrefix(token) {\n  return tokenPrefixes[token];\n}\nfunction tokenIsTSTypeOperator(token) {\n  return token >= 121 && token <= 123;\n}\nfunction tokenIsTSDeclarationStart(token) {\n  return token >= 124 && token <= 130;\n}\nfunction tokenLabelName(token) {\n  return tokenLabels[token];\n}\nfunction tokenOperatorPrecedence(token) {\n  return tokenBinops[token];\n}\nfunction tokenIsRightAssociative(token) {\n  return token === 57;\n}\nfunction tokenIsTemplate(token) {\n  return token >= 24 && token <= 25;\n}\nfunction getExportedToken(token) {\n  return tokenTypes[token];\n}\n{\n  tokenTypes[8].updateContext = context => {\n    context.pop();\n  };\n  tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = context => {\n    context.push(types.brace);\n  };\n  tokenTypes[22].updateContext = context => {\n    if (context[context.length - 1] === types.template) {\n      context.pop();\n    } else {\n      context.push(types.template);\n    }\n  };\n  tokenTypes[143].updateContext = context => {\n    context.push(types.j_expr, types.j_oTag);\n  };\n}\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u0870-\\u0887\\u0889-\\u088e\\u08a0-\\u08c9\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c5d\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cdd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u1711\\u171f-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4c\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c8a\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7cd\\ua7d0\\ua7d1\\ua7d3\\ua7d5-\\ua7dc\\ua7f2-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nlet nonASCIIidentifierChars = \"\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u0897-\\u089f\\u08ca-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3c\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0cf3\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ece\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u180f-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf-\\u1ace\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1dff\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\u30fb\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\\uff65\";\nconst nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nconst nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\nconst astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];\nconst astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\nfunction isInAstralSet(code, set) {\n  let pos = 0x10000;\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n  return false;\n}\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\nconst reservedWords = {\n  keyword: [\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\"],\n  strict: [\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"],\n  strictBind: [\"eval\", \"arguments\"]\n};\nconst keywords = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\nfunction isReservedWord(word, inModule) {\n  return inModule && word === \"await\" || word === \"enum\";\n}\nfunction isStrictReservedWord(word, inModule) {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\nfunction isStrictBindOnlyReservedWord(word) {\n  return reservedWordsStrictBindSet.has(word);\n}\nfunction isStrictBindReservedWord(word, inModule) {\n  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n}\nfunction isKeyword(word) {\n  return keywords.has(word);\n}\nfunction isIteratorStart(current, next, next2) {\n  return current === 64 && next === 64 && isIdentifierStart(next2);\n}\nconst reservedWordLikeSet = new Set([\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\", \"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\", \"eval\", \"arguments\", \"enum\", \"await\"]);\nfunction canBeReservedWord(word) {\n  return reservedWordLikeSet.has(word);\n}\nclass Scope {\n  constructor(flags) {\n    this.flags = 0;\n    this.names = new Map();\n    this.firstLexicalName = \"\";\n    this.flags = flags;\n  }\n}\nclass ScopeHandler {\n  constructor(parser, inModule) {\n    this.parser = void 0;\n    this.scopeStack = [];\n    this.inModule = void 0;\n    this.undefinedExports = new Map();\n    this.parser = parser;\n    this.inModule = inModule;\n  }\n  get inTopLevel() {\n    return (this.currentScope().flags & 1) > 0;\n  }\n  get inFunction() {\n    return (this.currentVarScopeFlags() & 2) > 0;\n  }\n  get allowSuper() {\n    return (this.currentThisScopeFlags() & 16) > 0;\n  }\n  get allowDirectSuper() {\n    return (this.currentThisScopeFlags() & 32) > 0;\n  }\n  get inClass() {\n    return (this.currentThisScopeFlags() & 64) > 0;\n  }\n  get inClassAndNotInNonArrowFunction() {\n    const flags = this.currentThisScopeFlags();\n    return (flags & 64) > 0 && (flags & 2) === 0;\n  }\n  get inStaticBlock() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & 128) {\n        return true;\n      }\n      if (flags & (387 | 64)) {\n        return false;\n      }\n    }\n  }\n  get inNonArrowFunction() {\n    return (this.currentThisScopeFlags() & 2) > 0;\n  }\n  get treatFunctionsAsVar() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n  }\n  createScope(flags) {\n    return new Scope(flags);\n  }\n  enter(flags) {\n    this.scopeStack.push(this.createScope(flags));\n  }\n  exit() {\n    const scope = this.scopeStack.pop();\n    return scope.flags;\n  }\n  treatFunctionsAsVarInScope(scope) {\n    return !!(scope.flags & (2 | 128) || !this.parser.inModule && scope.flags & 1);\n  }\n  declareName(name, bindingType, loc) {\n    let scope = this.currentScope();\n    if (bindingType & 8 || bindingType & 16) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n      let type = scope.names.get(name) || 0;\n      if (bindingType & 16) {\n        type = type | 4;\n      } else {\n        if (!scope.firstLexicalName) {\n          scope.firstLexicalName = name;\n        }\n        type = type | 2;\n      }\n      scope.names.set(name, type);\n      if (bindingType & 8) {\n        this.maybeExportDefined(scope, name);\n      }\n    } else if (bindingType & 4) {\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\n        scope = this.scopeStack[i];\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        scope.names.set(name, (scope.names.get(name) || 0) | 1);\n        this.maybeExportDefined(scope, name);\n        if (scope.flags & 387) break;\n      }\n    }\n    if (this.parser.inModule && scope.flags & 1) {\n      this.undefinedExports.delete(name);\n    }\n  }\n  maybeExportDefined(scope, name) {\n    if (this.parser.inModule && scope.flags & 1) {\n      this.undefinedExports.delete(name);\n    }\n  }\n  checkRedeclarationInScope(scope, name, bindingType, loc) {\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\n      this.parser.raise(Errors.VarRedeclaration, loc, {\n        identifierName: name\n      });\n    }\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (!(bindingType & 1)) return false;\n    if (bindingType & 8) {\n      return scope.names.has(name);\n    }\n    const type = scope.names.get(name);\n    if (bindingType & 16) {\n      return (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope) && (type & 1) > 0;\n    }\n    return (type & 2) > 0 && !(scope.flags & 8 && scope.firstLexicalName === name) || !this.treatFunctionsAsVarInScope(scope) && (type & 4) > 0;\n  }\n  checkLocalExport(id) {\n    const {\n      name\n    } = id;\n    const topLevelScope = this.scopeStack[0];\n    if (!topLevelScope.names.has(name)) {\n      this.undefinedExports.set(name, id.loc.start);\n    }\n  }\n  currentScope() {\n    return this.scopeStack[this.scopeStack.length - 1];\n  }\n  currentVarScopeFlags() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & 387) {\n        return flags;\n      }\n    }\n  }\n  currentThisScopeFlags() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & (387 | 64) && !(flags & 4)) {\n        return flags;\n      }\n    }\n  }\n}\nclass FlowScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.declareFunctions = new Set();\n  }\n}\nclass FlowScopeHandler extends ScopeHandler {\n  createScope(flags) {\n    return new FlowScope(flags);\n  }\n  declareName(name, bindingType, loc) {\n    const scope = this.currentScope();\n    if (bindingType & 2048) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n      this.maybeExportDefined(scope, name);\n      scope.declareFunctions.add(name);\n      return;\n    }\n    super.declareName(name, bindingType, loc);\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (super.isRedeclaredInScope(scope, name, bindingType)) return true;\n    if (bindingType & 2048 && !scope.declareFunctions.has(name)) {\n      const type = scope.names.get(name);\n      return (type & 4) > 0 || (type & 2) > 0;\n    }\n    return false;\n  }\n  checkLocalExport(id) {\n    if (!this.scopeStack[0].declareFunctions.has(id.name)) {\n      super.checkLocalExport(id);\n    }\n  }\n}\nclass BaseParser {\n  constructor() {\n    this.sawUnambiguousESM = false;\n    this.ambiguousScriptDifferentAst = false;\n  }\n  sourceToOffsetPos(sourcePos) {\n    return sourcePos + this.startIndex;\n  }\n  offsetToSourcePos(offsetPos) {\n    return offsetPos - this.startIndex;\n  }\n  hasPlugin(pluginConfig) {\n    if (typeof pluginConfig === \"string\") {\n      return this.plugins.has(pluginConfig);\n    } else {\n      const [pluginName, pluginOptions] = pluginConfig;\n      if (!this.hasPlugin(pluginName)) {\n        return false;\n      }\n      const actualOptions = this.plugins.get(pluginName);\n      for (const key of Object.keys(pluginOptions)) {\n        if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n  getPluginOption(plugin, name) {\n    var _this$plugins$get;\n    return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];\n  }\n}\nfunction setTrailingComments(node, comments) {\n  if (node.trailingComments === undefined) {\n    node.trailingComments = comments;\n  } else {\n    node.trailingComments.unshift(...comments);\n  }\n}\nfunction setLeadingComments(node, comments) {\n  if (node.leadingComments === undefined) {\n    node.leadingComments = comments;\n  } else {\n    node.leadingComments.unshift(...comments);\n  }\n}\nfunction setInnerComments(node, comments) {\n  if (node.innerComments === undefined) {\n    node.innerComments = comments;\n  } else {\n    node.innerComments.unshift(...comments);\n  }\n}\nfunction adjustInnerComments(node, elements, commentWS) {\n  let lastElement = null;\n  let i = elements.length;\n  while (lastElement === null && i > 0) {\n    lastElement = elements[--i];\n  }\n  if (lastElement === null || lastElement.start > commentWS.start) {\n    setInnerComments(node, commentWS.comments);\n  } else {\n    setTrailingComments(lastElement, commentWS.comments);\n  }\n}\nclass CommentsParser extends BaseParser {\n  addComment(comment) {\n    if (this.filename) comment.loc.filename = this.filename;\n    const {\n      commentsLen\n    } = this.state;\n    if (this.comments.length !== commentsLen) {\n      this.comments.length = commentsLen;\n    }\n    this.comments.push(comment);\n    this.state.commentsLen++;\n  }\n  processComment(node) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n    const lastCommentWS = commentStack[i];\n    if (lastCommentWS.start === node.end) {\n      lastCommentWS.leadingNode = node;\n      i--;\n    }\n    const {\n      start: nodeStart\n    } = node;\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      if (commentEnd > nodeStart) {\n        commentWS.containingNode = node;\n        this.finalizeComment(commentWS);\n        commentStack.splice(i, 1);\n      } else {\n        if (commentEnd === nodeStart) {\n          commentWS.trailingNode = node;\n        }\n        break;\n      }\n    }\n  }\n  finalizeComment(commentWS) {\n    const {\n      comments\n    } = commentWS;\n    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {\n      if (commentWS.leadingNode !== null) {\n        setTrailingComments(commentWS.leadingNode, comments);\n      }\n      if (commentWS.trailingNode !== null) {\n        setLeadingComments(commentWS.trailingNode, comments);\n      }\n    } else {\n      const {\n        containingNode: node,\n        start: commentStart\n      } = commentWS;\n      if (this.input.charCodeAt(this.offsetToSourcePos(commentStart) - 1) === 44) {\n        switch (node.type) {\n          case \"ObjectExpression\":\n          case \"ObjectPattern\":\n          case \"RecordExpression\":\n            adjustInnerComments(node, node.properties, commentWS);\n            break;\n          case \"CallExpression\":\n          case \"OptionalCallExpression\":\n            adjustInnerComments(node, node.arguments, commentWS);\n            break;\n          case \"FunctionDeclaration\":\n          case \"FunctionExpression\":\n          case \"ArrowFunctionExpression\":\n          case \"ObjectMethod\":\n          case \"ClassMethod\":\n          case \"ClassPrivateMethod\":\n            adjustInnerComments(node, node.params, commentWS);\n            break;\n          case \"ArrayExpression\":\n          case \"ArrayPattern\":\n          case \"TupleExpression\":\n            adjustInnerComments(node, node.elements, commentWS);\n            break;\n          case \"ExportNamedDeclaration\":\n          case \"ImportDeclaration\":\n            adjustInnerComments(node, node.specifiers, commentWS);\n            break;\n          case \"TSEnumDeclaration\":\n            {\n              adjustInnerComments(node, node.members, commentWS);\n            }\n            break;\n          case \"TSEnumBody\":\n            adjustInnerComments(node, node.members, commentWS);\n            break;\n          default:\n            {\n              setInnerComments(node, comments);\n            }\n        }\n      } else {\n        setInnerComments(node, comments);\n      }\n    }\n  }\n  finalizeRemainingComments() {\n    const {\n      commentStack\n    } = this.state;\n    for (let i = commentStack.length - 1; i >= 0; i--) {\n      this.finalizeComment(commentStack[i]);\n    }\n    this.state.commentStack = [];\n  }\n  resetPreviousNodeTrailingComments(node) {\n    const {\n      commentStack\n    } = this.state;\n    const {\n      length\n    } = commentStack;\n    if (length === 0) return;\n    const commentWS = commentStack[length - 1];\n    if (commentWS.leadingNode === node) {\n      commentWS.leadingNode = null;\n    }\n  }\n  resetPreviousIdentifierLeadingComments(node) {\n    const {\n      commentStack\n    } = this.state;\n    const {\n      length\n    } = commentStack;\n    if (length === 0) return;\n    if (commentStack[length - 1].trailingNode === node) {\n      commentStack[length - 1].trailingNode = null;\n    } else if (length >= 2 && commentStack[length - 2].trailingNode === node) {\n      commentStack[length - 2].trailingNode = null;\n    }\n  }\n  takeSurroundingComments(node, start, end) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      const commentStart = commentWS.start;\n      if (commentStart === end) {\n        commentWS.leadingNode = node;\n      } else if (commentEnd === start) {\n        commentWS.trailingNode = node;\n      } else if (commentEnd < start) {\n        break;\n      }\n    }\n  }\n}\nconst lineBreak = /\\r\\n|[\\r\\n\\u2028\\u2029]/;\nconst lineBreakG = new RegExp(lineBreak.source, \"g\");\nfunction isNewLine(code) {\n  switch (code) {\n    case 10:\n    case 13:\n    case 8232:\n    case 8233:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction hasNewLine(input, start, end) {\n  for (let i = start; i < end; i++) {\n    if (isNewLine(input.charCodeAt(i))) {\n      return true;\n    }\n  }\n  return false;\n}\nconst skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nconst skipWhiteSpaceInLine = /(?:[^\\S\\n\\r\\u2028\\u2029]|\\/\\/.*|\\/\\*.*?\\*\\/)*/g;\nfunction isWhitespace(code) {\n  switch (code) {\n    case 0x0009:\n    case 0x000b:\n    case 0x000c:\n    case 32:\n    case 160:\n    case 5760:\n    case 0x2000:\n    case 0x2001:\n    case 0x2002:\n    case 0x2003:\n    case 0x2004:\n    case 0x2005:\n    case 0x2006:\n    case 0x2007:\n    case 0x2008:\n    case 0x2009:\n    case 0x200a:\n    case 0x202f:\n    case 0x205f:\n    case 0x3000:\n    case 0xfeff:\n      return true;\n    default:\n      return false;\n  }\n}\nclass State {\n  constructor() {\n    this.flags = 1024;\n    this.startIndex = void 0;\n    this.curLine = void 0;\n    this.lineStart = void 0;\n    this.startLoc = void 0;\n    this.endLoc = void 0;\n    this.errors = [];\n    this.potentialArrowAt = -1;\n    this.noArrowAt = [];\n    this.noArrowParamsConversionAt = [];\n    this.topicContext = {\n      maxNumOfResolvableTopics: 0,\n      maxTopicIndex: null\n    };\n    this.labels = [];\n    this.commentsLen = 0;\n    this.commentStack = [];\n    this.pos = 0;\n    this.type = 140;\n    this.value = null;\n    this.start = 0;\n    this.end = 0;\n    this.lastTokEndLoc = null;\n    this.lastTokStartLoc = null;\n    this.context = [types.brace];\n    this.firstInvalidTemplateEscapePos = null;\n    this.strictErrors = new Map();\n    this.tokensLength = 0;\n  }\n  get strict() {\n    return (this.flags & 1) > 0;\n  }\n  set strict(v) {\n    if (v) this.flags |= 1;else this.flags &= -2;\n  }\n  init({\n    strictMode,\n    sourceType,\n    startIndex,\n    startLine,\n    startColumn\n  }) {\n    this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === \"module\";\n    this.startIndex = startIndex;\n    this.curLine = startLine;\n    this.lineStart = -startColumn;\n    this.startLoc = this.endLoc = new Position(startLine, startColumn, startIndex);\n  }\n  get maybeInArrowParameters() {\n    return (this.flags & 2) > 0;\n  }\n  set maybeInArrowParameters(v) {\n    if (v) this.flags |= 2;else this.flags &= -3;\n  }\n  get inType() {\n    return (this.flags & 4) > 0;\n  }\n  set inType(v) {\n    if (v) this.flags |= 4;else this.flags &= -5;\n  }\n  get noAnonFunctionType() {\n    return (this.flags & 8) > 0;\n  }\n  set noAnonFunctionType(v) {\n    if (v) this.flags |= 8;else this.flags &= -9;\n  }\n  get hasFlowComment() {\n    return (this.flags & 16) > 0;\n  }\n  set hasFlowComment(v) {\n    if (v) this.flags |= 16;else this.flags &= -17;\n  }\n  get isAmbientContext() {\n    return (this.flags & 32) > 0;\n  }\n  set isAmbientContext(v) {\n    if (v) this.flags |= 32;else this.flags &= -33;\n  }\n  get inAbstractClass() {\n    return (this.flags & 64) > 0;\n  }\n  set inAbstractClass(v) {\n    if (v) this.flags |= 64;else this.flags &= -65;\n  }\n  get inDisallowConditionalTypesContext() {\n    return (this.flags & 128) > 0;\n  }\n  set inDisallowConditionalTypesContext(v) {\n    if (v) this.flags |= 128;else this.flags &= -129;\n  }\n  get soloAwait() {\n    return (this.flags & 256) > 0;\n  }\n  set soloAwait(v) {\n    if (v) this.flags |= 256;else this.flags &= -257;\n  }\n  get inFSharpPipelineDirectBody() {\n    return (this.flags & 512) > 0;\n  }\n  set inFSharpPipelineDirectBody(v) {\n    if (v) this.flags |= 512;else this.flags &= -513;\n  }\n  get canStartJSXElement() {\n    return (this.flags & 1024) > 0;\n  }\n  set canStartJSXElement(v) {\n    if (v) this.flags |= 1024;else this.flags &= -1025;\n  }\n  get containsEsc() {\n    return (this.flags & 2048) > 0;\n  }\n  set containsEsc(v) {\n    if (v) this.flags |= 2048;else this.flags &= -2049;\n  }\n  get hasTopLevelAwait() {\n    return (this.flags & 4096) > 0;\n  }\n  set hasTopLevelAwait(v) {\n    if (v) this.flags |= 4096;else this.flags &= -4097;\n  }\n  curPosition() {\n    return new Position(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);\n  }\n  clone() {\n    const state = new State();\n    state.flags = this.flags;\n    state.startIndex = this.startIndex;\n    state.curLine = this.curLine;\n    state.lineStart = this.lineStart;\n    state.startLoc = this.startLoc;\n    state.endLoc = this.endLoc;\n    state.errors = this.errors.slice();\n    state.potentialArrowAt = this.potentialArrowAt;\n    state.noArrowAt = this.noArrowAt.slice();\n    state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();\n    state.topicContext = this.topicContext;\n    state.labels = this.labels.slice();\n    state.commentsLen = this.commentsLen;\n    state.commentStack = this.commentStack.slice();\n    state.pos = this.pos;\n    state.type = this.type;\n    state.value = this.value;\n    state.start = this.start;\n    state.end = this.end;\n    state.lastTokEndLoc = this.lastTokEndLoc;\n    state.lastTokStartLoc = this.lastTokStartLoc;\n    state.context = this.context.slice();\n    state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;\n    state.strictErrors = this.strictErrors;\n    state.tokensLength = this.tokensLength;\n    return state;\n  }\n}\nvar _isDigit = function isDigit(code) {\n  return code >= 48 && code <= 57;\n};\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),\n  hex: new Set([46, 88, 95, 120])\n};\nconst isAllowedNumericSeparatorSibling = {\n  bin: ch => ch === 48 || ch === 49,\n  oct: ch => ch >= 48 && ch <= 55,\n  dec: ch => ch >= 48 && ch <= 57,\n  hex: ch => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102\n};\nfunction readStringContents(type, input, pos, lineStart, curLine, errors) {\n  const initialPos = pos;\n  const initialLineStart = lineStart;\n  const initialCurLine = curLine;\n  let out = \"\";\n  let firstInvalidLoc = null;\n  let chunkStart = pos;\n  const {\n    length\n  } = input;\n  for (;;) {\n    if (pos >= length) {\n      errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    const ch = input.charCodeAt(pos);\n    if (isStringEnd(type, ch, input, pos)) {\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    if (ch === 92) {\n      out += input.slice(chunkStart, pos);\n      const res = readEscapedChar(input, pos, lineStart, curLine, type === \"template\", errors);\n      if (res.ch === null && !firstInvalidLoc) {\n        firstInvalidLoc = {\n          pos,\n          lineStart,\n          curLine\n        };\n      } else {\n        out += res.ch;\n      }\n      ({\n        pos,\n        lineStart,\n        curLine\n      } = res);\n      chunkStart = pos;\n    } else if (ch === 8232 || ch === 8233) {\n      ++pos;\n      ++curLine;\n      lineStart = pos;\n    } else if (ch === 10 || ch === 13) {\n      if (type === \"template\") {\n        out += input.slice(chunkStart, pos) + \"\\n\";\n        ++pos;\n        if (ch === 13 && input.charCodeAt(pos) === 10) {\n          ++pos;\n        }\n        ++curLine;\n        chunkStart = lineStart = pos;\n      } else {\n        errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      }\n    } else {\n      ++pos;\n    }\n  }\n  return {\n    pos,\n    str: out,\n    firstInvalidLoc,\n    lineStart,\n    curLine,\n    containsInvalid: !!firstInvalidLoc\n  };\n}\nfunction isStringEnd(type, ch, input, pos) {\n  if (type === \"template\") {\n    return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;\n  }\n  return ch === (type === \"double\" ? 34 : 39);\n}\nfunction readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {\n  const throwOnInvalid = !inTemplate;\n  pos++;\n  const res = ch => ({\n    pos,\n    ch,\n    lineStart,\n    curLine\n  });\n  const ch = input.charCodeAt(pos++);\n  switch (ch) {\n    case 110:\n      return res(\"\\n\");\n    case 114:\n      return res(\"\\r\");\n    case 120:\n      {\n        let code;\n        ({\n          code,\n          pos\n        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));\n        return res(code === null ? null : String.fromCharCode(code));\n      }\n    case 117:\n      {\n        let code;\n        ({\n          code,\n          pos\n        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));\n        return res(code === null ? null : String.fromCodePoint(code));\n      }\n    case 116:\n      return res(\"\\t\");\n    case 98:\n      return res(\"\\b\");\n    case 118:\n      return res(\"\\u000b\");\n    case 102:\n      return res(\"\\f\");\n    case 13:\n      if (input.charCodeAt(pos) === 10) {\n        ++pos;\n      }\n    case 10:\n      lineStart = pos;\n      ++curLine;\n    case 8232:\n    case 8233:\n      return res(\"\");\n    case 56:\n    case 57:\n      if (inTemplate) {\n        return res(null);\n      } else {\n        errors.strictNumericEscape(pos - 1, lineStart, curLine);\n      }\n    default:\n      if (ch >= 48 && ch <= 55) {\n        const startPos = pos - 1;\n        const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));\n        let octalStr = match[0];\n        let octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        pos += octalStr.length - 1;\n        const next = input.charCodeAt(pos);\n        if (octalStr !== \"0\" || next === 56 || next === 57) {\n          if (inTemplate) {\n            return res(null);\n          } else {\n            errors.strictNumericEscape(startPos, lineStart, curLine);\n          }\n        }\n        return res(String.fromCharCode(octal));\n      }\n      return res(String.fromCharCode(ch));\n  }\n}\nfunction readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {\n  const initialPos = pos;\n  let n;\n  ({\n    n,\n    pos\n  } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));\n  if (n === null) {\n    if (throwOnInvalid) {\n      errors.invalidEscapeSequence(initialPos, lineStart, curLine);\n    } else {\n      pos = initialPos - 1;\n    }\n  }\n  return {\n    code: n,\n    pos\n  };\n}\nfunction readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {\n  const start = pos;\n  const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;\n  const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;\n  let invalid = false;\n  let total = 0;\n  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    const code = input.charCodeAt(pos);\n    let val;\n    if (code === 95 && allowNumSeparator !== \"bail\") {\n      const prev = input.charCodeAt(pos - 1);\n      const next = input.charCodeAt(pos + 1);\n      if (!allowNumSeparator) {\n        if (bailOnError) return {\n          n: null,\n          pos\n        };\n        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);\n      } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {\n        if (bailOnError) return {\n          n: null,\n          pos\n        };\n        errors.unexpectedNumericSeparator(pos, lineStart, curLine);\n      }\n      ++pos;\n      continue;\n    }\n    if (code >= 97) {\n      val = code - 97 + 10;\n    } else if (code >= 65) {\n      val = code - 65 + 10;\n    } else if (_isDigit(code)) {\n      val = code - 48;\n    } else {\n      val = Infinity;\n    }\n    if (val >= radix) {\n      if (val <= 9 && bailOnError) {\n        return {\n          n: null,\n          pos\n        };\n      } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {\n        val = 0;\n      } else if (forceLen) {\n        val = 0;\n        invalid = true;\n      } else {\n        break;\n      }\n    }\n    ++pos;\n    total = total * radix + val;\n  }\n  if (pos === start || len != null && pos - start !== len || invalid) {\n    return {\n      n: null,\n      pos\n    };\n  }\n  return {\n    n: total,\n    pos\n  };\n}\nfunction readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {\n  const ch = input.charCodeAt(pos);\n  let code;\n  if (ch === 123) {\n    ++pos;\n    ({\n      code,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, input.indexOf(\"}\", pos) - pos, true, throwOnInvalid, errors));\n    ++pos;\n    if (code !== null && code > 0x10ffff) {\n      if (throwOnInvalid) {\n        errors.invalidCodePoint(pos, lineStart, curLine);\n      } else {\n        return {\n          code: null,\n          pos\n        };\n      }\n    }\n  } else {\n    ({\n      code,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));\n  }\n  return {\n    code,\n    pos\n  };\n}\nfunction buildPosition(pos, lineStart, curLine) {\n  return new Position(curLine, pos - lineStart, pos);\n}\nconst VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100, 118]);\nclass Token {\n  constructor(state) {\n    const startIndex = state.startIndex || 0;\n    this.type = state.type;\n    this.value = state.value;\n    this.start = startIndex + state.start;\n    this.end = startIndex + state.end;\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\n  }\n}\nclass Tokenizer extends CommentsParser {\n  constructor(options, input) {\n    super();\n    this.isLookahead = void 0;\n    this.tokens = [];\n    this.errorHandlers_readInt = {\n      invalidDigit: (pos, lineStart, curLine, radix) => {\n        if (!(this.optionFlags & 2048)) return false;\n        this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {\n          radix\n        });\n        return true;\n      },\n      numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),\n      unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)\n    };\n    this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {\n      invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),\n      invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)\n    });\n    this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {\n      strictNumericEscape: (pos, lineStart, curLine) => {\n        this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));\n      },\n      unterminated: (pos, lineStart, curLine) => {\n        throw this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));\n      }\n    });\n    this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {\n      strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),\n      unterminated: (pos, lineStart, curLine) => {\n        throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));\n      }\n    });\n    this.state = new State();\n    this.state.init(options);\n    this.input = input;\n    this.length = input.length;\n    this.comments = [];\n    this.isLookahead = false;\n  }\n  pushToken(token) {\n    this.tokens.length = this.state.tokensLength;\n    this.tokens.push(token);\n    ++this.state.tokensLength;\n  }\n  next() {\n    this.checkKeywordEscapes();\n    if (this.optionFlags & 256) {\n      this.pushToken(new Token(this.state));\n    }\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }\n  eat(type) {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n  match(type) {\n    return this.state.type === type;\n  }\n  createLookaheadState(state) {\n    return {\n      pos: state.pos,\n      value: null,\n      type: state.type,\n      start: state.start,\n      end: state.end,\n      context: [this.curContext()],\n      inType: state.inType,\n      startLoc: state.startLoc,\n      lastTokEndLoc: state.lastTokEndLoc,\n      curLine: state.curLine,\n      lineStart: state.lineStart,\n      curPosition: state.curPosition\n    };\n  }\n  lookahead() {\n    const old = this.state;\n    this.state = this.createLookaheadState(old);\n    this.isLookahead = true;\n    this.nextToken();\n    this.isLookahead = false;\n    const curr = this.state;\n    this.state = old;\n    return curr;\n  }\n  nextTokenStart() {\n    return this.nextTokenStartSince(this.state.pos);\n  }\n  nextTokenStartSince(pos) {\n    skipWhiteSpace.lastIndex = pos;\n    return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;\n  }\n  lookaheadCharCode() {\n    return this.input.charCodeAt(this.nextTokenStart());\n  }\n  nextTokenInLineStart() {\n    return this.nextTokenInLineStartSince(this.state.pos);\n  }\n  nextTokenInLineStartSince(pos) {\n    skipWhiteSpaceInLine.lastIndex = pos;\n    return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;\n  }\n  lookaheadInLineCharCode() {\n    return this.input.charCodeAt(this.nextTokenInLineStart());\n  }\n  codePointAtPos(pos) {\n    let cp = this.input.charCodeAt(pos);\n    if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {\n      const trail = this.input.charCodeAt(pos);\n      if ((trail & 0xfc00) === 0xdc00) {\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n      }\n    }\n    return cp;\n  }\n  setStrict(strict) {\n    this.state.strict = strict;\n    if (strict) {\n      this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, at));\n      this.state.strictErrors.clear();\n    }\n  }\n  curContext() {\n    return this.state.context[this.state.context.length - 1];\n  }\n  nextToken() {\n    this.skipSpace();\n    this.state.start = this.state.pos;\n    if (!this.isLookahead) this.state.startLoc = this.state.curPosition();\n    if (this.state.pos >= this.length) {\n      this.finishToken(140);\n      return;\n    }\n    this.getTokenFromCode(this.codePointAtPos(this.state.pos));\n  }\n  skipBlockComment(commentEnd) {\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    const start = this.state.pos;\n    const end = this.input.indexOf(commentEnd, start + 2);\n    if (end === -1) {\n      throw this.raise(Errors.UnterminatedComment, this.state.curPosition());\n    }\n    this.state.pos = end + commentEnd.length;\n    lineBreakG.lastIndex = start + 2;\n    while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {\n      ++this.state.curLine;\n      this.state.lineStart = lineBreakG.lastIndex;\n    }\n    if (this.isLookahead) return;\n    const comment = {\n      type: \"CommentBlock\",\n      value: this.input.slice(start + 2, end),\n      start: this.sourceToOffsetPos(start),\n      end: this.sourceToOffsetPos(end + commentEnd.length),\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.optionFlags & 256) this.pushToken(comment);\n    return comment;\n  }\n  skipLineComment(startSkip) {\n    const start = this.state.pos;\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    let ch = this.input.charCodeAt(this.state.pos += startSkip);\n    if (this.state.pos < this.length) {\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n    if (this.isLookahead) return;\n    const end = this.state.pos;\n    const value = this.input.slice(start + startSkip, end);\n    const comment = {\n      type: \"CommentLine\",\n      value,\n      start: this.sourceToOffsetPos(start),\n      end: this.sourceToOffsetPos(end),\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.optionFlags & 256) this.pushToken(comment);\n    return comment;\n  }\n  skipSpace() {\n    const spaceStart = this.state.pos;\n    const comments = this.optionFlags & 4096 ? [] : null;\n    loop: while (this.state.pos < this.length) {\n      const ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case 32:\n        case 160:\n        case 9:\n          ++this.state.pos;\n          break;\n        case 13:\n          if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n            ++this.state.pos;\n          }\n        case 10:\n        case 8232:\n        case 8233:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n        case 47:\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case 42:\n              {\n                const comment = this.skipBlockComment(\"*/\");\n                if (comment !== undefined) {\n                  this.addComment(comment);\n                  comments == null || comments.push(comment);\n                }\n                break;\n              }\n            case 47:\n              {\n                const comment = this.skipLineComment(2);\n                if (comment !== undefined) {\n                  this.addComment(comment);\n                  comments == null || comments.push(comment);\n                }\n                break;\n              }\n            default:\n              break loop;\n          }\n          break;\n        default:\n          if (isWhitespace(ch)) {\n            ++this.state.pos;\n          } else if (ch === 45 && !this.inModule && this.optionFlags & 8192) {\n            const pos = this.state.pos;\n            if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {\n              const comment = this.skipLineComment(3);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                comments == null || comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else if (ch === 60 && !this.inModule && this.optionFlags & 8192) {\n            const pos = this.state.pos;\n            if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {\n              const comment = this.skipLineComment(4);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                comments == null || comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else {\n            break loop;\n          }\n      }\n    }\n    if ((comments == null ? void 0 : comments.length) > 0) {\n      const end = this.state.pos;\n      const commentWhitespace = {\n        start: this.sourceToOffsetPos(spaceStart),\n        end: this.sourceToOffsetPos(end),\n        comments,\n        leadingNode: null,\n        trailingNode: null,\n        containingNode: null\n      };\n      this.state.commentStack.push(commentWhitespace);\n    }\n  }\n  finishToken(type, val) {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    const prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n    if (!this.isLookahead) {\n      this.updateContext(prevType);\n    }\n  }\n  replaceToken(type) {\n    this.state.type = type;\n    this.updateContext();\n  }\n  readToken_numberSign() {\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\n      return;\n    }\n    const nextPos = this.state.pos + 1;\n    const next = this.codePointAtPos(nextPos);\n    if (next >= 48 && next <= 57) {\n      throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());\n    }\n    if (next === 123 || next === 91 && this.hasPlugin(\"recordAndTuple\")) {\n      this.expectPlugin(\"recordAndTuple\");\n      if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") === \"bar\") {\n        throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());\n      }\n      this.state.pos += 2;\n      if (next === 123) {\n        this.finishToken(7);\n      } else {\n        this.finishToken(1);\n      }\n    } else if (isIdentifierStart(next)) {\n      ++this.state.pos;\n      this.finishToken(139, this.readWord1(next));\n    } else if (next === 92) {\n      ++this.state.pos;\n      this.finishToken(139, this.readWord1());\n    } else {\n      this.finishOp(27, 1);\n    }\n  }\n  readToken_dot() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next >= 48 && next <= 57) {\n      this.readNumber(true);\n      return;\n    }\n    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {\n      this.state.pos += 3;\n      this.finishToken(21);\n    } else {\n      ++this.state.pos;\n      this.finishToken(16);\n    }\n  }\n  readToken_slash() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) {\n      this.finishOp(31, 2);\n    } else {\n      this.finishOp(56, 1);\n    }\n  }\n  readToken_interpreter() {\n    if (this.state.pos !== 0 || this.length < 2) return false;\n    let ch = this.input.charCodeAt(this.state.pos + 1);\n    if (ch !== 33) return false;\n    const start = this.state.pos;\n    this.state.pos += 1;\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n    const value = this.input.slice(start + 2, this.state.pos);\n    this.finishToken(28, value);\n    return true;\n  }\n  readToken_mult_modulo(code) {\n    let type = code === 42 ? 55 : 54;\n    let width = 1;\n    let next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 42 && next === 42) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = 57;\n    }\n    if (next === 61 && !this.state.inType) {\n      width++;\n      type = code === 37 ? 33 : 30;\n    }\n    this.finishOp(type, width);\n  }\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === code) {\n      if (this.input.charCodeAt(this.state.pos + 2) === 61) {\n        this.finishOp(30, 3);\n      } else {\n        this.finishOp(code === 124 ? 41 : 42, 2);\n      }\n      return;\n    }\n    if (code === 124) {\n      if (next === 62) {\n        this.finishOp(39, 2);\n        return;\n      }\n      if (this.hasPlugin(\"recordAndTuple\") && next === 125) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());\n        }\n        this.state.pos += 2;\n        this.finishToken(9);\n        return;\n      }\n      if (this.hasPlugin(\"recordAndTuple\") && next === 93) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());\n        }\n        this.state.pos += 2;\n        this.finishToken(4);\n        return;\n      }\n    }\n    if (next === 61) {\n      this.finishOp(30, 2);\n      return;\n    }\n    this.finishOp(code === 124 ? 43 : 45, 1);\n  }\n  readToken_caret() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61 && !this.state.inType) {\n      this.finishOp(32, 2);\n    } else if (next === 94 && this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"hack\",\n      topicToken: \"^^\"\n    }])) {\n      this.finishOp(37, 2);\n      const lookaheadCh = this.input.codePointAt(this.state.pos);\n      if (lookaheadCh === 94) {\n        this.unexpected();\n      }\n    } else {\n      this.finishOp(44, 1);\n    }\n  }\n  readToken_atSign() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 64 && this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"hack\",\n      topicToken: \"@@\"\n    }])) {\n      this.finishOp(38, 2);\n    } else {\n      this.finishOp(26, 1);\n    }\n  }\n  readToken_plus_min(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === code) {\n      this.finishOp(34, 2);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(30, 2);\n    } else {\n      this.finishOp(53, 1);\n    }\n  }\n  readToken_lt() {\n    const {\n      pos\n    } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n    if (next === 60) {\n      if (this.input.charCodeAt(pos + 2) === 61) {\n        this.finishOp(30, 3);\n        return;\n      }\n      this.finishOp(51, 2);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(49, 2);\n      return;\n    }\n    this.finishOp(47, 1);\n  }\n  readToken_gt() {\n    const {\n      pos\n    } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n    if (next === 62) {\n      const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;\n      if (this.input.charCodeAt(pos + size) === 61) {\n        this.finishOp(30, size + 1);\n        return;\n      }\n      this.finishOp(52, size);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(49, 2);\n      return;\n    }\n    this.finishOp(48, 1);\n  }\n  readToken_eq_excl(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) {\n      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);\n      return;\n    }\n    if (code === 61 && next === 62) {\n      this.state.pos += 2;\n      this.finishToken(19);\n      return;\n    }\n    this.finishOp(code === 61 ? 29 : 35, 1);\n  }\n  readToken_question() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\n    if (next === 63) {\n      if (next2 === 61) {\n        this.finishOp(30, 3);\n      } else {\n        this.finishOp(40, 2);\n      }\n    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {\n      this.state.pos += 2;\n      this.finishToken(18);\n    } else {\n      ++this.state.pos;\n      this.finishToken(17);\n    }\n  }\n  getTokenFromCode(code) {\n    switch (code) {\n      case 46:\n        this.readToken_dot();\n        return;\n      case 40:\n        ++this.state.pos;\n        this.finishToken(10);\n        return;\n      case 41:\n        ++this.state.pos;\n        this.finishToken(11);\n        return;\n      case 59:\n        ++this.state.pos;\n        this.finishToken(13);\n        return;\n      case 44:\n        ++this.state.pos;\n        this.finishToken(12);\n        return;\n      case 91:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());\n          }\n          this.state.pos += 2;\n          this.finishToken(2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(0);\n        }\n        return;\n      case 93:\n        ++this.state.pos;\n        this.finishToken(3);\n        return;\n      case 123:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());\n          }\n          this.state.pos += 2;\n          this.finishToken(6);\n        } else {\n          ++this.state.pos;\n          this.finishToken(5);\n        }\n        return;\n      case 125:\n        ++this.state.pos;\n        this.finishToken(8);\n        return;\n      case 58:\n        if (this.hasPlugin(\"functionBind\") && this.input.charCodeAt(this.state.pos + 1) === 58) {\n          this.finishOp(15, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(14);\n        }\n        return;\n      case 63:\n        this.readToken_question();\n        return;\n      case 96:\n        this.readTemplateToken();\n        return;\n      case 48:\n        {\n          const next = this.input.charCodeAt(this.state.pos + 1);\n          if (next === 120 || next === 88) {\n            this.readRadixNumber(16);\n            return;\n          }\n          if (next === 111 || next === 79) {\n            this.readRadixNumber(8);\n            return;\n          }\n          if (next === 98 || next === 66) {\n            this.readRadixNumber(2);\n            return;\n          }\n        }\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        this.readNumber(false);\n        return;\n      case 34:\n      case 39:\n        this.readString(code);\n        return;\n      case 47:\n        this.readToken_slash();\n        return;\n      case 37:\n      case 42:\n        this.readToken_mult_modulo(code);\n        return;\n      case 124:\n      case 38:\n        this.readToken_pipe_amp(code);\n        return;\n      case 94:\n        this.readToken_caret();\n        return;\n      case 43:\n      case 45:\n        this.readToken_plus_min(code);\n        return;\n      case 60:\n        this.readToken_lt();\n        return;\n      case 62:\n        this.readToken_gt();\n        return;\n      case 61:\n      case 33:\n        this.readToken_eq_excl(code);\n        return;\n      case 126:\n        this.finishOp(36, 1);\n        return;\n      case 64:\n        this.readToken_atSign();\n        return;\n      case 35:\n        this.readToken_numberSign();\n        return;\n      case 92:\n        this.readWord();\n        return;\n      default:\n        if (isIdentifierStart(code)) {\n          this.readWord(code);\n          return;\n        }\n    }\n    throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {\n      unexpected: String.fromCodePoint(code)\n    });\n  }\n  finishOp(type, size) {\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  }\n  readRegexp() {\n    const startLoc = this.state.startLoc;\n    const start = this.state.start + 1;\n    let escaped, inClass;\n    let {\n      pos\n    } = this.state;\n    for (;; ++pos) {\n      if (pos >= this.length) {\n        throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));\n      }\n      const ch = this.input.charCodeAt(pos);\n      if (isNewLine(ch)) {\n        throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));\n      }\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === 91) {\n          inClass = true;\n        } else if (ch === 93 && inClass) {\n          inClass = false;\n        } else if (ch === 47 && !inClass) {\n          break;\n        }\n        escaped = ch === 92;\n      }\n    }\n    const content = this.input.slice(start, pos);\n    ++pos;\n    let mods = \"\";\n    const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);\n    while (pos < this.length) {\n      const cp = this.codePointAtPos(pos);\n      const char = String.fromCharCode(cp);\n      if (VALID_REGEX_FLAGS.has(cp)) {\n        if (cp === 118) {\n          if (mods.includes(\"u\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());\n          }\n        } else if (cp === 117) {\n          if (mods.includes(\"v\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());\n          }\n        }\n        if (mods.includes(char)) {\n          this.raise(Errors.DuplicateRegExpFlags, nextPos());\n        }\n      } else if (isIdentifierChar(cp) || cp === 92) {\n        this.raise(Errors.MalformedRegExpFlags, nextPos());\n      } else {\n        break;\n      }\n      ++pos;\n      mods += char;\n    }\n    this.state.pos = pos;\n    this.finishToken(138, {\n      pattern: content,\n      flags: mods\n    });\n  }\n  readInt(radix, len, forceLen = false, allowNumSeparator = true) {\n    const {\n      n,\n      pos\n    } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);\n    this.state.pos = pos;\n    return n;\n  }\n  readRadixNumber(radix) {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let isBigInt = false;\n    this.state.pos += 2;\n    const val = this.readInt(radix);\n    if (val == null) {\n      this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {\n        radix\n      });\n    }\n    const next = this.input.charCodeAt(this.state.pos);\n    if (next === 110) {\n      ++this.state.pos;\n      isBigInt = true;\n    } else if (next === 109) {\n      throw this.raise(Errors.InvalidDecimal, startLoc);\n    }\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, this.state.curPosition());\n    }\n    if (isBigInt) {\n      const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, \"\");\n      this.finishToken(136, str);\n      return;\n    }\n    this.finishToken(135, val);\n  }\n  readNumber(startsWithDot) {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let isFloat = false;\n    let isBigInt = false;\n    let hasExponent = false;\n    let isOctal = false;\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(Errors.InvalidNumber, this.state.curPosition());\n    }\n    const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n    if (hasLeadingZero) {\n      const integer = this.input.slice(start, this.state.pos);\n      this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);\n      if (!this.state.strict) {\n        const underscorePos = integer.indexOf(\"_\");\n        if (underscorePos > 0) {\n          this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));\n        }\n      }\n      isOctal = hasLeadingZero && !/[89]/.test(integer);\n    }\n    let next = this.input.charCodeAt(this.state.pos);\n    if (next === 46 && !isOctal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n    if ((next === 69 || next === 101) && !isOctal) {\n      next = this.input.charCodeAt(++this.state.pos);\n      if (next === 43 || next === 45) {\n        ++this.state.pos;\n      }\n      if (this.readInt(10) === null) {\n        this.raise(Errors.InvalidOrMissingExponent, startLoc);\n      }\n      isFloat = true;\n      hasExponent = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n    if (next === 110) {\n      if (isFloat || hasLeadingZero) {\n        this.raise(Errors.InvalidBigIntLiteral, startLoc);\n      }\n      ++this.state.pos;\n      isBigInt = true;\n    }\n    if (next === 109) {\n      this.expectPlugin(\"decimal\", this.state.curPosition());\n      if (hasExponent || hasLeadingZero) {\n        this.raise(Errors.InvalidDecimal, startLoc);\n      }\n      ++this.state.pos;\n      var isDecimal = true;\n    }\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, this.state.curPosition());\n    }\n    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, \"\");\n    if (isBigInt) {\n      this.finishToken(136, str);\n      return;\n    }\n    if (isDecimal) {\n      this.finishToken(137, str);\n      return;\n    }\n    const val = isOctal ? parseInt(str, 8) : parseFloat(str);\n    this.finishToken(135, val);\n  }\n  readCodePoint(throwOnInvalid) {\n    const {\n      code,\n      pos\n    } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);\n    this.state.pos = pos;\n    return code;\n  }\n  readString(quote) {\n    const {\n      str,\n      pos,\n      curLine,\n      lineStart\n    } = readStringContents(quote === 34 ? \"double\" : \"single\", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);\n    this.state.pos = pos + 1;\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n    this.finishToken(134, str);\n  }\n  readTemplateContinuation() {\n    if (!this.match(8)) {\n      this.unexpected(null, 8);\n    }\n    this.state.pos--;\n    this.readTemplateToken();\n  }\n  readTemplateToken() {\n    const opening = this.input[this.state.pos];\n    const {\n      str,\n      firstInvalidLoc,\n      pos,\n      curLine,\n      lineStart\n    } = readStringContents(\"template\", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);\n    this.state.pos = pos + 1;\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n    if (firstInvalidLoc) {\n      this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, this.sourceToOffsetPos(firstInvalidLoc.pos));\n    }\n    if (this.input.codePointAt(pos) === 96) {\n      this.finishToken(24, firstInvalidLoc ? null : opening + str + \"`\");\n    } else {\n      this.state.pos++;\n      this.finishToken(25, firstInvalidLoc ? null : opening + str + \"${\");\n    }\n  }\n  recordStrictModeErrors(toParseError, at) {\n    const index = at.index;\n    if (this.state.strict && !this.state.strictErrors.has(index)) {\n      this.raise(toParseError, at);\n    } else {\n      this.state.strictErrors.set(index, [toParseError, at]);\n    }\n  }\n  readWord1(firstCode) {\n    this.state.containsEsc = false;\n    let word = \"\";\n    const start = this.state.pos;\n    let chunkStart = this.state.pos;\n    if (firstCode !== undefined) {\n      this.state.pos += firstCode <= 0xffff ? 1 : 2;\n    }\n    while (this.state.pos < this.length) {\n      const ch = this.codePointAtPos(this.state.pos);\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === 92) {\n        this.state.containsEsc = true;\n        word += this.input.slice(chunkStart, this.state.pos);\n        const escStart = this.state.curPosition();\n        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;\n        if (this.input.charCodeAt(++this.state.pos) !== 117) {\n          this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());\n          chunkStart = this.state.pos - 1;\n          continue;\n        }\n        ++this.state.pos;\n        const esc = this.readCodePoint(true);\n        if (esc !== null) {\n          if (!identifierCheck(esc)) {\n            this.raise(Errors.EscapedCharNotAnIdentifier, escStart);\n          }\n          word += String.fromCodePoint(esc);\n        }\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n    }\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }\n  readWord(firstCode) {\n    const word = this.readWord1(firstCode);\n    const type = keywords$1.get(word);\n    if (type !== undefined) {\n      this.finishToken(type, tokenLabelName(type));\n    } else {\n      this.finishToken(132, word);\n    }\n  }\n  checkKeywordEscapes() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsKeyword(type) && this.state.containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {\n        reservedWord: tokenLabelName(type)\n      });\n    }\n  }\n  raise(toParseError, at, details = {}) {\n    const loc = at instanceof Position ? at : at.loc.start;\n    const error = toParseError(loc, details);\n    if (!(this.optionFlags & 2048)) throw error;\n    if (!this.isLookahead) this.state.errors.push(error);\n    return error;\n  }\n  raiseOverwrite(toParseError, at, details = {}) {\n    const loc = at instanceof Position ? at : at.loc.start;\n    const pos = loc.index;\n    const errors = this.state.errors;\n    for (let i = errors.length - 1; i >= 0; i--) {\n      const error = errors[i];\n      if (error.loc.index === pos) {\n        return errors[i] = toParseError(loc, details);\n      }\n      if (error.loc.index < pos) break;\n    }\n    return this.raise(toParseError, at, details);\n  }\n  updateContext(prevType) {}\n  unexpected(loc, type) {\n    throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, {\n      expected: type ? tokenLabelName(type) : null\n    });\n  }\n  expectPlugin(pluginName, loc) {\n    if (this.hasPlugin(pluginName)) {\n      return true;\n    }\n    throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, {\n      missingPlugin: [pluginName]\n    });\n  }\n  expectOnePlugin(pluginNames) {\n    if (!pluginNames.some(name => this.hasPlugin(name))) {\n      throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {\n        missingPlugin: pluginNames\n      });\n    }\n  }\n  errorBuilder(error) {\n    return (pos, lineStart, curLine) => {\n      this.raise(error, buildPosition(pos, lineStart, curLine));\n    };\n  }\n}\nclass ClassScope {\n  constructor() {\n    this.privateNames = new Set();\n    this.loneAccessors = new Map();\n    this.undefinedPrivateNames = new Map();\n  }\n}\nclass ClassScopeHandler {\n  constructor(parser) {\n    this.parser = void 0;\n    this.stack = [];\n    this.undefinedPrivateNames = new Map();\n    this.parser = parser;\n  }\n  current() {\n    return this.stack[this.stack.length - 1];\n  }\n  enter() {\n    this.stack.push(new ClassScope());\n  }\n  exit() {\n    const oldClassScope = this.stack.pop();\n    const current = this.current();\n    for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {\n      if (current) {\n        if (!current.undefinedPrivateNames.has(name)) {\n          current.undefinedPrivateNames.set(name, loc);\n        }\n      } else {\n        this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {\n          identifierName: name\n        });\n      }\n    }\n  }\n  declarePrivateName(name, elementType, loc) {\n    const {\n      privateNames,\n      loneAccessors,\n      undefinedPrivateNames\n    } = this.current();\n    let redefined = privateNames.has(name);\n    if (elementType & 3) {\n      const accessor = redefined && loneAccessors.get(name);\n      if (accessor) {\n        const oldStatic = accessor & 4;\n        const newStatic = elementType & 4;\n        const oldKind = accessor & 3;\n        const newKind = elementType & 3;\n        redefined = oldKind === newKind || oldStatic !== newStatic;\n        if (!redefined) loneAccessors.delete(name);\n      } else if (!redefined) {\n        loneAccessors.set(name, elementType);\n      }\n    }\n    if (redefined) {\n      this.parser.raise(Errors.PrivateNameRedeclaration, loc, {\n        identifierName: name\n      });\n    }\n    privateNames.add(name);\n    undefinedPrivateNames.delete(name);\n  }\n  usePrivateName(name, loc) {\n    let classScope;\n    for (classScope of this.stack) {\n      if (classScope.privateNames.has(name)) return;\n    }\n    if (classScope) {\n      classScope.undefinedPrivateNames.set(name, loc);\n    } else {\n      this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {\n        identifierName: name\n      });\n    }\n  }\n}\nclass ExpressionScope {\n  constructor(type = 0) {\n    this.type = type;\n  }\n  canBeArrowParameterDeclaration() {\n    return this.type === 2 || this.type === 1;\n  }\n  isCertainlyParameterDeclaration() {\n    return this.type === 3;\n  }\n}\nclass ArrowHeadParsingScope extends ExpressionScope {\n  constructor(type) {\n    super(type);\n    this.declarationErrors = new Map();\n  }\n  recordDeclarationError(ParsingErrorClass, at) {\n    const index = at.index;\n    this.declarationErrors.set(index, [ParsingErrorClass, at]);\n  }\n  clearDeclarationError(index) {\n    this.declarationErrors.delete(index);\n  }\n  iterateErrors(iterator) {\n    this.declarationErrors.forEach(iterator);\n  }\n}\nclass ExpressionScopeHandler {\n  constructor(parser) {\n    this.parser = void 0;\n    this.stack = [new ExpressionScope()];\n    this.parser = parser;\n  }\n  enter(scope) {\n    this.stack.push(scope);\n  }\n  exit() {\n    this.stack.pop();\n  }\n  recordParameterInitializerError(toParseError, node) {\n    const origin = node.loc.start;\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n    while (!scope.isCertainlyParameterDeclaration()) {\n      if (scope.canBeArrowParameterDeclaration()) {\n        scope.recordDeclarationError(toParseError, origin);\n      } else {\n        return;\n      }\n      scope = stack[--i];\n    }\n    this.parser.raise(toParseError, origin);\n  }\n  recordArrowParameterBindingError(error, node) {\n    const {\n      stack\n    } = this;\n    const scope = stack[stack.length - 1];\n    const origin = node.loc.start;\n    if (scope.isCertainlyParameterDeclaration()) {\n      this.parser.raise(error, origin);\n    } else if (scope.canBeArrowParameterDeclaration()) {\n      scope.recordDeclarationError(error, origin);\n    } else {\n      return;\n    }\n  }\n  recordAsyncArrowParametersError(at) {\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n    while (scope.canBeArrowParameterDeclaration()) {\n      if (scope.type === 2) {\n        scope.recordDeclarationError(Errors.AwaitBindingIdentifier, at);\n      }\n      scope = stack[--i];\n    }\n  }\n  validateAsPattern() {\n    const {\n      stack\n    } = this;\n    const currentScope = stack[stack.length - 1];\n    if (!currentScope.canBeArrowParameterDeclaration()) return;\n    currentScope.iterateErrors(([toParseError, loc]) => {\n      this.parser.raise(toParseError, loc);\n      let i = stack.length - 2;\n      let scope = stack[i];\n      while (scope.canBeArrowParameterDeclaration()) {\n        scope.clearDeclarationError(loc.index);\n        scope = stack[--i];\n      }\n    });\n  }\n}\nfunction newParameterDeclarationScope() {\n  return new ExpressionScope(3);\n}\nfunction newArrowHeadScope() {\n  return new ArrowHeadParsingScope(1);\n}\nfunction newAsyncArrowScope() {\n  return new ArrowHeadParsingScope(2);\n}\nfunction newExpressionScope() {\n  return new ExpressionScope();\n}\nclass ProductionParameterHandler {\n  constructor() {\n    this.stacks = [];\n  }\n  enter(flags) {\n    this.stacks.push(flags);\n  }\n  exit() {\n    this.stacks.pop();\n  }\n  currentFlags() {\n    return this.stacks[this.stacks.length - 1];\n  }\n  get hasAwait() {\n    return (this.currentFlags() & 2) > 0;\n  }\n  get hasYield() {\n    return (this.currentFlags() & 1) > 0;\n  }\n  get hasReturn() {\n    return (this.currentFlags() & 4) > 0;\n  }\n  get hasIn() {\n    return (this.currentFlags() & 8) > 0;\n  }\n}\nfunction functionFlags(isAsync, isGenerator) {\n  return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);\n}\nclass UtilParser extends Tokenizer {\n  addExtra(node, key, value, enumerable = true) {\n    if (!node) return;\n    let {\n      extra\n    } = node;\n    if (extra == null) {\n      extra = {};\n      node.extra = extra;\n    }\n    if (enumerable) {\n      extra[key] = value;\n    } else {\n      Object.defineProperty(extra, key, {\n        enumerable,\n        value\n      });\n    }\n  }\n  isContextual(token) {\n    return this.state.type === token && !this.state.containsEsc;\n  }\n  isUnparsedContextual(nameStart, name) {\n    const nameEnd = nameStart + name.length;\n    if (this.input.slice(nameStart, nameEnd) === name) {\n      const nextCh = this.input.charCodeAt(nameEnd);\n      return !(isIdentifierChar(nextCh) || (nextCh & 0xfc00) === 0xd800);\n    }\n    return false;\n  }\n  isLookaheadContextual(name) {\n    const next = this.nextTokenStart();\n    return this.isUnparsedContextual(next, name);\n  }\n  eatContextual(token) {\n    if (this.isContextual(token)) {\n      this.next();\n      return true;\n    }\n    return false;\n  }\n  expectContextual(token, toParseError) {\n    if (!this.eatContextual(token)) {\n      if (toParseError != null) {\n        throw this.raise(toParseError, this.state.startLoc);\n      }\n      this.unexpected(null, token);\n    }\n  }\n  canInsertSemicolon() {\n    return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();\n  }\n  hasPrecedingLineBreak() {\n    return hasNewLine(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);\n  }\n  hasFollowingLineBreak() {\n    return hasNewLine(this.input, this.state.end, this.nextTokenStart());\n  }\n  isLineTerminator() {\n    return this.eat(13) || this.canInsertSemicolon();\n  }\n  semicolon(allowAsi = true) {\n    if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;\n    this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);\n  }\n  expect(type, loc) {\n    if (!this.eat(type)) {\n      this.unexpected(loc, type);\n    }\n  }\n  tryParse(fn, oldState = this.state.clone()) {\n    const abortSignal = {\n      node: null\n    };\n    try {\n      const node = fn((node = null) => {\n        abortSignal.node = node;\n        throw abortSignal;\n      });\n      if (this.state.errors.length > oldState.errors.length) {\n        const failState = this.state;\n        this.state = oldState;\n        this.state.tokensLength = failState.tokensLength;\n        return {\n          node,\n          error: failState.errors[oldState.errors.length],\n          thrown: false,\n          aborted: false,\n          failState\n        };\n      }\n      return {\n        node,\n        error: null,\n        thrown: false,\n        aborted: false,\n        failState: null\n      };\n    } catch (error) {\n      const failState = this.state;\n      this.state = oldState;\n      if (error instanceof SyntaxError) {\n        return {\n          node: null,\n          error,\n          thrown: true,\n          aborted: false,\n          failState\n        };\n      }\n      if (error === abortSignal) {\n        return {\n          node: abortSignal.node,\n          error: null,\n          thrown: false,\n          aborted: true,\n          failState\n        };\n      }\n      throw error;\n    }\n  }\n  checkExpressionErrors(refExpressionErrors, andThrow) {\n    if (!refExpressionErrors) return false;\n    const {\n      shorthandAssignLoc,\n      doubleProtoLoc,\n      privateKeyLoc,\n      optionalParametersLoc\n    } = refExpressionErrors;\n    const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;\n    if (!andThrow) {\n      return hasErrors;\n    }\n    if (shorthandAssignLoc != null) {\n      this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);\n    }\n    if (doubleProtoLoc != null) {\n      this.raise(Errors.DuplicateProto, doubleProtoLoc);\n    }\n    if (privateKeyLoc != null) {\n      this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);\n    }\n    if (optionalParametersLoc != null) {\n      this.unexpected(optionalParametersLoc);\n    }\n  }\n  isLiteralPropertyName() {\n    return tokenIsLiteralPropertyName(this.state.type);\n  }\n  isPrivateName(node) {\n    return node.type === \"PrivateName\";\n  }\n  getPrivateNameSV(node) {\n    return node.id.name;\n  }\n  hasPropertyAsPrivateName(node) {\n    return (node.type === \"MemberExpression\" || node.type === \"OptionalMemberExpression\") && this.isPrivateName(node.property);\n  }\n  isObjectProperty(node) {\n    return node.type === \"ObjectProperty\";\n  }\n  isObjectMethod(node) {\n    return node.type === \"ObjectMethod\";\n  }\n  initializeScopes(inModule = this.options.sourceType === \"module\") {\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    const oldExportedIdentifiers = this.exportedIdentifiers;\n    this.exportedIdentifiers = new Set();\n    const oldInModule = this.inModule;\n    this.inModule = inModule;\n    const oldScope = this.scope;\n    const ScopeHandler = this.getScopeHandler();\n    this.scope = new ScopeHandler(this, inModule);\n    const oldProdParam = this.prodParam;\n    this.prodParam = new ProductionParameterHandler();\n    const oldClassScope = this.classScope;\n    this.classScope = new ClassScopeHandler(this);\n    const oldExpressionScope = this.expressionScope;\n    this.expressionScope = new ExpressionScopeHandler(this);\n    return () => {\n      this.state.labels = oldLabels;\n      this.exportedIdentifiers = oldExportedIdentifiers;\n      this.inModule = oldInModule;\n      this.scope = oldScope;\n      this.prodParam = oldProdParam;\n      this.classScope = oldClassScope;\n      this.expressionScope = oldExpressionScope;\n    };\n  }\n  enterInitialScopes() {\n    let paramFlags = 0;\n    if (this.inModule) {\n      paramFlags |= 2;\n    }\n    if (this.optionFlags & 32) {\n      paramFlags |= 1;\n    }\n    this.scope.enter(1);\n    this.prodParam.enter(paramFlags);\n  }\n  checkDestructuringPrivate(refExpressionErrors) {\n    const {\n      privateKeyLoc\n    } = refExpressionErrors;\n    if (privateKeyLoc !== null) {\n      this.expectPlugin(\"destructuringPrivate\", privateKeyLoc);\n    }\n  }\n}\nclass ExpressionErrors {\n  constructor() {\n    this.shorthandAssignLoc = null;\n    this.doubleProtoLoc = null;\n    this.privateKeyLoc = null;\n    this.optionalParametersLoc = null;\n  }\n}\nclass Node {\n  constructor(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if ((parser == null ? void 0 : parser.optionFlags) & 128) this.range = [pos, 0];\n    if (parser != null && parser.filename) this.loc.filename = parser.filename;\n  }\n}\nconst NodePrototype = Node.prototype;\n{\n  NodePrototype.__clone = function () {\n    const newNode = new Node(undefined, this.start, this.loc.start);\n    const keys = Object.keys(this);\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      if (key !== \"leadingComments\" && key !== \"trailingComments\" && key !== \"innerComments\") {\n        newNode[key] = this[key];\n      }\n    }\n    return newNode;\n  };\n}\nfunction clonePlaceholder(node) {\n  return cloneIdentifier(node);\n}\nfunction cloneIdentifier(node) {\n  const {\n    type,\n    start,\n    end,\n    loc,\n    range,\n    extra,\n    name\n  } = node;\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  cloned.extra = extra;\n  cloned.name = name;\n  if (type === \"Placeholder\") {\n    cloned.expectedNode = node.expectedNode;\n  }\n  return cloned;\n}\nfunction cloneStringLiteral(node) {\n  const {\n    type,\n    start,\n    end,\n    loc,\n    range,\n    extra\n  } = node;\n  if (type === \"Placeholder\") {\n    return clonePlaceholder(node);\n  }\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  if (node.raw !== undefined) {\n    cloned.raw = node.raw;\n  } else {\n    cloned.extra = extra;\n  }\n  cloned.value = node.value;\n  return cloned;\n}\nclass NodeUtils extends UtilParser {\n  startNode() {\n    const loc = this.state.startLoc;\n    return new Node(this, loc.index, loc);\n  }\n  startNodeAt(loc) {\n    return new Node(this, loc.index, loc);\n  }\n  startNodeAtNode(type) {\n    return this.startNodeAt(type.loc.start);\n  }\n  finishNode(node, type) {\n    return this.finishNodeAt(node, type, this.state.lastTokEndLoc);\n  }\n  finishNodeAt(node, type, endLoc) {\n    node.type = type;\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.optionFlags & 128) node.range[1] = endLoc.index;\n    if (this.optionFlags & 4096) {\n      this.processComment(node);\n    }\n    return node;\n  }\n  resetStartLocation(node, startLoc) {\n    node.start = startLoc.index;\n    node.loc.start = startLoc;\n    if (this.optionFlags & 128) node.range[0] = startLoc.index;\n  }\n  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.optionFlags & 128) node.range[1] = endLoc.index;\n  }\n  resetStartLocationFromNode(node, locationNode) {\n    this.resetStartLocation(node, locationNode.loc.start);\n  }\n}\nconst reservedTypes = new Set([\"_\", \"any\", \"bool\", \"boolean\", \"empty\", \"extends\", \"false\", \"interface\", \"mixed\", \"null\", \"number\", \"static\", \"string\", \"true\", \"typeof\", \"void\"]);\nconst FlowErrors = ParseErrorEnum`flow`({\n  AmbiguousConditionalArrow: \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",\n  AmbiguousDeclareModuleKind: \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.\",\n  AssignReservedType: ({\n    reservedType\n  }) => `Cannot overwrite reserved type ${reservedType}.`,\n  DeclareClassElement: \"The `declare` modifier can only appear on class fields.\",\n  DeclareClassFieldInitializer: \"Initializers are not allowed in fields with the `declare` modifier.\",\n  DuplicateDeclareModuleExports: \"Duplicate `declare module.exports` statement.\",\n  EnumBooleanMemberNotInitialized: ({\n    memberName,\n    enumName\n  }) => `Boolean enum members need to be initialized. Use either \\`${memberName} = true,\\` or \\`${memberName} = false,\\` in enum \\`${enumName}\\`.`,\n  EnumDuplicateMemberName: ({\n    memberName,\n    enumName\n  }) => `Enum member names need to be unique, but the name \\`${memberName}\\` has already been used before in enum \\`${enumName}\\`.`,\n  EnumInconsistentMemberValues: ({\n    enumName\n  }) => `Enum \\`${enumName}\\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,\n  EnumInvalidExplicitType: ({\n    invalidEnumType,\n    enumName\n  }) => `Enum type \\`${invalidEnumType}\\` is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidExplicitTypeUnknownSupplied: ({\n    enumName\n  }) => `Supplied enum type is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberInitializerPrimaryType: ({\n    enumName,\n    memberName,\n    explicitType\n  }) => `Enum \\`${enumName}\\` has type \\`${explicitType}\\`, so the initializer of \\`${memberName}\\` needs to be a ${explicitType} literal.`,\n  EnumInvalidMemberInitializerSymbolType: ({\n    enumName,\n    memberName\n  }) => `Symbol enum members cannot be initialized. Use \\`${memberName},\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberInitializerUnknownType: ({\n    enumName,\n    memberName\n  }) => `The enum member initializer for \\`${memberName}\\` needs to be a literal (either a boolean, number, or string) in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberName: ({\n    enumName,\n    memberName,\n    suggestion\n  }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \\`${memberName}\\`, consider using \\`${suggestion}\\`, in enum \\`${enumName}\\`.`,\n  EnumNumberMemberNotInitialized: ({\n    enumName,\n    memberName\n  }) => `Number enum members need to be initialized, e.g. \\`${memberName} = 1\\` in enum \\`${enumName}\\`.`,\n  EnumStringMemberInconsistentlyInitialized: ({\n    enumName\n  }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \\`${enumName}\\`.`,\n  GetterMayNotHaveThisParam: \"A getter cannot have a `this` parameter.\",\n  ImportReflectionHasImportType: \"An `import module` declaration can not use `type` or `typeof` keyword.\",\n  ImportTypeShorthandOnlyInPureImport: \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.\",\n  InexactInsideExact: \"Explicit inexact syntax cannot appear inside an explicit exact object type.\",\n  InexactInsideNonObject: \"Explicit inexact syntax cannot appear in class or interface definitions.\",\n  InexactVariance: \"Explicit inexact syntax cannot have variance.\",\n  InvalidNonTypeImportInDeclareModule: \"Imports within a `declare module` body must always be `import type` or `import typeof`.\",\n  MissingTypeParamDefault: \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",\n  NestedDeclareModule: \"`declare module` cannot be used inside another `declare module`.\",\n  NestedFlowComment: \"Cannot have a flow comment inside another flow comment.\",\n  PatternIsOptional: Object.assign({\n    message: \"A binding pattern parameter cannot be optional in an implementation signature.\"\n  }, {\n    reasonCode: \"OptionalBindingPattern\"\n  }),\n  SetterMayNotHaveThisParam: \"A setter cannot have a `this` parameter.\",\n  SpreadVariance: \"Spread properties cannot have variance.\",\n  ThisParamAnnotationRequired: \"A type annotation is required for the `this` parameter.\",\n  ThisParamBannedInConstructor: \"Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.\",\n  ThisParamMayNotBeOptional: \"The `this` parameter cannot be optional.\",\n  ThisParamMustBeFirst: \"The `this` parameter must be the first function parameter.\",\n  ThisParamNoDefault: \"The `this` parameter may not have a default value.\",\n  TypeBeforeInitializer: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeCastInPattern: \"The type cast expression is expected to be wrapped with parenthesis.\",\n  UnexpectedExplicitInexactInObject: \"Explicit inexact syntax must appear at the end of an inexact object.\",\n  UnexpectedReservedType: ({\n    reservedType\n  }) => `Unexpected reserved type ${reservedType}.`,\n  UnexpectedReservedUnderscore: \"`_` is only allowed as a type argument to call or new.\",\n  UnexpectedSpaceBetweenModuloChecks: \"Spaces between `%` and `checks` are not allowed here.\",\n  UnexpectedSpreadType: \"Spread operator cannot appear in class or interface definitions.\",\n  UnexpectedSubtractionOperand: 'Unexpected token, expected \"number\" or \"bigint\".',\n  UnexpectedTokenAfterTypeParameter: \"Expected an arrow function after this type parameter declaration.\",\n  UnexpectedTypeParameterBeforeAsyncArrowFunction: \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.\",\n  UnsupportedDeclareExportKind: ({\n    unsupportedExportKind,\n    suggestion\n  }) => `\\`declare export ${unsupportedExportKind}\\` is not supported. Use \\`${suggestion}\\` instead.`,\n  UnsupportedStatementInDeclareModule: \"Only declares and type imports are allowed inside declare module.\",\n  UnterminatedFlowComment: \"Unterminated flow-comment.\"\n});\nfunction isEsModuleType(bodyElement) {\n  return bodyElement.type === \"DeclareExportAllDeclaration\" || bodyElement.type === \"DeclareExportDeclaration\" && (!bodyElement.declaration || bodyElement.declaration.type !== \"TypeAlias\" && bodyElement.declaration.type !== \"InterfaceDeclaration\");\n}\nfunction hasTypeImportKind(node) {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\nconst exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\"\n};\nfunction partition(list, test) {\n  const list1 = [];\n  const list2 = [];\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n  return [list1, list2];\n}\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\nvar flow = superClass => class FlowParserMixin extends superClass {\n  constructor(...args) {\n    super(...args);\n    this.flowPragma = undefined;\n  }\n  getScopeHandler() {\n    return FlowScopeHandler;\n  }\n  shouldParseTypes() {\n    return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\n  }\n  finishToken(type, val) {\n    if (type !== 134 && type !== 13 && type !== 28) {\n      if (this.flowPragma === undefined) {\n        this.flowPragma = null;\n      }\n    }\n    super.finishToken(type, val);\n  }\n  addComment(comment) {\n    if (this.flowPragma === undefined) {\n      const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n      if (!matches) ;else if (matches[1] === \"flow\") {\n        this.flowPragma = \"flow\";\n      } else if (matches[1] === \"noflow\") {\n        this.flowPragma = \"noflow\";\n      } else {\n        throw new Error(\"Unexpected flow pragma\");\n      }\n    }\n    super.addComment(comment);\n  }\n  flowParseTypeInitialiser(tok) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(tok || 14);\n    const type = this.flowParseType();\n    this.state.inType = oldInType;\n    return type;\n  }\n  flowParsePredicate() {\n    const node = this.startNode();\n    const moduloLoc = this.state.startLoc;\n    this.next();\n    this.expectContextual(110);\n    if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) {\n      this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc);\n    }\n    if (this.eat(10)) {\n      node.value = super.parseExpression();\n      this.expect(11);\n      return this.finishNode(node, \"DeclaredPredicate\");\n    } else {\n      return this.finishNode(node, \"InferredPredicate\");\n    }\n  }\n  flowParseTypeAndPredicateInitialiser() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(14);\n    let type = null;\n    let predicate = null;\n    if (this.match(54)) {\n      this.state.inType = oldInType;\n      predicate = this.flowParsePredicate();\n    } else {\n      type = this.flowParseType();\n      this.state.inType = oldInType;\n      if (this.match(54)) {\n        predicate = this.flowParsePredicate();\n      }\n    }\n    return [type, predicate];\n  }\n  flowParseDeclareClass(node) {\n    this.next();\n    this.flowParseInterfaceish(node, true);\n    return this.finishNode(node, \"DeclareClass\");\n  }\n  flowParseDeclareFunction(node) {\n    this.next();\n    const id = node.id = this.parseIdentifier();\n    const typeNode = this.startNode();\n    const typeContainer = this.startNode();\n    if (this.match(47)) {\n      typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      typeNode.typeParameters = null;\n    }\n    this.expect(10);\n    const tmp = this.flowParseFunctionTypeParams();\n    typeNode.params = tmp.params;\n    typeNode.rest = tmp.rest;\n    typeNode.this = tmp._this;\n    this.expect(11);\n    [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n    typeContainer.typeAnnotation = this.finishNode(typeNode, \"FunctionTypeAnnotation\");\n    id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n    this.resetEndLocation(id);\n    this.semicolon();\n    this.scope.declareName(node.id.name, 2048, node.id.loc.start);\n    return this.finishNode(node, \"DeclareFunction\");\n  }\n  flowParseDeclare(node, insideModule) {\n    if (this.match(80)) {\n      return this.flowParseDeclareClass(node);\n    } else if (this.match(68)) {\n      return this.flowParseDeclareFunction(node);\n    } else if (this.match(74)) {\n      return this.flowParseDeclareVariable(node);\n    } else if (this.eatContextual(127)) {\n      if (this.match(16)) {\n        return this.flowParseDeclareModuleExports(node);\n      } else {\n        if (insideModule) {\n          this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc);\n        }\n        return this.flowParseDeclareModule(node);\n      }\n    } else if (this.isContextual(130)) {\n      return this.flowParseDeclareTypeAlias(node);\n    } else if (this.isContextual(131)) {\n      return this.flowParseDeclareOpaqueType(node);\n    } else if (this.isContextual(129)) {\n      return this.flowParseDeclareInterface(node);\n    } else if (this.match(82)) {\n      return this.flowParseDeclareExportDeclaration(node, insideModule);\n    } else {\n      this.unexpected();\n    }\n  }\n  flowParseDeclareVariable(node) {\n    this.next();\n    node.id = this.flowParseTypeAnnotatableIdentifier(true);\n    this.scope.declareName(node.id.name, 5, node.id.loc.start);\n    this.semicolon();\n    return this.finishNode(node, \"DeclareVariable\");\n  }\n  flowParseDeclareModule(node) {\n    this.scope.enter(0);\n    if (this.match(134)) {\n      node.id = super.parseExprAtom();\n    } else {\n      node.id = this.parseIdentifier();\n    }\n    const bodyNode = node.body = this.startNode();\n    const body = bodyNode.body = [];\n    this.expect(5);\n    while (!this.match(8)) {\n      let bodyNode = this.startNode();\n      if (this.match(83)) {\n        this.next();\n        if (!this.isContextual(130) && !this.match(87)) {\n          this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);\n        }\n        super.parseImport(bodyNode);\n      } else {\n        this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);\n        bodyNode = this.flowParseDeclare(bodyNode, true);\n      }\n      body.push(bodyNode);\n    }\n    this.scope.exit();\n    this.expect(8);\n    this.finishNode(bodyNode, \"BlockStatement\");\n    let kind = null;\n    let hasModuleExport = false;\n    body.forEach(bodyElement => {\n      if (isEsModuleType(bodyElement)) {\n        if (kind === \"CommonJS\") {\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);\n        }\n        kind = \"ES\";\n      } else if (bodyElement.type === \"DeclareModuleExports\") {\n        if (hasModuleExport) {\n          this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement);\n        }\n        if (kind === \"ES\") {\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);\n        }\n        kind = \"CommonJS\";\n        hasModuleExport = true;\n      }\n    });\n    node.kind = kind || \"CommonJS\";\n    return this.finishNode(node, \"DeclareModule\");\n  }\n  flowParseDeclareExportDeclaration(node, insideModule) {\n    this.expect(82);\n    if (this.eat(65)) {\n      if (this.match(68) || this.match(80)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n      } else {\n        node.declaration = this.flowParseType();\n        this.semicolon();\n      }\n      node.default = true;\n      return this.finishNode(node, \"DeclareExportDeclaration\");\n    } else {\n      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {\n        const label = this.state.value;\n        throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {\n          unsupportedExportKind: label,\n          suggestion: exportSuggestions[label]\n        });\n      }\n      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n        node.default = false;\n        return this.finishNode(node, \"DeclareExportDeclaration\");\n      } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {\n        node = this.parseExport(node, null);\n        if (node.type === \"ExportNamedDeclaration\") {\n          node.type = \"ExportDeclaration\";\n          node.default = false;\n          delete node.exportKind;\n        }\n        node.type = \"Declare\" + node.type;\n        return node;\n      }\n    }\n    this.unexpected();\n  }\n  flowParseDeclareModuleExports(node) {\n    this.next();\n    this.expectContextual(111);\n    node.typeAnnotation = this.flowParseTypeAnnotation();\n    this.semicolon();\n    return this.finishNode(node, \"DeclareModuleExports\");\n  }\n  flowParseDeclareTypeAlias(node) {\n    this.next();\n    const finished = this.flowParseTypeAlias(node);\n    finished.type = \"DeclareTypeAlias\";\n    return finished;\n  }\n  flowParseDeclareOpaqueType(node) {\n    this.next();\n    const finished = this.flowParseOpaqueType(node, true);\n    finished.type = \"DeclareOpaqueType\";\n    return finished;\n  }\n  flowParseDeclareInterface(node) {\n    this.next();\n    this.flowParseInterfaceish(node, false);\n    return this.finishNode(node, \"DeclareInterface\");\n  }\n  flowParseInterfaceish(node, isClass) {\n    node.id = this.flowParseRestrictedIdentifier(!isClass, true);\n    this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.extends = [];\n    if (this.eat(81)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (!isClass && this.eat(12));\n    }\n    if (isClass) {\n      node.implements = [];\n      node.mixins = [];\n      if (this.eatContextual(117)) {\n        do {\n          node.mixins.push(this.flowParseInterfaceExtends());\n        } while (this.eat(12));\n      }\n      if (this.eatContextual(113)) {\n        do {\n          node.implements.push(this.flowParseInterfaceExtends());\n        } while (this.eat(12));\n      }\n    }\n    node.body = this.flowParseObjectType({\n      allowStatic: isClass,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: isClass,\n      allowInexact: false\n    });\n  }\n  flowParseInterfaceExtends() {\n    const node = this.startNode();\n    node.id = this.flowParseQualifiedTypeIdentifier();\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    } else {\n      node.typeParameters = null;\n    }\n    return this.finishNode(node, \"InterfaceExtends\");\n  }\n  flowParseInterface(node) {\n    this.flowParseInterfaceish(node, false);\n    return this.finishNode(node, \"InterfaceDeclaration\");\n  }\n  checkNotUnderscore(word) {\n    if (word === \"_\") {\n      this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);\n    }\n  }\n  checkReservedType(word, startLoc, declaration) {\n    if (!reservedTypes.has(word)) return;\n    this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {\n      reservedType: word\n    });\n  }\n  flowParseRestrictedIdentifier(liberal, declaration) {\n    this.checkReservedType(this.state.value, this.state.startLoc, declaration);\n    return this.parseIdentifier(liberal);\n  }\n  flowParseTypeAlias(node) {\n    node.id = this.flowParseRestrictedIdentifier(false, true);\n    this.scope.declareName(node.id.name, 8201, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.right = this.flowParseTypeInitialiser(29);\n    this.semicolon();\n    return this.finishNode(node, \"TypeAlias\");\n  }\n  flowParseOpaqueType(node, declare) {\n    this.expectContextual(130);\n    node.id = this.flowParseRestrictedIdentifier(true, true);\n    this.scope.declareName(node.id.name, 8201, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.supertype = null;\n    if (this.match(14)) {\n      node.supertype = this.flowParseTypeInitialiser(14);\n    }\n    node.impltype = null;\n    if (!declare) {\n      node.impltype = this.flowParseTypeInitialiser(29);\n    }\n    this.semicolon();\n    return this.finishNode(node, \"OpaqueType\");\n  }\n  flowParseTypeParameter(requireDefault = false) {\n    const nodeStartLoc = this.state.startLoc;\n    const node = this.startNode();\n    const variance = this.flowParseVariance();\n    const ident = this.flowParseTypeAnnotatableIdentifier();\n    node.name = ident.name;\n    node.variance = variance;\n    node.bound = ident.typeAnnotation;\n    if (this.match(29)) {\n      this.eat(29);\n      node.default = this.flowParseType();\n    } else {\n      if (requireDefault) {\n        this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc);\n      }\n    }\n    return this.finishNode(node, \"TypeParameter\");\n  }\n  flowParseTypeParameterDeclaration() {\n    const oldInType = this.state.inType;\n    const node = this.startNode();\n    node.params = [];\n    this.state.inType = true;\n    if (this.match(47) || this.match(143)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n    let defaultRequired = false;\n    do {\n      const typeParameter = this.flowParseTypeParameter(defaultRequired);\n      node.params.push(typeParameter);\n      if (typeParameter.default) {\n        defaultRequired = true;\n      }\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    } while (!this.match(48));\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterDeclaration\");\n  }\n  flowInTopLevelContext(cb) {\n    if (this.curContext() !== types.brace) {\n      const oldContext = this.state.context;\n      this.state.context = [oldContext[0]];\n      try {\n        return cb();\n      } finally {\n        this.state.context = oldContext;\n      }\n    } else {\n      return cb();\n    }\n  }\n  flowParseTypeParameterInstantiationInExpression() {\n    if (this.reScan_lt() !== 47) return;\n    return this.flowParseTypeParameterInstantiation();\n  }\n  flowParseTypeParameterInstantiation() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    node.params = [];\n    this.flowInTopLevelContext(() => {\n      this.expect(47);\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = false;\n      while (!this.match(48)) {\n        node.params.push(this.flowParseType());\n        if (!this.match(48)) {\n          this.expect(12);\n        }\n      }\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    });\n    this.state.inType = oldInType;\n    if (!this.state.inType && this.curContext() === types.brace) {\n      this.reScan_lt_gt();\n    }\n    this.expect(48);\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n  flowParseTypeParameterInstantiationCallOrNew() {\n    if (this.reScan_lt() !== 47) return;\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expect(47);\n    while (!this.match(48)) {\n      node.params.push(this.flowParseTypeOrImplicitInstantiation());\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    }\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n  flowParseInterfaceType() {\n    const node = this.startNode();\n    this.expectContextual(129);\n    node.extends = [];\n    if (this.eat(81)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (this.eat(12));\n    }\n    node.body = this.flowParseObjectType({\n      allowStatic: false,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: false,\n      allowInexact: false\n    });\n    return this.finishNode(node, \"InterfaceTypeAnnotation\");\n  }\n  flowParseObjectPropertyKey() {\n    return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(true);\n  }\n  flowParseObjectTypeIndexer(node, isStatic, variance) {\n    node.static = isStatic;\n    if (this.lookahead().type === 14) {\n      node.id = this.flowParseObjectPropertyKey();\n      node.key = this.flowParseTypeInitialiser();\n    } else {\n      node.id = null;\n      node.key = this.flowParseType();\n    }\n    this.expect(3);\n    node.value = this.flowParseTypeInitialiser();\n    node.variance = variance;\n    return this.finishNode(node, \"ObjectTypeIndexer\");\n  }\n  flowParseObjectTypeInternalSlot(node, isStatic) {\n    node.static = isStatic;\n    node.id = this.flowParseObjectPropertyKey();\n    this.expect(3);\n    this.expect(3);\n    if (this.match(47) || this.match(10)) {\n      node.method = true;\n      node.optional = false;\n      node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));\n    } else {\n      node.method = false;\n      if (this.eat(17)) {\n        node.optional = true;\n      }\n      node.value = this.flowParseTypeInitialiser();\n    }\n    return this.finishNode(node, \"ObjectTypeInternalSlot\");\n  }\n  flowParseObjectTypeMethodish(node) {\n    node.params = [];\n    node.rest = null;\n    node.typeParameters = null;\n    node.this = null;\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    this.expect(10);\n    if (this.match(78)) {\n      node.this = this.flowParseFunctionTypeParam(true);\n      node.this.name = null;\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    while (!this.match(11) && !this.match(21)) {\n      node.params.push(this.flowParseFunctionTypeParam(false));\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    if (this.eat(21)) {\n      node.rest = this.flowParseFunctionTypeParam(false);\n    }\n    this.expect(11);\n    node.returnType = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"FunctionTypeAnnotation\");\n  }\n  flowParseObjectTypeCallProperty(node, isStatic) {\n    const valueNode = this.startNode();\n    node.static = isStatic;\n    node.value = this.flowParseObjectTypeMethodish(valueNode);\n    return this.finishNode(node, \"ObjectTypeCallProperty\");\n  }\n  flowParseObjectType({\n    allowStatic,\n    allowExact,\n    allowSpread,\n    allowProto,\n    allowInexact\n  }) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const nodeStart = this.startNode();\n    nodeStart.callProperties = [];\n    nodeStart.properties = [];\n    nodeStart.indexers = [];\n    nodeStart.internalSlots = [];\n    let endDelim;\n    let exact;\n    let inexact = false;\n    if (allowExact && this.match(6)) {\n      this.expect(6);\n      endDelim = 9;\n      exact = true;\n    } else {\n      this.expect(5);\n      endDelim = 8;\n      exact = false;\n    }\n    nodeStart.exact = exact;\n    while (!this.match(endDelim)) {\n      let isStatic = false;\n      let protoStartLoc = null;\n      let inexactStartLoc = null;\n      const node = this.startNode();\n      if (allowProto && this.isContextual(118)) {\n        const lookahead = this.lookahead();\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          protoStartLoc = this.state.startLoc;\n          allowStatic = false;\n        }\n      }\n      if (allowStatic && this.isContextual(106)) {\n        const lookahead = this.lookahead();\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          isStatic = true;\n        }\n      }\n      const variance = this.flowParseVariance();\n      if (this.eat(0)) {\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (this.eat(0)) {\n          if (variance) {\n            this.unexpected(variance.loc.start);\n          }\n          nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));\n        } else {\n          nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));\n        }\n      } else if (this.match(10) || this.match(47)) {\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (variance) {\n          this.unexpected(variance.loc.start);\n        }\n        nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));\n      } else {\n        let kind = \"init\";\n        if (this.isContextual(99) || this.isContextual(104)) {\n          const lookahead = this.lookahead();\n          if (tokenIsLiteralPropertyName(lookahead.type)) {\n            kind = this.state.value;\n            this.next();\n          }\n        }\n        const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);\n        if (propOrInexact === null) {\n          inexact = true;\n          inexactStartLoc = this.state.lastTokStartLoc;\n        } else {\n          nodeStart.properties.push(propOrInexact);\n        }\n      }\n      this.flowObjectTypeSemicolon();\n      if (inexactStartLoc && !this.match(8) && !this.match(9)) {\n        this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);\n      }\n    }\n    this.expect(endDelim);\n    if (allowSpread) {\n      nodeStart.inexact = inexact;\n    }\n    const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n    this.state.inType = oldInType;\n    return out;\n  }\n  flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {\n    if (this.eat(21)) {\n      const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);\n      if (isInexactToken) {\n        if (!allowSpread) {\n          this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc);\n        } else if (!allowInexact) {\n          this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc);\n        }\n        if (variance) {\n          this.raise(FlowErrors.InexactVariance, variance);\n        }\n        return null;\n      }\n      if (!allowSpread) {\n        this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc);\n      }\n      if (protoStartLoc != null) {\n        this.unexpected(protoStartLoc);\n      }\n      if (variance) {\n        this.raise(FlowErrors.SpreadVariance, variance);\n      }\n      node.argument = this.flowParseType();\n      return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n    } else {\n      node.key = this.flowParseObjectPropertyKey();\n      node.static = isStatic;\n      node.proto = protoStartLoc != null;\n      node.kind = kind;\n      let optional = false;\n      if (this.match(47) || this.match(10)) {\n        node.method = true;\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (variance) {\n          this.unexpected(variance.loc.start);\n        }\n        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));\n        if (kind === \"get\" || kind === \"set\") {\n          this.flowCheckGetterSetterParams(node);\n        }\n        if (!allowSpread && node.key.name === \"constructor\" && node.value.this) {\n          this.raise(FlowErrors.ThisParamBannedInConstructor, node.value.this);\n        }\n      } else {\n        if (kind !== \"init\") this.unexpected();\n        node.method = false;\n        if (this.eat(17)) {\n          optional = true;\n        }\n        node.value = this.flowParseTypeInitialiser();\n        node.variance = variance;\n      }\n      node.optional = optional;\n      return this.finishNode(node, \"ObjectTypeProperty\");\n    }\n  }\n  flowCheckGetterSetterParams(property) {\n    const paramCount = property.kind === \"get\" ? 0 : 1;\n    const length = property.value.params.length + (property.value.rest ? 1 : 0);\n    if (property.value.this) {\n      this.raise(property.kind === \"get\" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property.value.this);\n    }\n    if (length !== paramCount) {\n      this.raise(property.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity, property);\n    }\n    if (property.kind === \"set\" && property.value.rest) {\n      this.raise(Errors.BadSetterRestParameter, property);\n    }\n  }\n  flowObjectTypeSemicolon() {\n    if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {\n      this.unexpected();\n    }\n  }\n  flowParseQualifiedTypeIdentifier(startLoc, id) {\n    startLoc != null ? startLoc : startLoc = this.state.startLoc;\n    let node = id || this.flowParseRestrictedIdentifier(true);\n    while (this.eat(16)) {\n      const node2 = this.startNodeAt(startLoc);\n      node2.qualification = node;\n      node2.id = this.flowParseRestrictedIdentifier(true);\n      node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n    }\n    return node;\n  }\n  flowParseGenericType(startLoc, id) {\n    const node = this.startNodeAt(startLoc);\n    node.typeParameters = null;\n    node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    }\n    return this.finishNode(node, \"GenericTypeAnnotation\");\n  }\n  flowParseTypeofType() {\n    const node = this.startNode();\n    this.expect(87);\n    node.argument = this.flowParsePrimaryType();\n    return this.finishNode(node, \"TypeofTypeAnnotation\");\n  }\n  flowParseTupleType() {\n    const node = this.startNode();\n    node.types = [];\n    this.expect(0);\n    while (this.state.pos < this.length && !this.match(3)) {\n      node.types.push(this.flowParseType());\n      if (this.match(3)) break;\n      this.expect(12);\n    }\n    this.expect(3);\n    return this.finishNode(node, \"TupleTypeAnnotation\");\n  }\n  flowParseFunctionTypeParam(first) {\n    let name = null;\n    let optional = false;\n    let typeAnnotation = null;\n    const node = this.startNode();\n    const lh = this.lookahead();\n    const isThis = this.state.type === 78;\n    if (lh.type === 14 || lh.type === 17) {\n      if (isThis && !first) {\n        this.raise(FlowErrors.ThisParamMustBeFirst, node);\n      }\n      name = this.parseIdentifier(isThis);\n      if (this.eat(17)) {\n        optional = true;\n        if (isThis) {\n          this.raise(FlowErrors.ThisParamMayNotBeOptional, node);\n        }\n      }\n      typeAnnotation = this.flowParseTypeInitialiser();\n    } else {\n      typeAnnotation = this.flowParseType();\n    }\n    node.name = name;\n    node.optional = optional;\n    node.typeAnnotation = typeAnnotation;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n  reinterpretTypeAsFunctionTypeParam(type) {\n    const node = this.startNodeAt(type.loc.start);\n    node.name = null;\n    node.optional = false;\n    node.typeAnnotation = type;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n  flowParseFunctionTypeParams(params = []) {\n    let rest = null;\n    let _this = null;\n    if (this.match(78)) {\n      _this = this.flowParseFunctionTypeParam(true);\n      _this.name = null;\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    while (!this.match(11) && !this.match(21)) {\n      params.push(this.flowParseFunctionTypeParam(false));\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    if (this.eat(21)) {\n      rest = this.flowParseFunctionTypeParam(false);\n    }\n    return {\n      params,\n      rest,\n      _this\n    };\n  }\n  flowIdentToTypeAnnotation(startLoc, node, id) {\n    switch (id.name) {\n      case \"any\":\n        return this.finishNode(node, \"AnyTypeAnnotation\");\n      case \"bool\":\n      case \"boolean\":\n        return this.finishNode(node, \"BooleanTypeAnnotation\");\n      case \"mixed\":\n        return this.finishNode(node, \"MixedTypeAnnotation\");\n      case \"empty\":\n        return this.finishNode(node, \"EmptyTypeAnnotation\");\n      case \"number\":\n        return this.finishNode(node, \"NumberTypeAnnotation\");\n      case \"string\":\n        return this.finishNode(node, \"StringTypeAnnotation\");\n      case \"symbol\":\n        return this.finishNode(node, \"SymbolTypeAnnotation\");\n      default:\n        this.checkNotUnderscore(id.name);\n        return this.flowParseGenericType(startLoc, id);\n    }\n  }\n  flowParsePrimaryType() {\n    const startLoc = this.state.startLoc;\n    const node = this.startNode();\n    let tmp;\n    let type;\n    let isGroupedType = false;\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n    switch (this.state.type) {\n      case 5:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: false,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: true\n        });\n      case 6:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: true,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: false\n        });\n      case 0:\n        this.state.noAnonFunctionType = false;\n        type = this.flowParseTupleType();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        return type;\n      case 47:\n        {\n          const node = this.startNode();\n          node.typeParameters = this.flowParseTypeParameterDeclaration();\n          this.expect(10);\n          tmp = this.flowParseFunctionTypeParams();\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          node.this = tmp._this;\n          this.expect(11);\n          this.expect(19);\n          node.returnType = this.flowParseType();\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n        }\n      case 10:\n        {\n          const node = this.startNode();\n          this.next();\n          if (!this.match(11) && !this.match(21)) {\n            if (tokenIsIdentifier(this.state.type) || this.match(78)) {\n              const token = this.lookahead().type;\n              isGroupedType = token !== 17 && token !== 14;\n            } else {\n              isGroupedType = true;\n            }\n          }\n          if (isGroupedType) {\n            this.state.noAnonFunctionType = false;\n            type = this.flowParseType();\n            this.state.noAnonFunctionType = oldNoAnonFunctionType;\n            if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {\n              this.expect(11);\n              return type;\n            } else {\n              this.eat(12);\n            }\n          }\n          if (type) {\n            tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);\n          } else {\n            tmp = this.flowParseFunctionTypeParams();\n          }\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          node.this = tmp._this;\n          this.expect(11);\n          this.expect(19);\n          node.returnType = this.flowParseType();\n          node.typeParameters = null;\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n        }\n      case 134:\n        return this.parseLiteral(this.state.value, \"StringLiteralTypeAnnotation\");\n      case 85:\n      case 86:\n        node.value = this.match(85);\n        this.next();\n        return this.finishNode(node, \"BooleanLiteralTypeAnnotation\");\n      case 53:\n        if (this.state.value === \"-\") {\n          this.next();\n          if (this.match(135)) {\n            return this.parseLiteralAtNode(-this.state.value, \"NumberLiteralTypeAnnotation\", node);\n          }\n          if (this.match(136)) {\n            return this.parseLiteralAtNode(-this.state.value, \"BigIntLiteralTypeAnnotation\", node);\n          }\n          throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);\n        }\n        this.unexpected();\n        return;\n      case 135:\n        return this.parseLiteral(this.state.value, \"NumberLiteralTypeAnnotation\");\n      case 136:\n        return this.parseLiteral(this.state.value, \"BigIntLiteralTypeAnnotation\");\n      case 88:\n        this.next();\n        return this.finishNode(node, \"VoidTypeAnnotation\");\n      case 84:\n        this.next();\n        return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n      case 78:\n        this.next();\n        return this.finishNode(node, \"ThisTypeAnnotation\");\n      case 55:\n        this.next();\n        return this.finishNode(node, \"ExistsTypeAnnotation\");\n      case 87:\n        return this.flowParseTypeofType();\n      default:\n        if (tokenIsKeyword(this.state.type)) {\n          const label = tokenLabelName(this.state.type);\n          this.next();\n          return super.createIdentifier(node, label);\n        } else if (tokenIsIdentifier(this.state.type)) {\n          if (this.isContextual(129)) {\n            return this.flowParseInterfaceType();\n          }\n          return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());\n        }\n    }\n    this.unexpected();\n  }\n  flowParsePostfixType() {\n    const startLoc = this.state.startLoc;\n    let type = this.flowParsePrimaryType();\n    let seenOptionalIndexedAccess = false;\n    while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startLoc);\n      const optional = this.eat(18);\n      seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;\n      this.expect(0);\n      if (!optional && this.match(3)) {\n        node.elementType = type;\n        this.next();\n        type = this.finishNode(node, \"ArrayTypeAnnotation\");\n      } else {\n        node.objectType = type;\n        node.indexType = this.flowParseType();\n        this.expect(3);\n        if (seenOptionalIndexedAccess) {\n          node.optional = optional;\n          type = this.finishNode(node, \"OptionalIndexedAccessType\");\n        } else {\n          type = this.finishNode(node, \"IndexedAccessType\");\n        }\n      }\n    }\n    return type;\n  }\n  flowParsePrefixType() {\n    const node = this.startNode();\n    if (this.eat(17)) {\n      node.typeAnnotation = this.flowParsePrefixType();\n      return this.finishNode(node, \"NullableTypeAnnotation\");\n    } else {\n      return this.flowParsePostfixType();\n    }\n  }\n  flowParseAnonFunctionWithoutParens() {\n    const param = this.flowParsePrefixType();\n    if (!this.state.noAnonFunctionType && this.eat(19)) {\n      const node = this.startNodeAt(param.loc.start);\n      node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n      node.rest = null;\n      node.this = null;\n      node.returnType = this.flowParseType();\n      node.typeParameters = null;\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    }\n    return param;\n  }\n  flowParseIntersectionType() {\n    const node = this.startNode();\n    this.eat(45);\n    const type = this.flowParseAnonFunctionWithoutParens();\n    node.types = [type];\n    while (this.eat(45)) {\n      node.types.push(this.flowParseAnonFunctionWithoutParens());\n    }\n    return node.types.length === 1 ? type : this.finishNode(node, \"IntersectionTypeAnnotation\");\n  }\n  flowParseUnionType() {\n    const node = this.startNode();\n    this.eat(43);\n    const type = this.flowParseIntersectionType();\n    node.types = [type];\n    while (this.eat(43)) {\n      node.types.push(this.flowParseIntersectionType());\n    }\n    return node.types.length === 1 ? type : this.finishNode(node, \"UnionTypeAnnotation\");\n  }\n  flowParseType() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const type = this.flowParseUnionType();\n    this.state.inType = oldInType;\n    return type;\n  }\n  flowParseTypeOrImplicitInstantiation() {\n    if (this.state.type === 132 && this.state.value === \"_\") {\n      const startLoc = this.state.startLoc;\n      const node = this.parseIdentifier();\n      return this.flowParseGenericType(startLoc, node);\n    } else {\n      return this.flowParseType();\n    }\n  }\n  flowParseTypeAnnotation() {\n    const node = this.startNode();\n    node.typeAnnotation = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"TypeAnnotation\");\n  }\n  flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {\n    const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();\n    if (this.match(14)) {\n      ident.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(ident);\n    }\n    return ident;\n  }\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n  flowParseVariance() {\n    let variance = null;\n    if (this.match(53)) {\n      variance = this.startNode();\n      if (this.state.value === \"+\") {\n        variance.kind = \"plus\";\n      } else {\n        variance.kind = \"minus\";\n      }\n      this.next();\n      return this.finishNode(variance, \"Variance\");\n    }\n    return variance;\n  }\n  parseFunctionBody(node, allowExpressionBody, isMethod = false) {\n    if (allowExpressionBody) {\n      this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));\n      return;\n    }\n    super.parseFunctionBody(node, false, isMethod);\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(14)) {\n      const typeNode = this.startNode();\n      [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n      node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, \"TypeAnnotation\") : null;\n    }\n    return super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n  parseStatementLike(flags) {\n    if (this.state.strict && this.isContextual(129)) {\n      const lookahead = this.lookahead();\n      if (tokenIsKeywordOrIdentifier(lookahead.type)) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseInterface(node);\n      }\n    } else if (this.isContextual(126)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n    const stmt = super.parseStatementLike(flags);\n    if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\n      this.flowPragma = null;\n    }\n    return stmt;\n  }\n  parseExpressionStatement(node, expr, decorators) {\n    if (expr.type === \"Identifier\") {\n      if (expr.name === \"declare\") {\n        if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {\n          return this.flowParseDeclare(node);\n        }\n      } else if (tokenIsIdentifier(this.state.type)) {\n        if (expr.name === \"interface\") {\n          return this.flowParseInterface(node);\n        } else if (expr.name === \"type\") {\n          return this.flowParseTypeAlias(node);\n        } else if (expr.name === \"opaque\") {\n          return this.flowParseOpaqueType(node, false);\n        }\n      }\n    }\n    return super.parseExpressionStatement(node, expr, decorators);\n  }\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n    if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {\n      return !this.state.containsEsc;\n    }\n    return super.shouldParseExportDeclaration();\n  }\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n    if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {\n      return this.state.containsEsc;\n    }\n    return super.isExportDefaultSpecifier();\n  }\n  parseExportDefaultExpression() {\n    if (this.isContextual(126)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n    return super.parseExportDefaultExpression();\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (!this.match(17)) return expr;\n    if (this.state.maybeInArrowParameters) {\n      const nextCh = this.lookaheadCharCode();\n      if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {\n        this.setOptionalParametersError(refExpressionErrors);\n        return expr;\n      }\n    }\n    this.expect(17);\n    const state = this.state.clone();\n    const originalNoArrowAt = this.state.noArrowAt;\n    const node = this.startNodeAt(startLoc);\n    let {\n      consequent,\n      failed\n    } = this.tryParseConditionalConsequent();\n    let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n    if (failed || invalid.length > 0) {\n      const noArrowAt = [...originalNoArrowAt];\n      if (invalid.length > 0) {\n        this.state = state;\n        this.state.noArrowAt = noArrowAt;\n        for (let i = 0; i < invalid.length; i++) {\n          noArrowAt.push(invalid[i].start);\n        }\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n        [valid, invalid] = this.getArrowLikeExpressions(consequent);\n      }\n      if (failed && valid.length > 1) {\n        this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc);\n      }\n      if (failed && valid.length === 1) {\n        this.state = state;\n        noArrowAt.push(valid[0].start);\n        this.state.noArrowAt = noArrowAt;\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n      }\n    }\n    this.getArrowLikeExpressions(consequent, true);\n    this.state.noArrowAt = originalNoArrowAt;\n    this.expect(14);\n    node.test = expr;\n    node.consequent = consequent;\n    node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(undefined, undefined));\n    return this.finishNode(node, \"ConditionalExpression\");\n  }\n  tryParseConditionalConsequent() {\n    this.state.noArrowParamsConversionAt.push(this.state.start);\n    const consequent = this.parseMaybeAssignAllowIn();\n    const failed = !this.match(14);\n    this.state.noArrowParamsConversionAt.pop();\n    return {\n      consequent,\n      failed\n    };\n  }\n  getArrowLikeExpressions(node, disallowInvalid) {\n    const stack = [node];\n    const arrows = [];\n    while (stack.length !== 0) {\n      const node = stack.pop();\n      if (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") {\n        if (node.typeParameters || !node.returnType) {\n          this.finishArrowValidation(node);\n        } else {\n          arrows.push(node);\n        }\n        stack.push(node.body);\n      } else if (node.type === \"ConditionalExpression\") {\n        stack.push(node.consequent);\n        stack.push(node.alternate);\n      }\n    }\n    if (disallowInvalid) {\n      arrows.forEach(node => this.finishArrowValidation(node));\n      return [arrows, []];\n    }\n    return partition(arrows, node => node.params.every(param => this.isAssignable(param, true)));\n  }\n  finishArrowValidation(node) {\n    var _node$extra;\n    this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);\n    this.scope.enter(2 | 4);\n    super.checkParams(node, false, true);\n    this.scope.exit();\n  }\n  forwardNoArrowParamsConversionAt(node, parse) {\n    let result;\n    if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n      result = parse();\n      this.state.noArrowParamsConversionAt.pop();\n    } else {\n      result = parse();\n    }\n    return result;\n  }\n  parseParenItem(node, startLoc) {\n    const newNode = super.parseParenItem(node, startLoc);\n    if (this.eat(17)) {\n      newNode.optional = true;\n      this.resetEndLocation(node);\n    }\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startLoc);\n      typeCastNode.expression = newNode;\n      typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TypeCastExpression\");\n    }\n    return newNode;\n  }\n  assertModuleNodeAllowed(node) {\n    if (node.type === \"ImportDeclaration\" && (node.importKind === \"type\" || node.importKind === \"typeof\") || node.type === \"ExportNamedDeclaration\" && node.exportKind === \"type\" || node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\") {\n      return;\n    }\n    super.assertModuleNodeAllowed(node);\n  }\n  parseExportDeclaration(node) {\n    if (this.isContextual(130)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      if (this.match(5)) {\n        node.specifiers = this.parseExportSpecifiers(true);\n        super.parseExportFrom(node);\n        return null;\n      } else {\n        return this.flowParseTypeAlias(declarationNode);\n      }\n    } else if (this.isContextual(131)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseOpaqueType(declarationNode, false);\n    } else if (this.isContextual(129)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseInterface(declarationNode);\n    } else if (this.isContextual(126)) {\n      node.exportKind = \"value\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(declarationNode);\n    } else {\n      return super.parseExportDeclaration(node);\n    }\n  }\n  eatExportStar(node) {\n    if (super.eatExportStar(node)) return true;\n    if (this.isContextual(130) && this.lookahead().type === 55) {\n      node.exportKind = \"type\";\n      this.next();\n      this.next();\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamespaceSpecifier(node) {\n    const {\n      startLoc\n    } = this.state;\n    const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n    if (hasNamespace && node.exportKind === \"type\") {\n      this.unexpected(startLoc);\n    }\n    return hasNamespace;\n  }\n  parseClassId(node, isStatement, optionalId) {\n    super.parseClassId(node, isStatement, optionalId);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n  }\n  parseClassMember(classBody, member, state) {\n    const {\n      startLoc\n    } = this.state;\n    if (this.isContextual(125)) {\n      if (super.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n      member.declare = true;\n    }\n    super.parseClassMember(classBody, member, state);\n    if (member.declare) {\n      if (member.type !== \"ClassProperty\" && member.type !== \"ClassPrivateProperty\" && member.type !== \"PropertyDefinition\") {\n        this.raise(FlowErrors.DeclareClassElement, startLoc);\n      } else if (member.value) {\n        this.raise(FlowErrors.DeclareClassFieldInitializer, member.value);\n      }\n    }\n  }\n  isIterator(word) {\n    return word === \"iterator\" || word === \"asyncIterator\";\n  }\n  readIterator() {\n    const word = super.readWord1();\n    const fullWord = \"@@\" + word;\n    if (!this.isIterator(word) || !this.state.inType) {\n      this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {\n        identifierName: fullWord\n      });\n    }\n    this.finishToken(132, fullWord);\n  }\n  getTokenFromCode(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 123 && next === 124) {\n      this.finishOp(6, 2);\n    } else if (this.state.inType && (code === 62 || code === 60)) {\n      this.finishOp(code === 62 ? 48 : 47, 1);\n    } else if (this.state.inType && code === 63) {\n      if (next === 46) {\n        this.finishOp(18, 2);\n      } else {\n        this.finishOp(17, 1);\n      }\n    } else if (isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))) {\n      this.state.pos += 2;\n      this.readIterator();\n    } else {\n      super.getTokenFromCode(code);\n    }\n  }\n  isAssignable(node, isBinding) {\n    if (node.type === \"TypeCastExpression\") {\n      return this.isAssignable(node.expression, isBinding);\n    } else {\n      return super.isAssignable(node, isBinding);\n    }\n  }\n  toAssignable(node, isLHS = false) {\n    if (!isLHS && node.type === \"AssignmentExpression\" && node.left.type === \"TypeCastExpression\") {\n      node.left = this.typeCastToParameter(node.left);\n    }\n    super.toAssignable(node, isLHS);\n  }\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n      if ((expr == null ? void 0 : expr.type) === \"TypeCastExpression\") {\n        exprList[i] = this.typeCastToParameter(expr);\n      }\n    }\n    super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n  }\n  toReferencedList(exprList, isParenthesizedExpr) {\n    for (let i = 0; i < exprList.length; i++) {\n      var _expr$extra;\n      const expr = exprList[i];\n      if (expr && expr.type === \"TypeCastExpression\" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {\n        this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);\n      }\n    }\n    return exprList;\n  }\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);\n    if (canBePattern && !this.state.maybeInArrowParameters) {\n      this.toReferencedList(node.elements);\n    }\n    return node;\n  }\n  isValidLVal(type, isParenthesized, binding) {\n    return type === \"TypeCastExpression\" || super.isValidLVal(type, isParenthesized, binding);\n  }\n  parseClassProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n    return super.parseClassProperty(node);\n  }\n  parseClassPrivateProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n    return super.parseClassPrivateProperty(node);\n  }\n  isClassMethod() {\n    return this.match(47) || super.isClassMethod();\n  }\n  isClassProperty() {\n    return this.match(14) || super.isClassProperty();\n  }\n  isNonstaticConstructor(method) {\n    return !this.match(14) && super.isNonstaticConstructor(method);\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    if (method.variance) {\n      this.unexpected(method.variance.loc.start);\n    }\n    delete method.variance;\n    if (this.match(47)) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n    if (method.params && isConstructor) {\n      const params = method.params;\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(FlowErrors.ThisParamBannedInConstructor, method);\n      }\n    } else if (method.type === \"MethodDefinition\" && isConstructor && method.value.params) {\n      const params = method.value.params;\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(FlowErrors.ThisParamBannedInConstructor, method);\n      }\n    }\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    if (method.variance) {\n      this.unexpected(method.variance.loc.start);\n    }\n    delete method.variance;\n    if (this.match(47)) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n    if (node.superClass && (this.match(47) || this.match(51))) {\n      {\n        node.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression();\n      }\n    }\n    if (this.isContextual(113)) {\n      this.next();\n      const implemented = node.implements = [];\n      do {\n        const node = this.startNode();\n        node.id = this.flowParseRestrictedIdentifier(true);\n        if (this.match(47)) {\n          node.typeParameters = this.flowParseTypeParameterInstantiation();\n        } else {\n          node.typeParameters = null;\n        }\n        implemented.push(this.finishNode(node, \"ClassImplements\"));\n      } while (this.eat(12));\n    }\n  }\n  checkGetterSetterParams(method) {\n    super.checkGetterSetterParams(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    if (params.length > 0) {\n      const param = params[0];\n      if (this.isThisParam(param) && method.kind === \"get\") {\n        this.raise(FlowErrors.GetterMayNotHaveThisParam, param);\n      } else if (this.isThisParam(param)) {\n        this.raise(FlowErrors.SetterMayNotHaveThisParam, param);\n      }\n    }\n  }\n  parsePropertyNamePrefixOperator(node) {\n    node.variance = this.flowParseVariance();\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    if (prop.variance) {\n      this.unexpected(prop.variance.loc.start);\n    }\n    delete prop.variance;\n    let typeParameters;\n    if (this.match(47) && !isAccessor) {\n      typeParameters = this.flowParseTypeParameterDeclaration();\n      if (!this.match(10)) this.unexpected();\n    }\n    const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n    if (typeParameters) {\n      (result.value || result).typeParameters = typeParameters;\n    }\n    return result;\n  }\n  parseFunctionParamType(param) {\n    if (this.eat(17)) {\n      if (param.type !== \"Identifier\") {\n        this.raise(FlowErrors.PatternIsOptional, param);\n      }\n      if (this.isThisParam(param)) {\n        this.raise(FlowErrors.ThisParamMayNotBeOptional, param);\n      }\n      param.optional = true;\n    }\n    if (this.match(14)) {\n      param.typeAnnotation = this.flowParseTypeAnnotation();\n    } else if (this.isThisParam(param)) {\n      this.raise(FlowErrors.ThisParamAnnotationRequired, param);\n    }\n    if (this.match(29) && this.isThisParam(param)) {\n      this.raise(FlowErrors.ThisParamNoDefault, param);\n    }\n    this.resetEndLocation(param);\n    return param;\n  }\n  parseMaybeDefault(startLoc, left) {\n    const node = super.parseMaybeDefault(startLoc, left);\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation);\n    }\n    return node;\n  }\n  checkImportReflection(node) {\n    super.checkImportReflection(node);\n    if (node.module && node.importKind !== \"value\") {\n      this.raise(FlowErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);\n    }\n  }\n  parseImportSpecifierLocal(node, specifier, type) {\n    specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n  isPotentialImportPhase(isExport) {\n    if (super.isPotentialImportPhase(isExport)) return true;\n    if (this.isContextual(130)) {\n      if (!isExport) return true;\n      const ch = this.lookaheadCharCode();\n      return ch === 123 || ch === 42;\n    }\n    return !isExport && this.isContextual(87);\n  }\n  applyImportPhase(node, isExport, phase, loc) {\n    super.applyImportPhase(node, isExport, phase, loc);\n    if (isExport) {\n      if (!phase && this.match(65)) {\n        return;\n      }\n      node.exportKind = phase === \"type\" ? phase : \"value\";\n    } else {\n      if (phase === \"type\" && this.match(55)) this.unexpected();\n      node.importKind = phase === \"type\" || phase === \"typeof\" ? phase : \"value\";\n    }\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    const firstIdent = specifier.imported;\n    let specifierTypeKind = null;\n    if (firstIdent.type === \"Identifier\") {\n      if (firstIdent.name === \"type\") {\n        specifierTypeKind = \"type\";\n      } else if (firstIdent.name === \"typeof\") {\n        specifierTypeKind = \"typeof\";\n      }\n    }\n    let isBinding = false;\n    if (this.isContextual(93) && !this.isLookaheadContextual(\"as\")) {\n      const as_ident = this.parseIdentifier(true);\n      if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = as_ident;\n        specifier.importKind = specifierTypeKind;\n        specifier.local = cloneIdentifier(as_ident);\n      } else {\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n        specifier.local = this.parseIdentifier();\n      }\n    } else {\n      if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = this.parseIdentifier(true);\n        specifier.importKind = specifierTypeKind;\n      } else {\n        if (importedIsString) {\n          throw this.raise(Errors.ImportBindingIsString, specifier, {\n            importName: firstIdent.value\n          });\n        }\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n      }\n      if (this.eatContextual(93)) {\n        specifier.local = this.parseIdentifier();\n      } else {\n        isBinding = true;\n        specifier.local = cloneIdentifier(specifier.imported);\n      }\n    }\n    const specifierIsTypeImport = hasTypeImportKind(specifier);\n    if (isInTypeOnlyImport && specifierIsTypeImport) {\n      this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier);\n    }\n    if (isInTypeOnlyImport || specifierIsTypeImport) {\n      this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);\n    }\n    if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {\n      this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);\n    }\n    return this.finishImportSpecifier(specifier, \"ImportSpecifier\");\n  }\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 78:\n        return this.parseIdentifier(true);\n      default:\n        return super.parseBindingAtom();\n    }\n  }\n  parseFunctionParams(node, isConstructor) {\n    const kind = node.kind;\n    if (kind !== \"get\" && kind !== \"set\" && this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.parseFunctionParams(node, isConstructor);\n  }\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n    if (this.match(14)) {\n      decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(decl.id);\n    }\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = true;\n      node.returnType = this.flowParseTypeAnnotation();\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    }\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    var _jsx;\n    let state = null;\n    let jsx;\n    if (this.hasPlugin(\"jsx\") && (this.match(143) || this.match(47))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n      const currentContext = context[context.length - 1];\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\n        context.pop();\n      }\n    }\n    if ((_jsx = jsx) != null && _jsx.error || this.match(47)) {\n      var _jsx2, _jsx3;\n      state = state || this.state.clone();\n      let typeParameters;\n      const arrow = this.tryParse(abort => {\n        var _arrowExpression$extr;\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => {\n          const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n          this.resetStartLocationFromNode(result, typeParameters);\n          return result;\n        });\n        if ((_arrowExpression$extr = arrowExpression.extra) != null && _arrowExpression$extr.parenthesized) abort();\n        const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);\n        if (expr.type !== \"ArrowFunctionExpression\") abort();\n        expr.typeParameters = typeParameters;\n        this.resetStartLocationFromNode(expr, typeParameters);\n        return arrowExpression;\n      }, state);\n      let arrowExpression = null;\n      if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === \"ArrowFunctionExpression\") {\n        if (!arrow.error && !arrow.aborted) {\n          if (arrow.node.async) {\n            this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters);\n          }\n          return arrow.node;\n        }\n        arrowExpression = arrow.node;\n      }\n      if ((_jsx2 = jsx) != null && _jsx2.node) {\n        this.state = jsx.failState;\n        return jsx.node;\n      }\n      if (arrowExpression) {\n        this.state = arrow.failState;\n        return arrowExpression;\n      }\n      if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;\n      if (arrow.thrown) throw arrow.error;\n      throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);\n    }\n    return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n  }\n  parseArrow(node) {\n    if (this.match(14)) {\n      const result = this.tryParse(() => {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        const typeNode = this.startNode();\n        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        if (this.canInsertSemicolon()) this.unexpected();\n        if (!this.match(19)) this.unexpected();\n        return typeNode;\n      });\n      if (result.thrown) return null;\n      if (result.error) this.state = result.failState;\n      node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, \"TypeAnnotation\") : null;\n    }\n    return super.parseArrow(node);\n  }\n  shouldParseArrow(params) {\n    return this.match(14) || super.shouldParseArrow(params);\n  }\n  setArrowFunctionParameters(node, params) {\n    if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {\n      node.params = params;\n    } else {\n      super.setArrowFunctionParameters(node, params);\n    }\n  }\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    if (isArrowFunction && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {\n      return;\n    }\n    for (let i = 0; i < node.params.length; i++) {\n      if (this.isThisParam(node.params[i]) && i > 0) {\n        this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i]);\n      }\n    }\n    super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);\n  }\n  parseParenAndDistinguishExpression(canBeArrow) {\n    return super.parseParenAndDistinguishExpression(canBeArrow && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));\n  }\n  parseSubscripts(base, startLoc, noCalls) {\n    if (base.type === \"Identifier\" && base.name === \"async\" && this.state.noArrowAt.includes(startLoc.index)) {\n      this.next();\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      node.arguments = super.parseCallExpressionArguments(11);\n      base = this.finishNode(node, \"CallExpression\");\n    } else if (base.type === \"Identifier\" && base.name === \"async\" && this.match(47)) {\n      const state = this.state.clone();\n      const arrow = this.tryParse(abort => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);\n      if (!arrow.error && !arrow.aborted) return arrow.node;\n      const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);\n      if (result.node && !result.error) return result.node;\n      if (arrow.node) {\n        this.state = arrow.failState;\n        return arrow.node;\n      }\n      if (result.node) {\n        this.state = result.failState;\n        return result.node;\n      }\n      throw arrow.error || result.error;\n    }\n    return super.parseSubscripts(base, startLoc, noCalls);\n  }\n  parseSubscript(base, startLoc, noCalls, subscriptState) {\n    if (this.match(18) && this.isLookaheadToken_lt()) {\n      subscriptState.optionalChainMember = true;\n      if (noCalls) {\n        subscriptState.stop = true;\n        return base;\n      }\n      this.next();\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      node.typeArguments = this.flowParseTypeParameterInstantiationInExpression();\n      this.expect(10);\n      node.arguments = this.parseCallExpressionArguments(11);\n      node.optional = true;\n      return this.finishCallExpression(node, true);\n    } else if (!noCalls && this.shouldParseTypes() && (this.match(47) || this.match(51))) {\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      const result = this.tryParse(() => {\n        node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();\n        this.expect(10);\n        node.arguments = super.parseCallExpressionArguments(11);\n        if (subscriptState.optionalChainMember) {\n          node.optional = false;\n        }\n        return this.finishCallExpression(node, subscriptState.optionalChainMember);\n      });\n      if (result.node) {\n        if (result.error) this.state = result.failState;\n        return result.node;\n      }\n    }\n    return super.parseSubscript(base, startLoc, noCalls, subscriptState);\n  }\n  parseNewCallee(node) {\n    super.parseNewCallee(node);\n    let targs = null;\n    if (this.shouldParseTypes() && this.match(47)) {\n      targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;\n    }\n    node.typeArguments = targs;\n  }\n  parseAsyncArrowWithTypeParameters(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    this.parseFunctionParams(node, false);\n    if (!this.parseArrow(node)) return;\n    return super.parseArrowExpression(node, undefined, true);\n  }\n  readToken_mult_modulo(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 42 && next === 47 && this.state.hasFlowComment) {\n      this.state.hasFlowComment = false;\n      this.state.pos += 2;\n      this.nextToken();\n      return;\n    }\n    super.readToken_mult_modulo(code);\n  }\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 124 && next === 125) {\n      this.finishOp(9, 2);\n      return;\n    }\n    super.readToken_pipe_amp(code);\n  }\n  parseTopLevel(file, program) {\n    const fileNode = super.parseTopLevel(file, program);\n    if (this.state.hasFlowComment) {\n      this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition());\n    }\n    return fileNode;\n  }\n  skipBlockComment() {\n    if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n      if (this.state.hasFlowComment) {\n        throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);\n      }\n      this.hasFlowCommentCompletion();\n      const commentSkip = this.skipFlowComment();\n      if (commentSkip) {\n        this.state.pos += commentSkip;\n        this.state.hasFlowComment = true;\n      }\n      return;\n    }\n    return super.skipBlockComment(this.state.hasFlowComment ? \"*-/\" : \"*/\");\n  }\n  skipFlowComment() {\n    const {\n      pos\n    } = this.state;\n    let shiftToFirstNonWhiteSpace = 2;\n    while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {\n      shiftToFirstNonWhiteSpace++;\n    }\n    const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n    const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n    if (ch2 === 58 && ch3 === 58) {\n      return shiftToFirstNonWhiteSpace + 2;\n    }\n    if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === \"flow-include\") {\n      return shiftToFirstNonWhiteSpace + 12;\n    }\n    if (ch2 === 58 && ch3 !== 58) {\n      return shiftToFirstNonWhiteSpace;\n    }\n    return false;\n  }\n  hasFlowCommentCompletion() {\n    const end = this.input.indexOf(\"*/\", this.state.pos);\n    if (end === -1) {\n      throw this.raise(Errors.UnterminatedComment, this.state.curPosition());\n    }\n  }\n  flowEnumErrorBooleanMemberNotInitialized(loc, {\n    enumName,\n    memberName\n  }) {\n    this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {\n      memberName,\n      enumName\n    });\n  }\n  flowEnumErrorInvalidMemberInitializer(loc, enumContext) {\n    return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === \"symbol\" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, loc, enumContext);\n  }\n  flowEnumErrorNumberMemberNotInitialized(loc, details) {\n    this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);\n  }\n  flowEnumErrorStringMemberInconsistentlyInitialized(node, details) {\n    this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node, details);\n  }\n  flowEnumMemberInit() {\n    const startLoc = this.state.startLoc;\n    const endOfInit = () => this.match(12) || this.match(8);\n    switch (this.state.type) {\n      case 135:\n        {\n          const literal = this.parseNumericLiteral(this.state.value);\n          if (endOfInit()) {\n            return {\n              type: \"number\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n      case 134:\n        {\n          const literal = this.parseStringLiteral(this.state.value);\n          if (endOfInit()) {\n            return {\n              type: \"string\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n      case 85:\n      case 86:\n        {\n          const literal = this.parseBooleanLiteral(this.match(85));\n          if (endOfInit()) {\n            return {\n              type: \"boolean\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n      default:\n        return {\n          type: \"invalid\",\n          loc: startLoc\n        };\n    }\n  }\n  flowEnumMemberRaw() {\n    const loc = this.state.startLoc;\n    const id = this.parseIdentifier(true);\n    const init = this.eat(29) ? this.flowEnumMemberInit() : {\n      type: \"none\",\n      loc\n    };\n    return {\n      id,\n      init\n    };\n  }\n  flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {\n    const {\n      explicitType\n    } = context;\n    if (explicitType === null) {\n      return;\n    }\n    if (explicitType !== expectedType) {\n      this.flowEnumErrorInvalidMemberInitializer(loc, context);\n    }\n  }\n  flowEnumMembers({\n    enumName,\n    explicitType\n  }) {\n    const seenNames = new Set();\n    const members = {\n      booleanMembers: [],\n      numberMembers: [],\n      stringMembers: [],\n      defaultedMembers: []\n    };\n    let hasUnknownMembers = false;\n    while (!this.match(8)) {\n      if (this.eat(21)) {\n        hasUnknownMembers = true;\n        break;\n      }\n      const memberNode = this.startNode();\n      const {\n        id,\n        init\n      } = this.flowEnumMemberRaw();\n      const memberName = id.name;\n      if (memberName === \"\") {\n        continue;\n      }\n      if (/^[a-z]/.test(memberName)) {\n        this.raise(FlowErrors.EnumInvalidMemberName, id, {\n          memberName,\n          suggestion: memberName[0].toUpperCase() + memberName.slice(1),\n          enumName\n        });\n      }\n      if (seenNames.has(memberName)) {\n        this.raise(FlowErrors.EnumDuplicateMemberName, id, {\n          memberName,\n          enumName\n        });\n      }\n      seenNames.add(memberName);\n      const context = {\n        enumName,\n        explicitType,\n        memberName\n      };\n      memberNode.id = id;\n      switch (init.type) {\n        case \"boolean\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"boolean\");\n            memberNode.init = init.value;\n            members.booleanMembers.push(this.finishNode(memberNode, \"EnumBooleanMember\"));\n            break;\n          }\n        case \"number\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"number\");\n            memberNode.init = init.value;\n            members.numberMembers.push(this.finishNode(memberNode, \"EnumNumberMember\"));\n            break;\n          }\n        case \"string\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"string\");\n            memberNode.init = init.value;\n            members.stringMembers.push(this.finishNode(memberNode, \"EnumStringMember\"));\n            break;\n          }\n        case \"invalid\":\n          {\n            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);\n          }\n        case \"none\":\n          {\n            switch (explicitType) {\n              case \"boolean\":\n                this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);\n                break;\n              case \"number\":\n                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);\n                break;\n              default:\n                members.defaultedMembers.push(this.finishNode(memberNode, \"EnumDefaultedMember\"));\n            }\n          }\n      }\n      if (!this.match(8)) {\n        this.expect(12);\n      }\n    }\n    return {\n      members,\n      hasUnknownMembers\n    };\n  }\n  flowEnumStringMembers(initializedMembers, defaultedMembers, {\n    enumName\n  }) {\n    if (initializedMembers.length === 0) {\n      return defaultedMembers;\n    } else if (defaultedMembers.length === 0) {\n      return initializedMembers;\n    } else if (defaultedMembers.length > initializedMembers.length) {\n      for (const member of initializedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {\n          enumName\n        });\n      }\n      return defaultedMembers;\n    } else {\n      for (const member of defaultedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {\n          enumName\n        });\n      }\n      return initializedMembers;\n    }\n  }\n  flowEnumParseExplicitType({\n    enumName\n  }) {\n    if (!this.eatContextual(102)) return null;\n    if (!tokenIsIdentifier(this.state.type)) {\n      throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {\n        enumName\n      });\n    }\n    const {\n      value\n    } = this.state;\n    this.next();\n    if (value !== \"boolean\" && value !== \"number\" && value !== \"string\" && value !== \"symbol\") {\n      this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {\n        enumName,\n        invalidEnumType: value\n      });\n    }\n    return value;\n  }\n  flowEnumBody(node, id) {\n    const enumName = id.name;\n    const nameLoc = id.loc.start;\n    const explicitType = this.flowEnumParseExplicitType({\n      enumName\n    });\n    this.expect(5);\n    const {\n      members,\n      hasUnknownMembers\n    } = this.flowEnumMembers({\n      enumName,\n      explicitType\n    });\n    node.hasUnknownMembers = hasUnknownMembers;\n    switch (explicitType) {\n      case \"boolean\":\n        node.explicitType = true;\n        node.members = members.booleanMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumBooleanBody\");\n      case \"number\":\n        node.explicitType = true;\n        node.members = members.numberMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumNumberBody\");\n      case \"string\":\n        node.explicitType = true;\n        node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n          enumName\n        });\n        this.expect(8);\n        return this.finishNode(node, \"EnumStringBody\");\n      case \"symbol\":\n        node.members = members.defaultedMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumSymbolBody\");\n      default:\n        {\n          const empty = () => {\n            node.members = [];\n            this.expect(8);\n            return this.finishNode(node, \"EnumStringBody\");\n          };\n          node.explicitType = false;\n          const boolsLen = members.booleanMembers.length;\n          const numsLen = members.numberMembers.length;\n          const strsLen = members.stringMembers.length;\n          const defaultedLen = members.defaultedMembers.length;\n          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n            return empty();\n          } else if (!boolsLen && !numsLen) {\n            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n              enumName\n            });\n            this.expect(8);\n            return this.finishNode(node, \"EnumStringBody\");\n          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n            node.members = members.booleanMembers;\n            this.expect(8);\n            return this.finishNode(node, \"EnumBooleanBody\");\n          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n            node.members = members.numberMembers;\n            this.expect(8);\n            return this.finishNode(node, \"EnumNumberBody\");\n          } else {\n            this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {\n              enumName\n            });\n            return empty();\n          }\n        }\n    }\n  }\n  flowParseEnumDeclaration(node) {\n    const id = this.parseIdentifier();\n    node.id = id;\n    node.body = this.flowEnumBody(this.startNode(), id);\n    return this.finishNode(node, \"EnumDeclaration\");\n  }\n  jsxParseOpeningElementAfterName(node) {\n    if (this.shouldParseTypes()) {\n      if (this.match(47) || this.match(51)) {\n        node.typeArguments = this.flowParseTypeParameterInstantiationInExpression();\n      }\n    }\n    return super.jsxParseOpeningElementAfterName(node);\n  }\n  isLookaheadToken_lt() {\n    const next = this.nextTokenStart();\n    if (this.input.charCodeAt(next) === 60) {\n      const afterNext = this.input.charCodeAt(next + 1);\n      return afterNext !== 60 && afterNext !== 61;\n    }\n    return false;\n  }\n  reScan_lt_gt() {\n    const {\n      type\n    } = this.state;\n    if (type === 47) {\n      this.state.pos -= 1;\n      this.readToken_lt();\n    } else if (type === 48) {\n      this.state.pos -= 1;\n      this.readToken_gt();\n    }\n  }\n  reScan_lt() {\n    const {\n      type\n    } = this.state;\n    if (type === 51) {\n      this.state.pos -= 2;\n      this.finishOp(47, 1);\n      return 47;\n    }\n    return type;\n  }\n  maybeUnwrapTypeCastExpression(node) {\n    return node.type === \"TypeCastExpression\" ? node.expression : node;\n  }\n};\nconst entities = {\n  __proto__: null,\n  quot: \"\\u0022\",\n  amp: \"&\",\n  apos: \"\\u0027\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\u00A0\",\n  iexcl: \"\\u00A1\",\n  cent: \"\\u00A2\",\n  pound: \"\\u00A3\",\n  curren: \"\\u00A4\",\n  yen: \"\\u00A5\",\n  brvbar: \"\\u00A6\",\n  sect: \"\\u00A7\",\n  uml: \"\\u00A8\",\n  copy: \"\\u00A9\",\n  ordf: \"\\u00AA\",\n  laquo: \"\\u00AB\",\n  not: \"\\u00AC\",\n  shy: \"\\u00AD\",\n  reg: \"\\u00AE\",\n  macr: \"\\u00AF\",\n  deg: \"\\u00B0\",\n  plusmn: \"\\u00B1\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  acute: \"\\u00B4\",\n  micro: \"\\u00B5\",\n  para: \"\\u00B6\",\n  middot: \"\\u00B7\",\n  cedil: \"\\u00B8\",\n  sup1: \"\\u00B9\",\n  ordm: \"\\u00BA\",\n  raquo: \"\\u00BB\",\n  frac14: \"\\u00BC\",\n  frac12: \"\\u00BD\",\n  frac34: \"\\u00BE\",\n  iquest: \"\\u00BF\",\n  Agrave: \"\\u00C0\",\n  Aacute: \"\\u00C1\",\n  Acirc: \"\\u00C2\",\n  Atilde: \"\\u00C3\",\n  Auml: \"\\u00C4\",\n  Aring: \"\\u00C5\",\n  AElig: \"\\u00C6\",\n  Ccedil: \"\\u00C7\",\n  Egrave: \"\\u00C8\",\n  Eacute: \"\\u00C9\",\n  Ecirc: \"\\u00CA\",\n  Euml: \"\\u00CB\",\n  Igrave: \"\\u00CC\",\n  Iacute: \"\\u00CD\",\n  Icirc: \"\\u00CE\",\n  Iuml: \"\\u00CF\",\n  ETH: \"\\u00D0\",\n  Ntilde: \"\\u00D1\",\n  Ograve: \"\\u00D2\",\n  Oacute: \"\\u00D3\",\n  Ocirc: \"\\u00D4\",\n  Otilde: \"\\u00D5\",\n  Ouml: \"\\u00D6\",\n  times: \"\\u00D7\",\n  Oslash: \"\\u00D8\",\n  Ugrave: \"\\u00D9\",\n  Uacute: \"\\u00DA\",\n  Ucirc: \"\\u00DB\",\n  Uuml: \"\\u00DC\",\n  Yacute: \"\\u00DD\",\n  THORN: \"\\u00DE\",\n  szlig: \"\\u00DF\",\n  agrave: \"\\u00E0\",\n  aacute: \"\\u00E1\",\n  acirc: \"\\u00E2\",\n  atilde: \"\\u00E3\",\n  auml: \"\\u00E4\",\n  aring: \"\\u00E5\",\n  aelig: \"\\u00E6\",\n  ccedil: \"\\u00E7\",\n  egrave: \"\\u00E8\",\n  eacute: \"\\u00E9\",\n  ecirc: \"\\u00EA\",\n  euml: \"\\u00EB\",\n  igrave: \"\\u00EC\",\n  iacute: \"\\u00ED\",\n  icirc: \"\\u00EE\",\n  iuml: \"\\u00EF\",\n  eth: \"\\u00F0\",\n  ntilde: \"\\u00F1\",\n  ograve: \"\\u00F2\",\n  oacute: \"\\u00F3\",\n  ocirc: \"\\u00F4\",\n  otilde: \"\\u00F5\",\n  ouml: \"\\u00F6\",\n  divide: \"\\u00F7\",\n  oslash: \"\\u00F8\",\n  ugrave: \"\\u00F9\",\n  uacute: \"\\u00FA\",\n  ucirc: \"\\u00FB\",\n  uuml: \"\\u00FC\",\n  yacute: \"\\u00FD\",\n  thorn: \"\\u00FE\",\n  yuml: \"\\u00FF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\"\n};\nconst JsxErrors = ParseErrorEnum`jsx`({\n  AttributeIsEmpty: \"JSX attributes must only be assigned a non-empty expression.\",\n  MissingClosingTagElement: ({\n    openingTagName\n  }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,\n  MissingClosingTagFragment: \"Expected corresponding JSX closing tag for <>.\",\n  UnexpectedSequenceExpression: \"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?\",\n  UnexpectedToken: ({\n    unexpected,\n    HTMLEntity\n  }) => `Unexpected token \\`${unexpected}\\`. Did you mean \\`${HTMLEntity}\\` or \\`{'${unexpected}'}\\`?`,\n  UnsupportedJsxValue: \"JSX value should be either an expression or a quoted JSX text.\",\n  UnterminatedJsxContent: \"Unterminated JSX contents.\",\n  UnwrappedAdjacentJSXElements: \"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\"\n});\nfunction isFragment(object) {\n  return object ? object.type === \"JSXOpeningFragment\" || object.type === \"JSXClosingFragment\" : false;\n}\nfunction getQualifiedJSXName(object) {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n  if (object.type === \"JSXMemberExpression\") {\n    return getQualifiedJSXName(object.object) + \".\" + getQualifiedJSXName(object.property);\n  }\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\nvar jsx = superClass => class JSXParserMixin extends superClass {\n  jsxReadToken() {\n    let out = \"\";\n    let chunkStart = this.state.pos;\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);\n      }\n      const ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case 60:\n        case 123:\n          if (this.state.pos === this.state.start) {\n            if (ch === 60 && this.state.canStartJSXElement) {\n              ++this.state.pos;\n              this.finishToken(143);\n            } else {\n              super.getTokenFromCode(ch);\n            }\n            return;\n          }\n          out += this.input.slice(chunkStart, this.state.pos);\n          this.finishToken(142, out);\n          return;\n        case 38:\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n          break;\n        case 62:\n        case 125:\n        default:\n          if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadNewLine(true);\n            chunkStart = this.state.pos;\n          } else {\n            ++this.state.pos;\n          }\n      }\n    }\n  }\n  jsxReadNewLine(normalizeCRLF) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let out;\n    ++this.state.pos;\n    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {\n      ++this.state.pos;\n      out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n    } else {\n      out = String.fromCharCode(ch);\n    }\n    ++this.state.curLine;\n    this.state.lineStart = this.state.pos;\n    return out;\n  }\n  jsxReadString(quote) {\n    let out = \"\";\n    let chunkStart = ++this.state.pos;\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(Errors.UnterminatedString, this.state.startLoc);\n      }\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n      if (ch === 38) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadEntity();\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadNewLine(false);\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n    out += this.input.slice(chunkStart, this.state.pos++);\n    this.finishToken(134, out);\n  }\n  jsxReadEntity() {\n    const startPos = ++this.state.pos;\n    if (this.codePointAtPos(this.state.pos) === 35) {\n      ++this.state.pos;\n      let radix = 10;\n      if (this.codePointAtPos(this.state.pos) === 120) {\n        radix = 16;\n        ++this.state.pos;\n      }\n      const codePoint = this.readInt(radix, undefined, false, \"bail\");\n      if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {\n        ++this.state.pos;\n        return String.fromCodePoint(codePoint);\n      }\n    } else {\n      let count = 0;\n      let semi = false;\n      while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) === 59)) {\n        ++this.state.pos;\n      }\n      if (semi) {\n        const desc = this.input.slice(startPos, this.state.pos);\n        const entity = entities[desc];\n        ++this.state.pos;\n        if (entity) {\n          return entity;\n        }\n      }\n    }\n    this.state.pos = startPos;\n    return \"&\";\n  }\n  jsxReadWord() {\n    let ch;\n    const start = this.state.pos;\n    do {\n      ch = this.input.charCodeAt(++this.state.pos);\n    } while (isIdentifierChar(ch) || ch === 45);\n    this.finishToken(141, this.input.slice(start, this.state.pos));\n  }\n  jsxParseIdentifier() {\n    const node = this.startNode();\n    if (this.match(141)) {\n      node.name = this.state.value;\n    } else if (tokenIsKeyword(this.state.type)) {\n      node.name = tokenLabelName(this.state.type);\n    } else {\n      this.unexpected();\n    }\n    this.next();\n    return this.finishNode(node, \"JSXIdentifier\");\n  }\n  jsxParseNamespacedName() {\n    const startLoc = this.state.startLoc;\n    const name = this.jsxParseIdentifier();\n    if (!this.eat(14)) return name;\n    const node = this.startNodeAt(startLoc);\n    node.namespace = name;\n    node.name = this.jsxParseIdentifier();\n    return this.finishNode(node, \"JSXNamespacedName\");\n  }\n  jsxParseElementName() {\n    const startLoc = this.state.startLoc;\n    let node = this.jsxParseNamespacedName();\n    if (node.type === \"JSXNamespacedName\") {\n      return node;\n    }\n    while (this.eat(16)) {\n      const newNode = this.startNodeAt(startLoc);\n      newNode.object = node;\n      newNode.property = this.jsxParseIdentifier();\n      node = this.finishNode(newNode, \"JSXMemberExpression\");\n    }\n    return node;\n  }\n  jsxParseAttributeValue() {\n    let node;\n    switch (this.state.type) {\n      case 5:\n        node = this.startNode();\n        this.setContext(types.brace);\n        this.next();\n        node = this.jsxParseExpressionContainer(node, types.j_oTag);\n        if (node.expression.type === \"JSXEmptyExpression\") {\n          this.raise(JsxErrors.AttributeIsEmpty, node);\n        }\n        return node;\n      case 143:\n      case 134:\n        return this.parseExprAtom();\n      default:\n        throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);\n    }\n  }\n  jsxParseEmptyExpression() {\n    const node = this.startNodeAt(this.state.lastTokEndLoc);\n    return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.startLoc);\n  }\n  jsxParseSpreadChild(node) {\n    this.next();\n    node.expression = this.parseExpression();\n    this.setContext(types.j_expr);\n    this.state.canStartJSXElement = true;\n    this.expect(8);\n    return this.finishNode(node, \"JSXSpreadChild\");\n  }\n  jsxParseExpressionContainer(node, previousContext) {\n    if (this.match(8)) {\n      node.expression = this.jsxParseEmptyExpression();\n    } else {\n      const expression = this.parseExpression();\n      node.expression = expression;\n    }\n    this.setContext(previousContext);\n    this.state.canStartJSXElement = true;\n    this.expect(8);\n    return this.finishNode(node, \"JSXExpressionContainer\");\n  }\n  jsxParseAttribute() {\n    const node = this.startNode();\n    if (this.match(5)) {\n      this.setContext(types.brace);\n      this.next();\n      this.expect(21);\n      node.argument = this.parseMaybeAssignAllowIn();\n      this.setContext(types.j_oTag);\n      this.state.canStartJSXElement = true;\n      this.expect(8);\n      return this.finishNode(node, \"JSXSpreadAttribute\");\n    }\n    node.name = this.jsxParseNamespacedName();\n    node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;\n    return this.finishNode(node, \"JSXAttribute\");\n  }\n  jsxParseOpeningElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    if (this.eat(144)) {\n      return this.finishNode(node, \"JSXOpeningFragment\");\n    }\n    node.name = this.jsxParseElementName();\n    return this.jsxParseOpeningElementAfterName(node);\n  }\n  jsxParseOpeningElementAfterName(node) {\n    const attributes = [];\n    while (!this.match(56) && !this.match(144)) {\n      attributes.push(this.jsxParseAttribute());\n    }\n    node.attributes = attributes;\n    node.selfClosing = this.eat(56);\n    this.expect(144);\n    return this.finishNode(node, \"JSXOpeningElement\");\n  }\n  jsxParseClosingElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    if (this.eat(144)) {\n      return this.finishNode(node, \"JSXClosingFragment\");\n    }\n    node.name = this.jsxParseElementName();\n    this.expect(144);\n    return this.finishNode(node, \"JSXClosingElement\");\n  }\n  jsxParseElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    const children = [];\n    const openingElement = this.jsxParseOpeningElementAt(startLoc);\n    let closingElement = null;\n    if (!openingElement.selfClosing) {\n      contents: for (;;) {\n        switch (this.state.type) {\n          case 143:\n            startLoc = this.state.startLoc;\n            this.next();\n            if (this.eat(56)) {\n              closingElement = this.jsxParseClosingElementAt(startLoc);\n              break contents;\n            }\n            children.push(this.jsxParseElementAt(startLoc));\n            break;\n          case 142:\n            children.push(this.parseLiteral(this.state.value, \"JSXText\"));\n            break;\n          case 5:\n            {\n              const node = this.startNode();\n              this.setContext(types.brace);\n              this.next();\n              if (this.match(21)) {\n                children.push(this.jsxParseSpreadChild(node));\n              } else {\n                children.push(this.jsxParseExpressionContainer(node, types.j_expr));\n              }\n              break;\n            }\n          default:\n            this.unexpected();\n        }\n      }\n      if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {\n        this.raise(JsxErrors.MissingClosingTagFragment, closingElement);\n      } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n        this.raise(JsxErrors.MissingClosingTagElement, closingElement, {\n          openingTagName: getQualifiedJSXName(openingElement.name)\n        });\n      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(JsxErrors.MissingClosingTagElement, closingElement, {\n            openingTagName: getQualifiedJSXName(openingElement.name)\n          });\n        }\n      }\n    }\n    if (isFragment(openingElement)) {\n      node.openingFragment = openingElement;\n      node.closingFragment = closingElement;\n    } else {\n      node.openingElement = openingElement;\n      node.closingElement = closingElement;\n    }\n    node.children = children;\n    if (this.match(47)) {\n      throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);\n    }\n    return isFragment(openingElement) ? this.finishNode(node, \"JSXFragment\") : this.finishNode(node, \"JSXElement\");\n  }\n  jsxParseElement() {\n    const startLoc = this.state.startLoc;\n    this.next();\n    return this.jsxParseElementAt(startLoc);\n  }\n  setContext(newContext) {\n    const {\n      context\n    } = this.state;\n    context[context.length - 1] = newContext;\n  }\n  parseExprAtom(refExpressionErrors) {\n    if (this.match(143)) {\n      return this.jsxParseElement();\n    } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {\n      this.replaceToken(143);\n      return this.jsxParseElement();\n    } else {\n      return super.parseExprAtom(refExpressionErrors);\n    }\n  }\n  skipSpace() {\n    const curContext = this.curContext();\n    if (!curContext.preserveSpace) super.skipSpace();\n  }\n  getTokenFromCode(code) {\n    const context = this.curContext();\n    if (context === types.j_expr) {\n      this.jsxReadToken();\n      return;\n    }\n    if (context === types.j_oTag || context === types.j_cTag) {\n      if (isIdentifierStart(code)) {\n        this.jsxReadWord();\n        return;\n      }\n      if (code === 62) {\n        ++this.state.pos;\n        this.finishToken(144);\n        return;\n      }\n      if ((code === 34 || code === 39) && context === types.j_oTag) {\n        this.jsxReadString(code);\n        return;\n      }\n    }\n    if (code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {\n      ++this.state.pos;\n      this.finishToken(143);\n      return;\n    }\n    super.getTokenFromCode(code);\n  }\n  updateContext(prevType) {\n    const {\n      context,\n      type\n    } = this.state;\n    if (type === 56 && prevType === 143) {\n      context.splice(-2, 2, types.j_cTag);\n      this.state.canStartJSXElement = false;\n    } else if (type === 143) {\n      context.push(types.j_oTag);\n    } else if (type === 144) {\n      const out = context[context.length - 1];\n      if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {\n        context.pop();\n        this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;\n      } else {\n        this.setContext(types.j_expr);\n        this.state.canStartJSXElement = true;\n      }\n    } else {\n      this.state.canStartJSXElement = tokenComesBeforeExpression(type);\n    }\n  }\n};\nclass TypeScriptScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.tsNames = new Map();\n  }\n}\nclass TypeScriptScopeHandler extends ScopeHandler {\n  constructor(...args) {\n    super(...args);\n    this.importsStack = [];\n  }\n  createScope(flags) {\n    this.importsStack.push(new Set());\n    return new TypeScriptScope(flags);\n  }\n  enter(flags) {\n    if (flags === 256) {\n      this.importsStack.push(new Set());\n    }\n    super.enter(flags);\n  }\n  exit() {\n    const flags = super.exit();\n    if (flags === 256) {\n      this.importsStack.pop();\n    }\n    return flags;\n  }\n  hasImport(name, allowShadow) {\n    const len = this.importsStack.length;\n    if (this.importsStack[len - 1].has(name)) {\n      return true;\n    }\n    if (!allowShadow && len > 1) {\n      for (let i = 0; i < len - 1; i++) {\n        if (this.importsStack[i].has(name)) return true;\n      }\n    }\n    return false;\n  }\n  declareName(name, bindingType, loc) {\n    if (bindingType & 4096) {\n      if (this.hasImport(name, true)) {\n        this.parser.raise(Errors.VarRedeclaration, loc, {\n          identifierName: name\n        });\n      }\n      this.importsStack[this.importsStack.length - 1].add(name);\n      return;\n    }\n    const scope = this.currentScope();\n    let type = scope.tsNames.get(name) || 0;\n    if (bindingType & 1024) {\n      this.maybeExportDefined(scope, name);\n      scope.tsNames.set(name, type | 16);\n      return;\n    }\n    super.declareName(name, bindingType, loc);\n    if (bindingType & 2) {\n      if (!(bindingType & 1)) {\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        this.maybeExportDefined(scope, name);\n      }\n      type = type | 1;\n    }\n    if (bindingType & 256) {\n      type = type | 2;\n    }\n    if (bindingType & 512) {\n      type = type | 4;\n    }\n    if (bindingType & 128) {\n      type = type | 8;\n    }\n    if (type) scope.tsNames.set(name, type);\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    const type = scope.tsNames.get(name);\n    if ((type & 2) > 0) {\n      if (bindingType & 256) {\n        const isConst = !!(bindingType & 512);\n        const wasConst = (type & 4) > 0;\n        return isConst !== wasConst;\n      }\n      return true;\n    }\n    if (bindingType & 128 && (type & 8) > 0) {\n      if (scope.names.get(name) & 2) {\n        return !!(bindingType & 1);\n      } else {\n        return false;\n      }\n    }\n    if (bindingType & 2 && (type & 1) > 0) {\n      return true;\n    }\n    return super.isRedeclaredInScope(scope, name, bindingType);\n  }\n  checkLocalExport(id) {\n    const {\n      name\n    } = id;\n    if (this.hasImport(name)) return;\n    const len = this.scopeStack.length;\n    for (let i = len - 1; i >= 0; i--) {\n      const scope = this.scopeStack[i];\n      const type = scope.tsNames.get(name);\n      if ((type & 1) > 0 || (type & 16) > 0) {\n        return;\n      }\n    }\n    super.checkLocalExport(id);\n  }\n}\nconst unwrapParenthesizedExpression = node => {\n  return node.type === \"ParenthesizedExpression\" ? unwrapParenthesizedExpression(node.expression) : node;\n};\nclass LValParser extends NodeUtils {\n  toAssignable(node, isLHS = false) {\n    var _node$extra, _node$extra3;\n    let parenthesized = undefined;\n    if (node.type === \"ParenthesizedExpression\" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {\n      parenthesized = unwrapParenthesizedExpression(node);\n      if (isLHS) {\n        if (parenthesized.type === \"Identifier\") {\n          this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node);\n        } else if (parenthesized.type !== \"MemberExpression\" && !this.isOptionalMemberExpression(parenthesized)) {\n          this.raise(Errors.InvalidParenthesizedAssignment, node);\n        }\n      } else {\n        this.raise(Errors.InvalidParenthesizedAssignment, node);\n      }\n    }\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        break;\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {\n          var _node$extra2;\n          const prop = node.properties[i];\n          const isLast = i === last;\n          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n          if (isLast && prop.type === \"RestElement\" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {\n            this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);\n          }\n        }\n        break;\n      case \"ObjectProperty\":\n        {\n          const {\n            key,\n            value\n          } = node;\n          if (this.isPrivateName(key)) {\n            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\n          }\n          this.toAssignable(value, isLHS);\n          break;\n        }\n      case \"SpreadElement\":\n        {\n          throw new Error(\"Internal @babel/parser error (this is a bug, please report it).\" + \" SpreadElement should be converted by .toAssignable's caller.\");\n        }\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);\n        break;\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(Errors.MissingEqInAssignment, node.left.loc.end);\n        }\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isLHS);\n        break;\n      case \"ParenthesizedExpression\":\n        this.toAssignable(parenthesized, isLHS);\n        break;\n    }\n  }\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.type === \"ObjectMethod\") {\n      this.raise(prop.kind === \"get\" || prop.kind === \"set\" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);\n    } else if (prop.type === \"SpreadElement\") {\n      prop.type = \"RestElement\";\n      const arg = prop.argument;\n      this.checkToRestConversion(arg, false);\n      this.toAssignable(arg, isLHS);\n      if (!isLast) {\n        this.raise(Errors.RestTrailingComma, prop);\n      }\n    } else {\n      this.toAssignable(prop, isLHS);\n    }\n  }\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    const end = exprList.length - 1;\n    for (let i = 0; i <= end; i++) {\n      const elt = exprList[i];\n      if (!elt) continue;\n      this.toAssignableListItem(exprList, i, isLHS);\n      if (elt.type === \"RestElement\") {\n        if (i < end) {\n          this.raise(Errors.RestTrailingComma, elt);\n        } else if (trailingCommaLoc) {\n          this.raise(Errors.RestTrailingComma, trailingCommaLoc);\n        }\n      }\n    }\n  }\n  toAssignableListItem(exprList, index, isLHS) {\n    const node = exprList[index];\n    if (node.type === \"SpreadElement\") {\n      node.type = \"RestElement\";\n      const arg = node.argument;\n      this.checkToRestConversion(arg, true);\n      this.toAssignable(arg, isLHS);\n    } else {\n      this.toAssignable(node, isLHS);\n    }\n  }\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        return true;\n      case \"ObjectExpression\":\n        {\n          const last = node.properties.length - 1;\n          return node.properties.every((prop, i) => {\n            return prop.type !== \"ObjectMethod\" && (i === last || prop.type !== \"SpreadElement\") && this.isAssignable(prop);\n          });\n        }\n      case \"ObjectProperty\":\n        return this.isAssignable(node.value);\n      case \"SpreadElement\":\n        return this.isAssignable(node.argument);\n      case \"ArrayExpression\":\n        return node.elements.every(element => element === null || this.isAssignable(element));\n      case \"AssignmentExpression\":\n        return node.operator === \"=\";\n      case \"ParenthesizedExpression\":\n        return this.isAssignable(node.expression);\n      case \"MemberExpression\":\n      case \"OptionalMemberExpression\":\n        return !isBinding;\n      default:\n        return false;\n    }\n  }\n  toReferencedList(exprList, isParenthesizedExpr) {\n    return exprList;\n  }\n  toReferencedListDeep(exprList, isParenthesizedExpr) {\n    this.toReferencedList(exprList, isParenthesizedExpr);\n    for (const expr of exprList) {\n      if ((expr == null ? void 0 : expr.type) === \"ArrayExpression\") {\n        this.toReferencedListDeep(expr.elements);\n      }\n    }\n  }\n  parseSpread(refExpressionErrors) {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined);\n    return this.finishNode(node, \"SpreadElement\");\n  }\n  parseRestBinding() {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n  }\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 0:\n        {\n          const node = this.startNode();\n          this.next();\n          node.elements = this.parseBindingList(3, 93, 1);\n          return this.finishNode(node, \"ArrayPattern\");\n        }\n      case 5:\n        return this.parseObjectLike(8, true);\n    }\n    return this.parseIdentifier();\n  }\n  parseBindingList(close, closeCharCode, flags) {\n    const allowEmpty = flags & 1;\n    const elts = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n      }\n      if (allowEmpty && this.match(12)) {\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(21)) {\n        let rest = this.parseRestBinding();\n        if (this.hasPlugin(\"flow\") || flags & 2) {\n          rest = this.parseFunctionParamType(rest);\n        }\n        elts.push(rest);\n        if (!this.checkCommaAfterRest(closeCharCode)) {\n          this.expect(close);\n          break;\n        }\n      } else {\n        const decorators = [];\n        if (flags & 2) {\n          if (this.match(26) && this.hasPlugin(\"decorators\")) {\n            this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);\n          }\n          while (this.match(26)) {\n            decorators.push(this.parseDecorator());\n          }\n        }\n        elts.push(this.parseBindingElement(flags, decorators));\n      }\n    }\n    return elts;\n  }\n  parseBindingRestProperty(prop) {\n    this.next();\n    prop.argument = this.parseIdentifier();\n    this.checkCommaAfterRest(125);\n    return this.finishNode(prop, \"RestElement\");\n  }\n  parseBindingProperty() {\n    const {\n      type,\n      startLoc\n    } = this.state;\n    if (type === 21) {\n      return this.parseBindingRestProperty(this.startNode());\n    }\n    const prop = this.startNode();\n    if (type === 139) {\n      this.expectPlugin(\"destructuringPrivate\", startLoc);\n      this.classScope.usePrivateName(this.state.value, startLoc);\n      prop.key = this.parsePrivateName();\n    } else {\n      this.parsePropertyName(prop);\n    }\n    prop.method = false;\n    return this.parseObjPropValue(prop, startLoc, false, false, true, false);\n  }\n  parseBindingElement(flags, decorators) {\n    const left = this.parseMaybeDefault();\n    if (this.hasPlugin(\"flow\") || flags & 2) {\n      this.parseFunctionParamType(left);\n    }\n    const elt = this.parseMaybeDefault(left.loc.start, left);\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n    return elt;\n  }\n  parseFunctionParamType(param) {\n    return param;\n  }\n  parseMaybeDefault(startLoc, left) {\n    startLoc != null ? startLoc : startLoc = this.state.startLoc;\n    left = left != null ? left : this.parseBindingAtom();\n    if (!this.eat(29)) return left;\n    const node = this.startNodeAt(startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssignAllowIn();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    switch (type) {\n      case \"AssignmentPattern\":\n        return \"left\";\n      case \"RestElement\":\n        return \"argument\";\n      case \"ObjectProperty\":\n        return \"value\";\n      case \"ParenthesizedExpression\":\n        return \"expression\";\n      case \"ArrayPattern\":\n        return \"elements\";\n      case \"ObjectPattern\":\n        return \"properties\";\n    }\n    return false;\n  }\n  isOptionalMemberExpression(expression) {\n    return expression.type === \"OptionalMemberExpression\";\n  }\n  checkLVal(expression, ancestor, binding = 64, checkClashes = false, strictModeChanged = false, hasParenthesizedAncestor = false) {\n    var _expression$extra;\n    const type = expression.type;\n    if (this.isObjectMethod(expression)) return;\n    const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);\n    if (isOptionalMemberExpression || type === \"MemberExpression\") {\n      if (isOptionalMemberExpression) {\n        this.expectPlugin(\"optionalChainingAssign\", expression.loc.start);\n        if (ancestor.type !== \"AssignmentExpression\") {\n          this.raise(Errors.InvalidLhsOptionalChaining, expression, {\n            ancestor\n          });\n        }\n      }\n      if (binding !== 64) {\n        this.raise(Errors.InvalidPropertyBindingPattern, expression);\n      }\n      return;\n    }\n    if (type === \"Identifier\") {\n      this.checkIdentifier(expression, binding, strictModeChanged);\n      const {\n        name\n      } = expression;\n      if (checkClashes) {\n        if (checkClashes.has(name)) {\n          this.raise(Errors.ParamDupe, expression);\n        } else {\n          checkClashes.add(name);\n        }\n      }\n      return;\n    }\n    const validity = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === \"AssignmentExpression\", binding);\n    if (validity === true) return;\n    if (validity === false) {\n      const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;\n      this.raise(ParseErrorClass, expression, {\n        ancestor\n      });\n      return;\n    }\n    let key, isParenthesizedExpression;\n    if (typeof validity === \"string\") {\n      key = validity;\n      isParenthesizedExpression = type === \"ParenthesizedExpression\";\n    } else {\n      [key, isParenthesizedExpression] = validity;\n    }\n    const nextAncestor = type === \"ArrayPattern\" || type === \"ObjectPattern\" ? {\n      type\n    } : ancestor;\n    const val = expression[key];\n    if (Array.isArray(val)) {\n      for (const child of val) {\n        if (child) {\n          this.checkLVal(child, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);\n        }\n      }\n    } else if (val) {\n      this.checkLVal(val, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);\n    }\n  }\n  checkIdentifier(at, bindingType, strictModeChanged = false) {\n    if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {\n      if (bindingType === 64) {\n        this.raise(Errors.StrictEvalArguments, at, {\n          referenceName: at.name\n        });\n      } else {\n        this.raise(Errors.StrictEvalArgumentsBinding, at, {\n          bindingName: at.name\n        });\n      }\n    }\n    if (bindingType & 8192 && at.name === \"let\") {\n      this.raise(Errors.LetInLexicalBinding, at);\n    }\n    if (!(bindingType & 64)) {\n      this.declareNameFromIdentifier(at, bindingType);\n    }\n  }\n  declareNameFromIdentifier(identifier, binding) {\n    this.scope.declareName(identifier.name, binding, identifier.loc.start);\n  }\n  checkToRestConversion(node, allowPattern) {\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.checkToRestConversion(node.expression, allowPattern);\n        break;\n      case \"Identifier\":\n      case \"MemberExpression\":\n        break;\n      case \"ArrayExpression\":\n      case \"ObjectExpression\":\n        if (allowPattern) break;\n      default:\n        this.raise(Errors.InvalidRestAssignmentPattern, node);\n    }\n  }\n  checkCommaAfterRest(close) {\n    if (!this.match(12)) {\n      return false;\n    }\n    this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);\n    return true;\n  }\n}\nfunction nonNull(x) {\n  if (x == null) {\n    throw new Error(`Unexpected ${x} value.`);\n  }\n  return x;\n}\nfunction assert(x) {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\nconst TSErrors = ParseErrorEnum`typescript`({\n  AbstractMethodHasImplementation: ({\n    methodName\n  }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,\n  AbstractPropertyHasInitializer: ({\n    propertyName\n  }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,\n  AccessorCannotBeOptional: \"An 'accessor' property cannot be declared optional.\",\n  AccessorCannotDeclareThisParameter: \"'get' and 'set' accessors cannot declare 'this' parameters.\",\n  AccessorCannotHaveTypeParameters: \"An accessor cannot have type parameters.\",\n  ClassMethodHasDeclare: \"Class methods cannot have the 'declare' modifier.\",\n  ClassMethodHasReadonly: \"Class methods cannot have the 'readonly' modifier.\",\n  ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: \"A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.\",\n  ConstructorHasTypeParameters: \"Type parameters cannot appear on a constructor declaration.\",\n  DeclareAccessor: ({\n    kind\n  }) => `'declare' is not allowed in ${kind}ters.`,\n  DeclareClassFieldHasInitializer: \"Initializers are not allowed in ambient contexts.\",\n  DeclareFunctionHasImplementation: \"An implementation cannot be declared in ambient contexts.\",\n  DuplicateAccessibilityModifier: ({\n    modifier\n  }) => `Accessibility modifier already seen.`,\n  DuplicateModifier: ({\n    modifier\n  }) => `Duplicate modifier: '${modifier}'.`,\n  EmptyHeritageClauseType: ({\n    token\n  }) => `'${token}' list cannot be empty.`,\n  EmptyTypeArguments: \"Type argument list cannot be empty.\",\n  EmptyTypeParameters: \"Type parameter list cannot be empty.\",\n  ExpectedAmbientAfterExportDeclare: \"'export declare' must be followed by an ambient declaration.\",\n  ImportAliasHasImportType: \"An import alias can not use 'import type'.\",\n  ImportReflectionHasImportType: \"An `import module` declaration can not use `type` modifier\",\n  IncompatibleModifiers: ({\n    modifiers\n  }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,\n  IndexSignatureHasAbstract: \"Index signatures cannot have the 'abstract' modifier.\",\n  IndexSignatureHasAccessibility: ({\n    modifier\n  }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,\n  IndexSignatureHasDeclare: \"Index signatures cannot have the 'declare' modifier.\",\n  IndexSignatureHasOverride: \"'override' modifier cannot appear on an index signature.\",\n  IndexSignatureHasStatic: \"Index signatures cannot have the 'static' modifier.\",\n  InitializerNotAllowedInAmbientContext: \"Initializers are not allowed in ambient contexts.\",\n  InvalidHeritageClauseType: ({\n    token\n  }) => `'${token}' list can only include identifiers or qualified-names with optional type arguments.`,\n  InvalidModifierOnTypeMember: ({\n    modifier\n  }) => `'${modifier}' modifier cannot appear on a type member.`,\n  InvalidModifierOnTypeParameter: ({\n    modifier\n  }) => `'${modifier}' modifier cannot appear on a type parameter.`,\n  InvalidModifierOnTypeParameterPositions: ({\n    modifier\n  }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,\n  InvalidModifiersOrder: ({\n    orderedModifiers\n  }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,\n  InvalidPropertyAccessAfterInstantiationExpression: \"Invalid property access after an instantiation expression. \" + \"You can either wrap the instantiation expression in parentheses, or delete the type arguments.\",\n  InvalidTupleMemberLabel: \"Tuple members must be labeled with a simple identifier.\",\n  MissingInterfaceName: \"'interface' declarations must be followed by an identifier.\",\n  NonAbstractClassHasAbstractMethod: \"Abstract methods can only appear within an abstract class.\",\n  NonClassMethodPropertyHasAbstractModifer: \"'abstract' modifier can only appear on a class, method, or property declaration.\",\n  OptionalTypeBeforeRequired: \"A required element cannot follow an optional element.\",\n  OverrideNotInSubClass: \"This member cannot have an 'override' modifier because its containing class does not extend another class.\",\n  PatternIsOptional: \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  PrivateElementHasAbstract: \"Private elements cannot have the 'abstract' modifier.\",\n  PrivateElementHasAccessibility: ({\n    modifier\n  }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,\n  ReadonlyForMethodSignature: \"'readonly' modifier can only appear on a property declaration or index signature.\",\n  ReservedArrowTypeParam: \"This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.\",\n  ReservedTypeAssertion: \"This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.\",\n  SetAccessorCannotHaveOptionalParameter: \"A 'set' accessor cannot have an optional parameter.\",\n  SetAccessorCannotHaveRestParameter: \"A 'set' accessor cannot have rest parameter.\",\n  SetAccessorCannotHaveReturnType: \"A 'set' accessor cannot have a return type annotation.\",\n  SingleTypeParameterWithoutTrailingComma: ({\n    typeParameterName\n  }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,\n  StaticBlockCannotHaveModifier: \"Static class blocks cannot have any modifier.\",\n  TupleOptionalAfterType: \"A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).\",\n  TypeAnnotationAfterAssign: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeImportCannotSpecifyDefaultAndNamed: \"A type-only import can specify a default import or named bindings, but not both.\",\n  TypeModifierIsUsedInTypeExports: \"The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.\",\n  TypeModifierIsUsedInTypeImports: \"The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.\",\n  UnexpectedParameterModifier: \"A parameter property is only allowed in a constructor implementation.\",\n  UnexpectedReadonly: \"'readonly' type modifier is only permitted on array and tuple literal types.\",\n  UnexpectedTypeAnnotation: \"Did not expect a type annotation here.\",\n  UnexpectedTypeCastInParameter: \"Unexpected type cast in parameter position.\",\n  UnsupportedImportTypeArgument: \"Argument in a type import must be a string literal.\",\n  UnsupportedParameterPropertyKind: \"A parameter property may not be declared using a binding pattern.\",\n  UnsupportedSignatureParameterKind: ({\n    type\n  }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`\n});\nfunction keywordTypeFromName(value) {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n    case \"bigint\":\n      return \"TSBigIntKeyword\";\n    case \"never\":\n      return \"TSNeverKeyword\";\n    case \"number\":\n      return \"TSNumberKeyword\";\n    case \"object\":\n      return \"TSObjectKeyword\";\n    case \"string\":\n      return \"TSStringKeyword\";\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n    case \"unknown\":\n      return \"TSUnknownKeyword\";\n    default:\n      return undefined;\n  }\n}\nfunction tsIsAccessModifier(modifier) {\n  return modifier === \"private\" || modifier === \"public\" || modifier === \"protected\";\n}\nfunction tsIsVarianceAnnotations(modifier) {\n  return modifier === \"in\" || modifier === \"out\";\n}\nvar typescript = superClass => class TypeScriptParserMixin extends superClass {\n  constructor(...args) {\n    super(...args);\n    this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"in\", \"out\"],\n      disallowedModifiers: [\"const\", \"public\", \"private\", \"protected\", \"readonly\", \"declare\", \"abstract\", \"override\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter\n    });\n    this.tsParseConstModifier = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"const\"],\n      disallowedModifiers: [\"in\", \"out\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\n    });\n    this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"in\", \"out\", \"const\"],\n      disallowedModifiers: [\"public\", \"private\", \"protected\", \"readonly\", \"declare\", \"abstract\", \"override\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter\n    });\n  }\n  getScopeHandler() {\n    return TypeScriptScopeHandler;\n  }\n  tsIsIdentifier() {\n    return tokenIsIdentifier(this.state.type);\n  }\n  tsTokenCanFollowModifier() {\n    return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();\n  }\n  tsNextTokenOnSameLineAndCanFollowModifier() {\n    this.next();\n    if (this.hasPrecedingLineBreak()) {\n      return false;\n    }\n    return this.tsTokenCanFollowModifier();\n  }\n  tsNextTokenCanFollowModifier() {\n    if (this.match(106)) {\n      this.next();\n      return this.tsTokenCanFollowModifier();\n    }\n    return this.tsNextTokenOnSameLineAndCanFollowModifier();\n  }\n  tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {\n    if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {\n      return undefined;\n    }\n    const modifier = this.state.value;\n    if (allowedModifiers.includes(modifier)) {\n      if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {\n        return undefined;\n      }\n      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n        return modifier;\n      }\n    }\n    return undefined;\n  }\n  tsParseModifiers({\n    allowedModifiers,\n    disallowedModifiers,\n    stopOnStartOfClassStaticBlock,\n    errorTemplate = TSErrors.InvalidModifierOnTypeMember\n  }, modified) {\n    const enforceOrder = (loc, modifier, before, after) => {\n      if (modifier === before && modified[after]) {\n        this.raise(TSErrors.InvalidModifiersOrder, loc, {\n          orderedModifiers: [before, after]\n        });\n      }\n    };\n    const incompatible = (loc, modifier, mod1, mod2) => {\n      if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {\n        this.raise(TSErrors.IncompatibleModifiers, loc, {\n          modifiers: [mod1, mod2]\n        });\n      }\n    };\n    for (;;) {\n      const {\n        startLoc\n      } = this.state;\n      const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);\n      if (!modifier) break;\n      if (tsIsAccessModifier(modifier)) {\n        if (modified.accessibility) {\n          this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {\n            modifier\n          });\n        } else {\n          enforceOrder(startLoc, modifier, modifier, \"override\");\n          enforceOrder(startLoc, modifier, modifier, \"static\");\n          enforceOrder(startLoc, modifier, modifier, \"readonly\");\n          modified.accessibility = modifier;\n        }\n      } else if (tsIsVarianceAnnotations(modifier)) {\n        if (modified[modifier]) {\n          this.raise(TSErrors.DuplicateModifier, startLoc, {\n            modifier\n          });\n        }\n        modified[modifier] = true;\n        enforceOrder(startLoc, modifier, \"in\", \"out\");\n      } else {\n        if (hasOwnProperty.call(modified, modifier)) {\n          this.raise(TSErrors.DuplicateModifier, startLoc, {\n            modifier\n          });\n        } else {\n          enforceOrder(startLoc, modifier, \"static\", \"readonly\");\n          enforceOrder(startLoc, modifier, \"static\", \"override\");\n          enforceOrder(startLoc, modifier, \"override\", \"readonly\");\n          enforceOrder(startLoc, modifier, \"abstract\", \"override\");\n          incompatible(startLoc, modifier, \"declare\", \"override\");\n          incompatible(startLoc, modifier, \"static\", \"abstract\");\n        }\n        modified[modifier] = true;\n      }\n      if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {\n        this.raise(errorTemplate, startLoc, {\n          modifier\n        });\n      }\n    }\n  }\n  tsIsListTerminator(kind) {\n    switch (kind) {\n      case \"EnumMembers\":\n      case \"TypeMembers\":\n        return this.match(8);\n      case \"HeritageClauseElement\":\n        return this.match(5);\n      case \"TupleElementTypes\":\n        return this.match(3);\n      case \"TypeParametersOrArguments\":\n        return this.match(48);\n    }\n  }\n  tsParseList(kind, parseElement) {\n    const result = [];\n    while (!this.tsIsListTerminator(kind)) {\n      result.push(parseElement());\n    }\n    return result;\n  }\n  tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {\n    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));\n  }\n  tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {\n    const result = [];\n    let trailingCommaPos = -1;\n    for (;;) {\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n      trailingCommaPos = -1;\n      const element = parseElement();\n      if (element == null) {\n        return undefined;\n      }\n      result.push(element);\n      if (this.eat(12)) {\n        trailingCommaPos = this.state.lastTokStartLoc.index;\n        continue;\n      }\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n      if (expectSuccess) {\n        this.expect(12);\n      }\n      return undefined;\n    }\n    if (refTrailingCommaPos) {\n      refTrailingCommaPos.value = trailingCommaPos;\n    }\n    return result;\n  }\n  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {\n    if (!skipFirstToken) {\n      if (bracket) {\n        this.expect(0);\n      } else {\n        this.expect(47);\n      }\n    }\n    const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);\n    if (bracket) {\n      this.expect(3);\n    } else {\n      this.expect(48);\n    }\n    return result;\n  }\n  tsParseImportType() {\n    const node = this.startNode();\n    this.expect(83);\n    this.expect(10);\n    if (!this.match(134)) {\n      this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);\n      {\n        node.argument = super.parseExprAtom();\n      }\n    } else {\n      {\n        node.argument = this.parseStringLiteral(this.state.value);\n      }\n    }\n    if (this.eat(12) && !this.match(11)) {\n      node.options = super.parseMaybeAssignAllowIn();\n      this.eat(12);\n    } else {\n      node.options = null;\n    }\n    this.expect(11);\n    if (this.eat(16)) {\n      node.qualifier = this.tsParseEntityName(1 | 2);\n    }\n    if (this.match(47)) {\n      {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n    }\n    return this.finishNode(node, \"TSImportType\");\n  }\n  tsParseEntityName(flags) {\n    let entity;\n    if (flags & 1 && this.match(78)) {\n      if (flags & 2) {\n        entity = this.parseIdentifier(true);\n      } else {\n        const node = this.startNode();\n        this.next();\n        entity = this.finishNode(node, \"ThisExpression\");\n      }\n    } else {\n      entity = this.parseIdentifier(!!(flags & 1));\n    }\n    while (this.eat(16)) {\n      const node = this.startNodeAtNode(entity);\n      node.left = entity;\n      node.right = this.parseIdentifier(!!(flags & 1));\n      entity = this.finishNode(node, \"TSQualifiedName\");\n    }\n    return entity;\n  }\n  tsParseTypeReference() {\n    const node = this.startNode();\n    node.typeName = this.tsParseEntityName(1);\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\n      {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n    }\n    return this.finishNode(node, \"TSTypeReference\");\n  }\n  tsParseThisTypePredicate(lhs) {\n    this.next();\n    const node = this.startNodeAtNode(lhs);\n    node.parameterName = lhs;\n    node.typeAnnotation = this.tsParseTypeAnnotation(false);\n    node.asserts = false;\n    return this.finishNode(node, \"TSTypePredicate\");\n  }\n  tsParseThisTypeNode() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"TSThisType\");\n  }\n  tsParseTypeQuery() {\n    const node = this.startNode();\n    this.expect(87);\n    if (this.match(83)) {\n      node.exprName = this.tsParseImportType();\n    } else {\n      {\n        node.exprName = this.tsParseEntityName(1 | 2);\n      }\n    }\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\n      {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n    }\n    return this.finishNode(node, \"TSTypeQuery\");\n  }\n  tsParseTypeParameter(parseModifiers) {\n    const node = this.startNode();\n    parseModifiers(node);\n    node.name = this.tsParseTypeParameterName();\n    node.constraint = this.tsEatThenParseType(81);\n    node.default = this.tsEatThenParseType(29);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n  tsTryParseTypeParameters(parseModifiers) {\n    if (this.match(47)) {\n      return this.tsParseTypeParameters(parseModifiers);\n    }\n  }\n  tsParseTypeParameters(parseModifiers) {\n    const node = this.startNode();\n    if (this.match(47) || this.match(143)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n    const refTrailingCommaPos = {\n      value: -1\n    };\n    node.params = this.tsParseBracketedList(\"TypeParametersOrArguments\", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);\n    if (node.params.length === 0) {\n      this.raise(TSErrors.EmptyTypeParameters, node);\n    }\n    if (refTrailingCommaPos.value !== -1) {\n      this.addExtra(node, \"trailingComma\", refTrailingCommaPos.value);\n    }\n    return this.finishNode(node, \"TSTypeParameterDeclaration\");\n  }\n  tsFillSignature(returnToken, signature) {\n    const returnTokenRequired = returnToken === 19;\n    const paramsKey = \"parameters\";\n    const returnTypeKey = \"typeAnnotation\";\n    signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    this.expect(10);\n    signature[paramsKey] = this.tsParseBindingListForSignature();\n    if (returnTokenRequired) {\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    } else if (this.match(returnToken)) {\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    }\n  }\n  tsParseBindingListForSignature() {\n    const list = super.parseBindingList(11, 41, 2);\n    for (const pattern of list) {\n      const {\n        type\n      } = pattern;\n      if (type === \"AssignmentPattern\" || type === \"TSParameterProperty\") {\n        this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {\n          type\n        });\n      }\n    }\n    return list;\n  }\n  tsParseTypeMemberSemicolon() {\n    if (!this.eat(12) && !this.isLineTerminator()) {\n      this.expect(13);\n    }\n  }\n  tsParseSignatureMember(kind, node) {\n    this.tsFillSignature(14, node);\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, kind);\n  }\n  tsIsUnambiguouslyIndexSignature() {\n    this.next();\n    if (tokenIsIdentifier(this.state.type)) {\n      this.next();\n      return this.match(14);\n    }\n    return false;\n  }\n  tsTryParseIndexSignature(node) {\n    if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {\n      return;\n    }\n    this.expect(0);\n    const id = this.parseIdentifier();\n    id.typeAnnotation = this.tsParseTypeAnnotation();\n    this.resetEndLocation(id);\n    this.expect(3);\n    node.parameters = [id];\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, \"TSIndexSignature\");\n  }\n  tsParsePropertyOrMethodSignature(node, readonly) {\n    if (this.eat(17)) node.optional = true;\n    const nodeAny = node;\n    if (this.match(10) || this.match(47)) {\n      if (readonly) {\n        this.raise(TSErrors.ReadonlyForMethodSignature, node);\n      }\n      const method = nodeAny;\n      if (method.kind && this.match(47)) {\n        this.raise(TSErrors.AccessorCannotHaveTypeParameters, this.state.curPosition());\n      }\n      this.tsFillSignature(14, method);\n      this.tsParseTypeMemberSemicolon();\n      const paramsKey = \"parameters\";\n      const returnTypeKey = \"typeAnnotation\";\n      if (method.kind === \"get\") {\n        if (method[paramsKey].length > 0) {\n          this.raise(Errors.BadGetterArity, this.state.curPosition());\n          if (this.isThisParam(method[paramsKey][0])) {\n            this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());\n          }\n        }\n      } else if (method.kind === \"set\") {\n        if (method[paramsKey].length !== 1) {\n          this.raise(Errors.BadSetterArity, this.state.curPosition());\n        } else {\n          const firstParameter = method[paramsKey][0];\n          if (this.isThisParam(firstParameter)) {\n            this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());\n          }\n          if (firstParameter.type === \"Identifier\" && firstParameter.optional) {\n            this.raise(TSErrors.SetAccessorCannotHaveOptionalParameter, this.state.curPosition());\n          }\n          if (firstParameter.type === \"RestElement\") {\n            this.raise(TSErrors.SetAccessorCannotHaveRestParameter, this.state.curPosition());\n          }\n        }\n        if (method[returnTypeKey]) {\n          this.raise(TSErrors.SetAccessorCannotHaveReturnType, method[returnTypeKey]);\n        }\n      } else {\n        method.kind = \"method\";\n      }\n      return this.finishNode(method, \"TSMethodSignature\");\n    } else {\n      const property = nodeAny;\n      if (readonly) property.readonly = true;\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) property.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(property, \"TSPropertySignature\");\n    }\n  }\n  tsParseTypeMember() {\n    const node = this.startNode();\n    if (this.match(10) || this.match(47)) {\n      return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\n    }\n    if (this.match(77)) {\n      const id = this.startNode();\n      this.next();\n      if (this.match(10) || this.match(47)) {\n        return this.tsParseSignatureMember(\"TSConstructSignatureDeclaration\", node);\n      } else {\n        node.key = this.createIdentifier(id, \"new\");\n        return this.tsParsePropertyOrMethodSignature(node, false);\n      }\n    }\n    this.tsParseModifiers({\n      allowedModifiers: [\"readonly\"],\n      disallowedModifiers: [\"declare\", \"abstract\", \"private\", \"protected\", \"public\", \"static\", \"override\"]\n    }, node);\n    const idx = this.tsTryParseIndexSignature(node);\n    if (idx) {\n      return idx;\n    }\n    super.parsePropertyName(node);\n    if (!node.computed && node.key.type === \"Identifier\" && (node.key.name === \"get\" || node.key.name === \"set\") && this.tsTokenCanFollowModifier()) {\n      node.kind = node.key.name;\n      super.parsePropertyName(node);\n    }\n    return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);\n  }\n  tsParseTypeLiteral() {\n    const node = this.startNode();\n    node.members = this.tsParseObjectTypeMembers();\n    return this.finishNode(node, \"TSTypeLiteral\");\n  }\n  tsParseObjectTypeMembers() {\n    this.expect(5);\n    const members = this.tsParseList(\"TypeMembers\", this.tsParseTypeMember.bind(this));\n    this.expect(8);\n    return members;\n  }\n  tsIsStartOfMappedType() {\n    this.next();\n    if (this.eat(53)) {\n      return this.isContextual(122);\n    }\n    if (this.isContextual(122)) {\n      this.next();\n    }\n    if (!this.match(0)) {\n      return false;\n    }\n    this.next();\n    if (!this.tsIsIdentifier()) {\n      return false;\n    }\n    this.next();\n    return this.match(58);\n  }\n  tsParseMappedType() {\n    const node = this.startNode();\n    this.expect(5);\n    if (this.match(53)) {\n      node.readonly = this.state.value;\n      this.next();\n      this.expectContextual(122);\n    } else if (this.eatContextual(122)) {\n      node.readonly = true;\n    }\n    this.expect(0);\n    {\n      const typeParameter = this.startNode();\n      typeParameter.name = this.tsParseTypeParameterName();\n      typeParameter.constraint = this.tsExpectThenParseType(58);\n      node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n    }\n    node.nameType = this.eatContextual(93) ? this.tsParseType() : null;\n    this.expect(3);\n    if (this.match(53)) {\n      node.optional = this.state.value;\n      this.next();\n      this.expect(17);\n    } else if (this.eat(17)) {\n      node.optional = true;\n    }\n    node.typeAnnotation = this.tsTryParseType();\n    this.semicolon();\n    this.expect(8);\n    return this.finishNode(node, \"TSMappedType\");\n  }\n  tsParseTupleType() {\n    const node = this.startNode();\n    node.elementTypes = this.tsParseBracketedList(\"TupleElementTypes\", this.tsParseTupleElementType.bind(this), true, false);\n    let seenOptionalElement = false;\n    node.elementTypes.forEach(elementNode => {\n      const {\n        type\n      } = elementNode;\n      if (seenOptionalElement && type !== \"TSRestType\" && type !== \"TSOptionalType\" && !(type === \"TSNamedTupleMember\" && elementNode.optional)) {\n        this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);\n      }\n      seenOptionalElement || (seenOptionalElement = type === \"TSNamedTupleMember\" && elementNode.optional || type === \"TSOptionalType\");\n    });\n    return this.finishNode(node, \"TSTupleType\");\n  }\n  tsParseTupleElementType() {\n    const restStartLoc = this.state.startLoc;\n    const rest = this.eat(21);\n    const {\n      startLoc\n    } = this.state;\n    let labeled;\n    let label;\n    let optional;\n    let type;\n    const isWord = tokenIsKeywordOrIdentifier(this.state.type);\n    const chAfterWord = isWord ? this.lookaheadCharCode() : null;\n    if (chAfterWord === 58) {\n      labeled = true;\n      optional = false;\n      label = this.parseIdentifier(true);\n      this.expect(14);\n      type = this.tsParseType();\n    } else if (chAfterWord === 63) {\n      optional = true;\n      const wordName = this.state.value;\n      const typeOrLabel = this.tsParseNonArrayType();\n      if (this.lookaheadCharCode() === 58) {\n        labeled = true;\n        label = this.createIdentifier(this.startNodeAt(startLoc), wordName);\n        this.expect(17);\n        this.expect(14);\n        type = this.tsParseType();\n      } else {\n        labeled = false;\n        type = typeOrLabel;\n        this.expect(17);\n      }\n    } else {\n      type = this.tsParseType();\n      optional = this.eat(17);\n      labeled = this.eat(14);\n    }\n    if (labeled) {\n      let labeledNode;\n      if (label) {\n        labeledNode = this.startNodeAt(startLoc);\n        labeledNode.optional = optional;\n        labeledNode.label = label;\n        labeledNode.elementType = type;\n        if (this.eat(17)) {\n          labeledNode.optional = true;\n          this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);\n        }\n      } else {\n        labeledNode = this.startNodeAt(startLoc);\n        labeledNode.optional = optional;\n        this.raise(TSErrors.InvalidTupleMemberLabel, type);\n        labeledNode.label = type;\n        labeledNode.elementType = this.tsParseType();\n      }\n      type = this.finishNode(labeledNode, \"TSNamedTupleMember\");\n    } else if (optional) {\n      const optionalTypeNode = this.startNodeAt(startLoc);\n      optionalTypeNode.typeAnnotation = type;\n      type = this.finishNode(optionalTypeNode, \"TSOptionalType\");\n    }\n    if (rest) {\n      const restNode = this.startNodeAt(restStartLoc);\n      restNode.typeAnnotation = type;\n      type = this.finishNode(restNode, \"TSRestType\");\n    }\n    return type;\n  }\n  tsParseParenthesizedType() {\n    const node = this.startNode();\n    this.expect(10);\n    node.typeAnnotation = this.tsParseType();\n    this.expect(11);\n    return this.finishNode(node, \"TSParenthesizedType\");\n  }\n  tsParseFunctionOrConstructorType(type, abstract) {\n    const node = this.startNode();\n    if (type === \"TSConstructorType\") {\n      node.abstract = !!abstract;\n      if (abstract) this.next();\n      this.next();\n    }\n    this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));\n    return this.finishNode(node, type);\n  }\n  tsParseLiteralTypeNode() {\n    const node = this.startNode();\n    switch (this.state.type) {\n      case 135:\n      case 136:\n      case 134:\n      case 85:\n      case 86:\n        node.literal = super.parseExprAtom();\n        break;\n      default:\n        this.unexpected();\n    }\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n  tsParseTemplateLiteralType() {\n    {\n      const node = this.startNode();\n      node.literal = super.parseTemplate(false);\n      return this.finishNode(node, \"TSLiteralType\");\n    }\n  }\n  parseTemplateSubstitution() {\n    if (this.state.inType) return this.tsParseType();\n    return super.parseTemplateSubstitution();\n  }\n  tsParseThisTypeOrThisTypePredicate() {\n    const thisKeyword = this.tsParseThisTypeNode();\n    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {\n      return this.tsParseThisTypePredicate(thisKeyword);\n    } else {\n      return thisKeyword;\n    }\n  }\n  tsParseNonArrayType() {\n    switch (this.state.type) {\n      case 134:\n      case 135:\n      case 136:\n      case 85:\n      case 86:\n        return this.tsParseLiteralTypeNode();\n      case 53:\n        if (this.state.value === \"-\") {\n          const node = this.startNode();\n          const nextToken = this.lookahead();\n          if (nextToken.type !== 135 && nextToken.type !== 136) {\n            this.unexpected();\n          }\n          node.literal = this.parseMaybeUnary();\n          return this.finishNode(node, \"TSLiteralType\");\n        }\n        break;\n      case 78:\n        return this.tsParseThisTypeOrThisTypePredicate();\n      case 87:\n        return this.tsParseTypeQuery();\n      case 83:\n        return this.tsParseImportType();\n      case 5:\n        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();\n      case 0:\n        return this.tsParseTupleType();\n      case 10:\n        return this.tsParseParenthesizedType();\n      case 25:\n      case 24:\n        return this.tsParseTemplateLiteralType();\n      default:\n        {\n          const {\n            type\n          } = this.state;\n          if (tokenIsIdentifier(type) || type === 88 || type === 84) {\n            const nodeType = type === 88 ? \"TSVoidKeyword\" : type === 84 ? \"TSNullKeyword\" : keywordTypeFromName(this.state.value);\n            if (nodeType !== undefined && this.lookaheadCharCode() !== 46) {\n              const node = this.startNode();\n              this.next();\n              return this.finishNode(node, nodeType);\n            }\n            return this.tsParseTypeReference();\n          }\n        }\n    }\n    this.unexpected();\n  }\n  tsParseArrayTypeOrHigher() {\n    const {\n      startLoc\n    } = this.state;\n    let type = this.tsParseNonArrayType();\n    while (!this.hasPrecedingLineBreak() && this.eat(0)) {\n      if (this.match(3)) {\n        const node = this.startNodeAt(startLoc);\n        node.elementType = type;\n        this.expect(3);\n        type = this.finishNode(node, \"TSArrayType\");\n      } else {\n        const node = this.startNodeAt(startLoc);\n        node.objectType = type;\n        node.indexType = this.tsParseType();\n        this.expect(3);\n        type = this.finishNode(node, \"TSIndexedAccessType\");\n      }\n    }\n    return type;\n  }\n  tsParseTypeOperator() {\n    const node = this.startNode();\n    const operator = this.state.value;\n    this.next();\n    node.operator = operator;\n    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n    if (operator === \"readonly\") {\n      this.tsCheckTypeAnnotationForReadOnly(node);\n    }\n    return this.finishNode(node, \"TSTypeOperator\");\n  }\n  tsCheckTypeAnnotationForReadOnly(node) {\n    switch (node.typeAnnotation.type) {\n      case \"TSTupleType\":\n      case \"TSArrayType\":\n        return;\n      default:\n        this.raise(TSErrors.UnexpectedReadonly, node);\n    }\n  }\n  tsParseInferType() {\n    const node = this.startNode();\n    this.expectContextual(115);\n    const typeParameter = this.startNode();\n    typeParameter.name = this.tsParseTypeParameterName();\n    typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());\n    node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n    return this.finishNode(node, \"TSInferType\");\n  }\n  tsParseConstraintForInferType() {\n    if (this.eat(81)) {\n      const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());\n      if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {\n        return constraint;\n      }\n    }\n  }\n  tsParseTypeOperatorOrHigher() {\n    const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;\n    return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());\n  }\n  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {\n    const node = this.startNode();\n    const hasLeadingOperator = this.eat(operator);\n    const types = [];\n    do {\n      types.push(parseConstituentType());\n    } while (this.eat(operator));\n    if (types.length === 1 && !hasLeadingOperator) {\n      return types[0];\n    }\n    node.types = types;\n    return this.finishNode(node, kind);\n  }\n  tsParseIntersectionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSIntersectionType\", this.tsParseTypeOperatorOrHigher.bind(this), 45);\n  }\n  tsParseUnionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSUnionType\", this.tsParseIntersectionTypeOrHigher.bind(this), 43);\n  }\n  tsIsStartOfFunctionType() {\n    if (this.match(47)) {\n      return true;\n    }\n    return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));\n  }\n  tsSkipParameterStart() {\n    if (tokenIsIdentifier(this.state.type) || this.match(78)) {\n      this.next();\n      return true;\n    }\n    if (this.match(5)) {\n      const {\n        errors\n      } = this.state;\n      const previousErrorCount = errors.length;\n      try {\n        this.parseObjectLike(8, true);\n        return errors.length === previousErrorCount;\n      } catch (_unused) {\n        return false;\n      }\n    }\n    if (this.match(0)) {\n      this.next();\n      const {\n        errors\n      } = this.state;\n      const previousErrorCount = errors.length;\n      try {\n        super.parseBindingList(3, 93, 1);\n        return errors.length === previousErrorCount;\n      } catch (_unused2) {\n        return false;\n      }\n    }\n    return false;\n  }\n  tsIsUnambiguouslyStartOfFunctionType() {\n    this.next();\n    if (this.match(11) || this.match(21)) {\n      return true;\n    }\n    if (this.tsSkipParameterStart()) {\n      if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {\n        return true;\n      }\n      if (this.match(11)) {\n        this.next();\n        if (this.match(19)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  tsParseTypeOrTypePredicateAnnotation(returnToken) {\n    return this.tsInType(() => {\n      const t = this.startNode();\n      this.expect(returnToken);\n      const node = this.startNode();\n      const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));\n      if (asserts && this.match(78)) {\n        let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n        if (thisTypePredicate.type === \"TSThisType\") {\n          node.parameterName = thisTypePredicate;\n          node.asserts = true;\n          node.typeAnnotation = null;\n          thisTypePredicate = this.finishNode(node, \"TSTypePredicate\");\n        } else {\n          this.resetStartLocationFromNode(thisTypePredicate, node);\n          thisTypePredicate.asserts = true;\n        }\n        t.typeAnnotation = thisTypePredicate;\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n      if (!typePredicateVariable) {\n        if (!asserts) {\n          return this.tsParseTypeAnnotation(false, t);\n        }\n        node.parameterName = this.parseIdentifier();\n        node.asserts = asserts;\n        node.typeAnnotation = null;\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n      const type = this.tsParseTypeAnnotation(false);\n      node.parameterName = typePredicateVariable;\n      node.typeAnnotation = type;\n      node.asserts = asserts;\n      t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n      return this.finishNode(t, \"TSTypeAnnotation\");\n    });\n  }\n  tsTryParseTypeOrTypePredicateAnnotation() {\n    if (this.match(14)) {\n      return this.tsParseTypeOrTypePredicateAnnotation(14);\n    }\n  }\n  tsTryParseTypeAnnotation() {\n    if (this.match(14)) {\n      return this.tsParseTypeAnnotation();\n    }\n  }\n  tsTryParseType() {\n    return this.tsEatThenParseType(14);\n  }\n  tsParseTypePredicatePrefix() {\n    const id = this.parseIdentifier();\n    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {\n      this.next();\n      return id;\n    }\n  }\n  tsParseTypePredicateAsserts() {\n    if (this.state.type !== 109) {\n      return false;\n    }\n    const containsEsc = this.state.containsEsc;\n    this.next();\n    if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {\n      return false;\n    }\n    if (containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {\n        reservedWord: \"asserts\"\n      });\n    }\n    return true;\n  }\n  tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {\n    this.tsInType(() => {\n      if (eatColon) this.expect(14);\n      t.typeAnnotation = this.tsParseType();\n    });\n    return this.finishNode(t, \"TSTypeAnnotation\");\n  }\n  tsParseType() {\n    assert(this.state.inType);\n    const type = this.tsParseNonConditionalType();\n    if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {\n      return type;\n    }\n    const node = this.startNodeAtNode(type);\n    node.checkType = type;\n    node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());\n    this.expect(17);\n    node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n    this.expect(14);\n    node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n    return this.finishNode(node, \"TSConditionalType\");\n  }\n  isAbstractConstructorSignature() {\n    return this.isContextual(124) && this.lookahead().type === 77;\n  }\n  tsParseNonConditionalType() {\n    if (this.tsIsStartOfFunctionType()) {\n      return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n    }\n    if (this.match(77)) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n    } else if (this.isAbstractConstructorSignature()) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\", true);\n    }\n    return this.tsParseUnionTypeOrHigher();\n  }\n  tsParseTypeAssertion() {\n    if (this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n      this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);\n    }\n    const node = this.startNode();\n    node.typeAnnotation = this.tsInType(() => {\n      this.next();\n      return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();\n    });\n    this.expect(48);\n    node.expression = this.parseMaybeUnary();\n    return this.finishNode(node, \"TSTypeAssertion\");\n  }\n  tsParseHeritageClause(token) {\n    const originalStartLoc = this.state.startLoc;\n    const delimitedList = this.tsParseDelimitedList(\"HeritageClauseElement\", () => {\n      {\n        const node = this.startNode();\n        node.expression = this.tsParseEntityName(1 | 2);\n        if (this.match(47)) {\n          node.typeParameters = this.tsParseTypeArguments();\n        }\n        return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n      }\n    });\n    if (!delimitedList.length) {\n      this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {\n        token\n      });\n    }\n    return delimitedList;\n  }\n  tsParseInterfaceDeclaration(node, properties = {}) {\n    if (this.hasFollowingLineBreak()) return null;\n    this.expectContextual(129);\n    if (properties.declare) node.declare = true;\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      this.checkIdentifier(node.id, 130);\n    } else {\n      node.id = null;\n      this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);\n    }\n    node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);\n    if (this.eat(81)) {\n      node.extends = this.tsParseHeritageClause(\"extends\");\n    }\n    const body = this.startNode();\n    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n    node.body = this.finishNode(body, \"TSInterfaceBody\");\n    return this.finishNode(node, \"TSInterfaceDeclaration\");\n  }\n  tsParseTypeAliasDeclaration(node) {\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, 2);\n    node.typeAnnotation = this.tsInType(() => {\n      node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);\n      this.expect(29);\n      if (this.isContextual(114) && this.lookahead().type !== 16) {\n        const node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"TSIntrinsicKeyword\");\n      }\n      return this.tsParseType();\n    });\n    this.semicolon();\n    return this.finishNode(node, \"TSTypeAliasDeclaration\");\n  }\n  tsInTopLevelContext(cb) {\n    if (this.curContext() !== types.brace) {\n      const oldContext = this.state.context;\n      this.state.context = [oldContext[0]];\n      try {\n        return cb();\n      } finally {\n        this.state.context = oldContext;\n      }\n    } else {\n      return cb();\n    }\n  }\n  tsInType(cb) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    try {\n      return cb();\n    } finally {\n      this.state.inType = oldInType;\n    }\n  }\n  tsInDisallowConditionalTypesContext(cb) {\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\n    this.state.inDisallowConditionalTypesContext = true;\n    try {\n      return cb();\n    } finally {\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    }\n  }\n  tsInAllowConditionalTypesContext(cb) {\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\n    this.state.inDisallowConditionalTypesContext = false;\n    try {\n      return cb();\n    } finally {\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    }\n  }\n  tsEatThenParseType(token) {\n    if (this.match(token)) {\n      return this.tsNextThenParseType();\n    }\n  }\n  tsExpectThenParseType(token) {\n    return this.tsInType(() => {\n      this.expect(token);\n      return this.tsParseType();\n    });\n  }\n  tsNextThenParseType() {\n    return this.tsInType(() => {\n      this.next();\n      return this.tsParseType();\n    });\n  }\n  tsParseEnumMember() {\n    const node = this.startNode();\n    node.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);\n    if (this.eat(29)) {\n      node.initializer = super.parseMaybeAssignAllowIn();\n    }\n    return this.finishNode(node, \"TSEnumMember\");\n  }\n  tsParseEnumDeclaration(node, properties = {}) {\n    if (properties.const) node.const = true;\n    if (properties.declare) node.declare = true;\n    this.expectContextual(126);\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, node.const ? 8971 : 8459);\n    {\n      this.expect(5);\n      node.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this));\n      this.expect(8);\n    }\n    return this.finishNode(node, \"TSEnumDeclaration\");\n  }\n  tsParseEnumBody() {\n    const node = this.startNode();\n    this.expect(5);\n    node.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this));\n    this.expect(8);\n    return this.finishNode(node, \"TSEnumBody\");\n  }\n  tsParseModuleBlock() {\n    const node = this.startNode();\n    this.scope.enter(0);\n    this.expect(5);\n    super.parseBlockOrModuleBlockBody(node.body = [], undefined, true, 8);\n    this.scope.exit();\n    return this.finishNode(node, \"TSModuleBlock\");\n  }\n  tsParseModuleOrNamespaceDeclaration(node, nested = false) {\n    node.id = this.parseIdentifier();\n    if (!nested) {\n      this.checkIdentifier(node.id, 1024);\n    }\n    if (this.eat(16)) {\n      const inner = this.startNode();\n      this.tsParseModuleOrNamespaceDeclaration(inner, true);\n      node.body = inner;\n    } else {\n      this.scope.enter(256);\n      this.prodParam.enter(0);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    }\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n  tsParseAmbientExternalModuleDeclaration(node) {\n    if (this.isContextual(112)) {\n      node.kind = \"global\";\n      {\n        node.global = true;\n      }\n      node.id = this.parseIdentifier();\n    } else if (this.match(134)) {\n      node.kind = \"module\";\n      node.id = super.parseStringLiteral(this.state.value);\n    } else {\n      this.unexpected();\n    }\n    if (this.match(5)) {\n      this.scope.enter(256);\n      this.prodParam.enter(0);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    } else {\n      this.semicolon();\n    }\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n  tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {\n    {\n      node.isExport = isExport || false;\n    }\n    node.id = maybeDefaultIdentifier || this.parseIdentifier();\n    this.checkIdentifier(node.id, 4096);\n    this.expect(29);\n    const moduleReference = this.tsParseModuleReference();\n    if (node.importKind === \"type\" && moduleReference.type !== \"TSExternalModuleReference\") {\n      this.raise(TSErrors.ImportAliasHasImportType, moduleReference);\n    }\n    node.moduleReference = moduleReference;\n    this.semicolon();\n    return this.finishNode(node, \"TSImportEqualsDeclaration\");\n  }\n  tsIsExternalModuleReference() {\n    return this.isContextual(119) && this.lookaheadCharCode() === 40;\n  }\n  tsParseModuleReference() {\n    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);\n  }\n  tsParseExternalModuleReference() {\n    const node = this.startNode();\n    this.expectContextual(119);\n    this.expect(10);\n    if (!this.match(134)) {\n      this.unexpected();\n    }\n    node.expression = super.parseExprAtom();\n    this.expect(11);\n    this.sawUnambiguousESM = true;\n    return this.finishNode(node, \"TSExternalModuleReference\");\n  }\n  tsLookAhead(f) {\n    const state = this.state.clone();\n    const res = f();\n    this.state = state;\n    return res;\n  }\n  tsTryParseAndCatch(f) {\n    const result = this.tryParse(abort => f() || abort());\n    if (result.aborted || !result.node) return;\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n  tsTryParse(f) {\n    const state = this.state.clone();\n    const result = f();\n    if (result !== undefined && result !== false) {\n      return result;\n    }\n    this.state = state;\n  }\n  tsTryParseDeclare(nany) {\n    if (this.isLineTerminator()) {\n      return;\n    }\n    let startType = this.state.type;\n    let kind;\n    if (this.isContextual(100)) {\n      startType = 74;\n      kind = \"let\";\n    }\n    return this.tsInAmbientContext(() => {\n      switch (startType) {\n        case 68:\n          nany.declare = true;\n          return super.parseFunctionStatement(nany, false, false);\n        case 80:\n          nany.declare = true;\n          return this.parseClass(nany, true, false);\n        case 126:\n          return this.tsParseEnumDeclaration(nany, {\n            declare: true\n          });\n        case 112:\n          return this.tsParseAmbientExternalModuleDeclaration(nany);\n        case 75:\n        case 74:\n          if (!this.match(75) || !this.isLookaheadContextual(\"enum\")) {\n            nany.declare = true;\n            return this.parseVarStatement(nany, kind || this.state.value, true);\n          }\n          this.expect(75);\n          return this.tsParseEnumDeclaration(nany, {\n            const: true,\n            declare: true\n          });\n        case 129:\n          {\n            const result = this.tsParseInterfaceDeclaration(nany, {\n              declare: true\n            });\n            if (result) return result;\n          }\n        default:\n          if (tokenIsIdentifier(startType)) {\n            return this.tsParseDeclaration(nany, this.state.value, true, null);\n          }\n      }\n    });\n  }\n  tsTryParseExportDeclaration() {\n    return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);\n  }\n  tsParseExpressionStatement(node, expr, decorators) {\n    switch (expr.name) {\n      case \"declare\":\n        {\n          const declaration = this.tsTryParseDeclare(node);\n          if (declaration) {\n            declaration.declare = true;\n          }\n          return declaration;\n        }\n      case \"global\":\n        if (this.match(5)) {\n          this.scope.enter(256);\n          this.prodParam.enter(0);\n          const mod = node;\n          mod.kind = \"global\";\n          {\n            node.global = true;\n          }\n          mod.id = expr;\n          mod.body = this.tsParseModuleBlock();\n          this.scope.exit();\n          this.prodParam.exit();\n          return this.finishNode(mod, \"TSModuleDeclaration\");\n        }\n        break;\n      default:\n        return this.tsParseDeclaration(node, expr.name, false, decorators);\n    }\n  }\n  tsParseDeclaration(node, value, next, decorators) {\n    switch (value) {\n      case \"abstract\":\n        if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {\n          return this.tsParseAbstractDeclaration(node, decorators);\n        }\n        break;\n      case \"module\":\n        if (this.tsCheckLineTerminator(next)) {\n          if (this.match(134)) {\n            return this.tsParseAmbientExternalModuleDeclaration(node);\n          } else if (tokenIsIdentifier(this.state.type)) {\n            node.kind = \"module\";\n            return this.tsParseModuleOrNamespaceDeclaration(node);\n          }\n        }\n        break;\n      case \"namespace\":\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          node.kind = \"namespace\";\n          return this.tsParseModuleOrNamespaceDeclaration(node);\n        }\n        break;\n      case \"type\":\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          return this.tsParseTypeAliasDeclaration(node);\n        }\n        break;\n    }\n  }\n  tsCheckLineTerminator(next) {\n    if (next) {\n      if (this.hasFollowingLineBreak()) return false;\n      this.next();\n      return true;\n    }\n    return !this.isLineTerminator();\n  }\n  tsTryParseGenericAsyncArrowFunction(startLoc) {\n    if (!this.match(47)) return;\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = true;\n    const res = this.tsTryParseAndCatch(() => {\n      const node = this.startNodeAt(startLoc);\n      node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);\n      super.parseFunctionParams(node);\n      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n      this.expect(19);\n      return node;\n    });\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    if (!res) return;\n    return super.parseArrowExpression(res, null, true);\n  }\n  tsParseTypeArgumentsInExpression() {\n    if (this.reScan_lt() !== 47) return;\n    return this.tsParseTypeArguments();\n  }\n  tsParseTypeArguments() {\n    const node = this.startNode();\n    node.params = this.tsInType(() => this.tsInTopLevelContext(() => {\n      this.expect(47);\n      return this.tsParseDelimitedList(\"TypeParametersOrArguments\", this.tsParseType.bind(this));\n    }));\n    if (node.params.length === 0) {\n      this.raise(TSErrors.EmptyTypeArguments, node);\n    } else if (!this.state.inType && this.curContext() === types.brace) {\n      this.reScan_lt_gt();\n    }\n    this.expect(48);\n    return this.finishNode(node, \"TSTypeParameterInstantiation\");\n  }\n  tsIsDeclarationStart() {\n    return tokenIsTSDeclarationStart(this.state.type);\n  }\n  isExportDefaultSpecifier() {\n    if (this.tsIsDeclarationStart()) return false;\n    return super.isExportDefaultSpecifier();\n  }\n  parseBindingElement(flags, decorators) {\n    const startLoc = this.state.startLoc;\n    const modified = {};\n    this.tsParseModifiers({\n      allowedModifiers: [\"public\", \"private\", \"protected\", \"override\", \"readonly\"]\n    }, modified);\n    const accessibility = modified.accessibility;\n    const override = modified.override;\n    const readonly = modified.readonly;\n    if (!(flags & 4) && (accessibility || readonly || override)) {\n      this.raise(TSErrors.UnexpectedParameterModifier, startLoc);\n    }\n    const left = this.parseMaybeDefault();\n    if (flags & 2) {\n      this.parseFunctionParamType(left);\n    }\n    const elt = this.parseMaybeDefault(left.loc.start, left);\n    if (accessibility || readonly || override) {\n      const pp = this.startNodeAt(startLoc);\n      if (decorators.length) {\n        pp.decorators = decorators;\n      }\n      if (accessibility) pp.accessibility = accessibility;\n      if (readonly) pp.readonly = readonly;\n      if (override) pp.override = override;\n      if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n        this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);\n      }\n      pp.parameter = elt;\n      return this.finishNode(pp, \"TSParameterProperty\");\n    }\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n    return elt;\n  }\n  isSimpleParameter(node) {\n    return node.type === \"TSParameterProperty\" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);\n  }\n  tsDisallowOptionalPattern(node) {\n    for (const param of node.params) {\n      if (param.type !== \"Identifier\" && param.optional && !this.state.isAmbientContext) {\n        this.raise(TSErrors.PatternIsOptional, param);\n      }\n    }\n  }\n  setArrowFunctionParameters(node, params, trailingCommaLoc) {\n    super.setArrowFunctionParameters(node, params, trailingCommaLoc);\n    this.tsDisallowOptionalPattern(node);\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n    }\n    const bodilessType = type === \"FunctionDeclaration\" ? \"TSDeclareFunction\" : type === \"ClassMethod\" || type === \"ClassPrivateMethod\" ? \"TSDeclareMethod\" : undefined;\n    if (bodilessType && !this.match(5) && this.isLineTerminator()) {\n      return this.finishNode(node, bodilessType);\n    }\n    if (bodilessType === \"TSDeclareFunction\" && this.state.isAmbientContext) {\n      this.raise(TSErrors.DeclareFunctionHasImplementation, node);\n      if (node.declare) {\n        return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);\n      }\n    }\n    this.tsDisallowOptionalPattern(node);\n    return super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n  registerFunctionStatementId(node) {\n    if (!node.body && node.id) {\n      this.checkIdentifier(node.id, 1024);\n    } else {\n      super.registerFunctionStatementId(node);\n    }\n  }\n  tsCheckForInvalidTypeCasts(items) {\n    items.forEach(node => {\n      if ((node == null ? void 0 : node.type) === \"TSTypeCastExpression\") {\n        this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);\n      }\n    });\n  }\n  toReferencedList(exprList, isInParens) {\n    this.tsCheckForInvalidTypeCasts(exprList);\n    return exprList;\n  }\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);\n    if (node.type === \"ArrayExpression\") {\n      this.tsCheckForInvalidTypeCasts(node.elements);\n    }\n    return node;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    if (!this.hasPrecedingLineBreak() && this.match(35)) {\n      this.state.canStartJSXElement = false;\n      this.next();\n      const nonNullExpression = this.startNodeAt(startLoc);\n      nonNullExpression.expression = base;\n      return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n    }\n    let isOptionalCall = false;\n    if (this.match(18) && this.lookaheadCharCode() === 60) {\n      if (noCalls) {\n        state.stop = true;\n        return base;\n      }\n      state.optionalChainMember = isOptionalCall = true;\n      this.next();\n    }\n    if (this.match(47) || this.match(51)) {\n      let missingParenErrorLoc;\n      const result = this.tsTryParseAndCatch(() => {\n        if (!noCalls && this.atPossibleAsyncArrow(base)) {\n          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);\n          if (asyncArrowFn) {\n            return asyncArrowFn;\n          }\n        }\n        const typeArguments = this.tsParseTypeArgumentsInExpression();\n        if (!typeArguments) return;\n        if (isOptionalCall && !this.match(10)) {\n          missingParenErrorLoc = this.state.curPosition();\n          return;\n        }\n        if (tokenIsTemplate(this.state.type)) {\n          const result = super.parseTaggedTemplateExpression(base, startLoc, state);\n          {\n            result.typeParameters = typeArguments;\n          }\n          return result;\n        }\n        if (!noCalls && this.eat(10)) {\n          const node = this.startNodeAt(startLoc);\n          node.callee = base;\n          node.arguments = this.parseCallExpressionArguments(11);\n          this.tsCheckForInvalidTypeCasts(node.arguments);\n          {\n            node.typeParameters = typeArguments;\n          }\n          if (state.optionalChainMember) {\n            node.optional = isOptionalCall;\n          }\n          return this.finishCallExpression(node, state.optionalChainMember);\n        }\n        const tokenType = this.state.type;\n        if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {\n          return;\n        }\n        const node = this.startNodeAt(startLoc);\n        node.expression = base;\n        {\n          node.typeParameters = typeArguments;\n        }\n        return this.finishNode(node, \"TSInstantiationExpression\");\n      });\n      if (missingParenErrorLoc) {\n        this.unexpected(missingParenErrorLoc, 10);\n      }\n      if (result) {\n        if (result.type === \"TSInstantiationExpression\" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {\n          this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);\n        }\n        return result;\n      }\n    }\n    return super.parseSubscript(base, startLoc, noCalls, state);\n  }\n  parseNewCallee(node) {\n    var _callee$extra;\n    super.parseNewCallee(node);\n    const {\n      callee\n    } = node;\n    if (callee.type === \"TSInstantiationExpression\" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {\n      {\n        node.typeParameters = callee.typeParameters;\n      }\n      node.callee = callee.expression;\n    }\n  }\n  parseExprOp(left, leftStartLoc, minPrec) {\n    let isSatisfies;\n    if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {\n      const node = this.startNodeAt(leftStartLoc);\n      node.expression = left;\n      node.typeAnnotation = this.tsInType(() => {\n        this.next();\n        if (this.match(75)) {\n          if (isSatisfies) {\n            this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {\n              keyword: \"const\"\n            });\n          }\n          return this.tsParseTypeReference();\n        }\n        return this.tsParseType();\n      });\n      this.finishNode(node, isSatisfies ? \"TSSatisfiesExpression\" : \"TSAsExpression\");\n      this.reScan_lt_gt();\n      return this.parseExprOp(node, leftStartLoc, minPrec);\n    }\n    return super.parseExprOp(left, leftStartLoc, minPrec);\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (!this.state.isAmbientContext) {\n      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n    }\n  }\n  checkImportReflection(node) {\n    super.checkImportReflection(node);\n    if (node.module && node.importKind !== \"value\") {\n      this.raise(TSErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);\n    }\n  }\n  checkDuplicateExports() {}\n  isPotentialImportPhase(isExport) {\n    if (super.isPotentialImportPhase(isExport)) return true;\n    if (this.isContextual(130)) {\n      const ch = this.lookaheadCharCode();\n      return isExport ? ch === 123 || ch === 42 : ch !== 61;\n    }\n    return !isExport && this.isContextual(87);\n  }\n  applyImportPhase(node, isExport, phase, loc) {\n    super.applyImportPhase(node, isExport, phase, loc);\n    if (isExport) {\n      node.exportKind = phase === \"type\" ? \"type\" : \"value\";\n    } else {\n      node.importKind = phase === \"type\" || phase === \"typeof\" ? phase : \"value\";\n    }\n  }\n  parseImport(node) {\n    if (this.match(134)) {\n      node.importKind = \"value\";\n      return super.parseImport(node);\n    }\n    let importNode;\n    if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {\n      node.importKind = \"value\";\n      return this.tsParseImportEqualsDeclaration(node);\n    } else if (this.isContextual(130)) {\n      const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);\n      if (this.lookaheadCharCode() === 61) {\n        return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);\n      } else {\n        importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);\n      }\n    } else {\n      importNode = super.parseImport(node);\n    }\n    if (importNode.importKind === \"type\" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === \"ImportDefaultSpecifier\") {\n      this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);\n    }\n    return importNode;\n  }\n  parseExport(node, decorators) {\n    if (this.match(83)) {\n      const nodeImportEquals = node;\n      this.next();\n      let maybeDefaultIdentifier = null;\n      if (this.isContextual(130) && this.isPotentialImportPhase(false)) {\n        maybeDefaultIdentifier = this.parseMaybeImportPhase(nodeImportEquals, false);\n      } else {\n        nodeImportEquals.importKind = \"value\";\n      }\n      const declaration = this.tsParseImportEqualsDeclaration(nodeImportEquals, maybeDefaultIdentifier, true);\n      {\n        return declaration;\n      }\n    } else if (this.eat(29)) {\n      const assign = node;\n      assign.expression = super.parseExpression();\n      this.semicolon();\n      this.sawUnambiguousESM = true;\n      return this.finishNode(assign, \"TSExportAssignment\");\n    } else if (this.eatContextual(93)) {\n      const decl = node;\n      this.expectContextual(128);\n      decl.id = this.parseIdentifier();\n      this.semicolon();\n      return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n    } else {\n      return super.parseExport(node, decorators);\n    }\n  }\n  isAbstractClass() {\n    return this.isContextual(124) && this.lookahead().type === 80;\n  }\n  parseExportDefaultExpression() {\n    if (this.isAbstractClass()) {\n      const cls = this.startNode();\n      this.next();\n      cls.abstract = true;\n      return this.parseClass(cls, true, true);\n    }\n    if (this.match(129)) {\n      const result = this.tsParseInterfaceDeclaration(this.startNode());\n      if (result) return result;\n    }\n    return super.parseExportDefaultExpression();\n  }\n  parseVarStatement(node, kind, allowMissingInitializer = false) {\n    const {\n      isAmbientContext\n    } = this.state;\n    const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);\n    if (!isAmbientContext) return declaration;\n    for (const {\n      id,\n      init\n    } of declaration.declarations) {\n      if (!init) continue;\n      if (kind !== \"const\" || !!id.typeAnnotation) {\n        this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);\n      } else if (!isValidAmbientConstInitializer(init, this.hasPlugin(\"estree\"))) {\n        this.raise(TSErrors.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, init);\n      }\n    }\n    return declaration;\n  }\n  parseStatementContent(flags, decorators) {\n    if (this.match(75) && this.isLookaheadContextual(\"enum\")) {\n      const node = this.startNode();\n      this.expect(75);\n      return this.tsParseEnumDeclaration(node, {\n        const: true\n      });\n    }\n    if (this.isContextual(126)) {\n      return this.tsParseEnumDeclaration(this.startNode());\n    }\n    if (this.isContextual(129)) {\n      const result = this.tsParseInterfaceDeclaration(this.startNode());\n      if (result) return result;\n    }\n    return super.parseStatementContent(flags, decorators);\n  }\n  parseAccessModifier() {\n    return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n  }\n  tsHasSomeModifiers(member, modifiers) {\n    return modifiers.some(modifier => {\n      if (tsIsAccessModifier(modifier)) {\n        return member.accessibility === modifier;\n      }\n      return !!member[modifier];\n    });\n  }\n  tsIsStartOfStaticBlocks() {\n    return this.isContextual(106) && this.lookaheadCharCode() === 123;\n  }\n  parseClassMember(classBody, member, state) {\n    const modifiers = [\"declare\", \"private\", \"public\", \"protected\", \"override\", \"abstract\", \"readonly\", \"static\"];\n    this.tsParseModifiers({\n      allowedModifiers: modifiers,\n      disallowedModifiers: [\"in\", \"out\"],\n      stopOnStartOfClassStaticBlock: true,\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\n    }, member);\n    const callParseClassMemberWithIsStatic = () => {\n      if (this.tsIsStartOfStaticBlocks()) {\n        this.next();\n        this.next();\n        if (this.tsHasSomeModifiers(member, modifiers)) {\n          this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition());\n        }\n        super.parseClassStaticBlock(classBody, member);\n      } else {\n        this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);\n      }\n    };\n    if (member.declare) {\n      this.tsInAmbientContext(callParseClassMemberWithIsStatic);\n    } else {\n      callParseClassMemberWithIsStatic();\n    }\n  }\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const idx = this.tsTryParseIndexSignature(member);\n    if (idx) {\n      classBody.body.push(idx);\n      if (member.abstract) {\n        this.raise(TSErrors.IndexSignatureHasAbstract, member);\n      }\n      if (member.accessibility) {\n        this.raise(TSErrors.IndexSignatureHasAccessibility, member, {\n          modifier: member.accessibility\n        });\n      }\n      if (member.declare) {\n        this.raise(TSErrors.IndexSignatureHasDeclare, member);\n      }\n      if (member.override) {\n        this.raise(TSErrors.IndexSignatureHasOverride, member);\n      }\n      return;\n    }\n    if (!this.state.inAbstractClass && member.abstract) {\n      this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);\n    }\n    if (member.override) {\n      if (!state.hadSuperClass) {\n        this.raise(TSErrors.OverrideNotInSubClass, member);\n      }\n    }\n    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n  parsePostMemberNameModifiers(methodOrProp) {\n    const optional = this.eat(17);\n    if (optional) methodOrProp.optional = true;\n    if (methodOrProp.readonly && this.match(10)) {\n      this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);\n    }\n    if (methodOrProp.declare && this.match(10)) {\n      this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);\n    }\n  }\n  parseExpressionStatement(node, expr, decorators) {\n    const decl = expr.type === \"Identifier\" ? this.tsParseExpressionStatement(node, expr, decorators) : undefined;\n    return decl || super.parseExpressionStatement(node, expr, decorators);\n  }\n  shouldParseExportDeclaration() {\n    if (this.tsIsDeclarationStart()) return true;\n    return super.shouldParseExportDeclaration();\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (!this.match(17)) return expr;\n    if (this.state.maybeInArrowParameters) {\n      const nextCh = this.lookaheadCharCode();\n      if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {\n        this.setOptionalParametersError(refExpressionErrors);\n        return expr;\n      }\n    }\n    return super.parseConditional(expr, startLoc, refExpressionErrors);\n  }\n  parseParenItem(node, startLoc) {\n    const newNode = super.parseParenItem(node, startLoc);\n    if (this.eat(17)) {\n      newNode.optional = true;\n      this.resetEndLocation(node);\n    }\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n    }\n    return node;\n  }\n  parseExportDeclaration(node) {\n    if (!this.state.isAmbientContext && this.isContextual(125)) {\n      return this.tsInAmbientContext(() => this.parseExportDeclaration(node));\n    }\n    const startLoc = this.state.startLoc;\n    const isDeclare = this.eatContextual(125);\n    if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {\n      throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);\n    }\n    const isIdentifier = tokenIsIdentifier(this.state.type);\n    const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);\n    if (!declaration) return null;\n    if (declaration.type === \"TSInterfaceDeclaration\" || declaration.type === \"TSTypeAliasDeclaration\" || isDeclare) {\n      node.exportKind = \"type\";\n    }\n    if (isDeclare && declaration.type !== \"TSImportEqualsDeclaration\") {\n      this.resetStartLocation(declaration, startLoc);\n      declaration.declare = true;\n    }\n    return declaration;\n  }\n  parseClassId(node, isStatement, optionalId, bindingType) {\n    if ((!isStatement || optionalId) && this.isContextual(113)) {\n      return;\n    }\n    super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 8331);\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);\n    if (typeParameters) node.typeParameters = typeParameters;\n  }\n  parseClassPropertyAnnotation(node) {\n    if (!node.optional) {\n      if (this.eat(35)) {\n        node.definite = true;\n      } else if (this.eat(17)) {\n        node.optional = true;\n      }\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n  }\n  parseClassProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n    if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {\n      this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);\n    }\n    if (node.abstract && this.match(29)) {\n      const {\n        key\n      } = node;\n      this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {\n        propertyName: key.type === \"Identifier\" && !node.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`\n      });\n    }\n    return super.parseClassProperty(node);\n  }\n  parseClassPrivateProperty(node) {\n    if (node.abstract) {\n      this.raise(TSErrors.PrivateElementHasAbstract, node);\n    }\n    if (node.accessibility) {\n      this.raise(TSErrors.PrivateElementHasAccessibility, node, {\n        modifier: node.accessibility\n      });\n    }\n    this.parseClassPropertyAnnotation(node);\n    return super.parseClassPrivateProperty(node);\n  }\n  parseClassAccessorProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n    if (node.optional) {\n      this.raise(TSErrors.AccessorCannotBeOptional, node);\n    }\n    return super.parseClassAccessorProperty(node);\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters && isConstructor) {\n      this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);\n    }\n    const {\n      declare = false,\n      kind\n    } = method;\n    if (declare && (kind === \"get\" || kind === \"set\")) {\n      this.raise(TSErrors.DeclareAccessor, method, {\n        kind\n      });\n    }\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n  declareClassPrivateMethodInScope(node, kind) {\n    if (node.type === \"TSDeclareMethod\") return;\n    if (node.type === \"MethodDefinition\" && !hasOwnProperty.call(node.value, \"body\")) {\n      return;\n    }\n    super.declareClassPrivateMethodInScope(node, kind);\n  }\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n    if (node.superClass && (this.match(47) || this.match(51))) {\n      {\n        node.superTypeParameters = this.tsParseTypeArgumentsInExpression();\n      }\n    }\n    if (this.eatContextual(113)) {\n      node.implements = this.tsParseHeritageClause(\"implements\");\n    }\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters) prop.typeParameters = typeParameters;\n    return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n  }\n  parseFunctionParams(node, isConstructor) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters) node.typeParameters = typeParameters;\n    super.parseFunctionParams(node, isConstructor);\n  }\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n    if (decl.id.type === \"Identifier\" && !this.hasPrecedingLineBreak() && this.eat(35)) {\n      decl.definite = true;\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) {\n      decl.id.typeAnnotation = type;\n      this.resetEndLocation(decl.id);\n    }\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeAnnotation();\n    }\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;\n    let state;\n    let jsx;\n    let typeCast;\n    if (this.hasPlugin(\"jsx\") && (this.match(143) || this.match(47))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n      const currentContext = context[context.length - 1];\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\n        context.pop();\n      }\n    }\n    if (!((_jsx = jsx) != null && _jsx.error) && !this.match(47)) {\n      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n    }\n    if (!state || state === this.state) state = this.state.clone();\n    let typeParameters;\n    const arrow = this.tryParse(abort => {\n      var _expr$extra, _typeParameters;\n      typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);\n      const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n      if (expr.type !== \"ArrowFunctionExpression\" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {\n        abort();\n      }\n      if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {\n        this.resetStartLocationFromNode(expr, typeParameters);\n      }\n      expr.typeParameters = typeParameters;\n      return expr;\n    }, state);\n    if (!arrow.error && !arrow.aborted) {\n      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n      return arrow.node;\n    }\n    if (!jsx) {\n      assert(!this.hasPlugin(\"jsx\"));\n      typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!typeCast.error) return typeCast.node;\n    }\n    if ((_jsx2 = jsx) != null && _jsx2.node) {\n      this.state = jsx.failState;\n      return jsx.node;\n    }\n    if (arrow.node) {\n      this.state = arrow.failState;\n      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n      return arrow.node;\n    }\n    if ((_typeCast = typeCast) != null && _typeCast.node) {\n      this.state = typeCast.failState;\n      return typeCast.node;\n    }\n    throw ((_jsx3 = jsx) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);\n  }\n  reportReservedArrowTypeParam(node) {\n    var _node$extra2;\n    if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra2 = node.extra) != null && _node$extra2.trailingComma) && this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n      this.raise(TSErrors.ReservedArrowTypeParam, node);\n    }\n  }\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\n    if (!this.hasPlugin(\"jsx\") && this.match(47)) {\n      return this.tsParseTypeAssertion();\n    }\n    return super.parseMaybeUnary(refExpressionErrors, sawUnary);\n  }\n  parseArrow(node) {\n    if (this.match(14)) {\n      const result = this.tryParse(abort => {\n        const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n        if (this.canInsertSemicolon() || !this.match(19)) abort();\n        return returnType;\n      });\n      if (result.aborted) return;\n      if (!result.thrown) {\n        if (result.error) this.state = result.failState;\n        node.returnType = result.node;\n      }\n    }\n    return super.parseArrow(node);\n  }\n  parseFunctionParamType(param) {\n    if (this.eat(17)) {\n      param.optional = true;\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) param.typeAnnotation = type;\n    this.resetEndLocation(param);\n    return param;\n  }\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"TSTypeCastExpression\":\n        return this.isAssignable(node.expression, isBinding);\n      case \"TSParameterProperty\":\n        return true;\n      default:\n        return super.isAssignable(node, isBinding);\n    }\n  }\n  toAssignable(node, isLHS = false) {\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.toAssignableParenthesizedExpression(node, isLHS);\n        break;\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n        if (isLHS) {\n          this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node);\n        } else {\n          this.raise(TSErrors.UnexpectedTypeCastInParameter, node);\n        }\n        this.toAssignable(node.expression, isLHS);\n        break;\n      case \"AssignmentExpression\":\n        if (!isLHS && node.left.type === \"TSTypeCastExpression\") {\n          node.left = this.typeCastToParameter(node.left);\n        }\n      default:\n        super.toAssignable(node, isLHS);\n    }\n  }\n  toAssignableParenthesizedExpression(node, isLHS) {\n    switch (node.expression.type) {\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n      case \"ParenthesizedExpression\":\n        this.toAssignable(node.expression, isLHS);\n        break;\n      default:\n        super.toAssignable(node, isLHS);\n    }\n  }\n  checkToRestConversion(node, allowPattern) {\n    switch (node.type) {\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSTypeAssertion\":\n      case \"TSNonNullExpression\":\n        this.checkToRestConversion(node.expression, false);\n        break;\n      default:\n        super.checkToRestConversion(node, allowPattern);\n    }\n  }\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    switch (type) {\n      case \"TSTypeCastExpression\":\n        return true;\n      case \"TSParameterProperty\":\n        return \"parameter\";\n      case \"TSNonNullExpression\":\n        return \"expression\";\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSTypeAssertion\":\n        return (binding !== 64 || !isUnparenthesizedInAssign) && [\"expression\", true];\n      default:\n        return super.isValidLVal(type, isUnparenthesizedInAssign, binding);\n    }\n  }\n  parseBindingAtom() {\n    if (this.state.type === 78) {\n      return this.parseIdentifier(true);\n    }\n    return super.parseBindingAtom();\n  }\n  parseMaybeDecoratorArguments(expr, startLoc) {\n    if (this.match(47) || this.match(51)) {\n      const typeArguments = this.tsParseTypeArgumentsInExpression();\n      if (this.match(10)) {\n        const call = super.parseMaybeDecoratorArguments(expr, startLoc);\n        {\n          call.typeParameters = typeArguments;\n        }\n        return call;\n      }\n      this.unexpected(null, 10);\n    }\n    return super.parseMaybeDecoratorArguments(expr, startLoc);\n  }\n  checkCommaAfterRest(close) {\n    if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {\n      this.next();\n      return false;\n    }\n    return super.checkCommaAfterRest(close);\n  }\n  isClassMethod() {\n    return this.match(47) || super.isClassMethod();\n  }\n  isClassProperty() {\n    return this.match(35) || this.match(14) || super.isClassProperty();\n  }\n  parseMaybeDefault(startLoc, left) {\n    const node = super.parseMaybeDefault(startLoc, left);\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation);\n    }\n    return node;\n  }\n  getTokenFromCode(code) {\n    if (this.state.inType) {\n      if (code === 62) {\n        this.finishOp(48, 1);\n        return;\n      }\n      if (code === 60) {\n        this.finishOp(47, 1);\n        return;\n      }\n    }\n    super.getTokenFromCode(code);\n  }\n  reScan_lt_gt() {\n    const {\n      type\n    } = this.state;\n    if (type === 47) {\n      this.state.pos -= 1;\n      this.readToken_lt();\n    } else if (type === 48) {\n      this.state.pos -= 1;\n      this.readToken_gt();\n    }\n  }\n  reScan_lt() {\n    const {\n      type\n    } = this.state;\n    if (type === 51) {\n      this.state.pos -= 2;\n      this.finishOp(47, 1);\n      return 47;\n    }\n    return type;\n  }\n  toAssignableListItem(exprList, index, isLHS) {\n    const node = exprList[index];\n    if (node.type === \"TSTypeCastExpression\") {\n      exprList[index] = this.typeCastToParameter(node);\n    }\n    super.toAssignableListItem(exprList, index, isLHS);\n  }\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n  shouldParseArrow(params) {\n    if (this.match(14)) {\n      return params.every(expr => this.isAssignable(expr, true));\n    }\n    return super.shouldParseArrow(params);\n  }\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n  canHaveLeadingDecorator() {\n    return super.canHaveLeadingDecorator() || this.isAbstractClass();\n  }\n  jsxParseOpeningElementAfterName(node) {\n    if (this.match(47) || this.match(51)) {\n      const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());\n      if (typeArguments) {\n        {\n          node.typeParameters = typeArguments;\n        }\n      }\n    }\n    return super.jsxParseOpeningElementAfterName(node);\n  }\n  getGetterSetterExpectedParamCount(method) {\n    const baseCount = super.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    const firstParam = params[0];\n    const hasContextParam = firstParam && this.isThisParam(firstParam);\n    return hasContextParam ? baseCount + 1 : baseCount;\n  }\n  parseCatchClauseParam() {\n    const param = super.parseCatchClauseParam();\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) {\n      param.typeAnnotation = type;\n      this.resetEndLocation(param);\n    }\n    return param;\n  }\n  tsInAmbientContext(cb) {\n    const {\n      isAmbientContext: oldIsAmbientContext,\n      strict: oldStrict\n    } = this.state;\n    this.state.isAmbientContext = true;\n    this.state.strict = false;\n    try {\n      return cb();\n    } finally {\n      this.state.isAmbientContext = oldIsAmbientContext;\n      this.state.strict = oldStrict;\n    }\n  }\n  parseClass(node, isStatement, optionalId) {\n    const oldInAbstractClass = this.state.inAbstractClass;\n    this.state.inAbstractClass = !!node.abstract;\n    try {\n      return super.parseClass(node, isStatement, optionalId);\n    } finally {\n      this.state.inAbstractClass = oldInAbstractClass;\n    }\n  }\n  tsParseAbstractDeclaration(node, decorators) {\n    if (this.match(80)) {\n      node.abstract = true;\n      return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));\n    } else if (this.isContextual(129)) {\n      if (!this.hasFollowingLineBreak()) {\n        node.abstract = true;\n        this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, node);\n        return this.tsParseInterfaceDeclaration(node);\n      }\n    } else {\n      this.unexpected(null, 80);\n    }\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {\n    const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    if (method.abstract) {\n      const hasEstreePlugin = this.hasPlugin(\"estree\");\n      const methodFn = hasEstreePlugin ? method.value : method;\n      if (methodFn.body) {\n        const {\n          key\n        } = method;\n        this.raise(TSErrors.AbstractMethodHasImplementation, method, {\n          methodName: key.type === \"Identifier\" && !method.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`\n        });\n      }\n    }\n    return method;\n  }\n  tsParseTypeParameterName() {\n    const typeName = this.parseIdentifier();\n    return typeName.name;\n  }\n  shouldParseAsAmbientContext() {\n    return !!this.getPluginOption(\"typescript\", \"dts\");\n  }\n  parse() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n    return super.parse();\n  }\n  getExpression() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n    return super.getExpression();\n  }\n  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {\n    if (!isString && isMaybeTypeOnly) {\n      this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);\n      return this.finishNode(node, \"ExportSpecifier\");\n    }\n    node.exportKind = \"value\";\n    return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    if (!importedIsString && isMaybeTypeOnly) {\n      this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);\n      return this.finishNode(specifier, \"ImportSpecifier\");\n    }\n    specifier.importKind = \"value\";\n    return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);\n  }\n  parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {\n    const leftOfAsKey = isImport ? \"imported\" : \"local\";\n    const rightOfAsKey = isImport ? \"local\" : \"exported\";\n    let leftOfAs = node[leftOfAsKey];\n    let rightOfAs;\n    let hasTypeSpecifier = false;\n    let canParseAsKeyword = true;\n    const loc = leftOfAs.loc.start;\n    if (this.isContextual(93)) {\n      const firstAs = this.parseIdentifier();\n      if (this.isContextual(93)) {\n        const secondAs = this.parseIdentifier();\n        if (tokenIsKeywordOrIdentifier(this.state.type)) {\n          hasTypeSpecifier = true;\n          leftOfAs = firstAs;\n          rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n          canParseAsKeyword = false;\n        } else {\n          rightOfAs = secondAs;\n          canParseAsKeyword = false;\n        }\n      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n        canParseAsKeyword = false;\n        rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n      } else {\n        hasTypeSpecifier = true;\n        leftOfAs = firstAs;\n      }\n    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n      hasTypeSpecifier = true;\n      if (isImport) {\n        leftOfAs = this.parseIdentifier(true);\n        if (!this.isContextual(93)) {\n          this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);\n        }\n      } else {\n        leftOfAs = this.parseModuleExportName();\n      }\n    }\n    if (hasTypeSpecifier && isInTypeOnlyImportExport) {\n      this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);\n    }\n    node[leftOfAsKey] = leftOfAs;\n    node[rightOfAsKey] = rightOfAs;\n    const kindKey = isImport ? \"importKind\" : \"exportKind\";\n    node[kindKey] = hasTypeSpecifier ? \"type\" : \"value\";\n    if (canParseAsKeyword && this.eatContextual(93)) {\n      node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n    }\n    if (!node[rightOfAsKey]) {\n      node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);\n    }\n    if (isImport) {\n      this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);\n    }\n  }\n};\nfunction isPossiblyLiteralEnum(expression) {\n  if (expression.type !== \"MemberExpression\") return false;\n  const {\n    computed,\n    property\n  } = expression;\n  if (computed && property.type !== \"StringLiteral\" && (property.type !== \"TemplateLiteral\" || property.expressions.length > 0)) {\n    return false;\n  }\n  return isUncomputedMemberExpressionChain(expression.object);\n}\nfunction isValidAmbientConstInitializer(expression, estree) {\n  var _expression$extra;\n  const {\n    type\n  } = expression;\n  if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {\n    return false;\n  }\n  if (estree) {\n    if (type === \"Literal\") {\n      const {\n        value\n      } = expression;\n      if (typeof value === \"string\" || typeof value === \"boolean\") {\n        return true;\n      }\n    }\n  } else {\n    if (type === \"StringLiteral\" || type === \"BooleanLiteral\") {\n      return true;\n    }\n  }\n  if (isNumber(expression, estree) || isNegativeNumber(expression, estree)) {\n    return true;\n  }\n  if (type === \"TemplateLiteral\" && expression.expressions.length === 0) {\n    return true;\n  }\n  if (isPossiblyLiteralEnum(expression)) {\n    return true;\n  }\n  return false;\n}\nfunction isNumber(expression, estree) {\n  if (estree) {\n    return expression.type === \"Literal\" && (typeof expression.value === \"number\" || \"bigint\" in expression);\n  }\n  return expression.type === \"NumericLiteral\" || expression.type === \"BigIntLiteral\";\n}\nfunction isNegativeNumber(expression, estree) {\n  if (expression.type === \"UnaryExpression\") {\n    const {\n      operator,\n      argument\n    } = expression;\n    if (operator === \"-\" && isNumber(argument, estree)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isUncomputedMemberExpressionChain(expression) {\n  if (expression.type === \"Identifier\") return true;\n  if (expression.type !== \"MemberExpression\" || expression.computed) {\n    return false;\n  }\n  return isUncomputedMemberExpressionChain(expression.object);\n}\nconst PlaceholderErrors = ParseErrorEnum`placeholders`({\n  ClassNameIsRequired: \"A class name is required.\",\n  UnexpectedSpace: \"Unexpected space in placeholder.\"\n});\nvar placeholders = superClass => class PlaceholdersParserMixin extends superClass {\n  parsePlaceholder(expectedNode) {\n    if (this.match(133)) {\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace();\n      node.name = super.parseIdentifier(true);\n      this.assertNoSpace();\n      this.expect(133);\n      return this.finishPlaceholder(node, expectedNode);\n    }\n  }\n  finishPlaceholder(node, expectedNode) {\n    let placeholder = node;\n    if (!placeholder.expectedNode || !placeholder.type) {\n      placeholder = this.finishNode(placeholder, \"Placeholder\");\n    }\n    placeholder.expectedNode = expectedNode;\n    return placeholder;\n  }\n  getTokenFromCode(code) {\n    if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {\n      this.finishOp(133, 2);\n    } else {\n      super.getTokenFromCode(code);\n    }\n  }\n  parseExprAtom(refExpressionErrors) {\n    return this.parsePlaceholder(\"Expression\") || super.parseExprAtom(refExpressionErrors);\n  }\n  parseIdentifier(liberal) {\n    return this.parsePlaceholder(\"Identifier\") || super.parseIdentifier(liberal);\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (word !== undefined) {\n      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n    }\n  }\n  parseBindingAtom() {\n    return this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom();\n  }\n  isValidLVal(type, isParenthesized, binding) {\n    return type === \"Placeholder\" || super.isValidLVal(type, isParenthesized, binding);\n  }\n  toAssignable(node, isLHS) {\n    if (node && node.type === \"Placeholder\" && node.expectedNode === \"Expression\") {\n      node.expectedNode = \"Pattern\";\n    } else {\n      super.toAssignable(node, isLHS);\n    }\n  }\n  chStartsBindingIdentifier(ch, pos) {\n    if (super.chStartsBindingIdentifier(ch, pos)) {\n      return true;\n    }\n    const nextToken = this.lookahead();\n    if (nextToken.type === 133) {\n      return true;\n    }\n    return false;\n  }\n  verifyBreakContinue(node, isBreak) {\n    if (node.label && node.label.type === \"Placeholder\") return;\n    super.verifyBreakContinue(node, isBreak);\n  }\n  parseExpressionStatement(node, expr) {\n    var _expr$extra;\n    if (expr.type !== \"Placeholder\" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {\n      return super.parseExpressionStatement(node, expr);\n    }\n    if (this.match(14)) {\n      const stmt = node;\n      stmt.label = this.finishPlaceholder(expr, \"Identifier\");\n      this.next();\n      stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();\n      return this.finishNode(stmt, \"LabeledStatement\");\n    }\n    this.semicolon();\n    const stmtPlaceholder = node;\n    stmtPlaceholder.name = expr.name;\n    return this.finishPlaceholder(stmtPlaceholder, \"Statement\");\n  }\n  parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {\n    return this.parsePlaceholder(\"BlockStatement\") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);\n  }\n  parseFunctionId(requireId) {\n    return this.parsePlaceholder(\"Identifier\") || super.parseFunctionId(requireId);\n  }\n  parseClass(node, isStatement, optionalId) {\n    const type = isStatement ? \"ClassDeclaration\" : \"ClassExpression\";\n    this.next();\n    const oldStrict = this.state.strict;\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (placeholder) {\n      if (this.match(81) || this.match(133) || this.match(5)) {\n        node.id = placeholder;\n      } else if (optionalId || !isStatement) {\n        node.id = null;\n        node.body = this.finishPlaceholder(placeholder, \"ClassBody\");\n        return this.finishNode(node, type);\n      } else {\n        throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);\n      }\n    } else {\n      this.parseClassId(node, isStatement, optionalId);\n    }\n    super.parseClassSuper(node);\n    node.body = this.parsePlaceholder(\"ClassBody\") || super.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, type);\n  }\n  parseExport(node, decorators) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseExport(node, decorators);\n    const node2 = node;\n    if (!this.isContextual(98) && !this.match(12)) {\n      node2.specifiers = [];\n      node2.source = null;\n      node2.declaration = this.finishPlaceholder(placeholder, \"Declaration\");\n      return this.finishNode(node2, \"ExportNamedDeclaration\");\n    }\n    this.expectPlugin(\"exportDefaultFrom\");\n    const specifier = this.startNode();\n    specifier.exported = placeholder;\n    node2.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n    return super.parseExport(node2, decorators);\n  }\n  isExportDefaultSpecifier() {\n    if (this.match(65)) {\n      const next = this.nextTokenStart();\n      if (this.isUnparsedContextual(next, \"from\")) {\n        if (this.input.startsWith(tokenLabelName(133), this.nextTokenStartSince(next + 4))) {\n          return true;\n        }\n      }\n    }\n    return super.isExportDefaultSpecifier();\n  }\n  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {\n    var _specifiers;\n    if ((_specifiers = node.specifiers) != null && _specifiers.length) {\n      return true;\n    }\n    return super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);\n  }\n  checkExport(node) {\n    const {\n      specifiers\n    } = node;\n    if (specifiers != null && specifiers.length) {\n      node.specifiers = specifiers.filter(node => node.exported.type === \"Placeholder\");\n    }\n    super.checkExport(node);\n    node.specifiers = specifiers;\n  }\n  parseImport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseImport(node);\n    node.specifiers = [];\n    if (!this.isContextual(98) && !this.match(12)) {\n      node.source = this.finishPlaceholder(placeholder, \"StringLiteral\");\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n    const specifier = this.startNodeAtNode(placeholder);\n    specifier.local = placeholder;\n    node.specifiers.push(this.finishNode(specifier, \"ImportDefaultSpecifier\"));\n    if (this.eat(12)) {\n      const hasStarImport = this.maybeParseStarImportSpecifier(node);\n      if (!hasStarImport) this.parseNamedImportSpecifiers(node);\n    }\n    this.expectContextual(98);\n    node.source = this.parseImportSource();\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n  parseImportSource() {\n    return this.parsePlaceholder(\"StringLiteral\") || super.parseImportSource();\n  }\n  assertNoSpace() {\n    if (this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index)) {\n      this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);\n    }\n  }\n};\nvar v8intrinsic = superClass => class V8IntrinsicMixin extends superClass {\n  parseV8Intrinsic() {\n    if (this.match(54)) {\n      const v8IntrinsicStartLoc = this.state.startLoc;\n      const node = this.startNode();\n      this.next();\n      if (tokenIsIdentifier(this.state.type)) {\n        const name = this.parseIdentifierName();\n        const identifier = this.createIdentifier(node, name);\n        identifier.type = \"V8IntrinsicIdentifier\";\n        if (this.match(10)) {\n          return identifier;\n        }\n      }\n      this.unexpected(v8IntrinsicStartLoc);\n    }\n  }\n  parseExprAtom(refExpressionErrors) {\n    return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);\n  }\n};\nconst PIPELINE_PROPOSALS = [\"minimal\", \"fsharp\", \"hack\", \"smart\"];\nconst TOPIC_TOKENS = [\"^^\", \"@@\", \"^\", \"%\", \"#\"];\nfunction validatePlugins(pluginsMap) {\n  if (pluginsMap.has(\"decorators\")) {\n    if (pluginsMap.has(\"decorators-legacy\")) {\n      throw new Error(\"Cannot use the decorators and decorators-legacy plugin together\");\n    }\n    const decoratorsBeforeExport = pluginsMap.get(\"decorators\").decoratorsBeforeExport;\n    if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== \"boolean\") {\n      throw new Error(\"'decoratorsBeforeExport' must be a boolean, if specified.\");\n    }\n    const allowCallParenthesized = pluginsMap.get(\"decorators\").allowCallParenthesized;\n    if (allowCallParenthesized != null && typeof allowCallParenthesized !== \"boolean\") {\n      throw new Error(\"'allowCallParenthesized' must be a boolean.\");\n    }\n  }\n  if (pluginsMap.has(\"flow\") && pluginsMap.has(\"typescript\")) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n  if (pluginsMap.has(\"placeholders\") && pluginsMap.has(\"v8intrinsic\")) {\n    throw new Error(\"Cannot combine placeholders and v8intrinsic plugins.\");\n  }\n  if (pluginsMap.has(\"pipelineOperator\")) {\n    var _pluginsMap$get;\n    const proposal = pluginsMap.get(\"pipelineOperator\").proposal;\n    if (!PIPELINE_PROPOSALS.includes(proposal)) {\n      const proposalList = PIPELINE_PROPOSALS.map(p => `\"${p}\"`).join(\", \");\n      throw new Error(`\"pipelineOperator\" requires \"proposal\" option whose value must be one of: ${proposalList}.`);\n    }\n    const tupleSyntaxIsHash = ((_pluginsMap$get = pluginsMap.get(\"recordAndTuple\")) == null ? void 0 : _pluginsMap$get.syntaxType) === \"hash\";\n    if (proposal === \"hack\") {\n      if (pluginsMap.has(\"placeholders\")) {\n        throw new Error(\"Cannot combine placeholders plugin and Hack-style pipes.\");\n      }\n      if (pluginsMap.has(\"v8intrinsic\")) {\n        throw new Error(\"Cannot combine v8intrinsic plugin and Hack-style pipes.\");\n      }\n      const topicToken = pluginsMap.get(\"pipelineOperator\").topicToken;\n      if (!TOPIC_TOKENS.includes(topicToken)) {\n        const tokenList = TOPIC_TOKENS.map(t => `\"${t}\"`).join(\", \");\n        throw new Error(`\"pipelineOperator\" in \"proposal\": \"hack\" mode also requires a \"topicToken\" option whose value must be one of: ${tokenList}.`);\n      }\n      if (topicToken === \"#\" && tupleSyntaxIsHash) {\n        throw new Error(`Plugin conflict between \\`[\"pipelineOperator\", { proposal: \"hack\", topicToken: \"#\" }]\\` and \\`${JSON.stringify([\"recordAndTuple\", pluginsMap.get(\"recordAndTuple\")])}\\`.`);\n      }\n    } else if (proposal === \"smart\" && tupleSyntaxIsHash) {\n      throw new Error(`Plugin conflict between \\`[\"pipelineOperator\", { proposal: \"smart\" }]\\` and \\`${JSON.stringify([\"recordAndTuple\", pluginsMap.get(\"recordAndTuple\")])}\\`.`);\n    }\n  }\n  if (pluginsMap.has(\"moduleAttributes\")) {\n    {\n      if (pluginsMap.has(\"deprecatedImportAssert\") || pluginsMap.has(\"importAssertions\")) {\n        throw new Error(\"Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.\");\n      }\n      const moduleAttributesVersionPluginOption = pluginsMap.get(\"moduleAttributes\").version;\n      if (moduleAttributesVersionPluginOption !== \"may-2020\") {\n        throw new Error(\"The 'moduleAttributes' plugin requires a 'version' option,\" + \" representing the last proposal update. Currently, the\" + \" only supported value is 'may-2020'.\");\n      }\n    }\n  }\n  if (pluginsMap.has(\"importAssertions\")) {\n    if (pluginsMap.has(\"deprecatedImportAssert\")) {\n      throw new Error(\"Cannot combine importAssertions and deprecatedImportAssert plugins.\");\n    }\n  }\n  if (!pluginsMap.has(\"deprecatedImportAssert\") && pluginsMap.has(\"importAttributes\") && pluginsMap.get(\"importAttributes\").deprecatedAssertSyntax) {\n    {\n      pluginsMap.set(\"deprecatedImportAssert\", {});\n    }\n  }\n  if (pluginsMap.has(\"recordAndTuple\")) {\n    const syntaxType = pluginsMap.get(\"recordAndTuple\").syntaxType;\n    if (syntaxType != null) {\n      {\n        const RECORD_AND_TUPLE_SYNTAX_TYPES = [\"hash\", \"bar\"];\n        if (!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(syntaxType)) {\n          throw new Error(\"The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: \" + RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(\", \"));\n        }\n      }\n    }\n  }\n  if (pluginsMap.has(\"asyncDoExpressions\") && !pluginsMap.has(\"doExpressions\")) {\n    const error = new Error(\"'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.\");\n    error.missingPlugins = \"doExpressions\";\n    throw error;\n  }\n  if (pluginsMap.has(\"optionalChainingAssign\") && pluginsMap.get(\"optionalChainingAssign\").version !== \"2023-07\") {\n    throw new Error(\"The 'optionalChainingAssign' plugin requires a 'version' option,\" + \" representing the last proposal update. Currently, the\" + \" only supported value is '2023-07'.\");\n  }\n}\nconst mixinPlugins = {\n  estree,\n  jsx,\n  flow,\n  typescript,\n  v8intrinsic,\n  placeholders\n};\nconst mixinPluginNames = Object.keys(mixinPlugins);\nclass ExpressionParser extends LValParser {\n  checkProto(prop, isRecord, sawProto, refExpressionErrors) {\n    if (prop.type === \"SpreadElement\" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {\n      return sawProto;\n    }\n    const key = prop.key;\n    const name = key.type === \"Identifier\" ? key.name : key.value;\n    if (name === \"__proto__\") {\n      if (isRecord) {\n        this.raise(Errors.RecordNoProto, key);\n        return true;\n      }\n      if (sawProto) {\n        if (refExpressionErrors) {\n          if (refExpressionErrors.doubleProtoLoc === null) {\n            refExpressionErrors.doubleProtoLoc = key.loc.start;\n          }\n        } else {\n          this.raise(Errors.DuplicateProto, key);\n        }\n      }\n      return true;\n    }\n    return sawProto;\n  }\n  shouldExitDescending(expr, potentialArrowAt) {\n    return expr.type === \"ArrowFunctionExpression\" && this.offsetToSourcePos(expr.start) === potentialArrowAt;\n  }\n  getExpression() {\n    this.enterInitialScopes();\n    this.nextToken();\n    const expr = this.parseExpression();\n    if (!this.match(140)) {\n      this.unexpected();\n    }\n    this.finalizeRemainingComments();\n    expr.comments = this.comments;\n    expr.errors = this.state.errors;\n    if (this.optionFlags & 256) {\n      expr.tokens = this.tokens;\n    }\n    return expr;\n  }\n  parseExpression(disallowIn, refExpressionErrors) {\n    if (disallowIn) {\n      return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n    }\n    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n  }\n  parseExpressionBase(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(refExpressionErrors);\n    if (this.match(12)) {\n      const node = this.startNodeAt(startLoc);\n      node.expressions = [expr];\n      while (this.eat(12)) {\n        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));\n      }\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n    return expr;\n  }\n  parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {\n    return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n  parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {\n    return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n  setOptionalParametersError(refExpressionErrors) {\n    refExpressionErrors.optionalParametersLoc = this.state.startLoc;\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    const startLoc = this.state.startLoc;\n    const isYield = this.isContextual(108);\n    if (isYield) {\n      if (this.prodParam.hasYield) {\n        this.next();\n        let left = this.parseYield(startLoc);\n        if (afterLeftParse) {\n          left = afterLeftParse.call(this, left, startLoc);\n        }\n        return left;\n      }\n    }\n    let ownExpressionErrors;\n    if (refExpressionErrors) {\n      ownExpressionErrors = false;\n    } else {\n      refExpressionErrors = new ExpressionErrors();\n      ownExpressionErrors = true;\n    }\n    const {\n      type\n    } = this.state;\n    if (type === 10 || tokenIsIdentifier(type)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n    let left = this.parseMaybeConditional(refExpressionErrors);\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startLoc);\n    }\n    if (tokenIsAssignment(this.state.type)) {\n      const node = this.startNodeAt(startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n      if (this.match(29)) {\n        this.toAssignable(left, true);\n        node.left = left;\n        const startIndex = startLoc.index;\n        if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {\n          refExpressionErrors.doubleProtoLoc = null;\n        }\n        if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {\n          refExpressionErrors.shorthandAssignLoc = null;\n        }\n        if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {\n          this.checkDestructuringPrivate(refExpressionErrors);\n          refExpressionErrors.privateKeyLoc = null;\n        }\n      } else {\n        node.left = left;\n      }\n      this.next();\n      node.right = this.parseMaybeAssign();\n      this.checkLVal(left, this.finishNode(node, \"AssignmentExpression\"));\n      return node;\n    } else if (ownExpressionErrors) {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    if (isYield) {\n      const {\n        type\n      } = this.state;\n      const startsExpr = this.hasPlugin(\"v8intrinsic\") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);\n      if (startsExpr && !this.isAmbiguousPrefixOrIdentifier()) {\n        this.raiseOverwrite(Errors.YieldNotInGeneratorFunction, startLoc);\n        return this.parseYield(startLoc);\n      }\n    }\n    return left;\n  }\n  parseMaybeConditional(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseConditional(expr, startLoc, refExpressionErrors);\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (this.eat(17)) {\n      const node = this.startNodeAt(startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssignAllowIn();\n      this.expect(14);\n      node.alternate = this.parseMaybeAssign();\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n    return expr;\n  }\n  parseMaybeUnaryOrPrivate(refExpressionErrors) {\n    return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);\n  }\n  parseExprOps(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseExprOp(expr, startLoc, -1);\n  }\n  parseExprOp(left, leftStartLoc, minPrec) {\n    if (this.isPrivateName(left)) {\n      const value = this.getPrivateNameSV(left);\n      if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {\n        this.raise(Errors.PrivateInExpectedIn, left, {\n          identifierName: value\n        });\n      }\n      this.classScope.usePrivateName(value, left.loc.start);\n    }\n    const op = this.state.type;\n    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {\n      let prec = tokenOperatorPrecedence(op);\n      if (prec > minPrec) {\n        if (op === 39) {\n          this.expectPlugin(\"pipelineOperator\");\n          if (this.state.inFSharpPipelineDirectBody) {\n            return left;\n          }\n          this.checkPipelineAtInfixOperator(left, leftStartLoc);\n        }\n        const node = this.startNodeAt(leftStartLoc);\n        node.left = left;\n        node.operator = this.state.value;\n        const logical = op === 41 || op === 42;\n        const coalesce = op === 40;\n        if (coalesce) {\n          prec = tokenOperatorPrecedence(42);\n        }\n        this.next();\n        if (op === 39 && this.hasPlugin([\"pipelineOperator\", {\n          proposal: \"minimal\"\n        }])) {\n          if (this.state.type === 96 && this.prodParam.hasAwait) {\n            throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);\n          }\n        }\n        node.right = this.parseExprOpRightExpr(op, prec);\n        const finishedNode = this.finishNode(node, logical || coalesce ? \"LogicalExpression\" : \"BinaryExpression\");\n        const nextOp = this.state.type;\n        if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {\n          throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);\n        }\n        return this.parseExprOp(finishedNode, leftStartLoc, minPrec);\n      }\n    }\n    return left;\n  }\n  parseExprOpRightExpr(op, prec) {\n    const startLoc = this.state.startLoc;\n    switch (op) {\n      case 39:\n        switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n          case \"hack\":\n            return this.withTopicBindingContext(() => {\n              return this.parseHackPipeBody();\n            });\n          case \"fsharp\":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec);\n            });\n        }\n        if (this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"smart\") {\n          return this.withTopicBindingContext(() => {\n            if (this.prodParam.hasYield && this.isContextual(108)) {\n              throw this.raise(Errors.PipeBodyIsTighter, this.state.startLoc);\n            }\n            return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);\n          });\n        }\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec);\n    }\n  }\n  parseExprOpBaseRightExpr(op, prec) {\n    const startLoc = this.state.startLoc;\n    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);\n  }\n  parseHackPipeBody() {\n    var _body$extra;\n    const {\n      startLoc\n    } = this.state;\n    const body = this.parseMaybeAssign();\n    const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);\n    if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {\n      this.raise(Errors.PipeUnparenthesizedBody, startLoc, {\n        type: body.type\n      });\n    }\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipeTopicUnused, startLoc);\n    }\n    return body;\n  }\n  checkExponentialAfterUnary(node) {\n    if (this.match(57)) {\n      this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);\n    }\n  }\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\n    const startLoc = this.state.startLoc;\n    const isAwait = this.isContextual(96);\n    if (isAwait && this.recordAwaitIfAllowed()) {\n      this.next();\n      const expr = this.parseAwait(startLoc);\n      if (!sawUnary) this.checkExponentialAfterUnary(expr);\n      return expr;\n    }\n    const update = this.match(34);\n    const node = this.startNode();\n    if (tokenIsPrefix(this.state.type)) {\n      node.operator = this.state.value;\n      node.prefix = true;\n      if (this.match(72)) {\n        this.expectPlugin(\"throwExpressions\");\n      }\n      const isDelete = this.match(89);\n      this.next();\n      node.argument = this.parseMaybeUnary(null, true);\n      this.checkExpressionErrors(refExpressionErrors, true);\n      if (this.state.strict && isDelete) {\n        const arg = node.argument;\n        if (arg.type === \"Identifier\") {\n          this.raise(Errors.StrictDelete, node);\n        } else if (this.hasPropertyAsPrivateName(arg)) {\n          this.raise(Errors.DeletePrivateField, node);\n        }\n      }\n      if (!update) {\n        if (!sawUnary) {\n          this.checkExponentialAfterUnary(node);\n        }\n        return this.finishNode(node, \"UnaryExpression\");\n      }\n    }\n    const expr = this.parseUpdate(node, update, refExpressionErrors);\n    if (isAwait) {\n      const {\n        type\n      } = this.state;\n      const startsExpr = this.hasPlugin(\"v8intrinsic\") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);\n      if (startsExpr && !this.isAmbiguousPrefixOrIdentifier()) {\n        this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);\n        return this.parseAwait(startLoc);\n      }\n    }\n    return expr;\n  }\n  parseUpdate(node, update, refExpressionErrors) {\n    if (update) {\n      const updateExpressionNode = node;\n      this.checkLVal(updateExpressionNode.argument, this.finishNode(updateExpressionNode, \"UpdateExpression\"));\n      return node;\n    }\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refExpressionErrors);\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\n    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startLoc);\n      node.operator = this.state.value;\n      node.prefix = false;\n      node.argument = expr;\n      this.next();\n      this.checkLVal(expr, expr = this.finishNode(node, \"UpdateExpression\"));\n    }\n    return expr;\n  }\n  parseExprSubscripts(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseSubscripts(expr, startLoc);\n  }\n  parseSubscripts(base, startLoc, noCalls) {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\n      stop: false\n    };\n    do {\n      base = this.parseSubscript(base, startLoc, noCalls, state);\n      state.maybeAsyncArrow = false;\n    } while (!state.stop);\n    return base;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    const {\n      type\n    } = this.state;\n    if (!noCalls && type === 15) {\n      return this.parseBind(base, startLoc, noCalls, state);\n    } else if (tokenIsTemplate(type)) {\n      return this.parseTaggedTemplateExpression(base, startLoc, state);\n    }\n    let optional = false;\n    if (type === 18) {\n      if (noCalls) {\n        this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);\n        if (this.lookaheadCharCode() === 40) {\n          state.stop = true;\n          return base;\n        }\n      }\n      state.optionalChainMember = optional = true;\n      this.next();\n    }\n    if (!noCalls && this.match(10)) {\n      return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);\n    } else {\n      const computed = this.eat(0);\n      if (computed || optional || this.eat(16)) {\n        return this.parseMember(base, startLoc, state, computed, optional);\n      } else {\n        state.stop = true;\n        return base;\n      }\n    }\n  }\n  parseMember(base, startLoc, state, computed, optional) {\n    const node = this.startNodeAt(startLoc);\n    node.object = base;\n    node.computed = computed;\n    if (computed) {\n      node.property = this.parseExpression();\n      this.expect(3);\n    } else if (this.match(139)) {\n      if (base.type === \"Super\") {\n        this.raise(Errors.SuperPrivateField, startLoc);\n      }\n      this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n      node.property = this.parsePrivateName();\n    } else {\n      node.property = this.parseIdentifier(true);\n    }\n    if (state.optionalChainMember) {\n      node.optional = optional;\n      return this.finishNode(node, \"OptionalMemberExpression\");\n    } else {\n      return this.finishNode(node, \"MemberExpression\");\n    }\n  }\n  parseBind(base, startLoc, noCalls, state) {\n    const node = this.startNodeAt(startLoc);\n    node.object = base;\n    this.next();\n    node.callee = this.parseNoCallExpr();\n    state.stop = true;\n    return this.parseSubscripts(this.finishNode(node, \"BindExpression\"), startLoc, noCalls);\n  }\n  parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    let refExpressionErrors = null;\n    this.state.maybeInArrowParameters = true;\n    this.next();\n    const node = this.startNodeAt(startLoc);\n    node.callee = base;\n    const {\n      maybeAsyncArrow,\n      optionalChainMember\n    } = state;\n    if (maybeAsyncArrow) {\n      this.expressionScope.enter(newAsyncArrowScope());\n      refExpressionErrors = new ExpressionErrors();\n    }\n    if (optionalChainMember) {\n      node.optional = optional;\n    }\n    if (optional) {\n      node.arguments = this.parseCallExpressionArguments(11);\n    } else {\n      node.arguments = this.parseCallExpressionArguments(11, base.type !== \"Super\", node, refExpressionErrors);\n    }\n    let finishedNode = this.finishCallExpression(node, optionalChainMember);\n    if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\n      state.stop = true;\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);\n    } else {\n      if (maybeAsyncArrow) {\n        this.checkExpressionErrors(refExpressionErrors, true);\n        this.expressionScope.exit();\n      }\n      this.toReferencedArguments(finishedNode);\n    }\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return finishedNode;\n  }\n  toReferencedArguments(node, isParenthesizedExpr) {\n    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);\n  }\n  parseTaggedTemplateExpression(base, startLoc, state) {\n    const node = this.startNodeAt(startLoc);\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n    if (state.optionalChainMember) {\n      this.raise(Errors.OptionalChainingNoTemplate, startLoc);\n    }\n    return this.finishNode(node, \"TaggedTemplateExpression\");\n  }\n  atPossibleAsyncArrow(base) {\n    return base.type === \"Identifier\" && base.name === \"async\" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.offsetToSourcePos(base.start) === this.state.potentialArrowAt;\n  }\n  finishCallExpression(node, optional) {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length === 0 || node.arguments.length > 2) {\n        this.raise(Errors.ImportCallArity, node);\n      } else {\n        for (const arg of node.arguments) {\n          if (arg.type === \"SpreadElement\") {\n            this.raise(Errors.ImportCallSpreadArgument, arg);\n          }\n        }\n      }\n    }\n    return this.finishNode(node, optional ? \"OptionalCallExpression\" : \"CallExpression\");\n  }\n  parseCallExpressionArguments(close, allowPlaceholder, nodeForExtra, refExpressionErrors) {\n    const elts = [];\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n      elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));\n    }\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return elts;\n  }\n  shouldParseAsyncArrow() {\n    return this.match(19) && !this.canInsertSemicolon();\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    var _call$extra;\n    this.resetPreviousNodeTrailingComments(call);\n    this.expect(19);\n    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);\n    if (call.innerComments) {\n      setInnerComments(node, call.innerComments);\n    }\n    if (call.callee.trailingComments) {\n      setInnerComments(node, call.callee.trailingComments);\n    }\n    return node;\n  }\n  parseNoCallExpr() {\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startLoc, true);\n  }\n  parseExprAtom(refExpressionErrors) {\n    let node;\n    let decorators = null;\n    const {\n      type\n    } = this.state;\n    switch (type) {\n      case 79:\n        return this.parseSuper();\n      case 83:\n        node = this.startNode();\n        this.next();\n        if (this.match(16)) {\n          return this.parseImportMetaProperty(node);\n        }\n        if (this.match(10)) {\n          if (this.optionFlags & 512) {\n            return this.parseImportCall(node);\n          } else {\n            return this.finishNode(node, \"Import\");\n          }\n        } else {\n          this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);\n          return this.finishNode(node, \"Import\");\n        }\n      case 78:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n      case 90:\n        {\n          return this.parseDo(this.startNode(), false);\n        }\n      case 56:\n      case 31:\n        {\n          this.readRegexp();\n          return this.parseRegExpLiteral(this.state.value);\n        }\n      case 135:\n        return this.parseNumericLiteral(this.state.value);\n      case 136:\n        return this.parseBigIntLiteral(this.state.value);\n      case 134:\n        return this.parseStringLiteral(this.state.value);\n      case 84:\n        return this.parseNullLiteral();\n      case 85:\n        return this.parseBooleanLiteral(true);\n      case 86:\n        return this.parseBooleanLiteral(false);\n      case 10:\n        {\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          return this.parseParenAndDistinguishExpression(canBeArrow);\n        }\n      case 2:\n      case 1:\n        {\n          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);\n        }\n      case 0:\n        {\n          return this.parseArrayLike(3, true, false, refExpressionErrors);\n        }\n      case 6:\n      case 7:\n        {\n          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);\n        }\n      case 5:\n        {\n          return this.parseObjectLike(8, false, false, refExpressionErrors);\n        }\n      case 68:\n        return this.parseFunctionOrFunctionSent();\n      case 26:\n        decorators = this.parseDecorators();\n      case 80:\n        return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);\n      case 77:\n        return this.parseNewOrNewTarget();\n      case 25:\n      case 24:\n        return this.parseTemplate(false);\n      case 15:\n        {\n          node = this.startNode();\n          this.next();\n          node.object = null;\n          const callee = node.callee = this.parseNoCallExpr();\n          if (callee.type === \"MemberExpression\") {\n            return this.finishNode(node, \"BindExpression\");\n          } else {\n            throw this.raise(Errors.UnsupportedBind, callee);\n          }\n        }\n      case 139:\n        {\n          this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {\n            identifierName: this.state.value\n          });\n          return this.parsePrivateName();\n        }\n      case 33:\n        {\n          return this.parseTopicReferenceThenEqualsSign(54, \"%\");\n        }\n      case 32:\n        {\n          return this.parseTopicReferenceThenEqualsSign(44, \"^\");\n        }\n      case 37:\n      case 38:\n        {\n          return this.parseTopicReference(\"hack\");\n        }\n      case 44:\n      case 54:\n      case 27:\n        {\n          const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n          if (pipeProposal) {\n            return this.parseTopicReference(pipeProposal);\n          }\n          this.unexpected();\n          break;\n        }\n      case 47:\n        {\n          const lookaheadCh = this.input.codePointAt(this.nextTokenStart());\n          if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {\n            this.expectOnePlugin([\"jsx\", \"flow\", \"typescript\"]);\n          } else {\n            this.unexpected();\n          }\n          break;\n        }\n      default:\n        if (type === 137) {\n          return this.parseDecimalLiteral(this.state.value);\n        }\n        if (tokenIsIdentifier(type)) {\n          if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {\n            return this.parseModuleExpression();\n          }\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          const containsEsc = this.state.containsEsc;\n          const id = this.parseIdentifier();\n          if (!containsEsc && id.name === \"async\" && !this.canInsertSemicolon()) {\n            const {\n              type\n            } = this.state;\n            if (type === 68) {\n              this.resetPreviousNodeTrailingComments(id);\n              this.next();\n              return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));\n            } else if (tokenIsIdentifier(type)) {\n              if (this.lookaheadCharCode() === 61) {\n                return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));\n              } else {\n                return id;\n              }\n            } else if (type === 90) {\n              this.resetPreviousNodeTrailingComments(id);\n              return this.parseDo(this.startNodeAtNode(id), true);\n            }\n          }\n          if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {\n            this.next();\n            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);\n          }\n          return id;\n        } else {\n          this.unexpected();\n        }\n    }\n  }\n  parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {\n    const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n    if (pipeProposal) {\n      this.state.type = topicTokenType;\n      this.state.value = topicTokenValue;\n      this.state.pos--;\n      this.state.end--;\n      this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);\n      return this.parseTopicReference(pipeProposal);\n    } else {\n      this.unexpected();\n    }\n  }\n  parseTopicReference(pipeProposal) {\n    const node = this.startNode();\n    const startLoc = this.state.startLoc;\n    const tokenType = this.state.type;\n    this.next();\n    return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);\n  }\n  finishTopicReference(node, startLoc, pipeProposal, tokenType) {\n    if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {\n      if (pipeProposal === \"hack\") {\n        if (!this.topicReferenceIsAllowedInCurrentContext()) {\n          this.raise(Errors.PipeTopicUnbound, startLoc);\n        }\n        this.registerTopicReference();\n        return this.finishNode(node, \"TopicReference\");\n      } else {\n        if (!this.topicReferenceIsAllowedInCurrentContext()) {\n          this.raise(Errors.PrimaryTopicNotAllowed, startLoc);\n        }\n        this.registerTopicReference();\n        return this.finishNode(node, \"PipelinePrimaryTopicReference\");\n      }\n    } else {\n      throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {\n        token: tokenLabelName(tokenType)\n      });\n    }\n  }\n  testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {\n    switch (pipeProposal) {\n      case \"hack\":\n        {\n          return this.hasPlugin([\"pipelineOperator\", {\n            topicToken: tokenLabelName(tokenType)\n          }]);\n        }\n      case \"smart\":\n        return tokenType === 27;\n      default:\n        throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);\n    }\n  }\n  parseAsyncArrowUnaryFunction(node) {\n    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));\n    const params = [this.parseIdentifier()];\n    this.prodParam.exit();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());\n    }\n    this.expect(19);\n    return this.parseArrowExpression(node, params, true);\n  }\n  parseDo(node, isAsync) {\n    this.expectPlugin(\"doExpressions\");\n    if (isAsync) {\n      this.expectPlugin(\"asyncDoExpressions\");\n    }\n    node.async = isAsync;\n    this.next();\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    if (isAsync) {\n      this.prodParam.enter(2);\n      node.body = this.parseBlock();\n      this.prodParam.exit();\n    } else {\n      node.body = this.parseBlock();\n    }\n    this.state.labels = oldLabels;\n    return this.finishNode(node, \"DoExpression\");\n  }\n  parseSuper() {\n    const node = this.startNode();\n    this.next();\n    if (this.match(10) && !this.scope.allowDirectSuper && !(this.optionFlags & 16)) {\n      this.raise(Errors.SuperNotAllowed, node);\n    } else if (!this.scope.allowSuper && !(this.optionFlags & 16)) {\n      this.raise(Errors.UnexpectedSuper, node);\n    }\n    if (!this.match(10) && !this.match(0) && !this.match(16)) {\n      this.raise(Errors.UnsupportedSuper, node);\n    }\n    return this.finishNode(node, \"Super\");\n  }\n  parsePrivateName() {\n    const node = this.startNode();\n    const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));\n    const name = this.state.value;\n    this.next();\n    node.id = this.createIdentifier(id, name);\n    return this.finishNode(node, \"PrivateName\");\n  }\n  parseFunctionOrFunctionSent() {\n    const node = this.startNode();\n    this.next();\n    if (this.prodParam.hasYield && this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"function\");\n      this.next();\n      if (this.match(103)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        this.unexpected();\n      }\n      return this.parseMetaProperty(node, meta, \"sent\");\n    }\n    return this.parseFunction(node);\n  }\n  parseMetaProperty(node, meta, propertyName) {\n    node.meta = meta;\n    const containsEsc = this.state.containsEsc;\n    node.property = this.parseIdentifier(true);\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(Errors.UnsupportedMetaProperty, node.property, {\n        target: meta.name,\n        onlyValidPropertyName: propertyName\n      });\n    }\n    return this.finishNode(node, \"MetaProperty\");\n  }\n  parseImportMetaProperty(node) {\n    const id = this.createIdentifier(this.startNodeAtNode(node), \"import\");\n    this.next();\n    if (this.isContextual(101)) {\n      if (!this.inModule) {\n        this.raise(Errors.ImportMetaOutsideModule, id);\n      }\n      this.sawUnambiguousESM = true;\n    } else if (this.isContextual(105) || this.isContextual(97)) {\n      const isSource = this.isContextual(105);\n      this.expectPlugin(isSource ? \"sourcePhaseImports\" : \"deferredImportEvaluation\");\n      if (!(this.optionFlags & 512)) {\n        throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {\n          phase: this.state.value\n        });\n      }\n      this.next();\n      node.phase = isSource ? \"source\" : \"defer\";\n      return this.parseImportCall(node);\n    }\n    return this.parseMetaProperty(node, id, \"meta\");\n  }\n  parseLiteralAtNode(value, type, node) {\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode(node, type);\n  }\n  parseLiteral(value, type) {\n    const node = this.startNode();\n    return this.parseLiteralAtNode(value, type, node);\n  }\n  parseStringLiteral(value) {\n    return this.parseLiteral(value, \"StringLiteral\");\n  }\n  parseNumericLiteral(value) {\n    return this.parseLiteral(value, \"NumericLiteral\");\n  }\n  parseBigIntLiteral(value) {\n    return this.parseLiteral(value, \"BigIntLiteral\");\n  }\n  parseDecimalLiteral(value) {\n    return this.parseLiteral(value, \"DecimalLiteral\");\n  }\n  parseRegExpLiteral(value) {\n    const node = this.startNode();\n    this.addExtra(node, \"raw\", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));\n    node.pattern = value.pattern;\n    node.flags = value.flags;\n    this.next();\n    return this.finishNode(node, \"RegExpLiteral\");\n  }\n  parseBooleanLiteral(value) {\n    const node = this.startNode();\n    node.value = value;\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  }\n  parseNullLiteral() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"NullLiteral\");\n  }\n  parseParenAndDistinguishExpression(canBeArrow) {\n    const startLoc = this.state.startLoc;\n    let val;\n    this.next();\n    this.expressionScope.enter(newArrowHeadScope());\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.inFSharpPipelineDirectBody = false;\n    const innerStartLoc = this.state.startLoc;\n    const exprList = [];\n    const refExpressionErrors = new ExpressionErrors();\n    let first = true;\n    let spreadStartLoc;\n    let optionalCommaStartLoc;\n    while (!this.match(11)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);\n        if (this.match(11)) {\n          optionalCommaStartLoc = this.state.startLoc;\n          break;\n        }\n      }\n      if (this.match(21)) {\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStartLoc = this.state.startLoc;\n        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));\n        if (!this.checkCommaAfterRest(41)) {\n          break;\n        }\n      } else {\n        exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));\n      }\n    }\n    const innerEndLoc = this.state.lastTokEndLoc;\n    this.expect(11);\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let arrowNode = this.startNodeAt(startLoc);\n    if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      this.parseArrowExpression(arrowNode, exprList, false);\n      return arrowNode;\n    }\n    this.expressionScope.exit();\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStartLoc);\n    }\n    if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);\n    if (spreadStartLoc) this.unexpected(spreadStartLoc);\n    this.checkExpressionErrors(refExpressionErrors, true);\n    this.toReferencedListDeep(exprList, true);\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartLoc);\n      val.expressions = exprList;\n      this.finishNode(val, \"SequenceExpression\");\n      this.resetEndLocation(val, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n    return this.wrapParenthesis(startLoc, val);\n  }\n  wrapParenthesis(startLoc, expression) {\n    if (!(this.optionFlags & 1024)) {\n      this.addExtra(expression, \"parenthesized\", true);\n      this.addExtra(expression, \"parenStart\", startLoc.index);\n      this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);\n      return expression;\n    }\n    const parenExpression = this.startNodeAt(startLoc);\n    parenExpression.expression = expression;\n    return this.finishNode(parenExpression, \"ParenthesizedExpression\");\n  }\n  shouldParseArrow(params) {\n    return !this.canInsertSemicolon();\n  }\n  parseArrow(node) {\n    if (this.eat(19)) {\n      return node;\n    }\n  }\n  parseParenItem(node, startLoc) {\n    return node;\n  }\n  parseNewOrNewTarget() {\n    const node = this.startNode();\n    this.next();\n    if (this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"new\");\n      this.next();\n      const metaProp = this.parseMetaProperty(node, meta, \"target\");\n      if (!this.scope.inNonArrowFunction && !this.scope.inClass && !(this.optionFlags & 4)) {\n        this.raise(Errors.UnexpectedNewTarget, metaProp);\n      }\n      return metaProp;\n    }\n    return this.parseNew(node);\n  }\n  parseNew(node) {\n    this.parseNewCallee(node);\n    if (this.eat(10)) {\n      const args = this.parseExprList(11);\n      this.toReferencedList(args);\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n    return this.finishNode(node, \"NewExpression\");\n  }\n  parseNewCallee(node) {\n    const isImport = this.match(83);\n    const callee = this.parseNoCallExpr();\n    node.callee = callee;\n    if (isImport && (callee.type === \"Import\" || callee.type === \"ImportExpression\")) {\n      this.raise(Errors.ImportCallNotNewExpression, callee);\n    }\n  }\n  parseTemplateElement(isTagged) {\n    const {\n      start,\n      startLoc,\n      end,\n      value\n    } = this.state;\n    const elemStart = start + 1;\n    const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));\n    if (value === null) {\n      if (!isTagged) {\n        this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));\n      }\n    }\n    const isTail = this.match(24);\n    const endOffset = isTail ? -1 : -2;\n    const elemEnd = end + endOffset;\n    elem.value = {\n      raw: this.input.slice(elemStart, elemEnd).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: value === null ? null : value.slice(1, endOffset)\n    };\n    elem.tail = isTail;\n    this.next();\n    const finishedNode = this.finishNode(elem, \"TemplateElement\");\n    this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));\n    return finishedNode;\n  }\n  parseTemplate(isTagged) {\n    const node = this.startNode();\n    let curElt = this.parseTemplateElement(isTagged);\n    const quasis = [curElt];\n    const substitutions = [];\n    while (!curElt.tail) {\n      substitutions.push(this.parseTemplateSubstitution());\n      this.readTemplateContinuation();\n      quasis.push(curElt = this.parseTemplateElement(isTagged));\n    }\n    node.expressions = substitutions;\n    node.quasis = quasis;\n    return this.finishNode(node, \"TemplateLiteral\");\n  }\n  parseTemplateSubstitution() {\n    return this.parseExpression();\n  }\n  parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {\n    if (isRecord) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    let sawProto = false;\n    let first = true;\n    const node = this.startNode();\n    node.properties = [];\n    this.next();\n    while (!this.match(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          this.addTrailingCommaExtraToNode(node);\n          break;\n        }\n      }\n      let prop;\n      if (isPattern) {\n        prop = this.parseBindingProperty();\n      } else {\n        prop = this.parsePropertyDefinition(refExpressionErrors);\n        sawProto = this.checkProto(prop, isRecord, sawProto, refExpressionErrors);\n      }\n      if (isRecord && !this.isObjectProperty(prop) && prop.type !== \"SpreadElement\") {\n        this.raise(Errors.InvalidRecordProperty, prop);\n      }\n      {\n        if (prop.shorthand) {\n          this.addExtra(prop, \"shorthand\", true);\n        }\n      }\n      node.properties.push(prop);\n    }\n    this.next();\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let type = \"ObjectExpression\";\n    if (isPattern) {\n      type = \"ObjectPattern\";\n    } else if (isRecord) {\n      type = \"RecordExpression\";\n    }\n    return this.finishNode(node, type);\n  }\n  addTrailingCommaExtraToNode(node) {\n    this.addExtra(node, \"trailingComma\", this.state.lastTokStartLoc.index);\n    this.addExtra(node, \"trailingCommaLoc\", this.state.lastTokStartLoc, false);\n  }\n  maybeAsyncOrAccessorProp(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));\n  }\n  parsePropertyDefinition(refExpressionErrors) {\n    let decorators = [];\n    if (this.match(26)) {\n      if (this.hasPlugin(\"decorators\")) {\n        this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);\n      }\n      while (this.match(26)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n    const prop = this.startNode();\n    let isAsync = false;\n    let isAccessor = false;\n    let startLoc;\n    if (this.match(21)) {\n      if (decorators.length) this.unexpected();\n      return this.parseSpread();\n    }\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n    prop.method = false;\n    if (refExpressionErrors) {\n      startLoc = this.state.startLoc;\n    }\n    let isGenerator = this.eat(55);\n    this.parsePropertyNamePrefixOperator(prop);\n    const containsEsc = this.state.containsEsc;\n    this.parsePropertyName(prop, refExpressionErrors);\n    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {\n      const {\n        key\n      } = prop;\n      const keyName = key.name;\n      if (keyName === \"async\" && !this.hasPrecedingLineBreak()) {\n        isAsync = true;\n        this.resetPreviousNodeTrailingComments(key);\n        isGenerator = this.eat(55);\n        this.parsePropertyName(prop);\n      }\n      if (keyName === \"get\" || keyName === \"set\") {\n        isAccessor = true;\n        this.resetPreviousNodeTrailingComments(key);\n        prop.kind = keyName;\n        if (this.match(55)) {\n          isGenerator = true;\n          this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {\n            kind: keyName\n          });\n          this.next();\n        }\n        this.parsePropertyName(prop);\n      }\n    }\n    return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);\n  }\n  getGetterSetterExpectedParamCount(method) {\n    return method.kind === \"get\" ? 0 : 1;\n  }\n  getObjectOrClassMethodParams(method) {\n    return method.params;\n  }\n  checkGetterSetterParams(method) {\n    var _params;\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    if (params.length !== paramCount) {\n      this.raise(method.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity, method);\n    }\n    if (method.kind === \"set\" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === \"RestElement\") {\n      this.raise(Errors.BadSetterRestParameter, method);\n    }\n  }\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    if (isAccessor) {\n      const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, \"ObjectMethod\");\n      this.checkGetterSetterParams(finishedProp);\n      return finishedProp;\n    }\n    if (isAsync || isGenerator || this.match(10)) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(prop, isGenerator, isAsync, false, false, \"ObjectMethod\");\n    }\n  }\n  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {\n    prop.shorthand = false;\n    if (this.eat(14)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));\n      } else if (this.match(29)) {\n        const shorthandAssignLoc = this.state.startLoc;\n        if (refExpressionErrors != null) {\n          if (refExpressionErrors.shorthandAssignLoc === null) {\n            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;\n          }\n        } else {\n          this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);\n        }\n        prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));\n      } else {\n        prop.value = cloneIdentifier(prop.key);\n      }\n      prop.shorthand = true;\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);\n    if (!node) this.unexpected();\n    return node;\n  }\n  parsePropertyName(prop, refExpressionErrors) {\n    if (this.eat(0)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssignAllowIn();\n      this.expect(3);\n    } else {\n      const {\n        type,\n        value\n      } = this.state;\n      let key;\n      if (tokenIsKeywordOrIdentifier(type)) {\n        key = this.parseIdentifier(true);\n      } else {\n        switch (type) {\n          case 135:\n            key = this.parseNumericLiteral(value);\n            break;\n          case 134:\n            key = this.parseStringLiteral(value);\n            break;\n          case 136:\n            key = this.parseBigIntLiteral(value);\n            break;\n          case 139:\n            {\n              const privateKeyLoc = this.state.startLoc;\n              if (refExpressionErrors != null) {\n                if (refExpressionErrors.privateKeyLoc === null) {\n                  refExpressionErrors.privateKeyLoc = privateKeyLoc;\n                }\n              } else {\n                this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);\n              }\n              key = this.parsePrivateName();\n              break;\n            }\n          default:\n            if (type === 137) {\n              key = this.parseDecimalLiteral(value);\n              break;\n            }\n            this.unexpected();\n        }\n      }\n      prop.key = key;\n      if (type !== 139) {\n        prop.computed = false;\n      }\n    }\n  }\n  initFunction(node, isAsync) {\n    node.id = null;\n    node.generator = false;\n    node.async = isAsync;\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    this.initFunction(node, isAsync);\n    node.generator = isGenerator;\n    this.scope.enter(2 | 16 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0));\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    this.parseFunctionParams(node, isConstructor);\n    const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    return finishedNode;\n  }\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    if (isTuple) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return this.finishNode(node, isTuple ? \"TupleExpression\" : \"ArrayExpression\");\n  }\n  parseArrowExpression(node, params, isAsync, trailingCommaLoc) {\n    this.scope.enter(2 | 4);\n    let flags = functionFlags(isAsync, false);\n    if (!this.match(5) && this.prodParam.hasIn) {\n      flags |= 8;\n    }\n    this.prodParam.enter(flags);\n    this.initFunction(node, isAsync);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    if (params) {\n      this.state.maybeInArrowParameters = true;\n      this.setArrowFunctionParameters(node, params, trailingCommaLoc);\n    }\n    this.state.maybeInArrowParameters = false;\n    this.parseFunctionBody(node, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }\n  setArrowFunctionParameters(node, params, trailingCommaLoc) {\n    this.toAssignableList(params, trailingCommaLoc, false);\n    node.params = params;\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    this.parseFunctionBody(node, false, isMethod);\n    return this.finishNode(node, type);\n  }\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    const isExpression = allowExpression && !this.match(5);\n    this.expressionScope.enter(newExpressionScope());\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      this.checkParams(node, false, allowExpression, false);\n    } else {\n      const oldStrict = this.state.strict;\n      const oldLabels = this.state.labels;\n      this.state.labels = [];\n      this.prodParam.enter(this.prodParam.currentFlags() | 4);\n      node.body = this.parseBlock(true, false, hasStrictModeDirective => {\n        const nonSimple = !this.isSimpleParamList(node.params);\n        if (hasStrictModeDirective && nonSimple) {\n          this.raise(Errors.IllegalLanguageModeDirective, (node.kind === \"method\" || node.kind === \"constructor\") && !!node.key ? node.key.loc.end : node);\n        }\n        const strictModeChanged = !oldStrict && this.state.strict;\n        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);\n        if (this.state.strict && node.id) {\n          this.checkIdentifier(node.id, 65, strictModeChanged);\n        }\n      });\n      this.prodParam.exit();\n      this.state.labels = oldLabels;\n    }\n    this.expressionScope.exit();\n  }\n  isSimpleParameter(node) {\n    return node.type === \"Identifier\";\n  }\n  isSimpleParamList(params) {\n    for (let i = 0, len = params.length; i < len; i++) {\n      if (!this.isSimpleParameter(params[i])) return false;\n    }\n    return true;\n  }\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    const checkClashes = !allowDuplicates && new Set();\n    const formalParameters = {\n      type: \"FormalParameters\"\n    };\n    for (const param of node.params) {\n      this.checkLVal(param, formalParameters, 5, checkClashes, strictModeChanged);\n    }\n  }\n  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {\n    const elts = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));\n    }\n    return elts;\n  }\n  parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {\n    let elt;\n    if (this.match(12)) {\n      if (!allowEmpty) {\n        this.raise(Errors.UnexpectedToken, this.state.curPosition(), {\n          unexpected: \",\"\n        });\n      }\n      elt = null;\n    } else if (this.match(21)) {\n      const spreadNodeStartLoc = this.state.startLoc;\n      elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);\n    } else if (this.match(17)) {\n      this.expectPlugin(\"partialApplication\");\n      if (!allowPlaceholder) {\n        this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);\n      }\n      const node = this.startNode();\n      this.next();\n      elt = this.finishNode(node, \"ArgumentPlaceholder\");\n    } else {\n      elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);\n    }\n    return elt;\n  }\n  parseIdentifier(liberal) {\n    const node = this.startNode();\n    const name = this.parseIdentifierName(liberal);\n    return this.createIdentifier(node, name);\n  }\n  createIdentifier(node, name) {\n    node.name = name;\n    node.loc.identifierName = name;\n    return this.finishNode(node, \"Identifier\");\n  }\n  parseIdentifierName(liberal) {\n    let name;\n    const {\n      startLoc,\n      type\n    } = this.state;\n    if (tokenIsKeywordOrIdentifier(type)) {\n      name = this.state.value;\n    } else {\n      this.unexpected();\n    }\n    const tokenIsKeyword = tokenKeywordOrIdentifierIsKeyword(type);\n    if (liberal) {\n      if (tokenIsKeyword) {\n        this.replaceToken(132);\n      }\n    } else {\n      this.checkReservedWord(name, startLoc, tokenIsKeyword, false);\n    }\n    this.next();\n    return name;\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (word.length > 10) {\n      return;\n    }\n    if (!canBeReservedWord(word)) {\n      return;\n    }\n    if (checkKeywords && isKeyword(word)) {\n      this.raise(Errors.UnexpectedKeyword, startLoc, {\n        keyword: word\n      });\n      return;\n    }\n    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;\n    if (reservedTest(word, this.inModule)) {\n      this.raise(Errors.UnexpectedReservedWord, startLoc, {\n        reservedWord: word\n      });\n      return;\n    } else if (word === \"yield\") {\n      if (this.prodParam.hasYield) {\n        this.raise(Errors.YieldBindingIdentifier, startLoc);\n        return;\n      }\n    } else if (word === \"await\") {\n      if (this.prodParam.hasAwait) {\n        this.raise(Errors.AwaitBindingIdentifier, startLoc);\n        return;\n      }\n      if (this.scope.inStaticBlock) {\n        this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);\n        return;\n      }\n      this.expressionScope.recordAsyncArrowParametersError(startLoc);\n    } else if (word === \"arguments\") {\n      if (this.scope.inClassAndNotInNonArrowFunction) {\n        this.raise(Errors.ArgumentsInClass, startLoc);\n        return;\n      }\n    }\n  }\n  recordAwaitIfAllowed() {\n    const isAwaitAllowed = this.prodParam.hasAwait || this.optionFlags & 1 && !this.scope.inFunction;\n    if (isAwaitAllowed && !this.scope.inFunction) {\n      this.state.hasTopLevelAwait = true;\n    }\n    return isAwaitAllowed;\n  }\n  parseAwait(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node);\n    if (this.eat(55)) {\n      this.raise(Errors.ObsoleteAwaitStar, node);\n    }\n    if (!this.scope.inFunction && !(this.optionFlags & 1)) {\n      if (this.isAmbiguousPrefixOrIdentifier()) {\n        this.ambiguousScriptDifferentAst = true;\n      } else {\n        this.sawUnambiguousESM = true;\n      }\n    }\n    if (!this.state.soloAwait) {\n      node.argument = this.parseMaybeUnary(null, true);\n    }\n    return this.finishNode(node, \"AwaitExpression\");\n  }\n  isAmbiguousPrefixOrIdentifier() {\n    if (this.hasPrecedingLineBreak()) return true;\n    const {\n      type\n    } = this.state;\n    return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 138 || type === 56 || this.hasPlugin(\"v8intrinsic\") && type === 54;\n  }\n  parseYield(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node);\n    let delegating = false;\n    let argument = null;\n    if (!this.hasPrecedingLineBreak()) {\n      delegating = this.eat(55);\n      switch (this.state.type) {\n        case 13:\n        case 140:\n        case 8:\n        case 11:\n        case 3:\n        case 9:\n        case 14:\n        case 12:\n          if (!delegating) break;\n        default:\n          argument = this.parseMaybeAssign();\n      }\n    }\n    node.delegate = delegating;\n    node.argument = argument;\n    return this.finishNode(node, \"YieldExpression\");\n  }\n  parseImportCall(node) {\n    this.next();\n    node.source = this.parseMaybeAssignAllowIn();\n    node.options = null;\n    if (this.eat(12)) {\n      if (!this.match(11)) {\n        node.options = this.parseMaybeAssignAllowIn();\n        if (this.eat(12) && !this.match(11)) {\n          do {\n            this.parseMaybeAssignAllowIn();\n          } while (this.eat(12) && !this.match(11));\n          this.raise(Errors.ImportCallArity, node);\n        }\n      }\n    }\n    this.expect(11);\n    return this.finishNode(node, \"ImportExpression\");\n  }\n  checkPipelineAtInfixOperator(left, leftStartLoc) {\n    if (this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"smart\"\n    }])) {\n      if (left.type === \"SequenceExpression\") {\n        this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);\n      }\n    }\n  }\n  parseSmartPipelineBodyInStyle(childExpr, startLoc) {\n    if (this.isSimpleReference(childExpr)) {\n      const bodyNode = this.startNodeAt(startLoc);\n      bodyNode.callee = childExpr;\n      return this.finishNode(bodyNode, \"PipelineBareFunction\");\n    } else {\n      const bodyNode = this.startNodeAt(startLoc);\n      this.checkSmartPipeTopicBodyEarlyErrors(startLoc);\n      bodyNode.expression = childExpr;\n      return this.finishNode(bodyNode, \"PipelineTopicExpression\");\n    }\n  }\n  isSimpleReference(expression) {\n    switch (expression.type) {\n      case \"MemberExpression\":\n        return !expression.computed && this.isSimpleReference(expression.object);\n      case \"Identifier\":\n        return true;\n      default:\n        return false;\n    }\n  }\n  checkSmartPipeTopicBodyEarlyErrors(startLoc) {\n    if (this.match(19)) {\n      throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);\n    }\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipelineTopicUnused, startLoc);\n    }\n  }\n  withTopicBindingContext(callback) {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      maxNumOfResolvableTopics: 1,\n      maxTopicIndex: null\n    };\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n  withSmartMixTopicForbiddingContext(callback) {\n    if (this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"smart\"\n    }])) {\n      const outerContextTopicState = this.state.topicContext;\n      this.state.topicContext = {\n        maxNumOfResolvableTopics: 0,\n        maxTopicIndex: null\n      };\n      try {\n        return callback();\n      } finally {\n        this.state.topicContext = outerContextTopicState;\n      }\n    } else {\n      return callback();\n    }\n  }\n  withSoloAwaitPermittingContext(callback) {\n    const outerContextSoloAwaitState = this.state.soloAwait;\n    this.state.soloAwait = true;\n    try {\n      return callback();\n    } finally {\n      this.state.soloAwait = outerContextSoloAwaitState;\n    }\n  }\n  allowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToSet = 8 & ~flags;\n    if (prodParamToSet) {\n      this.prodParam.enter(flags | 8);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n  disallowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToClear = 8 & flags;\n    if (prodParamToClear) {\n      this.prodParam.enter(flags & ~8);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n  registerTopicReference() {\n    this.state.topicContext.maxTopicIndex = 0;\n  }\n  topicReferenceIsAllowedInCurrentContext() {\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n  }\n  topicReferenceWasUsedInCurrentContext() {\n    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;\n  }\n  parseFSharpPipelineBody(prec) {\n    const startLoc = this.state.startLoc;\n    this.state.potentialArrowAt = this.state.start;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = true;\n    const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return ret;\n  }\n  parseModuleExpression() {\n    this.expectPlugin(\"moduleBlocks\");\n    const node = this.startNode();\n    this.next();\n    if (!this.match(5)) {\n      this.unexpected(null, 5);\n    }\n    const program = this.startNodeAt(this.state.endLoc);\n    this.next();\n    const revertScopes = this.initializeScopes(true);\n    this.enterInitialScopes();\n    try {\n      node.body = this.parseProgram(program, 8, \"module\");\n    } finally {\n      revertScopes();\n    }\n    return this.finishNode(node, \"ModuleExpression\");\n  }\n  parsePropertyNamePrefixOperator(prop) {}\n}\nconst loopLabel = {\n    kind: 1\n  },\n  switchLabel = {\n    kind: 2\n  };\nconst loneSurrogate = /[\\uD800-\\uDFFF]/u;\nconst keywordRelationalOperator = /in(?:stanceof)?/y;\nfunction babel7CompatTokens(tokens, input, startIndex) {\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    const {\n      type\n    } = token;\n    if (typeof type === \"number\") {\n      {\n        if (type === 139) {\n          const {\n            loc,\n            start,\n            value,\n            end\n          } = token;\n          const hashEndPos = start + 1;\n          const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          tokens.splice(i, 1, new Token({\n            type: getExportedToken(27),\n            value: \"#\",\n            start: start,\n            end: hashEndPos,\n            startLoc: loc.start,\n            endLoc: hashEndLoc\n          }), new Token({\n            type: getExportedToken(132),\n            value: value,\n            start: hashEndPos,\n            end: end,\n            startLoc: hashEndLoc,\n            endLoc: loc.end\n          }));\n          i++;\n          continue;\n        }\n        if (tokenIsTemplate(type)) {\n          const {\n            loc,\n            start,\n            value,\n            end\n          } = token;\n          const backquoteEnd = start + 1;\n          const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          let startToken;\n          if (input.charCodeAt(start - startIndex) === 96) {\n            startToken = new Token({\n              type: getExportedToken(22),\n              value: \"`\",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc\n            });\n          } else {\n            startToken = new Token({\n              type: getExportedToken(8),\n              value: \"}\",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc\n            });\n          }\n          let templateValue, templateElementEnd, templateElementEndLoc, endToken;\n          if (type === 24) {\n            templateElementEnd = end - 1;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);\n            templateValue = value === null ? null : value.slice(1, -1);\n            endToken = new Token({\n              type: getExportedToken(22),\n              value: \"`\",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end\n            });\n          } else {\n            templateElementEnd = end - 2;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);\n            templateValue = value === null ? null : value.slice(1, -2);\n            endToken = new Token({\n              type: getExportedToken(23),\n              value: \"${\",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end\n            });\n          }\n          tokens.splice(i, 1, startToken, new Token({\n            type: getExportedToken(20),\n            value: templateValue,\n            start: backquoteEnd,\n            end: templateElementEnd,\n            startLoc: backquoteEndLoc,\n            endLoc: templateElementEndLoc\n          }), endToken);\n          i += 2;\n          continue;\n        }\n      }\n      token.type = getExportedToken(type);\n    }\n  }\n  return tokens;\n}\nclass StatementParser extends ExpressionParser {\n  parseTopLevel(file, program) {\n    file.program = this.parseProgram(program);\n    file.comments = this.comments;\n    if (this.optionFlags & 256) {\n      file.tokens = babel7CompatTokens(this.tokens, this.input, this.startIndex);\n    }\n    return this.finishNode(file, \"File\");\n  }\n  parseProgram(program, end = 140, sourceType = this.options.sourceType) {\n    program.sourceType = sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, end);\n    if (this.inModule) {\n      if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0) {\n        for (const [localName, at] of Array.from(this.scope.undefinedExports)) {\n          this.raise(Errors.ModuleExportUndefined, at, {\n            localName\n          });\n        }\n      }\n      this.addExtra(program, \"topLevelAwait\", this.state.hasTopLevelAwait);\n    }\n    let finishedProgram;\n    if (end === 140) {\n      finishedProgram = this.finishNode(program, \"Program\");\n    } else {\n      finishedProgram = this.finishNodeAt(program, \"Program\", createPositionWithColumnOffset(this.state.startLoc, -1));\n    }\n    return finishedProgram;\n  }\n  stmtToDirective(stmt) {\n    const directive = stmt;\n    directive.type = \"Directive\";\n    directive.value = directive.expression;\n    delete directive.expression;\n    const directiveLiteral = directive.value;\n    const expressionValue = directiveLiteral.value;\n    const raw = this.input.slice(this.offsetToSourcePos(directiveLiteral.start), this.offsetToSourcePos(directiveLiteral.end));\n    const val = directiveLiteral.value = raw.slice(1, -1);\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    this.addExtra(directiveLiteral, \"expressionValue\", expressionValue);\n    directiveLiteral.type = \"DirectiveLiteral\";\n    return directive;\n  }\n  parseInterpreterDirective() {\n    if (!this.match(28)) {\n      return null;\n    }\n    const node = this.startNode();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, \"InterpreterDirective\");\n  }\n  isLet() {\n    if (!this.isContextual(100)) {\n      return false;\n    }\n    return this.hasFollowingBindingAtom();\n  }\n  chStartsBindingIdentifier(ch, pos) {\n    if (isIdentifierStart(ch)) {\n      keywordRelationalOperator.lastIndex = pos;\n      if (keywordRelationalOperator.test(this.input)) {\n        const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);\n        if (!isIdentifierChar(endCh) && endCh !== 92) {\n          return false;\n        }\n      }\n      return true;\n    } else if (ch === 92) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  chStartsBindingPattern(ch) {\n    return ch === 91 || ch === 123;\n  }\n  hasFollowingBindingAtom() {\n    const next = this.nextTokenStart();\n    const nextCh = this.codePointAtPos(next);\n    return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);\n  }\n  hasInLineFollowingBindingIdentifierOrBrace() {\n    const next = this.nextTokenInLineStart();\n    const nextCh = this.codePointAtPos(next);\n    return nextCh === 123 || this.chStartsBindingIdentifier(nextCh, next);\n  }\n  startsUsingForOf() {\n    const {\n      type,\n      containsEsc\n    } = this.lookahead();\n    if (type === 102 && !containsEsc) {\n      return false;\n    } else if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {\n      this.expectPlugin(\"explicitResourceManagement\");\n      return true;\n    }\n  }\n  startsAwaitUsing() {\n    let next = this.nextTokenInLineStart();\n    if (this.isUnparsedContextual(next, \"using\")) {\n      next = this.nextTokenInLineStartSince(next + 5);\n      const nextCh = this.codePointAtPos(next);\n      if (this.chStartsBindingIdentifier(nextCh, next)) {\n        this.expectPlugin(\"explicitResourceManagement\");\n        return true;\n      }\n    }\n    return false;\n  }\n  parseModuleItem() {\n    return this.parseStatementLike(1 | 2 | 4 | 8);\n  }\n  parseStatementListItem() {\n    return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));\n  }\n  parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {\n    let flags = 0;\n    if (this.options.annexB && !this.state.strict) {\n      flags |= 4;\n      if (allowLabeledFunction) {\n        flags |= 8;\n      }\n    }\n    return this.parseStatementLike(flags);\n  }\n  parseStatement() {\n    return this.parseStatementLike(0);\n  }\n  parseStatementLike(flags) {\n    let decorators = null;\n    if (this.match(26)) {\n      decorators = this.parseDecorators(true);\n    }\n    return this.parseStatementContent(flags, decorators);\n  }\n  parseStatementContent(flags, decorators) {\n    const startType = this.state.type;\n    const node = this.startNode();\n    const allowDeclaration = !!(flags & 2);\n    const allowFunctionDeclaration = !!(flags & 4);\n    const topLevel = flags & 1;\n    switch (startType) {\n      case 60:\n        return this.parseBreakContinueStatement(node, true);\n      case 63:\n        return this.parseBreakContinueStatement(node, false);\n      case 64:\n        return this.parseDebuggerStatement(node);\n      case 90:\n        return this.parseDoWhileStatement(node);\n      case 91:\n        return this.parseForStatement(node);\n      case 68:\n        if (this.lookaheadCharCode() === 46) break;\n        if (!allowFunctionDeclaration) {\n          this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);\n        }\n        return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);\n      case 80:\n        if (!allowDeclaration) this.unexpected();\n        return this.parseClass(this.maybeTakeDecorators(decorators, node), true);\n      case 69:\n        return this.parseIfStatement(node);\n      case 70:\n        return this.parseReturnStatement(node);\n      case 71:\n        return this.parseSwitchStatement(node);\n      case 72:\n        return this.parseThrowStatement(node);\n      case 73:\n        return this.parseTryStatement(node);\n      case 96:\n        if (!this.state.containsEsc && this.startsAwaitUsing()) {\n          if (!this.recordAwaitIfAllowed()) {\n            this.raise(Errors.AwaitUsingNotInAsyncContext, node);\n          } else if (!allowDeclaration) {\n            this.raise(Errors.UnexpectedLexicalDeclaration, node);\n          }\n          this.next();\n          return this.parseVarStatement(node, \"await using\");\n        }\n        break;\n      case 107:\n        if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) {\n          break;\n        }\n        this.expectPlugin(\"explicitResourceManagement\");\n        if (!this.scope.inModule && this.scope.inTopLevel) {\n          this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);\n        } else if (!allowDeclaration) {\n          this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);\n        }\n        return this.parseVarStatement(node, \"using\");\n      case 100:\n        {\n          if (this.state.containsEsc) {\n            break;\n          }\n          const next = this.nextTokenStart();\n          const nextCh = this.codePointAtPos(next);\n          if (nextCh !== 91) {\n            if (!allowDeclaration && this.hasFollowingLineBreak()) break;\n            if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {\n              break;\n            }\n          }\n        }\n      case 75:\n        {\n          if (!allowDeclaration) {\n            this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);\n          }\n        }\n      case 74:\n        {\n          const kind = this.state.value;\n          return this.parseVarStatement(node, kind);\n        }\n      case 92:\n        return this.parseWhileStatement(node);\n      case 76:\n        return this.parseWithStatement(node);\n      case 5:\n        return this.parseBlock();\n      case 13:\n        return this.parseEmptyStatement(node);\n      case 83:\n        {\n          const nextTokenCharCode = this.lookaheadCharCode();\n          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {\n            break;\n          }\n        }\n      case 82:\n        {\n          if (!(this.optionFlags & 8) && !topLevel) {\n            this.raise(Errors.UnexpectedImportExport, this.state.startLoc);\n          }\n          this.next();\n          let result;\n          if (startType === 83) {\n            result = this.parseImport(node);\n          } else {\n            result = this.parseExport(node, decorators);\n          }\n          this.assertModuleNodeAllowed(result);\n          return result;\n        }\n      default:\n        {\n          if (this.isAsyncFunction()) {\n            if (!allowDeclaration) {\n              this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);\n            }\n            this.next();\n            return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);\n          }\n        }\n    }\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n    if (tokenIsIdentifier(startType) && expr.type === \"Identifier\" && this.eat(14)) {\n      return this.parseLabeledStatement(node, maybeName, expr, flags);\n    } else {\n      return this.parseExpressionStatement(node, expr, decorators);\n    }\n  }\n  assertModuleNodeAllowed(node) {\n    if (!(this.optionFlags & 8) && !this.inModule) {\n      this.raise(Errors.ImportOutsideModule, node);\n    }\n  }\n  decoratorsEnabledBeforeExport() {\n    if (this.hasPlugin(\"decorators-legacy\")) return true;\n    return this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") !== false;\n  }\n  maybeTakeDecorators(maybeDecorators, classNode, exportNode) {\n    if (maybeDecorators) {\n      var _classNode$decorators;\n      if ((_classNode$decorators = classNode.decorators) != null && _classNode$decorators.length) {\n        if (typeof this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") !== \"boolean\") {\n          this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);\n        }\n        classNode.decorators.unshift(...maybeDecorators);\n      } else {\n        classNode.decorators = maybeDecorators;\n      }\n      this.resetStartLocationFromNode(classNode, maybeDecorators[0]);\n      if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);\n    }\n    return classNode;\n  }\n  canHaveLeadingDecorator() {\n    return this.match(80);\n  }\n  parseDecorators(allowExport) {\n    const decorators = [];\n    do {\n      decorators.push(this.parseDecorator());\n    } while (this.match(26));\n    if (this.match(82)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n      if (!this.decoratorsEnabledBeforeExport()) {\n        this.raise(Errors.DecoratorExportClass, this.state.startLoc);\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);\n    }\n    return decorators;\n  }\n  parseDecorator() {\n    this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n    const node = this.startNode();\n    this.next();\n    if (this.hasPlugin(\"decorators\")) {\n      const startLoc = this.state.startLoc;\n      let expr;\n      if (this.match(10)) {\n        const startLoc = this.state.startLoc;\n        this.next();\n        expr = this.parseExpression();\n        this.expect(11);\n        expr = this.wrapParenthesis(startLoc, expr);\n        const paramsStartLoc = this.state.startLoc;\n        node.expression = this.parseMaybeDecoratorArguments(expr, startLoc);\n        if (this.getPluginOption(\"decorators\", \"allowCallParenthesized\") === false && node.expression !== expr) {\n          this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);\n        }\n      } else {\n        expr = this.parseIdentifier(false);\n        while (this.eat(16)) {\n          const node = this.startNodeAt(startLoc);\n          node.object = expr;\n          if (this.match(139)) {\n            this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n            node.property = this.parsePrivateName();\n          } else {\n            node.property = this.parseIdentifier(true);\n          }\n          node.computed = false;\n          expr = this.finishNode(node, \"MemberExpression\");\n        }\n        node.expression = this.parseMaybeDecoratorArguments(expr, startLoc);\n      }\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n    return this.finishNode(node, \"Decorator\");\n  }\n  parseMaybeDecoratorArguments(expr, startLoc) {\n    if (this.eat(10)) {\n      const node = this.startNodeAt(startLoc);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments(11);\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, \"CallExpression\");\n    }\n    return expr;\n  }\n  parseBreakContinueStatement(node, isBreak) {\n    this.next();\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n    this.verifyBreakContinue(node, isBreak);\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n  }\n  verifyBreakContinue(node, isBreak) {\n    let i;\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === 1)) {\n          break;\n        }\n        if (node.label && isBreak) break;\n      }\n    }\n    if (i === this.state.labels.length) {\n      const type = isBreak ? \"BreakStatement\" : \"ContinueStatement\";\n      this.raise(Errors.IllegalBreakContinue, node, {\n        type\n      });\n    }\n  }\n  parseDebuggerStatement(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  }\n  parseHeaderExpression() {\n    this.expect(10);\n    const val = this.parseExpression();\n    this.expect(11);\n    return val;\n  }\n  parseDoWhileStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.state.labels.pop();\n    this.expect(92);\n    node.test = this.parseHeaderExpression();\n    this.eat(13);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }\n  parseForStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    let awaitAt = null;\n    if (this.isContextual(96) && this.recordAwaitIfAllowed()) {\n      awaitAt = this.state.startLoc;\n      this.next();\n    }\n    this.scope.enter(0);\n    this.expect(10);\n    if (this.match(13)) {\n      if (awaitAt !== null) {\n        this.unexpected(awaitAt);\n      }\n      return this.parseFor(node, null);\n    }\n    const startsWithLet = this.isContextual(100);\n    {\n      const startsWithAwaitUsing = this.isContextual(96) && this.startsAwaitUsing();\n      const starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(107) && this.startsUsingForOf();\n      const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;\n      if (this.match(74) || this.match(75) || isLetOrUsing) {\n        const initNode = this.startNode();\n        let kind;\n        if (startsWithAwaitUsing) {\n          kind = \"await using\";\n          if (!this.recordAwaitIfAllowed()) {\n            this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);\n          }\n          this.next();\n        } else {\n          kind = this.state.value;\n        }\n        this.next();\n        this.parseVar(initNode, true, kind);\n        const init = this.finishNode(initNode, \"VariableDeclaration\");\n        const isForIn = this.match(58);\n        if (isForIn && starsWithUsingDeclaration) {\n          this.raise(Errors.ForInUsing, init);\n        }\n        if ((isForIn || this.isContextual(102)) && init.declarations.length === 1) {\n          return this.parseForIn(node, init, awaitAt);\n        }\n        if (awaitAt !== null) {\n          this.unexpected(awaitAt);\n        }\n        return this.parseFor(node, init);\n      }\n    }\n    const startsWithAsync = this.isContextual(95);\n    const refExpressionErrors = new ExpressionErrors();\n    const init = this.parseExpression(true, refExpressionErrors);\n    const isForOf = this.isContextual(102);\n    if (isForOf) {\n      if (startsWithLet) {\n        this.raise(Errors.ForOfLet, init);\n      }\n      if (awaitAt === null && startsWithAsync && init.type === \"Identifier\") {\n        this.raise(Errors.ForOfAsync, init);\n      }\n    }\n    if (isForOf || this.match(58)) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.toAssignable(init, true);\n      const type = isForOf ? \"ForOfStatement\" : \"ForInStatement\";\n      this.checkLVal(init, {\n        type\n      });\n      return this.parseForIn(node, init, awaitAt);\n    } else {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    if (awaitAt !== null) {\n      this.unexpected(awaitAt);\n    }\n    return this.parseFor(node, init);\n  }\n  parseFunctionStatement(node, isAsync, isHangingDeclaration) {\n    this.next();\n    return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));\n  }\n  parseIfStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();\n    node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;\n    return this.finishNode(node, \"IfStatement\");\n  }\n  parseReturnStatement(node) {\n    if (!this.prodParam.hasReturn && !(this.optionFlags & 2)) {\n      this.raise(Errors.IllegalReturn, this.state.startLoc);\n    }\n    this.next();\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ReturnStatement\");\n  }\n  parseSwitchStatement(node) {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases = node.cases = [];\n    this.expect(5);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(0);\n    let cur;\n    for (let sawDefault; !this.match(8);) {\n      if (this.match(61) || this.match(65)) {\n        const isCase = this.match(61);\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);\n          }\n          sawDefault = true;\n          cur.test = null;\n        }\n        this.expect(14);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatementListItem());\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n    this.scope.exit();\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next();\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  }\n  parseThrowStatement(node) {\n    this.next();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);\n    }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }\n  parseCatchClauseParam() {\n    const param = this.parseBindingAtom();\n    this.scope.enter(this.options.annexB && param.type === \"Identifier\" ? 8 : 0);\n    this.checkLVal(param, {\n      type: \"CatchClause\"\n    }, 9);\n    return param;\n  }\n  parseTryStatement(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n    if (this.match(62)) {\n      const clause = this.startNode();\n      this.next();\n      if (this.match(10)) {\n        this.expect(10);\n        clause.param = this.parseCatchClauseParam();\n        this.expect(11);\n      } else {\n        clause.param = null;\n        this.scope.enter(0);\n      }\n      clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));\n      this.scope.exit();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n    node.finalizer = this.eat(67) ? this.parseBlock() : null;\n    if (!node.handler && !node.finalizer) {\n      this.raise(Errors.NoCatchOrFinally, node);\n    }\n    return this.finishNode(node, \"TryStatement\");\n  }\n  parseVarStatement(node, kind, allowMissingInitializer = false) {\n    this.next();\n    this.parseVar(node, false, kind, allowMissingInitializer);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  }\n  parseWhileStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.state.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n  }\n  parseWithStatement(node) {\n    if (this.state.strict) {\n      this.raise(Errors.StrictWith, this.state.startLoc);\n    }\n    this.next();\n    node.object = this.parseHeaderExpression();\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    return this.finishNode(node, \"WithStatement\");\n  }\n  parseEmptyStatement(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  }\n  parseLabeledStatement(node, maybeName, expr, flags) {\n    for (const label of this.state.labels) {\n      if (label.name === maybeName) {\n        this.raise(Errors.LabelRedeclaration, expr, {\n          labelName: maybeName\n        });\n      }\n    }\n    const kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n      if (label.statementStart === node.start) {\n        label.statementStart = this.sourceToOffsetPos(this.state.start);\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.sourceToOffsetPos(this.state.start)\n    });\n    node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  }\n  parseExpressionStatement(node, expr, decorators) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }\n  parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {\n    const node = this.startNode();\n    if (allowDirectives) {\n      this.state.strictErrors.clear();\n    }\n    this.expect(5);\n    if (createNewLexicalScope) {\n      this.scope.enter(0);\n    }\n    this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n    return this.finishNode(node, \"BlockStatement\");\n  }\n  isValidDirective(stmt) {\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"StringLiteral\" && !stmt.expression.extra.parenthesized;\n  }\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    const body = node.body = [];\n    const directives = node.directives = [];\n    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);\n  }\n  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {\n    const oldStrict = this.state.strict;\n    let hasStrictModeDirective = false;\n    let parsedNonDirective = false;\n    while (!this.match(end)) {\n      const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();\n      if (directives && !parsedNonDirective) {\n        if (this.isValidDirective(stmt)) {\n          const directive = this.stmtToDirective(stmt);\n          directives.push(directive);\n          if (!hasStrictModeDirective && directive.value.value === \"use strict\") {\n            hasStrictModeDirective = true;\n            this.setStrict(true);\n          }\n          continue;\n        }\n        parsedNonDirective = true;\n        this.state.strictErrors.clear();\n      }\n      body.push(stmt);\n    }\n    afterBlockParse == null || afterBlockParse.call(this, hasStrictModeDirective);\n    if (!oldStrict) {\n      this.setStrict(false);\n    }\n    this.next();\n  }\n  parseFor(node, init) {\n    node.init = init;\n    this.semicolon(false);\n    node.test = this.match(13) ? null : this.parseExpression();\n    this.semicolon(false);\n    node.update = this.match(11) ? null : this.parseExpression();\n    this.expect(11);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n  }\n  parseForIn(node, init, awaitAt) {\n    const isForIn = this.match(58);\n    this.next();\n    if (isForIn) {\n      if (awaitAt !== null) this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt !== null;\n    }\n    if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) {\n      this.raise(Errors.ForInOfLoopInitializer, init, {\n        type: isForIn ? \"ForInStatement\" : \"ForOfStatement\"\n      });\n    }\n    if (init.type === \"AssignmentPattern\") {\n      this.raise(Errors.InvalidLhs, init, {\n        ancestor: {\n          type: \"ForStatement\"\n        }\n      });\n    }\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();\n    this.expect(11);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n  }\n  parseVar(node, isFor, kind, allowMissingInitializer = false) {\n    const declarations = node.declarations = [];\n    node.kind = kind;\n    for (;;) {\n      const decl = this.startNode();\n      this.parseVarId(decl, kind);\n      decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();\n      if (decl.init === null && !allowMissingInitializer) {\n        if (decl.id.type !== \"Identifier\" && !(isFor && (this.match(58) || this.isContextual(102)))) {\n          this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {\n            kind: \"destructuring\"\n          });\n        } else if ((kind === \"const\" || kind === \"using\" || kind === \"await using\") && !(this.match(58) || this.isContextual(102))) {\n          this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {\n            kind\n          });\n        }\n      }\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(12)) break;\n    }\n    return node;\n  }\n  parseVarId(decl, kind) {\n    const id = this.parseBindingAtom();\n    if (kind === \"using\" || kind === \"await using\") {\n      if (id.type === \"ArrayPattern\" || id.type === \"ObjectPattern\") {\n        this.raise(Errors.UsingDeclarationHasBindingPattern, id.loc.start);\n      }\n    }\n    this.checkLVal(id, {\n      type: \"VariableDeclarator\"\n    }, kind === \"var\" ? 5 : 8201);\n    decl.id = id;\n  }\n  parseAsyncFunctionExpression(node) {\n    return this.parseFunction(node, 8);\n  }\n  parseFunction(node, flags = 0) {\n    const hangingDeclaration = flags & 2;\n    const isDeclaration = !!(flags & 1);\n    const requireId = isDeclaration && !(flags & 4);\n    const isAsync = !!(flags & 8);\n    this.initFunction(node, isAsync);\n    if (this.match(55)) {\n      if (hangingDeclaration) {\n        this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);\n      }\n      this.next();\n      node.generator = true;\n    }\n    if (isDeclaration) {\n      node.id = this.parseFunctionId(requireId);\n    }\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = false;\n    this.scope.enter(2);\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    if (!isDeclaration) {\n      node.id = this.parseFunctionId();\n    }\n    this.parseFunctionParams(node, false);\n    this.withSmartMixTopicForbiddingContext(() => {\n      this.parseFunctionBodyAndFinish(node, isDeclaration ? \"FunctionDeclaration\" : \"FunctionExpression\");\n    });\n    this.prodParam.exit();\n    this.scope.exit();\n    if (isDeclaration && !hangingDeclaration) {\n      this.registerFunctionStatementId(node);\n    }\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node;\n  }\n  parseFunctionId(requireId) {\n    return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;\n  }\n  parseFunctionParams(node, isConstructor) {\n    this.expect(10);\n    this.expressionScope.enter(newParameterDeclarationScope());\n    node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));\n    this.expressionScope.exit();\n  }\n  registerFunctionStatementId(node) {\n    if (!node.id) return;\n    this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);\n  }\n  parseClass(node, isStatement, optionalId) {\n    this.next();\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n  }\n  isClassProperty() {\n    return this.match(29) || this.match(13) || this.match(8);\n  }\n  isClassMethod() {\n    return this.match(10);\n  }\n  nameIsConstructor(key) {\n    return key.type === \"Identifier\" && key.name === \"constructor\" || key.type === \"StringLiteral\" && key.value === \"constructor\";\n  }\n  isNonstaticConstructor(method) {\n    return !method.computed && !method.static && this.nameIsConstructor(method.key);\n  }\n  parseClassBody(hadSuperClass, oldStrict) {\n    this.classScope.enter();\n    const state = {\n      hadConstructor: false,\n      hadSuperClass\n    };\n    let decorators = [];\n    const classBody = this.startNode();\n    classBody.body = [];\n    this.expect(5);\n    this.withSmartMixTopicForbiddingContext(() => {\n      while (!this.match(8)) {\n        if (this.eat(13)) {\n          if (decorators.length > 0) {\n            throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);\n          }\n          continue;\n        }\n        if (this.match(26)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n        const member = this.startNode();\n        if (decorators.length) {\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n        this.parseClassMember(classBody, member, state);\n        if (member.kind === \"constructor\" && member.decorators && member.decorators.length > 0) {\n          this.raise(Errors.DecoratorConstructor, member);\n        }\n      }\n    });\n    this.state.strict = oldStrict;\n    this.next();\n    if (decorators.length) {\n      throw this.raise(Errors.TrailingDecorator, this.state.startLoc);\n    }\n    this.classScope.exit();\n    return this.finishNode(classBody, \"ClassBody\");\n  }\n  parseClassMemberFromModifier(classBody, member) {\n    const key = this.parseIdentifier(true);\n    if (this.isClassMethod()) {\n      const method = member;\n      method.kind = \"method\";\n      method.computed = false;\n      method.key = key;\n      method.static = false;\n      this.pushClassMethod(classBody, method, false, false, false, false);\n      return true;\n    } else if (this.isClassProperty()) {\n      const prop = member;\n      prop.computed = false;\n      prop.key = key;\n      prop.static = false;\n      classBody.body.push(this.parseClassProperty(prop));\n      return true;\n    }\n    this.resetPreviousNodeTrailingComments(key);\n    return false;\n  }\n  parseClassMember(classBody, member, state) {\n    const isStatic = this.isContextual(106);\n    if (isStatic) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n      if (this.eat(5)) {\n        this.parseClassStaticBlock(classBody, member);\n        return;\n      }\n    }\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const publicMethod = member;\n    const privateMethod = member;\n    const publicProp = member;\n    const privateProp = member;\n    const accessorProp = member;\n    const method = publicMethod;\n    const publicMember = publicMethod;\n    member.static = isStatic;\n    this.parsePropertyNamePrefixOperator(member);\n    if (this.eat(55)) {\n      method.kind = \"method\";\n      const isPrivateName = this.match(139);\n      this.parseClassElementName(method);\n      if (isPrivateName) {\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(Errors.ConstructorIsGenerator, publicMethod.key);\n      }\n      this.pushClassMethod(classBody, publicMethod, true, false, false, false);\n      return;\n    }\n    const isContextual = !this.state.containsEsc && tokenIsIdentifier(this.state.type);\n    const key = this.parseClassElementName(member);\n    const maybeContextualKw = isContextual ? key.name : null;\n    const isPrivate = this.isPrivateName(key);\n    const maybeQuestionTokenStartLoc = this.state.startLoc;\n    this.parsePostMemberNameModifiers(publicMember);\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(Errors.DuplicateConstructor, key);\n        }\n        if (isConstructor && this.hasPlugin(\"typescript\") && member.override) {\n          this.raise(Errors.OverrideOnConstructor, key);\n        }\n        state.hadConstructor = true;\n        allowsDirectSuper = state.hadSuperClass;\n      }\n      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (maybeContextualKw === \"async\" && !this.isLineTerminator()) {\n      this.resetPreviousNodeTrailingComments(key);\n      const isGenerator = this.eat(55);\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStartLoc);\n      }\n      method.kind = \"method\";\n      const isPrivate = this.match(139);\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAsync, publicMethod.key);\n        }\n        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);\n      }\n    } else if ((maybeContextualKw === \"get\" || maybeContextualKw === \"set\") && !(this.match(55) && this.isLineTerminator())) {\n      this.resetPreviousNodeTrailingComments(key);\n      method.kind = maybeContextualKw;\n      const isPrivate = this.match(139);\n      this.parseClassElementName(publicMethod);\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAccessor, publicMethod.key);\n        }\n        this.pushClassMethod(classBody, publicMethod, false, false, false, false);\n      }\n      this.checkGetterSetterParams(publicMethod);\n    } else if (maybeContextualKw === \"accessor\" && !this.isLineTerminator()) {\n      this.expectPlugin(\"decoratorAutoAccessors\");\n      this.resetPreviousNodeTrailingComments(key);\n      const isPrivate = this.match(139);\n      this.parseClassElementName(publicProp);\n      this.pushClassAccessorProperty(classBody, accessorProp, isPrivate);\n    } else if (this.isLineTerminator()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n  parseClassElementName(member) {\n    const {\n      type,\n      value\n    } = this.state;\n    if ((type === 132 || type === 134) && member.static && value === \"prototype\") {\n      this.raise(Errors.StaticPrototype, this.state.startLoc);\n    }\n    if (type === 139) {\n      if (value === \"constructor\") {\n        this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);\n      }\n      const key = this.parsePrivateName();\n      member.key = key;\n      return key;\n    }\n    this.parsePropertyName(member);\n    return member.key;\n  }\n  parseClassStaticBlock(classBody, member) {\n    var _member$decorators;\n    this.scope.enter(64 | 128 | 16);\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    this.prodParam.enter(0);\n    const body = member.body = [];\n    this.parseBlockOrModuleBlockBody(body, undefined, false, 8);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.labels = oldLabels;\n    classBody.body.push(this.finishNode(member, \"StaticBlock\"));\n    if ((_member$decorators = member.decorators) != null && _member$decorators.length) {\n      this.raise(Errors.DecoratorStaticBlock, member);\n    }\n  }\n  pushClassProperty(classBody, prop) {\n    if (!prop.computed && this.nameIsConstructor(prop.key)) {\n      this.raise(Errors.ConstructorClassField, prop.key);\n    }\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n  pushClassPrivateProperty(classBody, prop) {\n    const node = this.parseClassPrivateProperty(prop);\n    classBody.body.push(node);\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);\n  }\n  pushClassAccessorProperty(classBody, prop, isPrivate) {\n    if (!isPrivate && !prop.computed && this.nameIsConstructor(prop.key)) {\n      this.raise(Errors.ConstructorClassField, prop.key);\n    }\n    const node = this.parseClassAccessorProperty(prop);\n    classBody.body.push(node);\n    if (isPrivate) {\n      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);\n    }\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true));\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const node = this.parseMethod(method, isGenerator, isAsync, false, false, \"ClassPrivateMethod\", true);\n    classBody.body.push(node);\n    const kind = node.kind === \"get\" ? node.static ? 6 : 2 : node.kind === \"set\" ? node.static ? 5 : 1 : 0;\n    this.declareClassPrivateMethodInScope(node, kind);\n  }\n  declareClassPrivateMethodInScope(node, kind) {\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);\n  }\n  parsePostMemberNameModifiers(methodOrProp) {}\n  parseClassPrivateProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  }\n  parseClassProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassProperty\");\n  }\n  parseClassAccessorProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassAccessorProperty\");\n  }\n  parseInitializer(node) {\n    this.scope.enter(64 | 16);\n    this.expressionScope.enter(newExpressionScope());\n    this.prodParam.enter(0);\n    node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;\n    this.expressionScope.exit();\n    this.prodParam.exit();\n    this.scope.exit();\n  }\n  parseClassId(node, isStatement, optionalId, bindingType = 8331) {\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      if (isStatement) {\n        this.declareNameFromIdentifier(node.id, bindingType);\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        throw this.raise(Errors.MissingClassName, this.state.startLoc);\n      }\n    }\n  }\n  parseClassSuper(node) {\n    node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;\n  }\n  parseExport(node, decorators) {\n    const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);\n    const hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);\n    const parseAfterDefault = !hasDefault || this.eat(12);\n    const hasStar = parseAfterDefault && this.eatExportStar(node);\n    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);\n    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));\n    const isFromRequired = hasDefault || hasStar;\n    if (hasStar && !hasNamespace) {\n      if (hasDefault) this.unexpected();\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.parseExportFrom(node, true);\n      this.sawUnambiguousESM = true;\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);\n    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {\n      this.unexpected(null, 5);\n    }\n    if (hasNamespace && parseAfterNamespace) {\n      this.unexpected(null, 98);\n    }\n    let hasDeclaration;\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.parseExportFrom(node, isFromRequired);\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(node);\n    }\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      var _node2$declaration;\n      const node2 = node;\n      this.checkExport(node2, true, false, !!node2.source);\n      if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, node2.declaration, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.sawUnambiguousESM = true;\n      return this.finishNode(node2, \"ExportNamedDeclaration\");\n    }\n    if (this.eat(65)) {\n      const node2 = node;\n      const decl = this.parseExportDefaultExpression();\n      node2.declaration = decl;\n      if (decl.type === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, decl, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.checkExport(node2, true, true);\n      this.sawUnambiguousESM = true;\n      return this.finishNode(node2, \"ExportDefaultDeclaration\");\n    }\n    this.unexpected(null, 5);\n  }\n  eatExportStar(node) {\n    return this.eat(55);\n  }\n  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {\n    if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {\n      this.expectPlugin(\"exportDefaultFrom\", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);\n      const id = maybeDefaultIdentifier || this.parseIdentifier(true);\n      const specifier = this.startNodeAtNode(id);\n      specifier.exported = id;\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamespaceSpecifier(node) {\n    if (this.isContextual(93)) {\n      var _ref, _ref$specifiers;\n      (_ref$specifiers = (_ref = node).specifiers) != null ? _ref$specifiers : _ref.specifiers = [];\n      const specifier = this.startNodeAt(this.state.lastTokStartLoc);\n      this.next();\n      specifier.exported = this.parseModuleExportName();\n      node.specifiers.push(this.finishNode(specifier, \"ExportNamespaceSpecifier\"));\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamedSpecifiers(node) {\n    if (this.match(5)) {\n      const node2 = node;\n      if (!node2.specifiers) node2.specifiers = [];\n      const isTypeExport = node2.exportKind === \"type\";\n      node2.specifiers.push(...this.parseExportSpecifiers(isTypeExport));\n      node2.source = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node2.assertions = [];\n      } else {\n        node2.attributes = [];\n      }\n      node2.declaration = null;\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportDeclaration(node) {\n    if (this.shouldParseExportDeclaration()) {\n      node.specifiers = [];\n      node.source = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      } else {\n        node.attributes = [];\n      }\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n    return false;\n  }\n  isAsyncFunction() {\n    if (!this.isContextual(95)) return false;\n    const next = this.nextTokenInLineStart();\n    return this.isUnparsedContextual(next, \"function\");\n  }\n  parseExportDefaultExpression() {\n    const expr = this.startNode();\n    if (this.match(68)) {\n      this.next();\n      return this.parseFunction(expr, 1 | 4);\n    } else if (this.isAsyncFunction()) {\n      this.next();\n      this.next();\n      return this.parseFunction(expr, 1 | 4 | 8);\n    }\n    if (this.match(80)) {\n      return this.parseClass(expr, true, true);\n    }\n    if (this.match(26)) {\n      if (this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") === true) {\n        this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);\n      }\n      return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);\n    }\n    if (this.match(75) || this.match(74) || this.isLet()) {\n      throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);\n    }\n    const res = this.parseMaybeAssignAllowIn();\n    this.semicolon();\n    return res;\n  }\n  parseExportDeclaration(node) {\n    if (this.match(80)) {\n      const node = this.parseClass(this.startNode(), true, false);\n      return node;\n    }\n    return this.parseStatementListItem();\n  }\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsIdentifier(type)) {\n      if (type === 95 && !this.state.containsEsc || type === 100) {\n        return false;\n      }\n      if ((type === 130 || type === 129) && !this.state.containsEsc) {\n        const {\n          type: nextType\n        } = this.lookahead();\n        if (tokenIsIdentifier(nextType) && nextType !== 98 || nextType === 5) {\n          this.expectOnePlugin([\"flow\", \"typescript\"]);\n          return false;\n        }\n      }\n    } else if (!this.match(65)) {\n      return false;\n    }\n    const next = this.nextTokenStart();\n    const hasFrom = this.isUnparsedContextual(next, \"from\");\n    if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {\n      return true;\n    }\n    if (this.match(65) && hasFrom) {\n      const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));\n      return nextAfterFrom === 34 || nextAfterFrom === 39;\n    }\n    return false;\n  }\n  parseExportFrom(node, expect) {\n    if (this.eatContextual(98)) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n      this.maybeParseImportAttributes(node);\n      this.checkJSONModuleImport(node);\n    } else if (expect) {\n      this.unexpected();\n    }\n    this.semicolon();\n  }\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n    if (type === 26) {\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n      if (this.hasPlugin(\"decorators\")) {\n        if (this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") === true) {\n          this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);\n        }\n        return true;\n      }\n    }\n    if (this.isContextual(107)) {\n      this.raise(Errors.UsingDeclarationExport, this.state.startLoc);\n      return true;\n    }\n    if (this.isContextual(96) && this.startsAwaitUsing()) {\n      this.raise(Errors.UsingDeclarationExport, this.state.startLoc);\n      return true;\n    }\n    return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();\n  }\n  checkExport(node, checkNames, isDefault, isFrom) {\n    if (checkNames) {\n      var _node$specifiers;\n      if (isDefault) {\n        this.checkDuplicateExports(node, \"default\");\n        if (this.hasPlugin(\"exportDefaultFrom\")) {\n          var _declaration$extra;\n          const declaration = node.declaration;\n          if (declaration.type === \"Identifier\" && declaration.name === \"from\" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {\n            this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);\n          }\n        }\n      } else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length) {\n        for (const specifier of node.specifiers) {\n          const {\n            exported\n          } = specifier;\n          const exportName = exported.type === \"Identifier\" ? exported.name : exported.value;\n          this.checkDuplicateExports(specifier, exportName);\n          if (!isFrom && specifier.local) {\n            const {\n              local\n            } = specifier;\n            if (local.type !== \"Identifier\") {\n              this.raise(Errors.ExportBindingIsString, specifier, {\n                localName: local.value,\n                exportName\n              });\n            } else {\n              this.checkReservedWord(local.name, local.loc.start, true, false);\n              this.scope.checkLocalExport(local);\n            }\n          }\n        }\n      } else if (node.declaration) {\n        const decl = node.declaration;\n        if (decl.type === \"FunctionDeclaration\" || decl.type === \"ClassDeclaration\") {\n          const {\n            id\n          } = decl;\n          if (!id) throw new Error(\"Assertion failure\");\n          this.checkDuplicateExports(node, id.name);\n        } else if (decl.type === \"VariableDeclaration\") {\n          for (const declaration of decl.declarations) {\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n  }\n  checkDeclaration(node) {\n    if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === \"ObjectPattern\") {\n      for (const prop of node.properties) {\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (const elem of node.elements) {\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"AssignmentPattern\") {\n      this.checkDeclaration(node.left);\n    }\n  }\n  checkDuplicateExports(node, exportName) {\n    if (this.exportedIdentifiers.has(exportName)) {\n      if (exportName === \"default\") {\n        this.raise(Errors.DuplicateDefaultExport, node);\n      } else {\n        this.raise(Errors.DuplicateExport, node, {\n          exportName\n        });\n      }\n    }\n    this.exportedIdentifiers.add(exportName);\n  }\n  parseExportSpecifiers(isInTypeExport) {\n    const nodes = [];\n    let first = true;\n    this.expect(5);\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.eat(8)) break;\n      }\n      const isMaybeTypeOnly = this.isContextual(130);\n      const isString = this.match(134);\n      const node = this.startNode();\n      node.local = this.parseModuleExportName();\n      nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));\n    }\n    return nodes;\n  }\n  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {\n    if (this.eatContextual(93)) {\n      node.exported = this.parseModuleExportName();\n    } else if (isString) {\n      node.exported = cloneStringLiteral(node.local);\n    } else if (!node.exported) {\n      node.exported = cloneIdentifier(node.local);\n    }\n    return this.finishNode(node, \"ExportSpecifier\");\n  }\n  parseModuleExportName() {\n    if (this.match(134)) {\n      const result = this.parseStringLiteral(this.state.value);\n      const surrogate = loneSurrogate.exec(result.value);\n      if (surrogate) {\n        this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {\n          surrogateCharCode: surrogate[0].charCodeAt(0)\n        });\n      }\n      return result;\n    }\n    return this.parseIdentifier(true);\n  }\n  isJSONModuleImport(node) {\n    if (node.assertions != null) {\n      return node.assertions.some(({\n        key,\n        value\n      }) => {\n        return value.value === \"json\" && (key.type === \"Identifier\" ? key.name === \"type\" : key.value === \"type\");\n      });\n    }\n    return false;\n  }\n  checkImportReflection(node) {\n    const {\n      specifiers\n    } = node;\n    const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;\n    if (node.phase === \"source\") {\n      if (singleBindingType !== \"ImportDefaultSpecifier\") {\n        this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);\n      }\n    } else if (node.phase === \"defer\") {\n      if (singleBindingType !== \"ImportNamespaceSpecifier\") {\n        this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);\n      }\n    } else if (node.module) {\n      var _node$assertions;\n      if (singleBindingType !== \"ImportDefaultSpecifier\") {\n        this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);\n      }\n      if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {\n        this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);\n      }\n    }\n  }\n  checkJSONModuleImport(node) {\n    if (this.isJSONModuleImport(node) && node.type !== \"ExportAllDeclaration\") {\n      const {\n        specifiers\n      } = node;\n      if (specifiers != null) {\n        const nonDefaultNamedSpecifier = specifiers.find(specifier => {\n          let imported;\n          if (specifier.type === \"ExportSpecifier\") {\n            imported = specifier.local;\n          } else if (specifier.type === \"ImportSpecifier\") {\n            imported = specifier.imported;\n          }\n          if (imported !== undefined) {\n            return imported.type === \"Identifier\" ? imported.name !== \"default\" : imported.value !== \"default\";\n          }\n        });\n        if (nonDefaultNamedSpecifier !== undefined) {\n          this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);\n        }\n      }\n    }\n  }\n  isPotentialImportPhase(isExport) {\n    if (isExport) return false;\n    return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);\n  }\n  applyImportPhase(node, isExport, phase, loc) {\n    if (isExport) {\n      return;\n    }\n    if (phase === \"module\") {\n      this.expectPlugin(\"importReflection\", loc);\n      node.module = true;\n    } else if (this.hasPlugin(\"importReflection\")) {\n      node.module = false;\n    }\n    if (phase === \"source\") {\n      this.expectPlugin(\"sourcePhaseImports\", loc);\n      node.phase = \"source\";\n    } else if (phase === \"defer\") {\n      this.expectPlugin(\"deferredImportEvaluation\", loc);\n      node.phase = \"defer\";\n    } else if (this.hasPlugin(\"sourcePhaseImports\")) {\n      node.phase = null;\n    }\n  }\n  parseMaybeImportPhase(node, isExport) {\n    if (!this.isPotentialImportPhase(isExport)) {\n      this.applyImportPhase(node, isExport, null);\n      return null;\n    }\n    const phaseIdentifier = this.parseIdentifier(true);\n    const {\n      type\n    } = this.state;\n    const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;\n    if (isImportPhase) {\n      this.resetPreviousIdentifierLeadingComments(phaseIdentifier);\n      this.applyImportPhase(node, isExport, phaseIdentifier.name, phaseIdentifier.loc.start);\n      return null;\n    } else {\n      this.applyImportPhase(node, isExport, null);\n      return phaseIdentifier;\n    }\n  }\n  isPrecedingIdImportPhase(phase) {\n    const {\n      type\n    } = this.state;\n    return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;\n  }\n  parseImport(node) {\n    if (this.match(134)) {\n      return this.parseImportSourceAndAttributes(node);\n    }\n    return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));\n  }\n  parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {\n    node.specifiers = [];\n    const hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);\n    const parseNext = !hasDefault || this.eat(12);\n    const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n    if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\n    this.expectContextual(98);\n    return this.parseImportSourceAndAttributes(node);\n  }\n  parseImportSourceAndAttributes(node) {\n    var _node$specifiers2;\n    (_node$specifiers2 = node.specifiers) != null ? _node$specifiers2 : node.specifiers = [];\n    node.source = this.parseImportSource();\n    this.maybeParseImportAttributes(node);\n    this.checkImportReflection(node);\n    this.checkJSONModuleImport(node);\n    this.semicolon();\n    this.sawUnambiguousESM = true;\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n  parseImportSource() {\n    if (!this.match(134)) this.unexpected();\n    return this.parseExprAtom();\n  }\n  parseImportSpecifierLocal(node, specifier, type) {\n    specifier.local = this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n  finishImportSpecifier(specifier, type, bindingType = 8201) {\n    this.checkLVal(specifier.local, {\n      type\n    }, bindingType);\n    return this.finishNode(specifier, type);\n  }\n  parseImportAttributes() {\n    this.expect(5);\n    const attrs = [];\n    const attrNames = new Set();\n    do {\n      if (this.match(8)) {\n        break;\n      }\n      const node = this.startNode();\n      const keyName = this.state.value;\n      if (attrNames.has(keyName)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {\n          key: keyName\n        });\n      }\n      attrNames.add(keyName);\n      if (this.match(134)) {\n        node.key = this.parseStringLiteral(keyName);\n      } else {\n        node.key = this.parseIdentifier(true);\n      }\n      this.expect(14);\n      if (!this.match(134)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, \"ImportAttribute\"));\n    } while (this.eat(12));\n    this.expect(8);\n    return attrs;\n  }\n  parseModuleAttributes() {\n    const attrs = [];\n    const attributes = new Set();\n    do {\n      const node = this.startNode();\n      node.key = this.parseIdentifier(true);\n      if (node.key.name !== \"type\") {\n        this.raise(Errors.ModuleAttributeDifferentFromType, node.key);\n      }\n      if (attributes.has(node.key.name)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, {\n          key: node.key.name\n        });\n      }\n      attributes.add(node.key.name);\n      this.expect(14);\n      if (!this.match(134)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, \"ImportAttribute\"));\n    } while (this.eat(12));\n    return attrs;\n  }\n  maybeParseImportAttributes(node) {\n    let attributes;\n    {\n      var useWith = false;\n    }\n    if (this.match(76)) {\n      if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {\n        return;\n      }\n      this.next();\n      if (this.hasPlugin(\"moduleAttributes\")) {\n        attributes = this.parseModuleAttributes();\n        this.addExtra(node, \"deprecatedWithLegacySyntax\", true);\n      } else {\n        attributes = this.parseImportAttributes();\n      }\n      {\n        useWith = true;\n      }\n    } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {\n      if (!this.hasPlugin(\"deprecatedImportAssert\") && !this.hasPlugin(\"importAssertions\")) {\n        this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);\n      }\n      if (!this.hasPlugin(\"importAssertions\")) {\n        this.addExtra(node, \"deprecatedAssertSyntax\", true);\n      }\n      this.next();\n      attributes = this.parseImportAttributes();\n    } else {\n      attributes = [];\n    }\n    if (!useWith && this.hasPlugin(\"importAssertions\")) {\n      node.assertions = attributes;\n    } else {\n      node.attributes = attributes;\n    }\n  }\n  maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {\n    if (maybeDefaultIdentifier) {\n      const specifier = this.startNodeAtNode(maybeDefaultIdentifier);\n      specifier.local = maybeDefaultIdentifier;\n      node.specifiers.push(this.finishImportSpecifier(specifier, \"ImportDefaultSpecifier\"));\n      return true;\n    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n      this.parseImportSpecifierLocal(node, this.startNode(), \"ImportDefaultSpecifier\");\n      return true;\n    }\n    return false;\n  }\n  maybeParseStarImportSpecifier(node) {\n    if (this.match(55)) {\n      const specifier = this.startNode();\n      this.next();\n      this.expectContextual(93);\n      this.parseImportSpecifierLocal(node, specifier, \"ImportNamespaceSpecifier\");\n      return true;\n    }\n    return false;\n  }\n  parseNamedImportSpecifiers(node) {\n    let first = true;\n    this.expect(5);\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        if (this.eat(14)) {\n          throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);\n        }\n        this.expect(12);\n        if (this.eat(8)) break;\n      }\n      const specifier = this.startNode();\n      const importedIsString = this.match(134);\n      const isMaybeTypeOnly = this.isContextual(130);\n      specifier.imported = this.parseModuleExportName();\n      const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === \"type\" || node.importKind === \"typeof\", isMaybeTypeOnly, undefined);\n      node.specifiers.push(importSpecifier);\n    }\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    if (this.eatContextual(93)) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      const {\n        imported\n      } = specifier;\n      if (importedIsString) {\n        throw this.raise(Errors.ImportBindingIsString, specifier, {\n          importName: imported.value\n        });\n      }\n      this.checkReservedWord(imported.name, specifier.loc.start, true, true);\n      if (!specifier.local) {\n        specifier.local = cloneIdentifier(imported);\n      }\n    }\n    return this.finishImportSpecifier(specifier, \"ImportSpecifier\", bindingType);\n  }\n  isThisParam(param) {\n    return param.type === \"Identifier\" && param.name === \"this\";\n  }\n}\nclass Parser extends StatementParser {\n  constructor(options, input, pluginsMap) {\n    options = getOptions(options);\n    super(options, input);\n    this.options = options;\n    this.initializeScopes();\n    this.plugins = pluginsMap;\n    this.filename = options.sourceFilename;\n    this.startIndex = options.startIndex;\n    let optionFlags = 0;\n    if (options.allowAwaitOutsideFunction) {\n      optionFlags |= 1;\n    }\n    if (options.allowReturnOutsideFunction) {\n      optionFlags |= 2;\n    }\n    if (options.allowImportExportEverywhere) {\n      optionFlags |= 8;\n    }\n    if (options.allowSuperOutsideMethod) {\n      optionFlags |= 16;\n    }\n    if (options.allowUndeclaredExports) {\n      optionFlags |= 64;\n    }\n    if (options.allowNewTargetOutsideFunction) {\n      optionFlags |= 4;\n    }\n    if (options.allowYieldOutsideFunction) {\n      optionFlags |= 32;\n    }\n    if (options.ranges) {\n      optionFlags |= 128;\n    }\n    if (options.tokens) {\n      optionFlags |= 256;\n    }\n    if (options.createImportExpressions) {\n      optionFlags |= 512;\n    }\n    if (options.createParenthesizedExpressions) {\n      optionFlags |= 1024;\n    }\n    if (options.errorRecovery) {\n      optionFlags |= 2048;\n    }\n    if (options.attachComment) {\n      optionFlags |= 4096;\n    }\n    if (options.annexB) {\n      optionFlags |= 8192;\n    }\n    this.optionFlags = optionFlags;\n  }\n  getScopeHandler() {\n    return ScopeHandler;\n  }\n  parse() {\n    this.enterInitialScopes();\n    const file = this.startNode();\n    const program = this.startNode();\n    this.nextToken();\n    file.errors = null;\n    this.parseTopLevel(file, program);\n    file.errors = this.state.errors;\n    file.comments.length = this.state.commentsLen;\n    return file;\n  }\n}\nfunction parse(input, options) {\n  var _options;\n  if (((_options = options) == null ? void 0 : _options.sourceType) === \"unambiguous\") {\n    options = Object.assign({}, options);\n    try {\n      options.sourceType = \"module\";\n      const parser = getParser(options, input);\n      const ast = parser.parse();\n      if (parser.sawUnambiguousESM) {\n        return ast;\n      }\n      if (parser.ambiguousScriptDifferentAst) {\n        try {\n          options.sourceType = \"script\";\n          return getParser(options, input).parse();\n        } catch (_unused) {}\n      } else {\n        ast.program.sourceType = \"script\";\n      }\n      return ast;\n    } catch (moduleError) {\n      try {\n        options.sourceType = \"script\";\n        return getParser(options, input).parse();\n      } catch (_unused2) {}\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse();\n  }\n}\nfunction parseExpression(input, options) {\n  const parser = getParser(options, input);\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n  return parser.getExpression();\n}\nfunction generateExportedTokenTypes(internalTokenTypes) {\n  const tokenTypes = {};\n  for (const typeName of Object.keys(internalTokenTypes)) {\n    tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);\n  }\n  return tokenTypes;\n}\nconst tokTypes = generateExportedTokenTypes(tt);\nfunction getParser(options, input) {\n  let cls = Parser;\n  const pluginsMap = new Map();\n  if (options != null && options.plugins) {\n    for (const plugin of options.plugins) {\n      let name, opts;\n      if (typeof plugin === \"string\") {\n        name = plugin;\n      } else {\n        [name, opts] = plugin;\n      }\n      if (!pluginsMap.has(name)) {\n        pluginsMap.set(name, opts || {});\n      }\n    }\n    validatePlugins(pluginsMap);\n    cls = getParserClass(pluginsMap);\n  }\n  return new cls(options, input, pluginsMap);\n}\nconst parserClassCache = new Map();\nfunction getParserClass(pluginsMap) {\n  const pluginList = [];\n  for (const name of mixinPluginNames) {\n    if (pluginsMap.has(name)) {\n      pluginList.push(name);\n    }\n  }\n  const key = pluginList.join(\"|\");\n  let cls = parserClassCache.get(key);\n  if (!cls) {\n    cls = Parser;\n    for (const plugin of pluginList) {\n      cls = mixinPlugins[plugin](cls);\n    }\n    parserClassCache.set(key, cls);\n  }\n  return cls;\n}\nexports.parse = parse;\nexports.parseExpression = parseExpression;\nexports.tokTypes = tokTypes;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGJhYmVsK3BhcnNlckA3LjI3LjAvbm9kZV9tb2R1bGVzL0BiYWJlbC9wYXJzZXIvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwwR0FBMEcsWUFBWTtBQUN0SDtBQUNBO0FBQ0E7QUFDQSxHQUFHLFVBQVUsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRywrQkFBK0IsTUFBTTtBQUN4QztBQUNBLDBLQUEwSztBQUMxSztBQUNBLGlHQUFpRyxLQUFLO0FBQ3RHLHlLQUF5SztBQUN6SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFVBQVUsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZ0JBQWdCLE1BQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMEdBQTBHLEdBQUcsVUFBVSxRQUFRLFdBQVcsSUFBSTtBQUNqSjtBQUNBO0FBQ0E7QUFDQSxHQUFHLFNBQVMsZ0RBQWdEO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsb0JBQW9CLGlEQUFpRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx5RkFBeUYsR0FBRyxXQUFXLFVBQVU7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGlDQUFpQyxNQUFNO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxtQ0FBbUMsYUFBYTtBQUNuRDtBQUNBO0FBQ0EsR0FBRywyQkFBMkIsZUFBZTtBQUM3QztBQUNBO0FBQ0EsR0FBRyxrQ0FBa0MsNEJBQTRCO0FBQ2pFO0FBQ0E7QUFDQSxHQUFHLDBDQUEwQyw0QkFBNEI7QUFDekU7QUFDQTtBQUNBLEdBQUcsMkRBQTJELDRCQUE0QjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsOEJBQThCLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsR0FBRyxzQkFBc0IsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGVBQWUsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxzRUFBc0UsMkRBQTJEO0FBQ3BJO0FBQ0E7QUFDQSxHQUFHLDBGQUEwRiwyREFBMkQ7QUFDeEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx1QkFBdUIsSUFBSTtBQUM5QjtBQUNBO0FBQ0EsR0FBRyxrRUFBa0UsK0JBQStCO0FBQ3BHO0FBQ0E7QUFDQSxHQUFHLGdCQUFnQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLG9FQUFvRSxlQUFlLG1DQUFtQyxnQkFBZ0I7QUFDekk7QUFDQTtBQUNBLEdBQUcsZ0NBQWdDLGVBQWU7QUFDbEQsZ0ZBQWdGO0FBQ2hGLG1GQUFtRjtBQUNuRixxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDRCQUE0QixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxrQ0FBa0MsYUFBYTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsd0JBQXdCLGtCQUFrQixXQUFXLFNBQVMsRUFBRSwwQkFBMEIsU0FBUyxRQUFRO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcseUNBQXlDLFFBQVEsS0FBSyxPQUFPLEdBQUcsc0JBQXNCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsc0JBQXNCLGNBQWM7QUFDdkM7QUFDQTtBQUNBLEdBQUcsaUJBQWlCLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLEdBQUcsNEJBQTRCLE1BQU0sb0JBQW9CLE9BQU8sNEVBQTRFLHFDQUFxQyxNQUFNLEdBQUc7QUFDMUwsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQSxHQUFHLDBEQUEwRDtBQUM3RDtBQUNBLEdBQUcsSUFBSTtBQUNQLENBQUM7QUFDRCxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDRFQUE0RTtBQUM1RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CLEdBQUcsU0FBUyxHQUFHLFdBQVc7QUFDekU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxNQUFNLElBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsd0JBQXdCO0FBQ3hCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHNCQUFzQjtBQUN0QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxZQUFZO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sOERBQThEO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0EsS0FBSztBQUNMLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsdUNBQXVDLGFBQWE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxrRUFBa0UsWUFBWSxpQkFBaUIsWUFBWSx1QkFBdUIsU0FBUztBQUM5STtBQUNBO0FBQ0E7QUFDQSxHQUFHLDREQUE0RCxXQUFXLDRDQUE0QyxTQUFTO0FBQy9IO0FBQ0E7QUFDQSxHQUFHLGVBQWUsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixnQkFBZ0IsMkZBQTJGLFNBQVM7QUFDM0k7QUFDQTtBQUNBLEdBQUcsaUhBQWlILFNBQVM7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGVBQWUsU0FBUyxnQkFBZ0IsYUFBYSw4QkFBOEIsV0FBVyxtQkFBbUIsY0FBYztBQUNsSTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHlEQUF5RCxXQUFXLGdCQUFnQixTQUFTO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMENBQTBDLFdBQVcsMkVBQTJFLFNBQVM7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDBGQUEwRixXQUFXLHVCQUF1QixXQUFXLGdCQUFnQixTQUFTO0FBQ25LO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMkRBQTJELFlBQVksa0JBQWtCLFNBQVM7QUFDckc7QUFDQTtBQUNBLEdBQUcsZ0hBQWdILFNBQVM7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxpQ0FBaUMsYUFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMElBQTBJLHlCQUF5QjtBQUNuSztBQUNBO0FBQ0E7QUFDQSxHQUFHLHlCQUF5QixzQkFBc0IsNkJBQTZCLFdBQVc7QUFDMUY7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxvREFBb0QsZUFBZTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRywyQkFBMkIsV0FBVyxxQkFBcUIsV0FBVyxTQUFTLEdBQUcsV0FBVyxFQUFFO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxZQUFZO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxHQUFHO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGdCQUFnQixXQUFXO0FBQzlCO0FBQ0E7QUFDQSxHQUFHLGtCQUFrQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsb0NBQW9DLEtBQUs7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUcsNkJBQTZCLFNBQVM7QUFDekM7QUFDQTtBQUNBLEdBQUcsU0FBUyxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxTQUFTLGFBQWEsa0NBQWtDLGFBQWE7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsR0FBRyxpRUFBaUUsU0FBUztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFNBQVMsTUFBTTtBQUNsQjtBQUNBO0FBQ0EsR0FBRyxTQUFTLFNBQVM7QUFDckI7QUFDQTtBQUNBLEdBQUcsU0FBUyxTQUFTO0FBQ3JCO0FBQ0E7QUFDQSxHQUFHLFNBQVMsU0FBUztBQUNyQjtBQUNBO0FBQ0EsR0FBRyxTQUFTLG9CQUFvQiwyQkFBMkIsb0JBQW9CO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGlFQUFpRSxTQUFTO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDhCQUE4QixtQkFBbUIsZ0RBQWdELGtCQUFrQjtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw4RkFBOEYsS0FBSztBQUN0RyxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxtRkFBbUYscUZBQXFGO0FBQ3hLLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EscUZBQXFGLHFGQUFxRjtBQUMxSyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEVBQUU7QUFDN0QsbUdBQW1HLGFBQWE7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxFQUFFO0FBQ3RELHlJQUF5SSxVQUFVO0FBQ25KO0FBQ0E7QUFDQSwwRUFBMEUsbUNBQW1DLFlBQVkscUVBQXFFO0FBQzlMO0FBQ0EsTUFBTTtBQUNOLHdFQUF3RSxtQkFBbUIsWUFBWSxxRUFBcUU7QUFDNUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUpBQWlKLEVBQUU7QUFDbko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHVCQUF1QjtBQUN2QixnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL0BiYWJlbCtwYXJzZXJANy4yNy4wL25vZGVfbW9kdWxlcy9AYmFiZWwvcGFyc2VyL2xpYi9pbmRleC5qcz8wMGVlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShyLCBlKSB7XG4gIGlmIChudWxsID09IHIpIHJldHVybiB7fTtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgbiBpbiByKSBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChyLCBuKSkge1xuICAgIGlmICgtMSAhPT0gZS5pbmRleE9mKG4pKSBjb250aW51ZTtcbiAgICB0W25dID0gcltuXTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmNsYXNzIFBvc2l0aW9uIHtcbiAgY29uc3RydWN0b3IobGluZSwgY29sLCBpbmRleCkge1xuICAgIHRoaXMubGluZSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbHVtbiA9IHZvaWQgMDtcbiAgICB0aGlzLmluZGV4ID0gdm9pZCAwO1xuICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgdGhpcy5jb2x1bW4gPSBjb2w7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICB9XG59XG5jbGFzcyBTb3VyY2VMb2NhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLnN0YXJ0ID0gdm9pZCAwO1xuICAgIHRoaXMuZW5kID0gdm9pZCAwO1xuICAgIHRoaXMuZmlsZW5hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5pZGVudGlmaWVyTmFtZSA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldChwb3NpdGlvbiwgY29sdW1uT2Zmc2V0KSB7XG4gIGNvbnN0IHtcbiAgICBsaW5lLFxuICAgIGNvbHVtbixcbiAgICBpbmRleFxuICB9ID0gcG9zaXRpb247XG4gIHJldHVybiBuZXcgUG9zaXRpb24obGluZSwgY29sdW1uICsgY29sdW1uT2Zmc2V0LCBpbmRleCArIGNvbHVtbk9mZnNldCk7XG59XG5jb25zdCBjb2RlID0gXCJCQUJFTF9QQVJTRVJfU09VUkNFVFlQRV9NT0RVTEVfUkVRVUlSRURcIjtcbnZhciBNb2R1bGVFcnJvcnMgPSB7XG4gIEltcG9ydE1ldGFPdXRzaWRlTW9kdWxlOiB7XG4gICAgbWVzc2FnZTogYGltcG9ydC5tZXRhIG1heSBhcHBlYXIgb25seSB3aXRoICdzb3VyY2VUeXBlOiBcIm1vZHVsZVwiJ2AsXG4gICAgY29kZVxuICB9LFxuICBJbXBvcnRPdXRzaWRlTW9kdWxlOiB7XG4gICAgbWVzc2FnZTogYCdpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgYXBwZWFyIG9ubHkgd2l0aCAnc291cmNlVHlwZTogXCJtb2R1bGVcIidgLFxuICAgIGNvZGVcbiAgfVxufTtcbmNvbnN0IE5vZGVEZXNjcmlwdGlvbnMgPSB7XG4gIEFycmF5UGF0dGVybjogXCJhcnJheSBkZXN0cnVjdHVyaW5nIHBhdHRlcm5cIixcbiAgQXNzaWdubWVudEV4cHJlc3Npb246IFwiYXNzaWdubWVudCBleHByZXNzaW9uXCIsXG4gIEFzc2lnbm1lbnRQYXR0ZXJuOiBcImFzc2lnbm1lbnQgZXhwcmVzc2lvblwiLFxuICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogXCJhcnJvdyBmdW5jdGlvbiBleHByZXNzaW9uXCIsXG4gIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogXCJjb25kaXRpb25hbCBleHByZXNzaW9uXCIsXG4gIENhdGNoQ2xhdXNlOiBcImNhdGNoIGNsYXVzZVwiLFxuICBGb3JPZlN0YXRlbWVudDogXCJmb3Itb2Ygc3RhdGVtZW50XCIsXG4gIEZvckluU3RhdGVtZW50OiBcImZvci1pbiBzdGF0ZW1lbnRcIixcbiAgRm9yU3RhdGVtZW50OiBcImZvci1sb29wXCIsXG4gIEZvcm1hbFBhcmFtZXRlcnM6IFwiZnVuY3Rpb24gcGFyYW1ldGVyIGxpc3RcIixcbiAgSWRlbnRpZmllcjogXCJpZGVudGlmaWVyXCIsXG4gIEltcG9ydFNwZWNpZmllcjogXCJpbXBvcnQgc3BlY2lmaWVyXCIsXG4gIEltcG9ydERlZmF1bHRTcGVjaWZpZXI6IFwiaW1wb3J0IGRlZmF1bHQgc3BlY2lmaWVyXCIsXG4gIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjogXCJpbXBvcnQgbmFtZXNwYWNlIHNwZWNpZmllclwiLFxuICBPYmplY3RQYXR0ZXJuOiBcIm9iamVjdCBkZXN0cnVjdHVyaW5nIHBhdHRlcm5cIixcbiAgUGFyZW50aGVzaXplZEV4cHJlc3Npb246IFwicGFyZW50aGVzaXplZCBleHByZXNzaW9uXCIsXG4gIFJlc3RFbGVtZW50OiBcInJlc3QgZWxlbWVudFwiLFxuICBVcGRhdGVFeHByZXNzaW9uOiB7XG4gICAgdHJ1ZTogXCJwcmVmaXggb3BlcmF0aW9uXCIsXG4gICAgZmFsc2U6IFwicG9zdGZpeCBvcGVyYXRpb25cIlxuICB9LFxuICBWYXJpYWJsZURlY2xhcmF0b3I6IFwidmFyaWFibGUgZGVjbGFyYXRpb25cIixcbiAgWWllbGRFeHByZXNzaW9uOiBcInlpZWxkIGV4cHJlc3Npb25cIlxufTtcbmNvbnN0IHRvTm9kZURlc2NyaXB0aW9uID0gbm9kZSA9PiBub2RlLnR5cGUgPT09IFwiVXBkYXRlRXhwcmVzc2lvblwiID8gTm9kZURlc2NyaXB0aW9ucy5VcGRhdGVFeHByZXNzaW9uW2Ake25vZGUucHJlZml4fWBdIDogTm9kZURlc2NyaXB0aW9uc1tub2RlLnR5cGVdO1xudmFyIFN0YW5kYXJkRXJyb3JzID0ge1xuICBBY2Nlc3NvcklzR2VuZXJhdG9yOiAoe1xuICAgIGtpbmRcbiAgfSkgPT4gYEEgJHtraW5kfXRlciBjYW5ub3QgYmUgYSBnZW5lcmF0b3IuYCxcbiAgQXJndW1lbnRzSW5DbGFzczogXCInYXJndW1lbnRzJyBpcyBvbmx5IGFsbG93ZWQgaW4gZnVuY3Rpb25zIGFuZCBjbGFzcyBtZXRob2RzLlwiLFxuICBBc3luY0Z1bmN0aW9uSW5TaW5nbGVTdGF0ZW1lbnRDb250ZXh0OiBcIkFzeW5jIGZ1bmN0aW9ucyBjYW4gb25seSBiZSBkZWNsYXJlZCBhdCB0aGUgdG9wIGxldmVsIG9yIGluc2lkZSBhIGJsb2NrLlwiLFxuICBBd2FpdEJpbmRpbmdJZGVudGlmaWVyOiBcIkNhbiBub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb24uXCIsXG4gIEF3YWl0QmluZGluZ0lkZW50aWZpZXJJblN0YXRpY0Jsb2NrOiBcIkNhbiBub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYSBzdGF0aWMgYmxvY2suXCIsXG4gIEF3YWl0RXhwcmVzc2lvbkZvcm1hbFBhcmFtZXRlcjogXCInYXdhaXQnIGlzIG5vdCBhbGxvd2VkIGluIGFzeW5jIGZ1bmN0aW9uIHBhcmFtZXRlcnMuXCIsXG4gIEF3YWl0VXNpbmdOb3RJbkFzeW5jQ29udGV4dDogXCInYXdhaXQgdXNpbmcnIGlzIG9ubHkgYWxsb3dlZCB3aXRoaW4gYXN5bmMgZnVuY3Rpb25zIGFuZCBhdCB0aGUgdG9wIGxldmVscyBvZiBtb2R1bGVzLlwiLFxuICBBd2FpdE5vdEluQXN5bmNDb250ZXh0OiBcIidhd2FpdCcgaXMgb25seSBhbGxvd2VkIHdpdGhpbiBhc3luYyBmdW5jdGlvbnMgYW5kIGF0IHRoZSB0b3AgbGV2ZWxzIG9mIG1vZHVsZXMuXCIsXG4gIEJhZEdldHRlckFyaXR5OiBcIkEgJ2dldCcgYWNjZXNzb3IgbXVzdCBub3QgaGF2ZSBhbnkgZm9ybWFsIHBhcmFtZXRlcnMuXCIsXG4gIEJhZFNldHRlckFyaXR5OiBcIkEgJ3NldCcgYWNjZXNzb3IgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGZvcm1hbCBwYXJhbWV0ZXIuXCIsXG4gIEJhZFNldHRlclJlc3RQYXJhbWV0ZXI6IFwiQSAnc2V0JyBhY2Nlc3NvciBmdW5jdGlvbiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIHJlc3QgcGFyYW1ldGVyLlwiLFxuICBDb25zdHJ1Y3RvckNsYXNzRmllbGQ6IFwiQ2xhc3NlcyBtYXkgbm90IGhhdmUgYSBmaWVsZCBuYW1lZCAnY29uc3RydWN0b3InLlwiLFxuICBDb25zdHJ1Y3RvckNsYXNzUHJpdmF0ZUZpZWxkOiBcIkNsYXNzZXMgbWF5IG5vdCBoYXZlIGEgcHJpdmF0ZSBmaWVsZCBuYW1lZCAnI2NvbnN0cnVjdG9yJy5cIixcbiAgQ29uc3RydWN0b3JJc0FjY2Vzc29yOiBcIkNsYXNzIGNvbnN0cnVjdG9yIG1heSBub3QgYmUgYW4gYWNjZXNzb3IuXCIsXG4gIENvbnN0cnVjdG9ySXNBc3luYzogXCJDb25zdHJ1Y3RvciBjYW4ndCBiZSBhbiBhc3luYyBmdW5jdGlvbi5cIixcbiAgQ29uc3RydWN0b3JJc0dlbmVyYXRvcjogXCJDb25zdHJ1Y3RvciBjYW4ndCBiZSBhIGdlbmVyYXRvci5cIixcbiAgRGVjbGFyYXRpb25NaXNzaW5nSW5pdGlhbGl6ZXI6ICh7XG4gICAga2luZFxuICB9KSA9PiBgTWlzc2luZyBpbml0aWFsaXplciBpbiAke2tpbmR9IGRlY2xhcmF0aW9uLmAsXG4gIERlY29yYXRvckFyZ3VtZW50c091dHNpZGVQYXJlbnRoZXNlczogXCJEZWNvcmF0b3IgYXJndW1lbnRzIG11c3QgYmUgbW92ZWQgaW5zaWRlIHBhcmVudGhlc2VzOiB1c2UgJ0AoZGVjb3JhdG9yKGFyZ3MpKScgaW5zdGVhZCBvZiAnQChkZWNvcmF0b3IpKGFyZ3MpJy5cIixcbiAgRGVjb3JhdG9yQmVmb3JlRXhwb3J0OiBcIkRlY29yYXRvcnMgbXVzdCBiZSBwbGFjZWQgKmJlZm9yZSogdGhlICdleHBvcnQnIGtleXdvcmQuIFJlbW92ZSB0aGUgJ2RlY29yYXRvcnNCZWZvcmVFeHBvcnQ6IHRydWUnIG9wdGlvbiB0byB1c2UgdGhlICdleHBvcnQgQGRlY29yYXRvciBjbGFzcyB7fScgc3ludGF4LlwiLFxuICBEZWNvcmF0b3JzQmVmb3JlQWZ0ZXJFeHBvcnQ6IFwiRGVjb3JhdG9ycyBjYW4gYmUgcGxhY2VkICplaXRoZXIqIGJlZm9yZSBvciBhZnRlciB0aGUgJ2V4cG9ydCcga2V5d29yZCwgYnV0IG5vdCBpbiBib3RoIGxvY2F0aW9ucyBhdCB0aGUgc2FtZSB0aW1lLlwiLFxuICBEZWNvcmF0b3JDb25zdHJ1Y3RvcjogXCJEZWNvcmF0b3JzIGNhbid0IGJlIHVzZWQgd2l0aCBhIGNvbnN0cnVjdG9yLiBEaWQgeW91IG1lYW4gJ0BkZWMgY2xhc3MgeyAuLi4gfSc/XCIsXG4gIERlY29yYXRvckV4cG9ydENsYXNzOiBcIkRlY29yYXRvcnMgbXVzdCBiZSBwbGFjZWQgKmFmdGVyKiB0aGUgJ2V4cG9ydCcga2V5d29yZC4gUmVtb3ZlIHRoZSAnZGVjb3JhdG9yc0JlZm9yZUV4cG9ydDogZmFsc2UnIG9wdGlvbiB0byB1c2UgdGhlICdAZGVjb3JhdG9yIGV4cG9ydCBjbGFzcyB7fScgc3ludGF4LlwiLFxuICBEZWNvcmF0b3JTZW1pY29sb246IFwiRGVjb3JhdG9ycyBtdXN0IG5vdCBiZSBmb2xsb3dlZCBieSBhIHNlbWljb2xvbi5cIixcbiAgRGVjb3JhdG9yU3RhdGljQmxvY2s6IFwiRGVjb3JhdG9ycyBjYW4ndCBiZSB1c2VkIHdpdGggYSBzdGF0aWMgYmxvY2suXCIsXG4gIERlZmVySW1wb3J0UmVxdWlyZXNOYW1lc3BhY2U6ICdPbmx5IGBpbXBvcnQgZGVmZXIgKiBhcyB4IGZyb20gXCIuL21vZHVsZVwiYCBpcyB2YWxpZC4nLFxuICBEZWxldGVQcml2YXRlRmllbGQ6IFwiRGVsZXRpbmcgYSBwcml2YXRlIGZpZWxkIGlzIG5vdCBhbGxvd2VkLlwiLFxuICBEZXN0cnVjdHVyZU5hbWVkSW1wb3J0OiBcIkVTMjAxNSBuYW1lZCBpbXBvcnRzIGRvIG5vdCBkZXN0cnVjdHVyZS4gVXNlIGFub3RoZXIgc3RhdGVtZW50IGZvciBkZXN0cnVjdHVyaW5nIGFmdGVyIHRoZSBpbXBvcnQuXCIsXG4gIER1cGxpY2F0ZUNvbnN0cnVjdG9yOiBcIkR1cGxpY2F0ZSBjb25zdHJ1Y3RvciBpbiB0aGUgc2FtZSBjbGFzcy5cIixcbiAgRHVwbGljYXRlRGVmYXVsdEV4cG9ydDogXCJPbmx5IG9uZSBkZWZhdWx0IGV4cG9ydCBhbGxvd2VkIHBlciBtb2R1bGUuXCIsXG4gIER1cGxpY2F0ZUV4cG9ydDogKHtcbiAgICBleHBvcnROYW1lXG4gIH0pID0+IGBcXGAke2V4cG9ydE5hbWV9XFxgIGhhcyBhbHJlYWR5IGJlZW4gZXhwb3J0ZWQuIEV4cG9ydGVkIGlkZW50aWZpZXJzIG11c3QgYmUgdW5pcXVlLmAsXG4gIER1cGxpY2F0ZVByb3RvOiBcIlJlZGVmaW5pdGlvbiBvZiBfX3Byb3RvX18gcHJvcGVydHkuXCIsXG4gIER1cGxpY2F0ZVJlZ0V4cEZsYWdzOiBcIkR1cGxpY2F0ZSByZWd1bGFyIGV4cHJlc3Npb24gZmxhZy5cIixcbiAgRHluYW1pY0ltcG9ydFBoYXNlUmVxdWlyZXNJbXBvcnRFeHByZXNzaW9uczogKHtcbiAgICBwaGFzZVxuICB9KSA9PiBgJ2ltcG9ydC4ke3BoYXNlfSguLi4pJyBjYW4gb25seSBiZSBwYXJzZWQgd2hlbiB1c2luZyB0aGUgJ2NyZWF0ZUltcG9ydEV4cHJlc3Npb25zJyBvcHRpb24uYCxcbiAgRWxlbWVudEFmdGVyUmVzdDogXCJSZXN0IGVsZW1lbnQgbXVzdCBiZSBsYXN0IGVsZW1lbnQuXCIsXG4gIEVzY2FwZWRDaGFyTm90QW5JZGVudGlmaWVyOiBcIkludmFsaWQgVW5pY29kZSBlc2NhcGUuXCIsXG4gIEV4cG9ydEJpbmRpbmdJc1N0cmluZzogKHtcbiAgICBsb2NhbE5hbWUsXG4gICAgZXhwb3J0TmFtZVxuICB9KSA9PiBgQSBzdHJpbmcgbGl0ZXJhbCBjYW5ub3QgYmUgdXNlZCBhcyBhbiBleHBvcnRlZCBiaW5kaW5nIHdpdGhvdXQgXFxgZnJvbVxcYC5cXG4tIERpZCB5b3UgbWVhbiBcXGBleHBvcnQgeyAnJHtsb2NhbE5hbWV9JyBhcyAnJHtleHBvcnROYW1lfScgfSBmcm9tICdzb21lLW1vZHVsZSdcXGA/YCxcbiAgRXhwb3J0RGVmYXVsdEZyb21Bc0lkZW50aWZpZXI6IFwiJ2Zyb20nIGlzIG5vdCBhbGxvd2VkIGFzIGFuIGlkZW50aWZpZXIgYWZ0ZXIgJ2V4cG9ydCBkZWZhdWx0Jy5cIixcbiAgRm9ySW5PZkxvb3BJbml0aWFsaXplcjogKHtcbiAgICB0eXBlXG4gIH0pID0+IGAnJHt0eXBlID09PSBcIkZvckluU3RhdGVtZW50XCIgPyBcImZvci1pblwiIDogXCJmb3Itb2ZcIn0nIGxvb3AgdmFyaWFibGUgZGVjbGFyYXRpb24gbWF5IG5vdCBoYXZlIGFuIGluaXRpYWxpemVyLmAsXG4gIEZvckluVXNpbmc6IFwiRm9yLWluIGxvb3AgbWF5IG5vdCBzdGFydCB3aXRoICd1c2luZycgZGVjbGFyYXRpb24uXCIsXG4gIEZvck9mQXN5bmM6IFwiVGhlIGxlZnQtaGFuZCBzaWRlIG9mIGEgZm9yLW9mIGxvb3AgbWF5IG5vdCBiZSAnYXN5bmMnLlwiLFxuICBGb3JPZkxldDogXCJUaGUgbGVmdC1oYW5kIHNpZGUgb2YgYSBmb3Itb2YgbG9vcCBtYXkgbm90IHN0YXJ0IHdpdGggJ2xldCcuXCIsXG4gIEdlbmVyYXRvckluU2luZ2xlU3RhdGVtZW50Q29udGV4dDogXCJHZW5lcmF0b3JzIGNhbiBvbmx5IGJlIGRlY2xhcmVkIGF0IHRoZSB0b3AgbGV2ZWwgb3IgaW5zaWRlIGEgYmxvY2suXCIsXG4gIElsbGVnYWxCcmVha0NvbnRpbnVlOiAoe1xuICAgIHR5cGVcbiAgfSkgPT4gYFVuc3ludGFjdGljICR7dHlwZSA9PT0gXCJCcmVha1N0YXRlbWVudFwiID8gXCJicmVha1wiIDogXCJjb250aW51ZVwifS5gLFxuICBJbGxlZ2FsTGFuZ3VhZ2VNb2RlRGlyZWN0aXZlOiBcIklsbGVnYWwgJ3VzZSBzdHJpY3QnIGRpcmVjdGl2ZSBpbiBmdW5jdGlvbiB3aXRoIG5vbi1zaW1wbGUgcGFyYW1ldGVyIGxpc3QuXCIsXG4gIElsbGVnYWxSZXR1cm46IFwiJ3JldHVybicgb3V0c2lkZSBvZiBmdW5jdGlvbi5cIixcbiAgSW1wb3J0QXR0cmlidXRlc1VzZUFzc2VydDogXCJUaGUgYGFzc2VydGAga2V5d29yZCBpbiBpbXBvcnQgYXR0cmlidXRlcyBpcyBkZXByZWNhdGVkIGFuZCBpdCBoYXMgYmVlbiByZXBsYWNlZCBieSB0aGUgYHdpdGhgIGtleXdvcmQuIFlvdSBjYW4gZW5hYmxlIHRoZSBgZGVwcmVjYXRlZEltcG9ydEFzc2VydGAgcGFyc2VyIHBsdWdpbiB0byBzdXBwcmVzcyB0aGlzIGVycm9yLlwiLFxuICBJbXBvcnRCaW5kaW5nSXNTdHJpbmc6ICh7XG4gICAgaW1wb3J0TmFtZVxuICB9KSA9PiBgQSBzdHJpbmcgbGl0ZXJhbCBjYW5ub3QgYmUgdXNlZCBhcyBhbiBpbXBvcnRlZCBiaW5kaW5nLlxcbi0gRGlkIHlvdSBtZWFuIFxcYGltcG9ydCB7IFwiJHtpbXBvcnROYW1lfVwiIGFzIGZvbyB9XFxgP2AsXG4gIEltcG9ydENhbGxBcml0eTogYFxcYGltcG9ydCgpXFxgIHJlcXVpcmVzIGV4YWN0bHkgb25lIG9yIHR3byBhcmd1bWVudHMuYCxcbiAgSW1wb3J0Q2FsbE5vdE5ld0V4cHJlc3Npb246IFwiQ2Fubm90IHVzZSBuZXcgd2l0aCBpbXBvcnQoLi4uKS5cIixcbiAgSW1wb3J0Q2FsbFNwcmVhZEFyZ3VtZW50OiBcImAuLi5gIGlzIG5vdCBhbGxvd2VkIGluIGBpbXBvcnQoKWAuXCIsXG4gIEltcG9ydEpTT05CaW5kaW5nTm90RGVmYXVsdDogXCJBIEpTT04gbW9kdWxlIGNhbiBvbmx5IGJlIGltcG9ydGVkIHdpdGggYGRlZmF1bHRgLlwiLFxuICBJbXBvcnRSZWZsZWN0aW9uSGFzQXNzZXJ0aW9uOiBcImBpbXBvcnQgbW9kdWxlIHhgIGNhbm5vdCBoYXZlIGFzc2VydGlvbnMuXCIsXG4gIEltcG9ydFJlZmxlY3Rpb25Ob3RCaW5kaW5nOiAnT25seSBgaW1wb3J0IG1vZHVsZSB4IGZyb20gXCIuL21vZHVsZVwiYCBpcyB2YWxpZC4nLFxuICBJbmNvbXBhdGlibGVSZWdFeHBVVkZsYWdzOiBcIlRoZSAndScgYW5kICd2JyByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ3MgY2Fubm90IGJlIGVuYWJsZWQgYXQgdGhlIHNhbWUgdGltZS5cIixcbiAgSW52YWxpZEJpZ0ludExpdGVyYWw6IFwiSW52YWxpZCBCaWdJbnRMaXRlcmFsLlwiLFxuICBJbnZhbGlkQ29kZVBvaW50OiBcIkNvZGUgcG9pbnQgb3V0IG9mIGJvdW5kcy5cIixcbiAgSW52YWxpZENvdmVySW5pdGlhbGl6ZWROYW1lOiBcIkludmFsaWQgc2hvcnRoYW5kIHByb3BlcnR5IGluaXRpYWxpemVyLlwiLFxuICBJbnZhbGlkRGVjaW1hbDogXCJJbnZhbGlkIGRlY2ltYWwuXCIsXG4gIEludmFsaWREaWdpdDogKHtcbiAgICByYWRpeFxuICB9KSA9PiBgRXhwZWN0ZWQgbnVtYmVyIGluIHJhZGl4ICR7cmFkaXh9LmAsXG4gIEludmFsaWRFc2NhcGVTZXF1ZW5jZTogXCJCYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZS5cIixcbiAgSW52YWxpZEVzY2FwZVNlcXVlbmNlVGVtcGxhdGU6IFwiSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UgaW4gdGVtcGxhdGUuXCIsXG4gIEludmFsaWRFc2NhcGVkUmVzZXJ2ZWRXb3JkOiAoe1xuICAgIHJlc2VydmVkV29yZFxuICB9KSA9PiBgRXNjYXBlIHNlcXVlbmNlIGluIGtleXdvcmQgJHtyZXNlcnZlZFdvcmR9LmAsXG4gIEludmFsaWRJZGVudGlmaWVyOiAoe1xuICAgIGlkZW50aWZpZXJOYW1lXG4gIH0pID0+IGBJbnZhbGlkIGlkZW50aWZpZXIgJHtpZGVudGlmaWVyTmFtZX0uYCxcbiAgSW52YWxpZExoczogKHtcbiAgICBhbmNlc3RvclxuICB9KSA9PiBgSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiAke3RvTm9kZURlc2NyaXB0aW9uKGFuY2VzdG9yKX0uYCxcbiAgSW52YWxpZExoc0JpbmRpbmc6ICh7XG4gICAgYW5jZXN0b3JcbiAgfSkgPT4gYEJpbmRpbmcgaW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiAke3RvTm9kZURlc2NyaXB0aW9uKGFuY2VzdG9yKX0uYCxcbiAgSW52YWxpZExoc09wdGlvbmFsQ2hhaW5pbmc6ICh7XG4gICAgYW5jZXN0b3JcbiAgfSkgPT4gYEludmFsaWQgb3B0aW9uYWwgY2hhaW5pbmcgaW4gdGhlIGxlZnQtaGFuZCBzaWRlIG9mICR7dG9Ob2RlRGVzY3JpcHRpb24oYW5jZXN0b3IpfS5gLFxuICBJbnZhbGlkTnVtYmVyOiBcIkludmFsaWQgbnVtYmVyLlwiLFxuICBJbnZhbGlkT3JNaXNzaW5nRXhwb25lbnQ6IFwiRmxvYXRpbmctcG9pbnQgbnVtYmVycyByZXF1aXJlIGEgdmFsaWQgZXhwb25lbnQgYWZ0ZXIgdGhlICdlJy5cIixcbiAgSW52YWxpZE9yVW5leHBlY3RlZFRva2VuOiAoe1xuICAgIHVuZXhwZWN0ZWRcbiAgfSkgPT4gYFVuZXhwZWN0ZWQgY2hhcmFjdGVyICcke3VuZXhwZWN0ZWR9Jy5gLFxuICBJbnZhbGlkUGFyZW50aGVzaXplZEFzc2lnbm1lbnQ6IFwiSW52YWxpZCBwYXJlbnRoZXNpemVkIGFzc2lnbm1lbnQgcGF0dGVybi5cIixcbiAgSW52YWxpZFByaXZhdGVGaWVsZFJlc29sdXRpb246ICh7XG4gICAgaWRlbnRpZmllck5hbWVcbiAgfSkgPT4gYFByaXZhdGUgbmFtZSAjJHtpZGVudGlmaWVyTmFtZX0gaXMgbm90IGRlZmluZWQuYCxcbiAgSW52YWxpZFByb3BlcnR5QmluZGluZ1BhdHRlcm46IFwiQmluZGluZyBtZW1iZXIgZXhwcmVzc2lvbi5cIixcbiAgSW52YWxpZFJlY29yZFByb3BlcnR5OiBcIk9ubHkgcHJvcGVydGllcyBhbmQgc3ByZWFkIGVsZW1lbnRzIGFyZSBhbGxvd2VkIGluIHJlY29yZCBkZWZpbml0aW9ucy5cIixcbiAgSW52YWxpZFJlc3RBc3NpZ25tZW50UGF0dGVybjogXCJJbnZhbGlkIHJlc3Qgb3BlcmF0b3IncyBhcmd1bWVudC5cIixcbiAgTGFiZWxSZWRlY2xhcmF0aW9uOiAoe1xuICAgIGxhYmVsTmFtZVxuICB9KSA9PiBgTGFiZWwgJyR7bGFiZWxOYW1lfScgaXMgYWxyZWFkeSBkZWNsYXJlZC5gLFxuICBMZXRJbkxleGljYWxCaW5kaW5nOiBcIidsZXQnIGlzIGRpc2FsbG93ZWQgYXMgYSBsZXhpY2FsbHkgYm91bmQgbmFtZS5cIixcbiAgTGluZVRlcm1pbmF0b3JCZWZvcmVBcnJvdzogXCJObyBsaW5lIGJyZWFrIGlzIGFsbG93ZWQgYmVmb3JlICc9PicuXCIsXG4gIE1hbGZvcm1lZFJlZ0V4cEZsYWdzOiBcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWcuXCIsXG4gIE1pc3NpbmdDbGFzc05hbWU6IFwiQSBjbGFzcyBuYW1lIGlzIHJlcXVpcmVkLlwiLFxuICBNaXNzaW5nRXFJbkFzc2lnbm1lbnQ6IFwiT25seSAnPScgb3BlcmF0b3IgY2FuIGJlIHVzZWQgZm9yIHNwZWNpZnlpbmcgZGVmYXVsdCB2YWx1ZS5cIixcbiAgTWlzc2luZ1NlbWljb2xvbjogXCJNaXNzaW5nIHNlbWljb2xvbi5cIixcbiAgTWlzc2luZ1BsdWdpbjogKHtcbiAgICBtaXNzaW5nUGx1Z2luXG4gIH0pID0+IGBUaGlzIGV4cGVyaW1lbnRhbCBzeW50YXggcmVxdWlyZXMgZW5hYmxpbmcgdGhlIHBhcnNlciBwbHVnaW46ICR7bWlzc2luZ1BsdWdpbi5tYXAobmFtZSA9PiBKU09OLnN0cmluZ2lmeShuYW1lKSkuam9pbihcIiwgXCIpfS5gLFxuICBNaXNzaW5nT25lT2ZQbHVnaW5zOiAoe1xuICAgIG1pc3NpbmdQbHVnaW5cbiAgfSkgPT4gYFRoaXMgZXhwZXJpbWVudGFsIHN5bnRheCByZXF1aXJlcyBlbmFibGluZyBvbmUgb2YgdGhlIGZvbGxvd2luZyBwYXJzZXIgcGx1Z2luKHMpOiAke21pc3NpbmdQbHVnaW4ubWFwKG5hbWUgPT4gSlNPTi5zdHJpbmdpZnkobmFtZSkpLmpvaW4oXCIsIFwiKX0uYCxcbiAgTWlzc2luZ1VuaWNvZGVFc2NhcGU6IFwiRXhwZWN0aW5nIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlIFxcXFx1WFhYWC5cIixcbiAgTWl4aW5nQ29hbGVzY2VXaXRoTG9naWNhbDogXCJOdWxsaXNoIGNvYWxlc2Npbmcgb3BlcmF0b3IoPz8pIHJlcXVpcmVzIHBhcmVucyB3aGVuIG1peGluZyB3aXRoIGxvZ2ljYWwgb3BlcmF0b3JzLlwiLFxuICBNb2R1bGVBdHRyaWJ1dGVEaWZmZXJlbnRGcm9tVHlwZTogXCJUaGUgb25seSBhY2NlcHRlZCBtb2R1bGUgYXR0cmlidXRlIGlzIGB0eXBlYC5cIixcbiAgTW9kdWxlQXR0cmlidXRlSW52YWxpZFZhbHVlOiBcIk9ubHkgc3RyaW5nIGxpdGVyYWxzIGFyZSBhbGxvd2VkIGFzIG1vZHVsZSBhdHRyaWJ1dGUgdmFsdWVzLlwiLFxuICBNb2R1bGVBdHRyaWJ1dGVzV2l0aER1cGxpY2F0ZUtleXM6ICh7XG4gICAga2V5XG4gIH0pID0+IGBEdXBsaWNhdGUga2V5IFwiJHtrZXl9XCIgaXMgbm90IGFsbG93ZWQgaW4gbW9kdWxlIGF0dHJpYnV0ZXMuYCxcbiAgTW9kdWxlRXhwb3J0TmFtZUhhc0xvbmVTdXJyb2dhdGU6ICh7XG4gICAgc3Vycm9nYXRlQ2hhckNvZGVcbiAgfSkgPT4gYEFuIGV4cG9ydCBuYW1lIGNhbm5vdCBpbmNsdWRlIGEgbG9uZSBzdXJyb2dhdGUsIGZvdW5kICdcXFxcdSR7c3Vycm9nYXRlQ2hhckNvZGUudG9TdHJpbmcoMTYpfScuYCxcbiAgTW9kdWxlRXhwb3J0VW5kZWZpbmVkOiAoe1xuICAgIGxvY2FsTmFtZVxuICB9KSA9PiBgRXhwb3J0ICcke2xvY2FsTmFtZX0nIGlzIG5vdCBkZWZpbmVkLmAsXG4gIE11bHRpcGxlRGVmYXVsdHNJblN3aXRjaDogXCJNdWx0aXBsZSBkZWZhdWx0IGNsYXVzZXMuXCIsXG4gIE5ld2xpbmVBZnRlclRocm93OiBcIklsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvdy5cIixcbiAgTm9DYXRjaE9yRmluYWxseTogXCJNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgY2xhdXNlLlwiLFxuICBOdW1iZXJJZGVudGlmaWVyOiBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyLlwiLFxuICBOdW1lcmljU2VwYXJhdG9ySW5Fc2NhcGVTZXF1ZW5jZTogXCJOdW1lcmljIHNlcGFyYXRvcnMgYXJlIG5vdCBhbGxvd2VkIGluc2lkZSB1bmljb2RlIGVzY2FwZSBzZXF1ZW5jZXMgb3IgaGV4IGVzY2FwZSBzZXF1ZW5jZXMuXCIsXG4gIE9ic29sZXRlQXdhaXRTdGFyOiBcIidhd2FpdConIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgYXN5bmMgZnVuY3Rpb25zIHByb3Bvc2FsLiBVc2UgUHJvbWlzZS5hbGwoKSBpbnN0ZWFkLlwiLFxuICBPcHRpb25hbENoYWluaW5nTm9OZXc6IFwiQ29uc3RydWN0b3JzIGluL2FmdGVyIGFuIE9wdGlvbmFsIENoYWluIGFyZSBub3QgYWxsb3dlZC5cIixcbiAgT3B0aW9uYWxDaGFpbmluZ05vVGVtcGxhdGU6IFwiVGFnZ2VkIFRlbXBsYXRlIExpdGVyYWxzIGFyZSBub3QgYWxsb3dlZCBpbiBvcHRpb25hbENoYWluLlwiLFxuICBPdmVycmlkZU9uQ29uc3RydWN0b3I6IFwiJ292ZXJyaWRlJyBtb2RpZmllciBjYW5ub3QgYXBwZWFyIG9uIGEgY29uc3RydWN0b3IgZGVjbGFyYXRpb24uXCIsXG4gIFBhcmFtRHVwZTogXCJBcmd1bWVudCBuYW1lIGNsYXNoLlwiLFxuICBQYXR0ZXJuSGFzQWNjZXNzb3I6IFwiT2JqZWN0IHBhdHRlcm4gY2FuJ3QgY29udGFpbiBnZXR0ZXIgb3Igc2V0dGVyLlwiLFxuICBQYXR0ZXJuSGFzTWV0aG9kOiBcIk9iamVjdCBwYXR0ZXJuIGNhbid0IGNvbnRhaW4gbWV0aG9kcy5cIixcbiAgUHJpdmF0ZUluRXhwZWN0ZWRJbjogKHtcbiAgICBpZGVudGlmaWVyTmFtZVxuICB9KSA9PiBgUHJpdmF0ZSBuYW1lcyBhcmUgb25seSBhbGxvd2VkIGluIHByb3BlcnR5IGFjY2Vzc2VzIChcXGBvYmouIyR7aWRlbnRpZmllck5hbWV9XFxgKSBvciBpbiBcXGBpblxcYCBleHByZXNzaW9ucyAoXFxgIyR7aWRlbnRpZmllck5hbWV9IGluIG9ialxcYCkuYCxcbiAgUHJpdmF0ZU5hbWVSZWRlY2xhcmF0aW9uOiAoe1xuICAgIGlkZW50aWZpZXJOYW1lXG4gIH0pID0+IGBEdXBsaWNhdGUgcHJpdmF0ZSBuYW1lICMke2lkZW50aWZpZXJOYW1lfS5gLFxuICBSZWNvcmRFeHByZXNzaW9uQmFySW5jb3JyZWN0RW5kU3ludGF4VHlwZTogXCJSZWNvcmQgZXhwcmVzc2lvbnMgZW5kaW5nIHdpdGggJ3x9JyBhcmUgb25seSBhbGxvd2VkIHdoZW4gdGhlICdzeW50YXhUeXBlJyBvcHRpb24gb2YgdGhlICdyZWNvcmRBbmRUdXBsZScgcGx1Z2luIGlzIHNldCB0byAnYmFyJy5cIixcbiAgUmVjb3JkRXhwcmVzc2lvbkJhckluY29ycmVjdFN0YXJ0U3ludGF4VHlwZTogXCJSZWNvcmQgZXhwcmVzc2lvbnMgc3RhcnRpbmcgd2l0aCAne3wnIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiB0aGUgJ3N5bnRheFR5cGUnIG9wdGlvbiBvZiB0aGUgJ3JlY29yZEFuZFR1cGxlJyBwbHVnaW4gaXMgc2V0IHRvICdiYXInLlwiLFxuICBSZWNvcmRFeHByZXNzaW9uSGFzaEluY29ycmVjdFN0YXJ0U3ludGF4VHlwZTogXCJSZWNvcmQgZXhwcmVzc2lvbnMgc3RhcnRpbmcgd2l0aCAnI3snIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiB0aGUgJ3N5bnRheFR5cGUnIG9wdGlvbiBvZiB0aGUgJ3JlY29yZEFuZFR1cGxlJyBwbHVnaW4gaXMgc2V0IHRvICdoYXNoJy5cIixcbiAgUmVjb3JkTm9Qcm90bzogXCInX19wcm90b19fJyBpcyBub3QgYWxsb3dlZCBpbiBSZWNvcmQgZXhwcmVzc2lvbnMuXCIsXG4gIFJlc3RUcmFpbGluZ0NvbW1hOiBcIlVuZXhwZWN0ZWQgdHJhaWxpbmcgY29tbWEgYWZ0ZXIgcmVzdCBlbGVtZW50LlwiLFxuICBTbG9wcHlGdW5jdGlvbjogXCJJbiBub24tc3RyaWN0IG1vZGUgY29kZSwgZnVuY3Rpb25zIGNhbiBvbmx5IGJlIGRlY2xhcmVkIGF0IHRvcCBsZXZlbCBvciBpbnNpZGUgYSBibG9jay5cIixcbiAgU2xvcHB5RnVuY3Rpb25Bbm5leEI6IFwiSW4gbm9uLXN0cmljdCBtb2RlIGNvZGUsIGZ1bmN0aW9ucyBjYW4gb25seSBiZSBkZWNsYXJlZCBhdCB0b3AgbGV2ZWwsIGluc2lkZSBhIGJsb2NrLCBvciBhcyB0aGUgYm9keSBvZiBhbiBpZiBzdGF0ZW1lbnQuXCIsXG4gIFNvdXJjZVBoYXNlSW1wb3J0UmVxdWlyZXNEZWZhdWx0OiAnT25seSBgaW1wb3J0IHNvdXJjZSB4IGZyb20gXCIuL21vZHVsZVwiYCBpcyB2YWxpZC4nLFxuICBTdGF0aWNQcm90b3R5cGU6IFwiQ2xhc3NlcyBtYXkgbm90IGhhdmUgc3RhdGljIHByb3BlcnR5IG5hbWVkIHByb3RvdHlwZS5cIixcbiAgU3VwZXJOb3RBbGxvd2VkOiBcImBzdXBlcigpYCBpcyBvbmx5IHZhbGlkIGluc2lkZSBhIGNsYXNzIGNvbnN0cnVjdG9yIG9mIGEgc3ViY2xhc3MuIE1heWJlIGEgdHlwbyBpbiB0aGUgbWV0aG9kIG5hbWUgKCdjb25zdHJ1Y3RvcicpIG9yIG5vdCBleHRlbmRpbmcgYW5vdGhlciBjbGFzcz9cIixcbiAgU3VwZXJQcml2YXRlRmllbGQ6IFwiUHJpdmF0ZSBmaWVsZHMgY2FuJ3QgYmUgYWNjZXNzZWQgb24gc3VwZXIuXCIsXG4gIFRyYWlsaW5nRGVjb3JhdG9yOiBcIkRlY29yYXRvcnMgbXVzdCBiZSBhdHRhY2hlZCB0byBhIGNsYXNzIGVsZW1lbnQuXCIsXG4gIFR1cGxlRXhwcmVzc2lvbkJhckluY29ycmVjdEVuZFN5bnRheFR5cGU6IFwiVHVwbGUgZXhwcmVzc2lvbnMgZW5kaW5nIHdpdGggJ3xdJyBhcmUgb25seSBhbGxvd2VkIHdoZW4gdGhlICdzeW50YXhUeXBlJyBvcHRpb24gb2YgdGhlICdyZWNvcmRBbmRUdXBsZScgcGx1Z2luIGlzIHNldCB0byAnYmFyJy5cIixcbiAgVHVwbGVFeHByZXNzaW9uQmFySW5jb3JyZWN0U3RhcnRTeW50YXhUeXBlOiBcIlR1cGxlIGV4cHJlc3Npb25zIHN0YXJ0aW5nIHdpdGggJ1t8JyBhcmUgb25seSBhbGxvd2VkIHdoZW4gdGhlICdzeW50YXhUeXBlJyBvcHRpb24gb2YgdGhlICdyZWNvcmRBbmRUdXBsZScgcGx1Z2luIGlzIHNldCB0byAnYmFyJy5cIixcbiAgVHVwbGVFeHByZXNzaW9uSGFzaEluY29ycmVjdFN0YXJ0U3ludGF4VHlwZTogXCJUdXBsZSBleHByZXNzaW9ucyBzdGFydGluZyB3aXRoICcjWycgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHRoZSAnc3ludGF4VHlwZScgb3B0aW9uIG9mIHRoZSAncmVjb3JkQW5kVHVwbGUnIHBsdWdpbiBpcyBzZXQgdG8gJ2hhc2gnLlwiLFxuICBVbmV4cGVjdGVkQXJndW1lbnRQbGFjZWhvbGRlcjogXCJVbmV4cGVjdGVkIGFyZ3VtZW50IHBsYWNlaG9sZGVyLlwiLFxuICBVbmV4cGVjdGVkQXdhaXRBZnRlclBpcGVsaW5lQm9keTogJ1VuZXhwZWN0ZWQgXCJhd2FpdFwiIGFmdGVyIHBpcGVsaW5lIGJvZHk7IGF3YWl0IG11c3QgaGF2ZSBwYXJlbnRoZXNlcyBpbiBtaW5pbWFsIHByb3Bvc2FsLicsXG4gIFVuZXhwZWN0ZWREaWdpdEFmdGVySGFzaDogXCJVbmV4cGVjdGVkIGRpZ2l0IGFmdGVyIGhhc2ggdG9rZW4uXCIsXG4gIFVuZXhwZWN0ZWRJbXBvcnRFeHBvcnQ6IFwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBvbmx5IGFwcGVhciBhdCB0aGUgdG9wIGxldmVsLlwiLFxuICBVbmV4cGVjdGVkS2V5d29yZDogKHtcbiAgICBrZXl3b3JkXG4gIH0pID0+IGBVbmV4cGVjdGVkIGtleXdvcmQgJyR7a2V5d29yZH0nLmAsXG4gIFVuZXhwZWN0ZWRMZWFkaW5nRGVjb3JhdG9yOiBcIkxlYWRpbmcgZGVjb3JhdG9ycyBtdXN0IGJlIGF0dGFjaGVkIHRvIGEgY2xhc3MgZGVjbGFyYXRpb24uXCIsXG4gIFVuZXhwZWN0ZWRMZXhpY2FsRGVjbGFyYXRpb246IFwiTGV4aWNhbCBkZWNsYXJhdGlvbiBjYW5ub3QgYXBwZWFyIGluIGEgc2luZ2xlLXN0YXRlbWVudCBjb250ZXh0LlwiLFxuICBVbmV4cGVjdGVkTmV3VGFyZ2V0OiBcImBuZXcudGFyZ2V0YCBjYW4gb25seSBiZSB1c2VkIGluIGZ1bmN0aW9ucyBvciBjbGFzcyBwcm9wZXJ0aWVzLlwiLFxuICBVbmV4cGVjdGVkTnVtZXJpY1NlcGFyYXRvcjogXCJBIG51bWVyaWMgc2VwYXJhdG9yIGlzIG9ubHkgYWxsb3dlZCBiZXR3ZWVuIHR3byBkaWdpdHMuXCIsXG4gIFVuZXhwZWN0ZWRQcml2YXRlRmllbGQ6IFwiVW5leHBlY3RlZCBwcml2YXRlIG5hbWUuXCIsXG4gIFVuZXhwZWN0ZWRSZXNlcnZlZFdvcmQ6ICh7XG4gICAgcmVzZXJ2ZWRXb3JkXG4gIH0pID0+IGBVbmV4cGVjdGVkIHJlc2VydmVkIHdvcmQgJyR7cmVzZXJ2ZWRXb3JkfScuYCxcbiAgVW5leHBlY3RlZFN1cGVyOiBcIidzdXBlcicgaXMgb25seSBhbGxvd2VkIGluIG9iamVjdCBtZXRob2RzIGFuZCBjbGFzc2VzLlwiLFxuICBVbmV4cGVjdGVkVG9rZW46ICh7XG4gICAgZXhwZWN0ZWQsXG4gICAgdW5leHBlY3RlZFxuICB9KSA9PiBgVW5leHBlY3RlZCB0b2tlbiR7dW5leHBlY3RlZCA/IGAgJyR7dW5leHBlY3RlZH0nLmAgOiBcIlwifSR7ZXhwZWN0ZWQgPyBgLCBleHBlY3RlZCBcIiR7ZXhwZWN0ZWR9XCJgIDogXCJcIn1gLFxuICBVbmV4cGVjdGVkVG9rZW5VbmFyeUV4cG9uZW50aWF0aW9uOiBcIklsbGVnYWwgZXhwcmVzc2lvbi4gV3JhcCBsZWZ0IGhhbmQgc2lkZSBvciBlbnRpcmUgZXhwb25lbnRpYXRpb24gaW4gcGFyZW50aGVzZXMuXCIsXG4gIFVuZXhwZWN0ZWRVc2luZ0RlY2xhcmF0aW9uOiBcIlVzaW5nIGRlY2xhcmF0aW9uIGNhbm5vdCBhcHBlYXIgaW4gdGhlIHRvcCBsZXZlbCB3aGVuIHNvdXJjZSB0eXBlIGlzIGBzY3JpcHRgLlwiLFxuICBVbnN1cHBvcnRlZEJpbmQ6IFwiQmluZGluZyBzaG91bGQgYmUgcGVyZm9ybWVkIG9uIG9iamVjdCBwcm9wZXJ0eS5cIixcbiAgVW5zdXBwb3J0ZWREZWNvcmF0b3JFeHBvcnQ6IFwiQSBkZWNvcmF0ZWQgZXhwb3J0IG11c3QgZXhwb3J0IGEgY2xhc3MgZGVjbGFyYXRpb24uXCIsXG4gIFVuc3VwcG9ydGVkRGVmYXVsdEV4cG9ydDogXCJPbmx5IGV4cHJlc3Npb25zLCBmdW5jdGlvbnMgb3IgY2xhc3NlcyBhcmUgYWxsb3dlZCBhcyB0aGUgYGRlZmF1bHRgIGV4cG9ydC5cIixcbiAgVW5zdXBwb3J0ZWRJbXBvcnQ6IFwiYGltcG9ydGAgY2FuIG9ubHkgYmUgdXNlZCBpbiBgaW1wb3J0KClgIG9yIGBpbXBvcnQubWV0YWAuXCIsXG4gIFVuc3VwcG9ydGVkTWV0YVByb3BlcnR5OiAoe1xuICAgIHRhcmdldCxcbiAgICBvbmx5VmFsaWRQcm9wZXJ0eU5hbWVcbiAgfSkgPT4gYFRoZSBvbmx5IHZhbGlkIG1ldGEgcHJvcGVydHkgZm9yICR7dGFyZ2V0fSBpcyAke3RhcmdldH0uJHtvbmx5VmFsaWRQcm9wZXJ0eU5hbWV9LmAsXG4gIFVuc3VwcG9ydGVkUGFyYW1ldGVyRGVjb3JhdG9yOiBcIkRlY29yYXRvcnMgY2Fubm90IGJlIHVzZWQgdG8gZGVjb3JhdGUgcGFyYW1ldGVycy5cIixcbiAgVW5zdXBwb3J0ZWRQcm9wZXJ0eURlY29yYXRvcjogXCJEZWNvcmF0b3JzIGNhbm5vdCBiZSB1c2VkIHRvIGRlY29yYXRlIG9iamVjdCBsaXRlcmFsIHByb3BlcnRpZXMuXCIsXG4gIFVuc3VwcG9ydGVkU3VwZXI6IFwiJ3N1cGVyJyBjYW4gb25seSBiZSB1c2VkIHdpdGggZnVuY3Rpb24gY2FsbHMgKGkuZS4gc3VwZXIoKSkgb3IgaW4gcHJvcGVydHkgYWNjZXNzZXMgKGkuZS4gc3VwZXIucHJvcCBvciBzdXBlcltwcm9wXSkuXCIsXG4gIFVudGVybWluYXRlZENvbW1lbnQ6IFwiVW50ZXJtaW5hdGVkIGNvbW1lbnQuXCIsXG4gIFVudGVybWluYXRlZFJlZ0V4cDogXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uLlwiLFxuICBVbnRlcm1pbmF0ZWRTdHJpbmc6IFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudC5cIixcbiAgVW50ZXJtaW5hdGVkVGVtcGxhdGU6IFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlLlwiLFxuICBVc2luZ0RlY2xhcmF0aW9uRXhwb3J0OiBcIlVzaW5nIGRlY2xhcmF0aW9uIGNhbm5vdCBiZSBleHBvcnRlZC5cIixcbiAgVXNpbmdEZWNsYXJhdGlvbkhhc0JpbmRpbmdQYXR0ZXJuOiBcIlVzaW5nIGRlY2xhcmF0aW9uIGNhbm5vdCBoYXZlIGRlc3RydWN0dXJpbmcgcGF0dGVybnMuXCIsXG4gIFZhclJlZGVjbGFyYXRpb246ICh7XG4gICAgaWRlbnRpZmllck5hbWVcbiAgfSkgPT4gYElkZW50aWZpZXIgJyR7aWRlbnRpZmllck5hbWV9JyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkLmAsXG4gIFlpZWxkQmluZGluZ0lkZW50aWZpZXI6IFwiQ2FuIG5vdCB1c2UgJ3lpZWxkJyBhcyBpZGVudGlmaWVyIGluc2lkZSBhIGdlbmVyYXRvci5cIixcbiAgWWllbGRJblBhcmFtZXRlcjogXCJZaWVsZCBleHByZXNzaW9uIGlzIG5vdCBhbGxvd2VkIGluIGZvcm1hbCBwYXJhbWV0ZXJzLlwiLFxuICBZaWVsZE5vdEluR2VuZXJhdG9yRnVuY3Rpb246IFwiJ3lpZWxkJyBpcyBvbmx5IGFsbG93ZWQgd2l0aGluIGdlbmVyYXRvciBmdW5jdGlvbnMuXCIsXG4gIFplcm9EaWdpdE51bWVyaWNTZXBhcmF0b3I6IFwiTnVtZXJpYyBzZXBhcmF0b3IgY2FuIG5vdCBiZSB1c2VkIGFmdGVyIGxlYWRpbmcgMC5cIlxufTtcbnZhciBTdHJpY3RNb2RlRXJyb3JzID0ge1xuICBTdHJpY3REZWxldGU6IFwiRGVsZXRpbmcgbG9jYWwgdmFyaWFibGUgaW4gc3RyaWN0IG1vZGUuXCIsXG4gIFN0cmljdEV2YWxBcmd1bWVudHM6ICh7XG4gICAgcmVmZXJlbmNlTmFtZVxuICB9KSA9PiBgQXNzaWduaW5nIHRvICcke3JlZmVyZW5jZU5hbWV9JyBpbiBzdHJpY3QgbW9kZS5gLFxuICBTdHJpY3RFdmFsQXJndW1lbnRzQmluZGluZzogKHtcbiAgICBiaW5kaW5nTmFtZVxuICB9KSA9PiBgQmluZGluZyAnJHtiaW5kaW5nTmFtZX0nIGluIHN0cmljdCBtb2RlLmAsXG4gIFN0cmljdEZ1bmN0aW9uOiBcIkluIHN0cmljdCBtb2RlIGNvZGUsIGZ1bmN0aW9ucyBjYW4gb25seSBiZSBkZWNsYXJlZCBhdCB0b3AgbGV2ZWwgb3IgaW5zaWRlIGEgYmxvY2suXCIsXG4gIFN0cmljdE51bWVyaWNFc2NhcGU6IFwiVGhlIG9ubHkgdmFsaWQgbnVtZXJpYyBlc2NhcGUgaW4gc3RyaWN0IG1vZGUgaXMgJ1xcXFwwJy5cIixcbiAgU3RyaWN0T2N0YWxMaXRlcmFsOiBcIkxlZ2FjeSBvY3RhbCBsaXRlcmFscyBhcmUgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUuXCIsXG4gIFN0cmljdFdpdGg6IFwiJ3dpdGgnIGluIHN0cmljdCBtb2RlLlwiXG59O1xuY29uc3QgVW5wYXJlbnRoZXNpemVkUGlwZUJvZHlEZXNjcmlwdGlvbnMgPSBuZXcgU2V0KFtcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIsIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiwgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiwgXCJZaWVsZEV4cHJlc3Npb25cIl0pO1xudmFyIFBpcGVsaW5lT3BlcmF0b3JFcnJvcnMgPSBPYmplY3QuYXNzaWduKHtcbiAgUGlwZUJvZHlJc1RpZ2h0ZXI6IFwiVW5leHBlY3RlZCB5aWVsZCBhZnRlciBwaXBlbGluZSBib2R5OyBhbnkgeWllbGQgZXhwcmVzc2lvbiBhY3RpbmcgYXMgSGFjay1zdHlsZSBwaXBlIGJvZHkgbXVzdCBiZSBwYXJlbnRoZXNpemVkIGR1ZSB0byBpdHMgbG9vc2Ugb3BlcmF0b3IgcHJlY2VkZW5jZS5cIixcbiAgUGlwZVRvcGljUmVxdWlyZXNIYWNrUGlwZXM6ICdUb3BpYyByZWZlcmVuY2UgaXMgdXNlZCwgYnV0IHRoZSBwaXBlbGluZU9wZXJhdG9yIHBsdWdpbiB3YXMgbm90IHBhc3NlZCBhIFwicHJvcG9zYWxcIjogXCJoYWNrXCIgb3IgXCJzbWFydFwiIG9wdGlvbi4nLFxuICBQaXBlVG9waWNVbmJvdW5kOiBcIlRvcGljIHJlZmVyZW5jZSBpcyB1bmJvdW5kOyBpdCBtdXN0IGJlIGluc2lkZSBhIHBpcGUgYm9keS5cIixcbiAgUGlwZVRvcGljVW5jb25maWd1cmVkVG9rZW46ICh7XG4gICAgdG9rZW5cbiAgfSkgPT4gYEludmFsaWQgdG9waWMgdG9rZW4gJHt0b2tlbn0uIEluIG9yZGVyIHRvIHVzZSAke3Rva2VufSBhcyBhIHRvcGljIHJlZmVyZW5jZSwgdGhlIHBpcGVsaW5lT3BlcmF0b3IgcGx1Z2luIG11c3QgYmUgY29uZmlndXJlZCB3aXRoIHsgXCJwcm9wb3NhbFwiOiBcImhhY2tcIiwgXCJ0b3BpY1Rva2VuXCI6IFwiJHt0b2tlbn1cIiB9LmAsXG4gIFBpcGVUb3BpY1VudXNlZDogXCJIYWNrLXN0eWxlIHBpcGUgYm9keSBkb2VzIG5vdCBjb250YWluIGEgdG9waWMgcmVmZXJlbmNlOyBIYWNrLXN0eWxlIHBpcGVzIG11c3QgdXNlIHRvcGljIGF0IGxlYXN0IG9uY2UuXCIsXG4gIFBpcGVVbnBhcmVudGhlc2l6ZWRCb2R5OiAoe1xuICAgIHR5cGVcbiAgfSkgPT4gYEhhY2stc3R5bGUgcGlwZSBib2R5IGNhbm5vdCBiZSBhbiB1bnBhcmVudGhlc2l6ZWQgJHt0b05vZGVEZXNjcmlwdGlvbih7XG4gICAgdHlwZVxuICB9KX07IHBsZWFzZSB3cmFwIGl0IGluIHBhcmVudGhlc2VzLmBcbn0sIHtcbiAgUGlwZWxpbmVCb2R5Tm9BcnJvdzogJ1VuZXhwZWN0ZWQgYXJyb3cgXCI9PlwiIGFmdGVyIHBpcGVsaW5lIGJvZHk7IGFycm93IGZ1bmN0aW9uIGluIHBpcGVsaW5lIGJvZHkgbXVzdCBiZSBwYXJlbnRoZXNpemVkLicsXG4gIFBpcGVsaW5lQm9keVNlcXVlbmNlRXhwcmVzc2lvbjogXCJQaXBlbGluZSBib2R5IG1heSBub3QgYmUgYSBjb21tYS1zZXBhcmF0ZWQgc2VxdWVuY2UgZXhwcmVzc2lvbi5cIixcbiAgUGlwZWxpbmVIZWFkU2VxdWVuY2VFeHByZXNzaW9uOiBcIlBpcGVsaW5lIGhlYWQgc2hvdWxkIG5vdCBiZSBhIGNvbW1hLXNlcGFyYXRlZCBzZXF1ZW5jZSBleHByZXNzaW9uLlwiLFxuICBQaXBlbGluZVRvcGljVW51c2VkOiBcIlBpcGVsaW5lIGlzIGluIHRvcGljIHN0eWxlIGJ1dCBkb2VzIG5vdCB1c2UgdG9waWMgcmVmZXJlbmNlLlwiLFxuICBQcmltYXJ5VG9waWNOb3RBbGxvd2VkOiBcIlRvcGljIHJlZmVyZW5jZSB3YXMgdXNlZCBpbiBhIGxleGljYWwgY29udGV4dCB3aXRob3V0IHRvcGljIGJpbmRpbmcuXCIsXG4gIFByaW1hcnlUb3BpY1JlcXVpcmVzU21hcnRQaXBlbGluZTogJ1RvcGljIHJlZmVyZW5jZSBpcyB1c2VkLCBidXQgdGhlIHBpcGVsaW5lT3BlcmF0b3IgcGx1Z2luIHdhcyBub3QgcGFzc2VkIGEgXCJwcm9wb3NhbFwiOiBcImhhY2tcIiBvciBcInNtYXJ0XCIgb3B0aW9uLidcbn0pO1xuY29uc3QgX2V4Y2x1ZGVkID0gW1wibWVzc2FnZVwiXTtcbmZ1bmN0aW9uIGRlZmluZUhpZGRlbihvYmosIGtleSwgdmFsdWUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlXG4gIH0pO1xufVxuZnVuY3Rpb24gdG9QYXJzZUVycm9yQ29uc3RydWN0b3Ioe1xuICB0b01lc3NhZ2UsXG4gIGNvZGUsXG4gIHJlYXNvbkNvZGUsXG4gIHN5bnRheFBsdWdpblxufSkge1xuICBjb25zdCBoYXNNaXNzaW5nUGx1Z2luID0gcmVhc29uQ29kZSA9PT0gXCJNaXNzaW5nUGx1Z2luXCIgfHwgcmVhc29uQ29kZSA9PT0gXCJNaXNzaW5nT25lT2ZQbHVnaW5zXCI7XG4gIHtcbiAgICBjb25zdCBvbGRSZWFzb25Db2RlcyA9IHtcbiAgICAgIEFjY2Vzc29yQ2Fubm90RGVjbGFyZVRoaXNQYXJhbWV0ZXI6IFwiQWNjZXNvckNhbm5vdERlY2xhcmVUaGlzUGFyYW1ldGVyXCIsXG4gICAgICBBY2Nlc3NvckNhbm5vdEhhdmVUeXBlUGFyYW1ldGVyczogXCJBY2Nlc29yQ2Fubm90SGF2ZVR5cGVQYXJhbWV0ZXJzXCIsXG4gICAgICBDb25zdEluaXRpYWxpemVyTXVzdEJlU3RyaW5nT3JOdW1lcmljTGl0ZXJhbE9yTGl0ZXJhbEVudW1SZWZlcmVuY2U6IFwiQ29uc3RJbml0aWFpbGl6ZXJNdXN0QmVTdHJpbmdPck51bWVyaWNMaXRlcmFsT3JMaXRlcmFsRW51bVJlZmVyZW5jZVwiLFxuICAgICAgU2V0QWNjZXNzb3JDYW5ub3RIYXZlT3B0aW9uYWxQYXJhbWV0ZXI6IFwiU2V0QWNjZXNvckNhbm5vdEhhdmVPcHRpb25hbFBhcmFtZXRlclwiLFxuICAgICAgU2V0QWNjZXNzb3JDYW5ub3RIYXZlUmVzdFBhcmFtZXRlcjogXCJTZXRBY2Nlc29yQ2Fubm90SGF2ZVJlc3RQYXJhbWV0ZXJcIixcbiAgICAgIFNldEFjY2Vzc29yQ2Fubm90SGF2ZVJldHVyblR5cGU6IFwiU2V0QWNjZXNvckNhbm5vdEhhdmVSZXR1cm5UeXBlXCJcbiAgICB9O1xuICAgIGlmIChvbGRSZWFzb25Db2Rlc1tyZWFzb25Db2RlXSkge1xuICAgICAgcmVhc29uQ29kZSA9IG9sZFJlYXNvbkNvZGVzW3JlYXNvbkNvZGVdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0b3IobG9jLCBkZXRhaWxzKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgICBlcnJvci5yZWFzb25Db2RlID0gcmVhc29uQ29kZTtcbiAgICBlcnJvci5sb2MgPSBsb2M7XG4gICAgZXJyb3IucG9zID0gbG9jLmluZGV4O1xuICAgIGVycm9yLnN5bnRheFBsdWdpbiA9IHN5bnRheFBsdWdpbjtcbiAgICBpZiAoaGFzTWlzc2luZ1BsdWdpbikge1xuICAgICAgZXJyb3IubWlzc2luZ1BsdWdpbiA9IGRldGFpbHMubWlzc2luZ1BsdWdpbjtcbiAgICB9XG4gICAgZGVmaW5lSGlkZGVuKGVycm9yLCBcImNsb25lXCIsIGZ1bmN0aW9uIGNsb25lKG92ZXJyaWRlcyA9IHt9KSB7XG4gICAgICB2YXIgX292ZXJyaWRlcyRsb2M7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIGNvbHVtbixcbiAgICAgICAgaW5kZXhcbiAgICAgIH0gPSAoX292ZXJyaWRlcyRsb2MgPSBvdmVycmlkZXMubG9jKSAhPSBudWxsID8gX292ZXJyaWRlcyRsb2MgOiBsb2M7XG4gICAgICByZXR1cm4gY29uc3RydWN0b3IobmV3IFBvc2l0aW9uKGxpbmUsIGNvbHVtbiwgaW5kZXgpLCBPYmplY3QuYXNzaWduKHt9LCBkZXRhaWxzLCBvdmVycmlkZXMuZGV0YWlscykpO1xuICAgIH0pO1xuICAgIGRlZmluZUhpZGRlbihlcnJvciwgXCJkZXRhaWxzXCIsIGRldGFpbHMpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvciwgXCJtZXNzYWdlXCIsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGAke3RvTWVzc2FnZShkZXRhaWxzKX0gKCR7bG9jLmxpbmV9OiR7bG9jLmNvbHVtbn0pYDtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9LFxuICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1lc3NhZ2VcIiwge1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcjtcbiAgfTtcbn1cbmZ1bmN0aW9uIFBhcnNlRXJyb3JFbnVtKGFyZ3VtZW50LCBzeW50YXhQbHVnaW4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnQpKSB7XG4gICAgcmV0dXJuIHBhcnNlRXJyb3JUZW1wbGF0ZXMgPT4gUGFyc2VFcnJvckVudW0ocGFyc2VFcnJvclRlbXBsYXRlcywgYXJndW1lbnRbMF0pO1xuICB9XG4gIGNvbnN0IFBhcnNlRXJyb3JDb25zdHJ1Y3RvcnMgPSB7fTtcbiAgZm9yIChjb25zdCByZWFzb25Db2RlIG9mIE9iamVjdC5rZXlzKGFyZ3VtZW50KSkge1xuICAgIGNvbnN0IHRlbXBsYXRlID0gYXJndW1lbnRbcmVhc29uQ29kZV07XG4gICAgY29uc3QgX3JlZiA9IHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJzdHJpbmdcIiA/IHtcbiAgICAgICAgbWVzc2FnZTogKCkgPT4gdGVtcGxhdGVcbiAgICAgIH0gOiB0eXBlb2YgdGVtcGxhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHtcbiAgICAgICAgbWVzc2FnZTogdGVtcGxhdGVcbiAgICAgIH0gOiB0ZW1wbGF0ZSxcbiAgICAgIHtcbiAgICAgICAgbWVzc2FnZVxuICAgICAgfSA9IF9yZWYsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgX2V4Y2x1ZGVkKTtcbiAgICBjb25zdCB0b01lc3NhZ2UgPSB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/ICgpID0+IG1lc3NhZ2UgOiBtZXNzYWdlO1xuICAgIFBhcnNlRXJyb3JDb25zdHJ1Y3RvcnNbcmVhc29uQ29kZV0gPSB0b1BhcnNlRXJyb3JDb25zdHJ1Y3RvcihPYmplY3QuYXNzaWduKHtcbiAgICAgIGNvZGU6IFwiQkFCRUxfUEFSU0VSX1NZTlRBWF9FUlJPUlwiLFxuICAgICAgcmVhc29uQ29kZSxcbiAgICAgIHRvTWVzc2FnZVxuICAgIH0sIHN5bnRheFBsdWdpbiA/IHtcbiAgICAgIHN5bnRheFBsdWdpblxuICAgIH0gOiB7fSwgcmVzdCkpO1xuICB9XG4gIHJldHVybiBQYXJzZUVycm9yQ29uc3RydWN0b3JzO1xufVxuY29uc3QgRXJyb3JzID0gT2JqZWN0LmFzc2lnbih7fSwgUGFyc2VFcnJvckVudW0oTW9kdWxlRXJyb3JzKSwgUGFyc2VFcnJvckVudW0oU3RhbmRhcmRFcnJvcnMpLCBQYXJzZUVycm9yRW51bShTdHJpY3RNb2RlRXJyb3JzKSwgUGFyc2VFcnJvckVudW1gcGlwZWxpbmVPcGVyYXRvcmAoUGlwZWxpbmVPcGVyYXRvckVycm9ycykpO1xuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdE9wdGlvbnMoKSB7XG4gIHJldHVybiB7XG4gICAgc291cmNlVHlwZTogXCJzY3JpcHRcIixcbiAgICBzb3VyY2VGaWxlbmFtZTogdW5kZWZpbmVkLFxuICAgIHN0YXJ0SW5kZXg6IDAsXG4gICAgc3RhcnRDb2x1bW46IDAsXG4gICAgc3RhcnRMaW5lOiAxLFxuICAgIGFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuICAgIGFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcbiAgICBhbGxvd05ld1RhcmdldE91dHNpZGVGdW5jdGlvbjogZmFsc2UsXG4gICAgYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlOiBmYWxzZSxcbiAgICBhbGxvd1N1cGVyT3V0c2lkZU1ldGhvZDogZmFsc2UsXG4gICAgYWxsb3dVbmRlY2xhcmVkRXhwb3J0czogZmFsc2UsXG4gICAgYWxsb3dZaWVsZE91dHNpZGVGdW5jdGlvbjogZmFsc2UsXG4gICAgcGx1Z2luczogW10sXG4gICAgc3RyaWN0TW9kZTogbnVsbCxcbiAgICByYW5nZXM6IGZhbHNlLFxuICAgIHRva2VuczogZmFsc2UsXG4gICAgY3JlYXRlSW1wb3J0RXhwcmVzc2lvbnM6IGZhbHNlLFxuICAgIGNyZWF0ZVBhcmVudGhlc2l6ZWRFeHByZXNzaW9uczogZmFsc2UsXG4gICAgZXJyb3JSZWNvdmVyeTogZmFsc2UsXG4gICAgYXR0YWNoQ29tbWVudDogdHJ1ZSxcbiAgICBhbm5leEI6IHRydWVcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldE9wdGlvbnMob3B0cykge1xuICBjb25zdCBvcHRpb25zID0gY3JlYXRlRGVmYXVsdE9wdGlvbnMoKTtcbiAgaWYgKG9wdHMgPT0gbnVsbCkge1xuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG4gIGlmIChvcHRzLmFubmV4QiAhPSBudWxsICYmIG9wdHMuYW5uZXhCICE9PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgYW5uZXhCYCBvcHRpb24gY2FuIG9ubHkgYmUgc2V0IHRvIGBmYWxzZWAuXCIpO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9wdGlvbnMpKSB7XG4gICAgaWYgKG9wdHNba2V5XSAhPSBudWxsKSBvcHRpb25zW2tleV0gPSBvcHRzW2tleV07XG4gIH1cbiAgaWYgKG9wdGlvbnMuc3RhcnRMaW5lID09PSAxKSB7XG4gICAgaWYgKG9wdHMuc3RhcnRJbmRleCA9PSBudWxsICYmIG9wdGlvbnMuc3RhcnRDb2x1bW4gPiAwKSB7XG4gICAgICBvcHRpb25zLnN0YXJ0SW5kZXggPSBvcHRpb25zLnN0YXJ0Q29sdW1uO1xuICAgIH0gZWxzZSBpZiAob3B0cy5zdGFydENvbHVtbiA9PSBudWxsICYmIG9wdGlvbnMuc3RhcnRJbmRleCA+IDApIHtcbiAgICAgIG9wdGlvbnMuc3RhcnRDb2x1bW4gPSBvcHRpb25zLnN0YXJ0SW5kZXg7XG4gICAgfVxuICB9IGVsc2UgaWYgKG9wdHMuc3RhcnRDb2x1bW4gPT0gbnVsbCB8fCBvcHRzLnN0YXJ0SW5kZXggPT0gbnVsbCkge1xuICAgIGlmIChvcHRzLnN0YXJ0SW5kZXggIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2l0aCBhIGBzdGFydExpbmUgPiAxYCB5b3UgbXVzdCBhbHNvIHNwZWNpZnkgYHN0YXJ0SW5kZXhgIGFuZCBgc3RhcnRDb2x1bW5gLlwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5jb25zdCB7XG4gIGRlZmluZVByb3BlcnR5XG59ID0gT2JqZWN0O1xuY29uc3QgdG9VbmVudW1lcmFibGUgPSAob2JqZWN0LCBrZXkpID0+IHtcbiAgaWYgKG9iamVjdCkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBvYmplY3Rba2V5XVxuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gdG9FU1RyZWVMb2NhdGlvbihub2RlKSB7XG4gIHRvVW5lbnVtZXJhYmxlKG5vZGUubG9jLnN0YXJ0LCBcImluZGV4XCIpO1xuICB0b1VuZW51bWVyYWJsZShub2RlLmxvYy5lbmQsIFwiaW5kZXhcIik7XG4gIHJldHVybiBub2RlO1xufVxudmFyIGVzdHJlZSA9IHN1cGVyQ2xhc3MgPT4gY2xhc3MgRVNUcmVlUGFyc2VyTWl4aW4gZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgcGFyc2UoKSB7XG4gICAgY29uc3QgZmlsZSA9IHRvRVNUcmVlTG9jYXRpb24oc3VwZXIucGFyc2UoKSk7XG4gICAgaWYgKHRoaXMub3B0aW9uRmxhZ3MgJiAyNTYpIHtcbiAgICAgIGZpbGUudG9rZW5zID0gZmlsZS50b2tlbnMubWFwKHRvRVNUcmVlTG9jYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gZmlsZTtcbiAgfVxuICBwYXJzZVJlZ0V4cExpdGVyYWwoe1xuICAgIHBhdHRlcm4sXG4gICAgZmxhZ3NcbiAgfSkge1xuICAgIGxldCByZWdleCA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gICAgfSBjYXRjaCAoXykge31cbiAgICBjb25zdCBub2RlID0gdGhpcy5lc3RyZWVQYXJzZUxpdGVyYWwocmVnZXgpO1xuICAgIG5vZGUucmVnZXggPSB7XG4gICAgICBwYXR0ZXJuLFxuICAgICAgZmxhZ3NcbiAgICB9O1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHBhcnNlQmlnSW50TGl0ZXJhbCh2YWx1ZSkge1xuICAgIGxldCBiaWdJbnQ7XG4gICAgdHJ5IHtcbiAgICAgIGJpZ0ludCA9IEJpZ0ludCh2YWx1ZSk7XG4gICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgYmlnSW50ID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKGJpZ0ludCk7XG4gICAgbm9kZS5iaWdpbnQgPSBTdHJpbmcobm9kZS52YWx1ZSB8fCB2YWx1ZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcGFyc2VEZWNpbWFsTGl0ZXJhbCh2YWx1ZSkge1xuICAgIGNvbnN0IGRlY2ltYWwgPSBudWxsO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmVzdHJlZVBhcnNlTGl0ZXJhbChkZWNpbWFsKTtcbiAgICBub2RlLmRlY2ltYWwgPSBTdHJpbmcobm9kZS52YWx1ZSB8fCB2YWx1ZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgZXN0cmVlUGFyc2VMaXRlcmFsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHZhbHVlLCBcIkxpdGVyYWxcIik7XG4gIH1cbiAgcGFyc2VTdHJpbmdMaXRlcmFsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKHZhbHVlKTtcbiAgfVxuICBwYXJzZU51bWVyaWNMaXRlcmFsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKHZhbHVlKTtcbiAgfVxuICBwYXJzZU51bGxMaXRlcmFsKCkge1xuICAgIHJldHVybiB0aGlzLmVzdHJlZVBhcnNlTGl0ZXJhbChudWxsKTtcbiAgfVxuICBwYXJzZUJvb2xlYW5MaXRlcmFsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKHZhbHVlKTtcbiAgfVxuICBkaXJlY3RpdmVUb1N0bXQoZGlyZWN0aXZlKSB7XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IGRpcmVjdGl2ZS52YWx1ZTtcbiAgICBkZWxldGUgZGlyZWN0aXZlLnZhbHVlO1xuICAgIGV4cHJlc3Npb24udHlwZSA9IFwiTGl0ZXJhbFwiO1xuICAgIGV4cHJlc3Npb24ucmF3ID0gZXhwcmVzc2lvbi5leHRyYS5yYXc7XG4gICAgZXhwcmVzc2lvbi52YWx1ZSA9IGV4cHJlc3Npb24uZXh0cmEuZXhwcmVzc2lvblZhbHVlO1xuICAgIGNvbnN0IHN0bXQgPSBkaXJlY3RpdmU7XG4gICAgc3RtdC50eXBlID0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCI7XG4gICAgc3RtdC5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICBzdG10LmRpcmVjdGl2ZSA9IGV4cHJlc3Npb24uZXh0cmEucmF3VmFsdWU7XG4gICAgZGVsZXRlIGV4cHJlc3Npb24uZXh0cmE7XG4gICAgcmV0dXJuIHN0bXQ7XG4gIH1cbiAgaW5pdEZ1bmN0aW9uKG5vZGUsIGlzQXN5bmMpIHtcbiAgICBzdXBlci5pbml0RnVuY3Rpb24obm9kZSwgaXNBc3luYyk7XG4gICAgbm9kZS5leHByZXNzaW9uID0gZmFsc2U7XG4gIH1cbiAgY2hlY2tEZWNsYXJhdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUgIT0gbnVsbCAmJiB0aGlzLmlzT2JqZWN0UHJvcGVydHkobm9kZSkpIHtcbiAgICAgIHRoaXMuY2hlY2tEZWNsYXJhdGlvbihub2RlLnZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuY2hlY2tEZWNsYXJhdGlvbihub2RlKTtcbiAgICB9XG4gIH1cbiAgZ2V0T2JqZWN0T3JDbGFzc01ldGhvZFBhcmFtcyhtZXRob2QpIHtcbiAgICByZXR1cm4gbWV0aG9kLnZhbHVlLnBhcmFtcztcbiAgfVxuICBpc1ZhbGlkRGlyZWN0aXZlKHN0bXQpIHtcbiAgICB2YXIgX3N0bXQkZXhwcmVzc2lvbiRleHRyO1xuICAgIHJldHVybiBzdG10LnR5cGUgPT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiICYmIHN0bXQuZXhwcmVzc2lvbi50eXBlID09PSBcIkxpdGVyYWxcIiAmJiB0eXBlb2Ygc3RtdC5leHByZXNzaW9uLnZhbHVlID09PSBcInN0cmluZ1wiICYmICEoKF9zdG10JGV4cHJlc3Npb24kZXh0ciA9IHN0bXQuZXhwcmVzc2lvbi5leHRyYSkgIT0gbnVsbCAmJiBfc3RtdCRleHByZXNzaW9uJGV4dHIucGFyZW50aGVzaXplZCk7XG4gIH1cbiAgcGFyc2VCbG9ja0JvZHkobm9kZSwgYWxsb3dEaXJlY3RpdmVzLCB0b3BMZXZlbCwgZW5kLCBhZnRlckJsb2NrUGFyc2UpIHtcbiAgICBzdXBlci5wYXJzZUJsb2NrQm9keShub2RlLCBhbGxvd0RpcmVjdGl2ZXMsIHRvcExldmVsLCBlbmQsIGFmdGVyQmxvY2tQYXJzZSk7XG4gICAgY29uc3QgZGlyZWN0aXZlU3RhdGVtZW50cyA9IG5vZGUuZGlyZWN0aXZlcy5tYXAoZCA9PiB0aGlzLmRpcmVjdGl2ZVRvU3RtdChkKSk7XG4gICAgbm9kZS5ib2R5ID0gZGlyZWN0aXZlU3RhdGVtZW50cy5jb25jYXQobm9kZS5ib2R5KTtcbiAgICBkZWxldGUgbm9kZS5kaXJlY3RpdmVzO1xuICB9XG4gIHBhcnNlUHJpdmF0ZU5hbWUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHN1cGVyLnBhcnNlUHJpdmF0ZU5hbWUoKTtcbiAgICB7XG4gICAgICBpZiAoIXRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZXN0cmVlXCIsIFwiY2xhc3NGZWF0dXJlc1wiKSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udmVydFByaXZhdGVOYW1lVG9Qcml2YXRlSWRlbnRpZmllcihub2RlKTtcbiAgfVxuICBjb252ZXJ0UHJpdmF0ZU5hbWVUb1ByaXZhdGVJZGVudGlmaWVyKG5vZGUpIHtcbiAgICBjb25zdCBuYW1lID0gc3VwZXIuZ2V0UHJpdmF0ZU5hbWVTVihub2RlKTtcbiAgICBub2RlID0gbm9kZTtcbiAgICBkZWxldGUgbm9kZS5pZDtcbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICAgIG5vZGUudHlwZSA9IFwiUHJpdmF0ZUlkZW50aWZpZXJcIjtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBpc1ByaXZhdGVOYW1lKG5vZGUpIHtcbiAgICB7XG4gICAgICBpZiAoIXRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZXN0cmVlXCIsIFwiY2xhc3NGZWF0dXJlc1wiKSkge1xuICAgICAgICByZXR1cm4gc3VwZXIuaXNQcml2YXRlTmFtZShub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJQcml2YXRlSWRlbnRpZmllclwiO1xuICB9XG4gIGdldFByaXZhdGVOYW1lU1Yobm9kZSkge1xuICAgIHtcbiAgICAgIGlmICghdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJlc3RyZWVcIiwgXCJjbGFzc0ZlYXR1cmVzXCIpKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5nZXRQcml2YXRlTmFtZVNWKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZS5uYW1lO1xuICB9XG4gIHBhcnNlTGl0ZXJhbCh2YWx1ZSwgdHlwZSkge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5wYXJzZUxpdGVyYWwodmFsdWUsIHR5cGUpO1xuICAgIG5vZGUucmF3ID0gbm9kZS5leHRyYS5yYXc7XG4gICAgZGVsZXRlIG5vZGUuZXh0cmE7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgYWxsb3dFeHByZXNzaW9uLCBpc01ldGhvZCA9IGZhbHNlKSB7XG4gICAgc3VwZXIucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgYWxsb3dFeHByZXNzaW9uLCBpc01ldGhvZCk7XG4gICAgbm9kZS5leHByZXNzaW9uID0gbm9kZS5ib2R5LnR5cGUgIT09IFwiQmxvY2tTdGF0ZW1lbnRcIjtcbiAgfVxuICBwYXJzZU1ldGhvZChub2RlLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNDb25zdHJ1Y3RvciwgYWxsb3dEaXJlY3RTdXBlciwgdHlwZSwgaW5DbGFzc1Njb3BlID0gZmFsc2UpIHtcbiAgICBsZXQgZnVuY05vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGZ1bmNOb2RlLmtpbmQgPSBub2RlLmtpbmQ7XG4gICAgZnVuY05vZGUgPSBzdXBlci5wYXJzZU1ldGhvZChmdW5jTm9kZSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93RGlyZWN0U3VwZXIsIHR5cGUsIGluQ2xhc3NTY29wZSk7XG4gICAgZnVuY05vZGUudHlwZSA9IFwiRnVuY3Rpb25FeHByZXNzaW9uXCI7XG4gICAgZGVsZXRlIGZ1bmNOb2RlLmtpbmQ7XG4gICAgbm9kZS52YWx1ZSA9IGZ1bmNOb2RlO1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVQYXJhbWV0ZXJzXG4gICAgfSA9IG5vZGU7XG4gICAgaWYgKHR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgICBkZWxldGUgbm9kZS50eXBlUGFyYW1ldGVycztcbiAgICAgIGZ1bmNOb2RlLnR5cGVQYXJhbWV0ZXJzID0gdHlwZVBhcmFtZXRlcnM7XG4gICAgICB0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbkZyb21Ob2RlKGZ1bmNOb2RlLCB0eXBlUGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiKSB7XG4gICAgICBub2RlLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZXRob2REZWZpbml0aW9uXCIpO1xuICB9XG4gIG5hbWVJc0NvbnN0cnVjdG9yKGtleSkge1xuICAgIGlmIChrZXkudHlwZSA9PT0gXCJMaXRlcmFsXCIpIHJldHVybiBrZXkudmFsdWUgPT09IFwiY29uc3RydWN0b3JcIjtcbiAgICByZXR1cm4gc3VwZXIubmFtZUlzQ29uc3RydWN0b3Ioa2V5KTtcbiAgfVxuICBwYXJzZUNsYXNzUHJvcGVydHkoLi4uYXJncykge1xuICAgIGNvbnN0IHByb3BlcnR5Tm9kZSA9IHN1cGVyLnBhcnNlQ2xhc3NQcm9wZXJ0eSguLi5hcmdzKTtcbiAgICB7XG4gICAgICBpZiAoIXRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZXN0cmVlXCIsIFwiY2xhc3NGZWF0dXJlc1wiKSkge1xuICAgICAgICByZXR1cm4gcHJvcGVydHlOb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICBwcm9wZXJ0eU5vZGUudHlwZSA9IFwiUHJvcGVydHlEZWZpbml0aW9uXCI7XG4gICAgfVxuICAgIHJldHVybiBwcm9wZXJ0eU5vZGU7XG4gIH1cbiAgcGFyc2VDbGFzc1ByaXZhdGVQcm9wZXJ0eSguLi5hcmdzKSB7XG4gICAgY29uc3QgcHJvcGVydHlOb2RlID0gc3VwZXIucGFyc2VDbGFzc1ByaXZhdGVQcm9wZXJ0eSguLi5hcmdzKTtcbiAgICB7XG4gICAgICBpZiAoIXRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZXN0cmVlXCIsIFwiY2xhc3NGZWF0dXJlc1wiKSkge1xuICAgICAgICByZXR1cm4gcHJvcGVydHlOb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICBwcm9wZXJ0eU5vZGUudHlwZSA9IFwiUHJvcGVydHlEZWZpbml0aW9uXCI7XG4gICAgfVxuICAgIHByb3BlcnR5Tm9kZS5jb21wdXRlZCA9IGZhbHNlO1xuICAgIHJldHVybiBwcm9wZXJ0eU5vZGU7XG4gIH1cbiAgcGFyc2VDbGFzc0FjY2Vzc29yUHJvcGVydHkobm9kZSkge1xuICAgIGNvbnN0IGFjY2Vzc29yUHJvcGVydHlOb2RlID0gc3VwZXIucGFyc2VDbGFzc0FjY2Vzc29yUHJvcGVydHkobm9kZSk7XG4gICAge1xuICAgICAgaWYgKCF0aGlzLmdldFBsdWdpbk9wdGlvbihcImVzdHJlZVwiLCBcImNsYXNzRmVhdHVyZXNcIikpIHtcbiAgICAgICAgcmV0dXJuIGFjY2Vzc29yUHJvcGVydHlOb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBhY2Nlc3NvclByb3BlcnR5Tm9kZS50eXBlID0gXCJBY2Nlc3NvclByb3BlcnR5XCI7XG4gICAgcmV0dXJuIGFjY2Vzc29yUHJvcGVydHlOb2RlO1xuICB9XG4gIHBhcnNlT2JqZWN0TWV0aG9kKHByb3AsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc1BhdHRlcm4sIGlzQWNjZXNzb3IpIHtcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VPYmplY3RNZXRob2QocHJvcCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzUGF0dGVybiwgaXNBY2Nlc3Nvcik7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIG5vZGUudHlwZSA9IFwiUHJvcGVydHlcIjtcbiAgICAgIGlmIChub2RlLmtpbmQgPT09IFwibWV0aG9kXCIpIHtcbiAgICAgICAgbm9kZS5raW5kID0gXCJpbml0XCI7XG4gICAgICB9XG4gICAgICBub2RlLnNob3J0aGFuZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBwYXJzZU9iamVjdFByb3BlcnR5KHByb3AsIHN0YXJ0TG9jLCBpc1BhdHRlcm4sIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VPYmplY3RQcm9wZXJ0eShwcm9wLCBzdGFydExvYywgaXNQYXR0ZXJuLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZS5raW5kID0gXCJpbml0XCI7XG4gICAgICBub2RlLnR5cGUgPSBcIlByb3BlcnR5XCI7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGlzVmFsaWRMVmFsKHR5cGUsIGlzVW5wYXJlbnRoZXNpemVkSW5Bc3NpZ24sIGJpbmRpbmcpIHtcbiAgICByZXR1cm4gdHlwZSA9PT0gXCJQcm9wZXJ0eVwiID8gXCJ2YWx1ZVwiIDogc3VwZXIuaXNWYWxpZExWYWwodHlwZSwgaXNVbnBhcmVudGhlc2l6ZWRJbkFzc2lnbiwgYmluZGluZyk7XG4gIH1cbiAgaXNBc3NpZ25hYmxlKG5vZGUsIGlzQmluZGluZykge1xuICAgIGlmIChub2RlICE9IG51bGwgJiYgdGhpcy5pc09iamVjdFByb3BlcnR5KG5vZGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0Fzc2lnbmFibGUobm9kZS52YWx1ZSwgaXNCaW5kaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzQXNzaWduYWJsZShub2RlLCBpc0JpbmRpbmcpO1xuICB9XG4gIHRvQXNzaWduYWJsZShub2RlLCBpc0xIUyA9IGZhbHNlKSB7XG4gICAgaWYgKG5vZGUgIT0gbnVsbCAmJiB0aGlzLmlzT2JqZWN0UHJvcGVydHkobm9kZSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAga2V5LFxuICAgICAgICB2YWx1ZVxuICAgICAgfSA9IG5vZGU7XG4gICAgICBpZiAodGhpcy5pc1ByaXZhdGVOYW1lKGtleSkpIHtcbiAgICAgICAgdGhpcy5jbGFzc1Njb3BlLnVzZVByaXZhdGVOYW1lKHRoaXMuZ2V0UHJpdmF0ZU5hbWVTVihrZXkpLCBrZXkubG9jLnN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKHZhbHVlLCBpc0xIUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLnRvQXNzaWduYWJsZShub2RlLCBpc0xIUyk7XG4gICAgfVxuICB9XG4gIHRvQXNzaWduYWJsZU9iamVjdEV4cHJlc3Npb25Qcm9wKHByb3AsIGlzTGFzdCwgaXNMSFMpIHtcbiAgICBpZiAocHJvcC50eXBlID09PSBcIlByb3BlcnR5XCIgJiYgKHByb3Aua2luZCA9PT0gXCJnZXRcIiB8fCBwcm9wLmtpbmQgPT09IFwic2V0XCIpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5QYXR0ZXJuSGFzQWNjZXNzb3IsIHByb3Aua2V5KTtcbiAgICB9IGVsc2UgaWYgKHByb3AudHlwZSA9PT0gXCJQcm9wZXJ0eVwiICYmIHByb3AubWV0aG9kKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5QYXR0ZXJuSGFzTWV0aG9kLCBwcm9wLmtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLnRvQXNzaWduYWJsZU9iamVjdEV4cHJlc3Npb25Qcm9wKHByb3AsIGlzTGFzdCwgaXNMSFMpO1xuICAgIH1cbiAgfVxuICBmaW5pc2hDYWxsRXhwcmVzc2lvbih1bmZpbmlzaGVkLCBvcHRpb25hbCkge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5maW5pc2hDYWxsRXhwcmVzc2lvbih1bmZpbmlzaGVkLCBvcHRpb25hbCk7XG4gICAgaWYgKG5vZGUuY2FsbGVlLnR5cGUgPT09IFwiSW1wb3J0XCIpIHtcbiAgICAgIHZhciBfcmVmLCBfcmVmMjtcbiAgICAgIG5vZGUudHlwZSA9IFwiSW1wb3J0RXhwcmVzc2lvblwiO1xuICAgICAgbm9kZS5zb3VyY2UgPSBub2RlLmFyZ3VtZW50c1swXTtcbiAgICAgIG5vZGUub3B0aW9ucyA9IChfcmVmID0gbm9kZS5hcmd1bWVudHNbMV0pICE9IG51bGwgPyBfcmVmIDogbnVsbDtcbiAgICAgIG5vZGUuYXR0cmlidXRlcyA9IChfcmVmMiA9IG5vZGUuYXJndW1lbnRzWzFdKSAhPSBudWxsID8gX3JlZjIgOiBudWxsO1xuICAgICAgZGVsZXRlIG5vZGUuYXJndW1lbnRzO1xuICAgICAgZGVsZXRlIG5vZGUuY2FsbGVlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICB0b1JlZmVyZW5jZWRBcmd1bWVudHMobm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiSW1wb3J0RXhwcmVzc2lvblwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnRvUmVmZXJlbmNlZEFyZ3VtZW50cyhub2RlKTtcbiAgfVxuICBwYXJzZUV4cG9ydCh1bmZpbmlzaGVkLCBkZWNvcmF0b3JzKSB7XG4gICAgY29uc3QgZXhwb3J0U3RhcnRMb2MgPSB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYztcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VFeHBvcnQodW5maW5pc2hlZCwgZGVjb3JhdG9ycyk7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiOlxuICAgICAgICBub2RlLmV4cG9ydGVkID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiOlxuICAgICAgICBpZiAobm9kZS5zcGVjaWZpZXJzLmxlbmd0aCA9PT0gMSAmJiBub2RlLnNwZWNpZmllcnNbMF0udHlwZSA9PT0gXCJFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikge1xuICAgICAgICAgIG5vZGUudHlwZSA9IFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIjtcbiAgICAgICAgICBub2RlLmV4cG9ydGVkID0gbm9kZS5zcGVjaWZpZXJzWzBdLmV4cG9ydGVkO1xuICAgICAgICAgIGRlbGV0ZSBub2RlLnNwZWNpZmllcnM7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfZGVjbGFyYXRpb24kZGVjb3JhdG87XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZGVjbGFyYXRpb25cbiAgICAgICAgICB9ID0gbm9kZTtcbiAgICAgICAgICBpZiAoKGRlY2xhcmF0aW9uID09IG51bGwgPyB2b2lkIDAgOiBkZWNsYXJhdGlvbi50eXBlKSA9PT0gXCJDbGFzc0RlY2xhcmF0aW9uXCIgJiYgKChfZGVjbGFyYXRpb24kZGVjb3JhdG8gPSBkZWNsYXJhdGlvbi5kZWNvcmF0b3JzKSA9PSBudWxsID8gdm9pZCAwIDogX2RlY2xhcmF0aW9uJGRlY29yYXRvLmxlbmd0aCkgPiAwICYmIGRlY2xhcmF0aW9uLnN0YXJ0ID09PSBub2RlLnN0YXJ0KSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbihub2RlLCBleHBvcnRTdGFydExvYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBwYXJzZVN1YnNjcmlwdChiYXNlLCBzdGFydExvYywgbm9DYWxscywgc3RhdGUpIHtcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMsIHN0YXRlKTtcbiAgICBpZiAoc3RhdGUub3B0aW9uYWxDaGFpbk1lbWJlcikge1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIG5vZGUudHlwZSA9IG5vZGUudHlwZS5zdWJzdHJpbmcoOCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuc3RvcCkge1xuICAgICAgICBjb25zdCBjaGFpbiA9IHRoaXMuc3RhcnROb2RlQXROb2RlKG5vZGUpO1xuICAgICAgICBjaGFpbi5leHByZXNzaW9uID0gbm9kZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShjaGFpbiwgXCJDaGFpbkV4cHJlc3Npb25cIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiKSB7XG4gICAgICBub2RlLm9wdGlvbmFsID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGlzT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIkNoYWluRXhwcmVzc2lvblwiKSB7XG4gICAgICByZXR1cm4gbm9kZS5leHByZXNzaW9uLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuaXNPcHRpb25hbE1lbWJlckV4cHJlc3Npb24obm9kZSk7XG4gIH1cbiAgaGFzUHJvcGVydHlBc1ByaXZhdGVOYW1lKG5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIkNoYWluRXhwcmVzc2lvblwiKSB7XG4gICAgICBub2RlID0gbm9kZS5leHByZXNzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuaGFzUHJvcGVydHlBc1ByaXZhdGVOYW1lKG5vZGUpO1xuICB9XG4gIGlzT2JqZWN0UHJvcGVydHkobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiUHJvcGVydHlcIiAmJiBub2RlLmtpbmQgPT09IFwiaW5pdFwiICYmICFub2RlLm1ldGhvZDtcbiAgfVxuICBpc09iamVjdE1ldGhvZChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJQcm9wZXJ0eVwiICYmIChub2RlLm1ldGhvZCB8fCBub2RlLmtpbmQgPT09IFwiZ2V0XCIgfHwgbm9kZS5raW5kID09PSBcInNldFwiKTtcbiAgfVxuICBmaW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgZW5kTG9jKSB7XG4gICAgcmV0dXJuIHRvRVNUcmVlTG9jYXRpb24oc3VwZXIuZmluaXNoTm9kZUF0KG5vZGUsIHR5cGUsIGVuZExvYykpO1xuICB9XG4gIHJlc2V0U3RhcnRMb2NhdGlvbihub2RlLCBzdGFydExvYykge1xuICAgIHN1cGVyLnJlc2V0U3RhcnRMb2NhdGlvbihub2RlLCBzdGFydExvYyk7XG4gICAgdG9FU1RyZWVMb2NhdGlvbihub2RlKTtcbiAgfVxuICByZXNldEVuZExvY2F0aW9uKG5vZGUsIGVuZExvYyA9IHRoaXMuc3RhdGUubGFzdFRva0VuZExvYykge1xuICAgIHN1cGVyLnJlc2V0RW5kTG9jYXRpb24obm9kZSwgZW5kTG9jKTtcbiAgICB0b0VTVHJlZUxvY2F0aW9uKG5vZGUpO1xuICB9XG59O1xuY2xhc3MgVG9rQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKHRva2VuLCBwcmVzZXJ2ZVNwYWNlKSB7XG4gICAgdGhpcy50b2tlbiA9IHZvaWQgMDtcbiAgICB0aGlzLnByZXNlcnZlU3BhY2UgPSB2b2lkIDA7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIHRoaXMucHJlc2VydmVTcGFjZSA9ICEhcHJlc2VydmVTcGFjZTtcbiAgfVxufVxuY29uc3QgdHlwZXMgPSB7XG4gIGJyYWNlOiBuZXcgVG9rQ29udGV4dChcIntcIiksXG4gIGpfb1RhZzogbmV3IFRva0NvbnRleHQoXCI8dGFnXCIpLFxuICBqX2NUYWc6IG5ldyBUb2tDb250ZXh0KFwiPC90YWdcIiksXG4gIGpfZXhwcjogbmV3IFRva0NvbnRleHQoXCI8dGFnPi4uLjwvdGFnPlwiLCB0cnVlKVxufTtcbntcbiAgdHlwZXMudGVtcGxhdGUgPSBuZXcgVG9rQ29udGV4dChcImBcIiwgdHJ1ZSk7XG59XG5jb25zdCBiZWZvcmVFeHByID0gdHJ1ZTtcbmNvbnN0IHN0YXJ0c0V4cHIgPSB0cnVlO1xuY29uc3QgaXNMb29wID0gdHJ1ZTtcbmNvbnN0IGlzQXNzaWduID0gdHJ1ZTtcbmNvbnN0IHByZWZpeCA9IHRydWU7XG5jb25zdCBwb3N0Zml4ID0gdHJ1ZTtcbmNsYXNzIEV4cG9ydGVkVG9rZW5UeXBlIHtcbiAgY29uc3RydWN0b3IobGFiZWwsIGNvbmYgPSB7fSkge1xuICAgIHRoaXMubGFiZWwgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXl3b3JkID0gdm9pZCAwO1xuICAgIHRoaXMuYmVmb3JlRXhwciA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXJ0c0V4cHIgPSB2b2lkIDA7XG4gICAgdGhpcy5yaWdodEFzc29jaWF0aXZlID0gdm9pZCAwO1xuICAgIHRoaXMuaXNMb29wID0gdm9pZCAwO1xuICAgIHRoaXMuaXNBc3NpZ24gPSB2b2lkIDA7XG4gICAgdGhpcy5wcmVmaXggPSB2b2lkIDA7XG4gICAgdGhpcy5wb3N0Zml4ID0gdm9pZCAwO1xuICAgIHRoaXMuYmlub3AgPSB2b2lkIDA7XG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIHRoaXMua2V5d29yZCA9IGNvbmYua2V5d29yZDtcbiAgICB0aGlzLmJlZm9yZUV4cHIgPSAhIWNvbmYuYmVmb3JlRXhwcjtcbiAgICB0aGlzLnN0YXJ0c0V4cHIgPSAhIWNvbmYuc3RhcnRzRXhwcjtcbiAgICB0aGlzLnJpZ2h0QXNzb2NpYXRpdmUgPSAhIWNvbmYucmlnaHRBc3NvY2lhdGl2ZTtcbiAgICB0aGlzLmlzTG9vcCA9ICEhY29uZi5pc0xvb3A7XG4gICAgdGhpcy5pc0Fzc2lnbiA9ICEhY29uZi5pc0Fzc2lnbjtcbiAgICB0aGlzLnByZWZpeCA9ICEhY29uZi5wcmVmaXg7XG4gICAgdGhpcy5wb3N0Zml4ID0gISFjb25mLnBvc3RmaXg7XG4gICAgdGhpcy5iaW5vcCA9IGNvbmYuYmlub3AgIT0gbnVsbCA/IGNvbmYuYmlub3AgOiBudWxsO1xuICAgIHtcbiAgICAgIHRoaXMudXBkYXRlQ29udGV4dCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5jb25zdCBrZXl3b3JkcyQxID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gY3JlYXRlS2V5d29yZChuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucy5rZXl3b3JkID0gbmFtZTtcbiAgY29uc3QgdG9rZW4gPSBjcmVhdGVUb2tlbihuYW1lLCBvcHRpb25zKTtcbiAga2V5d29yZHMkMS5zZXQobmFtZSwgdG9rZW4pO1xuICByZXR1cm4gdG9rZW47XG59XG5mdW5jdGlvbiBjcmVhdGVCaW5vcChuYW1lLCBiaW5vcCkge1xuICByZXR1cm4gY3JlYXRlVG9rZW4obmFtZSwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgYmlub3BcbiAgfSk7XG59XG5sZXQgdG9rZW5UeXBlQ291bnRlciA9IC0xO1xuY29uc3QgdG9rZW5UeXBlcyA9IFtdO1xuY29uc3QgdG9rZW5MYWJlbHMgPSBbXTtcbmNvbnN0IHRva2VuQmlub3BzID0gW107XG5jb25zdCB0b2tlbkJlZm9yZUV4cHJzID0gW107XG5jb25zdCB0b2tlblN0YXJ0c0V4cHJzID0gW107XG5jb25zdCB0b2tlblByZWZpeGVzID0gW107XG5mdW5jdGlvbiBjcmVhdGVUb2tlbihuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgdmFyIF9vcHRpb25zJGJpbm9wLCBfb3B0aW9ucyRiZWZvcmVFeHByLCBfb3B0aW9ucyRzdGFydHNFeHByLCBfb3B0aW9ucyRwcmVmaXg7XG4gICsrdG9rZW5UeXBlQ291bnRlcjtcbiAgdG9rZW5MYWJlbHMucHVzaChuYW1lKTtcbiAgdG9rZW5CaW5vcHMucHVzaCgoX29wdGlvbnMkYmlub3AgPSBvcHRpb25zLmJpbm9wKSAhPSBudWxsID8gX29wdGlvbnMkYmlub3AgOiAtMSk7XG4gIHRva2VuQmVmb3JlRXhwcnMucHVzaCgoX29wdGlvbnMkYmVmb3JlRXhwciA9IG9wdGlvbnMuYmVmb3JlRXhwcikgIT0gbnVsbCA/IF9vcHRpb25zJGJlZm9yZUV4cHIgOiBmYWxzZSk7XG4gIHRva2VuU3RhcnRzRXhwcnMucHVzaCgoX29wdGlvbnMkc3RhcnRzRXhwciA9IG9wdGlvbnMuc3RhcnRzRXhwcikgIT0gbnVsbCA/IF9vcHRpb25zJHN0YXJ0c0V4cHIgOiBmYWxzZSk7XG4gIHRva2VuUHJlZml4ZXMucHVzaCgoX29wdGlvbnMkcHJlZml4ID0gb3B0aW9ucy5wcmVmaXgpICE9IG51bGwgPyBfb3B0aW9ucyRwcmVmaXggOiBmYWxzZSk7XG4gIHRva2VuVHlwZXMucHVzaChuZXcgRXhwb3J0ZWRUb2tlblR5cGUobmFtZSwgb3B0aW9ucykpO1xuICByZXR1cm4gdG9rZW5UeXBlQ291bnRlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUtleXdvcmRMaWtlKG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX29wdGlvbnMkYmlub3AyLCBfb3B0aW9ucyRiZWZvcmVFeHByMiwgX29wdGlvbnMkc3RhcnRzRXhwcjIsIF9vcHRpb25zJHByZWZpeDI7XG4gICsrdG9rZW5UeXBlQ291bnRlcjtcbiAga2V5d29yZHMkMS5zZXQobmFtZSwgdG9rZW5UeXBlQ291bnRlcik7XG4gIHRva2VuTGFiZWxzLnB1c2gobmFtZSk7XG4gIHRva2VuQmlub3BzLnB1c2goKF9vcHRpb25zJGJpbm9wMiA9IG9wdGlvbnMuYmlub3ApICE9IG51bGwgPyBfb3B0aW9ucyRiaW5vcDIgOiAtMSk7XG4gIHRva2VuQmVmb3JlRXhwcnMucHVzaCgoX29wdGlvbnMkYmVmb3JlRXhwcjIgPSBvcHRpb25zLmJlZm9yZUV4cHIpICE9IG51bGwgPyBfb3B0aW9ucyRiZWZvcmVFeHByMiA6IGZhbHNlKTtcbiAgdG9rZW5TdGFydHNFeHBycy5wdXNoKChfb3B0aW9ucyRzdGFydHNFeHByMiA9IG9wdGlvbnMuc3RhcnRzRXhwcikgIT0gbnVsbCA/IF9vcHRpb25zJHN0YXJ0c0V4cHIyIDogZmFsc2UpO1xuICB0b2tlblByZWZpeGVzLnB1c2goKF9vcHRpb25zJHByZWZpeDIgPSBvcHRpb25zLnByZWZpeCkgIT0gbnVsbCA/IF9vcHRpb25zJHByZWZpeDIgOiBmYWxzZSk7XG4gIHRva2VuVHlwZXMucHVzaChuZXcgRXhwb3J0ZWRUb2tlblR5cGUoXCJuYW1lXCIsIG9wdGlvbnMpKTtcbiAgcmV0dXJuIHRva2VuVHlwZUNvdW50ZXI7XG59XG5jb25zdCB0dCA9IHtcbiAgYnJhY2tldEw6IGNyZWF0ZVRva2VuKFwiW1wiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBicmFja2V0SGFzaEw6IGNyZWF0ZVRva2VuKFwiI1tcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYnJhY2tldEJhckw6IGNyZWF0ZVRva2VuKFwiW3xcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYnJhY2tldFI6IGNyZWF0ZVRva2VuKFwiXVwiKSxcbiAgYnJhY2tldEJhclI6IGNyZWF0ZVRva2VuKFwifF1cIiksXG4gIGJyYWNlTDogY3JlYXRlVG9rZW4oXCJ7XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIGJyYWNlQmFyTDogY3JlYXRlVG9rZW4oXCJ7fFwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBicmFjZUhhc2hMOiBjcmVhdGVUb2tlbihcIiN7XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIGJyYWNlUjogY3JlYXRlVG9rZW4oXCJ9XCIpLFxuICBicmFjZUJhclI6IGNyZWF0ZVRva2VuKFwifH1cIiksXG4gIHBhcmVuTDogY3JlYXRlVG9rZW4oXCIoXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIHBhcmVuUjogY3JlYXRlVG9rZW4oXCIpXCIpLFxuICBjb21tYTogY3JlYXRlVG9rZW4oXCIsXCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBzZW1pOiBjcmVhdGVUb2tlbihcIjtcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIGNvbG9uOiBjcmVhdGVUb2tlbihcIjpcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIGRvdWJsZUNvbG9uOiBjcmVhdGVUb2tlbihcIjo6XCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBkb3Q6IGNyZWF0ZVRva2VuKFwiLlwiKSxcbiAgcXVlc3Rpb246IGNyZWF0ZVRva2VuKFwiP1wiLCB7XG4gICAgYmVmb3JlRXhwclxuICB9KSxcbiAgcXVlc3Rpb25Eb3Q6IGNyZWF0ZVRva2VuKFwiPy5cIiksXG4gIGFycm93OiBjcmVhdGVUb2tlbihcIj0+XCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICB0ZW1wbGF0ZTogY3JlYXRlVG9rZW4oXCJ0ZW1wbGF0ZVwiKSxcbiAgZWxsaXBzaXM6IGNyZWF0ZVRva2VuKFwiLi4uXCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBiYWNrUXVvdGU6IGNyZWF0ZVRva2VuKFwiYFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgZG9sbGFyQnJhY2VMOiBjcmVhdGVUb2tlbihcIiR7XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIHRlbXBsYXRlVGFpbDogY3JlYXRlVG9rZW4oXCIuLi5gXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICB0ZW1wbGF0ZU5vblRhaWw6IGNyZWF0ZVRva2VuKFwiLi4uJHtcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYXQ6IGNyZWF0ZVRva2VuKFwiQFwiKSxcbiAgaGFzaDogY3JlYXRlVG9rZW4oXCIjXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBpbnRlcnByZXRlckRpcmVjdGl2ZTogY3JlYXRlVG9rZW4oXCIjIS4uLlwiKSxcbiAgZXE6IGNyZWF0ZVRva2VuKFwiPVwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBpc0Fzc2lnblxuICB9KSxcbiAgYXNzaWduOiBjcmVhdGVUb2tlbihcIl89XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIGlzQXNzaWduXG4gIH0pLFxuICBzbGFzaEFzc2lnbjogY3JlYXRlVG9rZW4oXCJfPVwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBpc0Fzc2lnblxuICB9KSxcbiAgeG9yQXNzaWduOiBjcmVhdGVUb2tlbihcIl89XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIGlzQXNzaWduXG4gIH0pLFxuICBtb2R1bG9Bc3NpZ246IGNyZWF0ZVRva2VuKFwiXz1cIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgaXNBc3NpZ25cbiAgfSksXG4gIGluY0RlYzogY3JlYXRlVG9rZW4oXCIrKy8tLVwiLCB7XG4gICAgcHJlZml4LFxuICAgIHBvc3RmaXgsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYmFuZzogY3JlYXRlVG9rZW4oXCIhXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICB0aWxkZTogY3JlYXRlVG9rZW4oXCJ+XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBkb3VibGVDYXJldDogY3JlYXRlVG9rZW4oXCJeXlwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgZG91YmxlQXQ6IGNyZWF0ZVRva2VuKFwiQEBcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIHBpcGVsaW5lOiBjcmVhdGVCaW5vcChcInw+XCIsIDApLFxuICBudWxsaXNoQ29hbGVzY2luZzogY3JlYXRlQmlub3AoXCI/P1wiLCAxKSxcbiAgbG9naWNhbE9SOiBjcmVhdGVCaW5vcChcInx8XCIsIDEpLFxuICBsb2dpY2FsQU5EOiBjcmVhdGVCaW5vcChcIiYmXCIsIDIpLFxuICBiaXR3aXNlT1I6IGNyZWF0ZUJpbm9wKFwifFwiLCAzKSxcbiAgYml0d2lzZVhPUjogY3JlYXRlQmlub3AoXCJeXCIsIDQpLFxuICBiaXR3aXNlQU5EOiBjcmVhdGVCaW5vcChcIiZcIiwgNSksXG4gIGVxdWFsaXR5OiBjcmVhdGVCaW5vcChcIj09LyE9Lz09PS8hPT1cIiwgNiksXG4gIGx0OiBjcmVhdGVCaW5vcChcIjwvPi88PS8+PVwiLCA3KSxcbiAgZ3Q6IGNyZWF0ZUJpbm9wKFwiPC8+Lzw9Lz49XCIsIDcpLFxuICByZWxhdGlvbmFsOiBjcmVhdGVCaW5vcChcIjwvPi88PS8+PVwiLCA3KSxcbiAgYml0U2hpZnQ6IGNyZWF0ZUJpbm9wKFwiPDwvPj4vPj4+XCIsIDgpLFxuICBiaXRTaGlmdEw6IGNyZWF0ZUJpbm9wKFwiPDwvPj4vPj4+XCIsIDgpLFxuICBiaXRTaGlmdFI6IGNyZWF0ZUJpbm9wKFwiPDwvPj4vPj4+XCIsIDgpLFxuICBwbHVzTWluOiBjcmVhdGVUb2tlbihcIisvLVwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBiaW5vcDogOSxcbiAgICBwcmVmaXgsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgbW9kdWxvOiBjcmVhdGVUb2tlbihcIiVcIiwge1xuICAgIGJpbm9wOiAxMCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBzdGFyOiBjcmVhdGVUb2tlbihcIipcIiwge1xuICAgIGJpbm9wOiAxMFxuICB9KSxcbiAgc2xhc2g6IGNyZWF0ZUJpbm9wKFwiL1wiLCAxMCksXG4gIGV4cG9uZW50OiBjcmVhdGVUb2tlbihcIioqXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIGJpbm9wOiAxMSxcbiAgICByaWdodEFzc29jaWF0aXZlOiB0cnVlXG4gIH0pLFxuICBfaW46IGNyZWF0ZUtleXdvcmQoXCJpblwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBiaW5vcDogN1xuICB9KSxcbiAgX2luc3RhbmNlb2Y6IGNyZWF0ZUtleXdvcmQoXCJpbnN0YW5jZW9mXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIGJpbm9wOiA3XG4gIH0pLFxuICBfYnJlYWs6IGNyZWF0ZUtleXdvcmQoXCJicmVha1wiKSxcbiAgX2Nhc2U6IGNyZWF0ZUtleXdvcmQoXCJjYXNlXCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBfY2F0Y2g6IGNyZWF0ZUtleXdvcmQoXCJjYXRjaFwiKSxcbiAgX2NvbnRpbnVlOiBjcmVhdGVLZXl3b3JkKFwiY29udGludWVcIiksXG4gIF9kZWJ1Z2dlcjogY3JlYXRlS2V5d29yZChcImRlYnVnZ2VyXCIpLFxuICBfZGVmYXVsdDogY3JlYXRlS2V5d29yZChcImRlZmF1bHRcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIF9lbHNlOiBjcmVhdGVLZXl3b3JkKFwiZWxzZVwiLCB7XG4gICAgYmVmb3JlRXhwclxuICB9KSxcbiAgX2ZpbmFsbHk6IGNyZWF0ZUtleXdvcmQoXCJmaW5hbGx5XCIpLFxuICBfZnVuY3Rpb246IGNyZWF0ZUtleXdvcmQoXCJmdW5jdGlvblwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2lmOiBjcmVhdGVLZXl3b3JkKFwiaWZcIiksXG4gIF9yZXR1cm46IGNyZWF0ZUtleXdvcmQoXCJyZXR1cm5cIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIF9zd2l0Y2g6IGNyZWF0ZUtleXdvcmQoXCJzd2l0Y2hcIiksXG4gIF90aHJvdzogY3JlYXRlS2V5d29yZChcInRocm93XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfdHJ5OiBjcmVhdGVLZXl3b3JkKFwidHJ5XCIpLFxuICBfdmFyOiBjcmVhdGVLZXl3b3JkKFwidmFyXCIpLFxuICBfY29uc3Q6IGNyZWF0ZUtleXdvcmQoXCJjb25zdFwiKSxcbiAgX3dpdGg6IGNyZWF0ZUtleXdvcmQoXCJ3aXRoXCIpLFxuICBfbmV3OiBjcmVhdGVLZXl3b3JkKFwibmV3XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF90aGlzOiBjcmVhdGVLZXl3b3JkKFwidGhpc1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3N1cGVyOiBjcmVhdGVLZXl3b3JkKFwic3VwZXJcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9jbGFzczogY3JlYXRlS2V5d29yZChcImNsYXNzXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZXh0ZW5kczogY3JlYXRlS2V5d29yZChcImV4dGVuZHNcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIF9leHBvcnQ6IGNyZWF0ZUtleXdvcmQoXCJleHBvcnRcIiksXG4gIF9pbXBvcnQ6IGNyZWF0ZUtleXdvcmQoXCJpbXBvcnRcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9udWxsOiBjcmVhdGVLZXl3b3JkKFwibnVsbFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3RydWU6IGNyZWF0ZUtleXdvcmQoXCJ0cnVlXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZmFsc2U6IGNyZWF0ZUtleXdvcmQoXCJmYWxzZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3R5cGVvZjogY3JlYXRlS2V5d29yZChcInR5cGVvZlwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBwcmVmaXgsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3ZvaWQ6IGNyZWF0ZUtleXdvcmQoXCJ2b2lkXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZGVsZXRlOiBjcmVhdGVLZXl3b3JkKFwiZGVsZXRlXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZG86IGNyZWF0ZUtleXdvcmQoXCJkb1wiLCB7XG4gICAgaXNMb29wLFxuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIF9mb3I6IGNyZWF0ZUtleXdvcmQoXCJmb3JcIiwge1xuICAgIGlzTG9vcFxuICB9KSxcbiAgX3doaWxlOiBjcmVhdGVLZXl3b3JkKFwid2hpbGVcIiwge1xuICAgIGlzTG9vcFxuICB9KSxcbiAgX2FzOiBjcmVhdGVLZXl3b3JkTGlrZShcImFzXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfYXNzZXJ0OiBjcmVhdGVLZXl3b3JkTGlrZShcImFzc2VydFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2FzeW5jOiBjcmVhdGVLZXl3b3JkTGlrZShcImFzeW5jXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfYXdhaXQ6IGNyZWF0ZUtleXdvcmRMaWtlKFwiYXdhaXRcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9kZWZlcjogY3JlYXRlS2V5d29yZExpa2UoXCJkZWZlclwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2Zyb206IGNyZWF0ZUtleXdvcmRMaWtlKFwiZnJvbVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2dldDogY3JlYXRlS2V5d29yZExpa2UoXCJnZXRcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9sZXQ6IGNyZWF0ZUtleXdvcmRMaWtlKFwibGV0XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfbWV0YTogY3JlYXRlS2V5d29yZExpa2UoXCJtZXRhXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfb2Y6IGNyZWF0ZUtleXdvcmRMaWtlKFwib2ZcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9zZW50OiBjcmVhdGVLZXl3b3JkTGlrZShcInNlbnRcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9zZXQ6IGNyZWF0ZUtleXdvcmRMaWtlKFwic2V0XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfc291cmNlOiBjcmVhdGVLZXl3b3JkTGlrZShcInNvdXJjZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3N0YXRpYzogY3JlYXRlS2V5d29yZExpa2UoXCJzdGF0aWNcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF91c2luZzogY3JlYXRlS2V5d29yZExpa2UoXCJ1c2luZ1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3lpZWxkOiBjcmVhdGVLZXl3b3JkTGlrZShcInlpZWxkXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfYXNzZXJ0czogY3JlYXRlS2V5d29yZExpa2UoXCJhc3NlcnRzXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfY2hlY2tzOiBjcmVhdGVLZXl3b3JkTGlrZShcImNoZWNrc1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2V4cG9ydHM6IGNyZWF0ZUtleXdvcmRMaWtlKFwiZXhwb3J0c1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2dsb2JhbDogY3JlYXRlS2V5d29yZExpa2UoXCJnbG9iYWxcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9pbXBsZW1lbnRzOiBjcmVhdGVLZXl3b3JkTGlrZShcImltcGxlbWVudHNcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9pbnRyaW5zaWM6IGNyZWF0ZUtleXdvcmRMaWtlKFwiaW50cmluc2ljXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfaW5mZXI6IGNyZWF0ZUtleXdvcmRMaWtlKFwiaW5mZXJcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9pczogY3JlYXRlS2V5d29yZExpa2UoXCJpc1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX21peGluczogY3JlYXRlS2V5d29yZExpa2UoXCJtaXhpbnNcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9wcm90bzogY3JlYXRlS2V5d29yZExpa2UoXCJwcm90b1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3JlcXVpcmU6IGNyZWF0ZUtleXdvcmRMaWtlKFwicmVxdWlyZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3NhdGlzZmllczogY3JlYXRlS2V5d29yZExpa2UoXCJzYXRpc2ZpZXNcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9rZXlvZjogY3JlYXRlS2V5d29yZExpa2UoXCJrZXlvZlwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3JlYWRvbmx5OiBjcmVhdGVLZXl3b3JkTGlrZShcInJlYWRvbmx5XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfdW5pcXVlOiBjcmVhdGVLZXl3b3JkTGlrZShcInVuaXF1ZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2Fic3RyYWN0OiBjcmVhdGVLZXl3b3JkTGlrZShcImFic3RyYWN0XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZGVjbGFyZTogY3JlYXRlS2V5d29yZExpa2UoXCJkZWNsYXJlXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZW51bTogY3JlYXRlS2V5d29yZExpa2UoXCJlbnVtXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfbW9kdWxlOiBjcmVhdGVLZXl3b3JkTGlrZShcIm1vZHVsZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX25hbWVzcGFjZTogY3JlYXRlS2V5d29yZExpa2UoXCJuYW1lc3BhY2VcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9pbnRlcmZhY2U6IGNyZWF0ZUtleXdvcmRMaWtlKFwiaW50ZXJmYWNlXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfdHlwZTogY3JlYXRlS2V5d29yZExpa2UoXCJ0eXBlXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfb3BhcXVlOiBjcmVhdGVLZXl3b3JkTGlrZShcIm9wYXF1ZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgbmFtZTogY3JlYXRlVG9rZW4oXCJuYW1lXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBwbGFjZWhvbGRlcjogY3JlYXRlVG9rZW4oXCIlJVwiLCB7XG4gICAgc3RhcnRzRXhwcjogdHJ1ZVxuICB9KSxcbiAgc3RyaW5nOiBjcmVhdGVUb2tlbihcInN0cmluZ1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgbnVtOiBjcmVhdGVUb2tlbihcIm51bVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYmlnaW50OiBjcmVhdGVUb2tlbihcImJpZ2ludFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgZGVjaW1hbDogY3JlYXRlVG9rZW4oXCJkZWNpbWFsXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICByZWdleHA6IGNyZWF0ZVRva2VuKFwicmVnZXhwXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBwcml2YXRlTmFtZTogY3JlYXRlVG9rZW4oXCIjbmFtZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgZW9mOiBjcmVhdGVUb2tlbihcImVvZlwiKSxcbiAganN4TmFtZTogY3JlYXRlVG9rZW4oXCJqc3hOYW1lXCIpLFxuICBqc3hUZXh0OiBjcmVhdGVUb2tlbihcImpzeFRleHRcIiwge1xuICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgfSksXG4gIGpzeFRhZ1N0YXJ0OiBjcmVhdGVUb2tlbihcImpzeFRhZ1N0YXJ0XCIsIHtcbiAgICBzdGFydHNFeHByOiB0cnVlXG4gIH0pLFxuICBqc3hUYWdFbmQ6IGNyZWF0ZVRva2VuKFwianN4VGFnRW5kXCIpXG59O1xuZnVuY3Rpb24gdG9rZW5Jc0lkZW50aWZpZXIodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID49IDkzICYmIHRva2VuIDw9IDEzMztcbn1cbmZ1bmN0aW9uIHRva2VuS2V5d29yZE9ySWRlbnRpZmllcklzS2V5d29yZCh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPD0gOTI7XG59XG5mdW5jdGlvbiB0b2tlbklzS2V5d29yZE9ySWRlbnRpZmllcih0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gNTggJiYgdG9rZW4gPD0gMTMzO1xufVxuZnVuY3Rpb24gdG9rZW5Jc0xpdGVyYWxQcm9wZXJ0eU5hbWUodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID49IDU4ICYmIHRva2VuIDw9IDEzNztcbn1cbmZ1bmN0aW9uIHRva2VuQ29tZXNCZWZvcmVFeHByZXNzaW9uKHRva2VuKSB7XG4gIHJldHVybiB0b2tlbkJlZm9yZUV4cHJzW3Rva2VuXTtcbn1cbmZ1bmN0aW9uIHRva2VuQ2FuU3RhcnRFeHByZXNzaW9uKHRva2VuKSB7XG4gIHJldHVybiB0b2tlblN0YXJ0c0V4cHJzW3Rva2VuXTtcbn1cbmZ1bmN0aW9uIHRva2VuSXNBc3NpZ25tZW50KHRva2VuKSB7XG4gIHJldHVybiB0b2tlbiA+PSAyOSAmJiB0b2tlbiA8PSAzMztcbn1cbmZ1bmN0aW9uIHRva2VuSXNGbG93SW50ZXJmYWNlT3JUeXBlT3JPcGFxdWUodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID49IDEyOSAmJiB0b2tlbiA8PSAxMzE7XG59XG5mdW5jdGlvbiB0b2tlbklzTG9vcCh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gOTAgJiYgdG9rZW4gPD0gOTI7XG59XG5mdW5jdGlvbiB0b2tlbklzS2V5d29yZCh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gNTggJiYgdG9rZW4gPD0gOTI7XG59XG5mdW5jdGlvbiB0b2tlbklzT3BlcmF0b3IodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID49IDM5ICYmIHRva2VuIDw9IDU5O1xufVxuZnVuY3Rpb24gdG9rZW5Jc1Bvc3RmaXgodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID09PSAzNDtcbn1cbmZ1bmN0aW9uIHRva2VuSXNQcmVmaXgodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuUHJlZml4ZXNbdG9rZW5dO1xufVxuZnVuY3Rpb24gdG9rZW5Jc1RTVHlwZU9wZXJhdG9yKHRva2VuKSB7XG4gIHJldHVybiB0b2tlbiA+PSAxMjEgJiYgdG9rZW4gPD0gMTIzO1xufVxuZnVuY3Rpb24gdG9rZW5Jc1RTRGVjbGFyYXRpb25TdGFydCh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gMTI0ICYmIHRva2VuIDw9IDEzMDtcbn1cbmZ1bmN0aW9uIHRva2VuTGFiZWxOYW1lKHRva2VuKSB7XG4gIHJldHVybiB0b2tlbkxhYmVsc1t0b2tlbl07XG59XG5mdW5jdGlvbiB0b2tlbk9wZXJhdG9yUHJlY2VkZW5jZSh0b2tlbikge1xuICByZXR1cm4gdG9rZW5CaW5vcHNbdG9rZW5dO1xufVxuZnVuY3Rpb24gdG9rZW5Jc1JpZ2h0QXNzb2NpYXRpdmUodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID09PSA1Nztcbn1cbmZ1bmN0aW9uIHRva2VuSXNUZW1wbGF0ZSh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gMjQgJiYgdG9rZW4gPD0gMjU7XG59XG5mdW5jdGlvbiBnZXRFeHBvcnRlZFRva2VuKHRva2VuKSB7XG4gIHJldHVybiB0b2tlblR5cGVzW3Rva2VuXTtcbn1cbntcbiAgdG9rZW5UeXBlc1s4XS51cGRhdGVDb250ZXh0ID0gY29udGV4dCA9PiB7XG4gICAgY29udGV4dC5wb3AoKTtcbiAgfTtcbiAgdG9rZW5UeXBlc1s1XS51cGRhdGVDb250ZXh0ID0gdG9rZW5UeXBlc1s3XS51cGRhdGVDb250ZXh0ID0gdG9rZW5UeXBlc1syM10udXBkYXRlQ29udGV4dCA9IGNvbnRleHQgPT4ge1xuICAgIGNvbnRleHQucHVzaCh0eXBlcy5icmFjZSk7XG4gIH07XG4gIHRva2VuVHlwZXNbMjJdLnVwZGF0ZUNvbnRleHQgPSBjb250ZXh0ID0+IHtcbiAgICBpZiAoY29udGV4dFtjb250ZXh0Lmxlbmd0aCAtIDFdID09PSB0eXBlcy50ZW1wbGF0ZSkge1xuICAgICAgY29udGV4dC5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5wdXNoKHR5cGVzLnRlbXBsYXRlKTtcbiAgICB9XG4gIH07XG4gIHRva2VuVHlwZXNbMTQzXS51cGRhdGVDb250ZXh0ID0gY29udGV4dCA9PiB7XG4gICAgY29udGV4dC5wdXNoKHR5cGVzLmpfZXhwciwgdHlwZXMual9vVGFnKTtcbiAgfTtcbn1cbmxldCBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzdmXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDhhLVxcdTA1MmZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MC1cXHUwNTg4XFx1MDVkMC1cXHUwNWVhXFx1MDVlZi1cXHUwNWYyXFx1MDYyMC1cXHUwNjRhXFx1MDY2ZVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNVxcdTA2ZTZcXHUwNmVlXFx1MDZlZlxcdTA2ZmEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwXFx1MDcxMi1cXHUwNzJmXFx1MDc0ZC1cXHUwN2E1XFx1MDdiMVxcdTA3Y2EtXFx1MDdlYVxcdTA3ZjRcXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgxNVxcdTA4MWFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4NjAtXFx1MDg2YVxcdTA4NzAtXFx1MDg4N1xcdTA4ODktXFx1MDg4ZVxcdTA4YTAtXFx1MDhjOVxcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MDlmY1xcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwXFx1MGFlMVxcdTBhZjlcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzZFxcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5XFx1MGI5YVxcdTBiOWNcXHUwYjllXFx1MGI5ZlxcdTBiYTNcXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzOVxcdTBjM2RcXHUwYzU4LVxcdTBjNWFcXHUwYzVkXFx1MGM2MFxcdTBjNjFcXHUwYzgwXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDQtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ1NC1cXHUwZDU2XFx1MGQ1Zi1cXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4Ni1cXHUwZThhXFx1MGU4Yy1cXHUwZWEzXFx1MGVhNVxcdTBlYTctXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y1XFx1MTNmOC1cXHUxM2ZkXFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmY4XFx1MTcwMC1cXHUxNzExXFx1MTcxZi1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzhcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFlXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTliMC1cXHUxOWM5XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0Y1xcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWM4MC1cXHUxYzhhXFx1MWM5MC1cXHUxY2JhXFx1MWNiZC1cXHUxY2JmXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YzXFx1MWNmNVxcdTFjZjZcXHUxY2ZhXFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5Yi1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJmXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJmXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGJmXFx1NGUwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OWRcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3Y2RcXHVhN2QwXFx1YTdkMVxcdWE3ZDNcXHVhN2Q1LVxcdWE3ZGNcXHVhN2YyLVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YThmZFxcdWE4ZmVcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YTllMC1cXHVhOWU0XFx1YTllNi1cXHVhOWVmXFx1YTlmYS1cXHVhOWZlXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhN2UtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWIzMC1cXHVhYjVhXFx1YWI1Yy1cXHVhYjY5XFx1YWI3MC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCI7XG5sZXQgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxceGI3XFx1MDMwMC1cXHUwMzZmXFx1MDM4N1xcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2NGItXFx1MDY2OVxcdTA2NzBcXHUwNmQ2LVxcdTA2ZGNcXHUwNmRmLVxcdTA2ZTRcXHUwNmU3XFx1MDZlOFxcdTA2ZWEtXFx1MDZlZFxcdTA2ZjAtXFx1MDZmOVxcdTA3MTFcXHUwNzMwLVxcdTA3NGFcXHUwN2E2LVxcdTA3YjBcXHUwN2MwLVxcdTA3YzlcXHUwN2ViLVxcdTA3ZjNcXHUwN2ZkXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg1OS1cXHUwODViXFx1MDg5Ny1cXHUwODlmXFx1MDhjYS1cXHUwOGUxXFx1MDhlMy1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWNiLVxcdTA5Y2RcXHUwOWQ3XFx1MDllMlxcdTA5ZTNcXHUwOWU2LVxcdTA5ZWZcXHUwOWZlXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMlxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYWZhLVxcdTBhZmZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU1LVxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMC1cXHUwYzA0XFx1MGMzY1xcdTBjM2UtXFx1MGM0NFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2MlxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgxLVxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBjZjNcXHUwZDAwLVxcdTBkMDNcXHUwZDNiXFx1MGQzY1xcdTBkM2UtXFx1MGQ0NFxcdTBkNDYtXFx1MGQ0OFxcdTBkNGEtXFx1MGQ0ZFxcdTBkNTdcXHUwZDYyXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkODEtXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRlNi1cXHUwZGVmXFx1MGRmMlxcdTBkZjNcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGU1MC1cXHUwZTU5XFx1MGViMVxcdTBlYjQtXFx1MGViY1xcdTBlYzgtXFx1MGVjZVxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGYzZVxcdTBmM2ZcXHUwZjcxLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJiLVxcdTEwM2VcXHUxMDQwLVxcdTEwNDlcXHUxMDU2LVxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDYyLVxcdTEwNjRcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxMzY5LVxcdTEzNzFcXHUxNzEyLVxcdTE3MTVcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNC1cXHUxN2QzXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MGYtXFx1MTgxOVxcdTE4YTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTQ2LVxcdTE5NGZcXHUxOWQwLVxcdTE5ZGFcXHUxYTE3LVxcdTFhMWJcXHUxYTU1LVxcdTFhNWVcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYWIwLVxcdTFhYmRcXHUxYWJmLVxcdTFhY2VcXHUxYjAwLVxcdTFiMDRcXHUxYjM0LVxcdTFiNDRcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYjgwLVxcdTFiODJcXHUxYmExLVxcdTFiYWRcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzI0LVxcdTFjMzdcXHUxYzQwLVxcdTFjNDlcXHUxYzUwLVxcdTFjNTlcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZThcXHUxY2VkXFx1MWNmNFxcdTFjZjctXFx1MWNmOVxcdTFkYzAtXFx1MWRmZlxcdTIwMGNcXHUyMDBkXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJjZWYtXFx1MmNmMVxcdTJkN2ZcXHUyZGUwLVxcdTJkZmZcXHUzMDJhLVxcdTMwMmZcXHUzMDk5XFx1MzA5YVxcdTMwZmJcXHVhNjIwLVxcdWE2MjlcXHVhNjZmXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZVxcdWE2OWZcXHVhNmYwXFx1YTZmMVxcdWE4MDJcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4MmNcXHVhODgwXFx1YTg4MVxcdWE4YjQtXFx1YThjNVxcdWE4ZDAtXFx1YThkOVxcdWE4ZTAtXFx1YThmMVxcdWE4ZmYtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5NDctXFx1YTk1M1xcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWE5ZDAtXFx1YTlkOVxcdWE5ZTVcXHVhOWYwLVxcdWE5ZjlcXHVhYTI5LVxcdWFhMzZcXHVhYTQzXFx1YWE0Y1xcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiLVxcdWFhN2RcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiN1xcdWFhYjhcXHVhYWJlXFx1YWFiZlxcdWFhYzFcXHVhYWViLVxcdWFhZWZcXHVhYWY1XFx1YWFmNlxcdWFiZTMtXFx1YWJlYVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIxZVxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyZlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlxcdWZmNjVcIjtcbmNvbnN0IG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG5jb25zdCBub25BU0NJSWlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdXCIpO1xubm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gbnVsbDtcbmNvbnN0IGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzID0gWzAsIDExLCAyLCAyNSwgMiwgMTgsIDIsIDEsIDIsIDE0LCAzLCAxMywgMzUsIDEyMiwgNzAsIDUyLCAyNjgsIDI4LCA0LCA0OCwgNDgsIDMxLCAxNCwgMjksIDYsIDM3LCAxMSwgMjksIDMsIDM1LCA1LCA3LCAyLCA0LCA0MywgMTU3LCAxOSwgMzUsIDUsIDM1LCA1LCAzOSwgOSwgNTEsIDEzLCAxMCwgMiwgMTQsIDIsIDYsIDIsIDEsIDIsIDEwLCAyLCAxNCwgMiwgNiwgMiwgMSwgNCwgNTEsIDEzLCAzMTAsIDEwLCAyMSwgMTEsIDcsIDI1LCA1LCAyLCA0MSwgMiwgOCwgNzAsIDUsIDMsIDAsIDIsIDQzLCAyLCAxLCA0LCAwLCAzLCAyMiwgMTEsIDIyLCAxMCwgMzAsIDY2LCAxOCwgMiwgMSwgMTEsIDIxLCAxMSwgMjUsIDcxLCA1NSwgNywgMSwgNjUsIDAsIDE2LCAzLCAyLCAyLCAyLCAyOCwgNDMsIDI4LCA0LCAyOCwgMzYsIDcsIDIsIDI3LCAyOCwgNTMsIDExLCAyMSwgMTEsIDE4LCAxNCwgMTcsIDExMSwgNzIsIDU2LCA1MCwgMTQsIDUwLCAxNCwgMzUsIDM5LCAyNywgMTAsIDIyLCAyNTEsIDQxLCA3LCAxLCAxNywgMiwgNjAsIDI4LCAxMSwgMCwgOSwgMjEsIDQzLCAxNywgNDcsIDIwLCAyOCwgMjIsIDEzLCA1MiwgNTgsIDEsIDMsIDAsIDE0LCA0NCwgMzMsIDI0LCAyNywgMzUsIDMwLCAwLCAzLCAwLCA5LCAzNCwgNCwgMCwgMTMsIDQ3LCAxNSwgMywgMjIsIDAsIDIsIDAsIDM2LCAxNywgMiwgMjQsIDIwLCAxLCA2NCwgNiwgMiwgMCwgMiwgMywgMiwgMTQsIDIsIDksIDgsIDQ2LCAzOSwgNywgMywgMSwgMywgMjEsIDIsIDYsIDIsIDEsIDIsIDQsIDQsIDAsIDE5LCAwLCAxMywgNCwgMzEsIDksIDIsIDAsIDMsIDAsIDIsIDM3LCAyLCAwLCAyNiwgMCwgMiwgMCwgNDUsIDUyLCAxOSwgMywgMjEsIDIsIDMxLCA0NywgMjEsIDEsIDIsIDAsIDE4NSwgNDYsIDQyLCAzLCAzNywgNDcsIDIxLCAwLCA2MCwgNDIsIDE0LCAwLCA3MiwgMjYsIDM4LCA2LCAxODYsIDQzLCAxMTcsIDYzLCAzMiwgNywgMywgMCwgMywgNywgMiwgMSwgMiwgMjMsIDE2LCAwLCAyLCAwLCA5NSwgNywgMywgMzgsIDE3LCAwLCAyLCAwLCAyOSwgMCwgMTEsIDM5LCA4LCAwLCAyMiwgMCwgMTIsIDQ1LCAyMCwgMCwgMTksIDcyLCAyMDAsIDMyLCAzMiwgOCwgMiwgMzYsIDE4LCAwLCA1MCwgMjksIDExMywgNiwgMiwgMSwgMiwgMzcsIDIyLCAwLCAyNiwgNSwgMiwgMSwgMiwgMzEsIDE1LCAwLCAzMjgsIDE4LCAxNiwgMCwgMiwgMTIsIDIsIDMzLCAxMjUsIDAsIDgwLCA5MjEsIDEwMywgMTEwLCAxOCwgMTk1LCAyNjM3LCA5NiwgMTYsIDEwNzEsIDE4LCA1LCAyNiwgMzk5NCwgNiwgNTgyLCA2ODQyLCAyOSwgMTc2MywgNTY4LCA4LCAzMCwgMTgsIDc4LCAxOCwgMjksIDE5LCA0NywgMTcsIDMsIDMyLCAyMCwgNiwgMTgsIDQzMywgNDQsIDIxMiwgNjMsIDEyOSwgNzQsIDYsIDAsIDY3LCAxMiwgNjUsIDEsIDIsIDAsIDI5LCA2MTM1LCA5LCAxMjM3LCA0MiwgOSwgODkzNiwgMywgMiwgNiwgMiwgMSwgMiwgMjkwLCAxNiwgMCwgMzAsIDIsIDMsIDAsIDE1LCAzLCA5LCAzOTUsIDIzMDksIDEwNiwgNiwgMTIsIDQsIDgsIDgsIDksIDU5OTEsIDg0LCAyLCA3MCwgMiwgMSwgMywgMCwgMywgMSwgMywgMywgMiwgMTEsIDIsIDAsIDIsIDYsIDIsIDY0LCAyLCAzLCAzLCA3LCAyLCA2LCAyLCAyNywgMiwgMywgMiwgNCwgMiwgMCwgNCwgNiwgMiwgMzM5LCAzLCAyNCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgNywgMTg0NSwgMzAsIDcsIDUsIDI2MiwgNjEsIDE0NywgNDQsIDExLCA2LCAxNywgMCwgMzIyLCAyOSwgMTksIDQzLCA0ODUsIDI3LCAyMjksIDI5LCAzLCAwLCA0OTYsIDYsIDIsIDMsIDIsIDEsIDIsIDE0LCAyLCAxOTYsIDYwLCA2NywgOCwgMCwgMTIwNSwgMywgMiwgMjYsIDIsIDEsIDIsIDAsIDMsIDAsIDIsIDksIDIsIDMsIDIsIDAsIDIsIDAsIDcsIDAsIDUsIDAsIDIsIDAsIDIsIDAsIDIsIDIsIDIsIDEsIDIsIDAsIDMsIDAsIDIsIDAsIDIsIDAsIDIsIDAsIDIsIDAsIDIsIDEsIDIsIDAsIDMsIDMsIDIsIDYsIDIsIDMsIDIsIDMsIDIsIDAsIDIsIDksIDIsIDE2LCA2LCAyLCAyLCA0LCAyLCAxNiwgNDQyMSwgNDI3MTksIDMzLCA0MTUzLCA3LCAyMjEsIDMsIDU3NjEsIDE1LCA3NDcyLCAxNiwgNjIxLCAyNDY3LCA1NDEsIDE1MDcsIDQ5MzgsIDYsIDQxOTFdO1xuY29uc3QgYXN0cmFsSWRlbnRpZmllckNvZGVzID0gWzUwOSwgMCwgMjI3LCAwLCAxNTAsIDQsIDI5NCwgOSwgMTM2OCwgMiwgMiwgMSwgNiwgMywgNDEsIDIsIDUsIDAsIDE2NiwgMSwgNTc0LCAzLCA5LCA5LCA3LCA5LCAzMiwgNCwgMzE4LCAxLCA4MCwgMywgNzEsIDEwLCA1MCwgMywgMTIzLCAyLCA1NCwgMTQsIDMyLCAxMCwgMywgMSwgMTEsIDMsIDQ2LCAxMCwgOCwgMCwgNDYsIDksIDcsIDIsIDM3LCAxMywgMiwgOSwgNiwgMSwgNDUsIDAsIDEzLCAyLCA0OSwgMTMsIDksIDMsIDIsIDExLCA4MywgMTEsIDcsIDAsIDMsIDAsIDE1OCwgMTEsIDYsIDksIDcsIDMsIDU2LCAxLCAyLCA2LCAzLCAxLCAzLCAyLCAxMCwgMCwgMTEsIDEsIDMsIDYsIDQsIDQsIDY4LCA4LCAyLCAwLCAzLCAwLCAyLCAzLCAyLCA0LCAyLCAwLCAxNSwgMSwgODMsIDE3LCAxMCwgOSwgNSwgMCwgODIsIDE5LCAxMywgOSwgMjE0LCA2LCAzLCA4LCAyOCwgMSwgODMsIDE2LCAxNiwgOSwgODIsIDEyLCA5LCA5LCA3LCAxOSwgNTgsIDE0LCA1LCA5LCAyNDMsIDE0LCAxNjYsIDksIDcxLCA1LCAyLCAxLCAzLCAzLCAyLCAwLCAyLCAxLCAxMywgOSwgMTIwLCA2LCAzLCA2LCA0LCAwLCAyOSwgOSwgNDEsIDYsIDIsIDMsIDksIDAsIDEwLCAxMCwgNDcsIDE1LCAzNDMsIDksIDU0LCA3LCAyLCA3LCAxNywgOSwgNTcsIDIxLCAyLCAxMywgMTIzLCA1LCA0LCAwLCAyLCAxLCAyLCA2LCAyLCAwLCA5LCA5LCA0OSwgNCwgMiwgMSwgMiwgNCwgOSwgOSwgMzMwLCAzLCAxMCwgMSwgMiwgMCwgNDksIDYsIDQsIDQsIDE0LCAxMCwgNTM1MCwgMCwgNywgMTQsIDExNDY1LCAyNywgMjM0MywgOSwgODcsIDksIDM5LCA0LCA2MCwgNiwgMjYsIDksIDUzNSwgOSwgNDcwLCAwLCAyLCA1NCwgOCwgMywgODIsIDAsIDEyLCAxLCAxOTYyOCwgMSwgNDE3OCwgOSwgNTE5LCA0NSwgMywgMjIsIDU0MywgNCwgNCwgNSwgOSwgNywgMywgNiwgMzEsIDMsIDE0OSwgMiwgMTQxOCwgNDksIDUxMywgNTQsIDUsIDQ5LCA5LCAwLCAxNSwgMCwgMjMsIDQsIDIsIDE0LCAxMzYxLCA2LCAyLCAxNiwgMywgNiwgMiwgMSwgMiwgNCwgMTAxLCAwLCAxNjEsIDYsIDEwLCA5LCAzNTcsIDAsIDYyLCAxMywgNDk5LCAxMywgMjQ1LCAxLCAyLCA5LCA3MjYsIDYsIDExMCwgNiwgNiwgOSwgNDc1OSwgOSwgNzg3NzE5LCAyMzldO1xuZnVuY3Rpb24gaXNJbkFzdHJhbFNldChjb2RlLCBzZXQpIHtcbiAgbGV0IHBvcyA9IDB4MTAwMDA7XG4gIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBzZXQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcbiAgICBwb3MgKz0gc2V0W2ldO1xuICAgIGlmIChwb3MgPiBjb2RlKSByZXR1cm4gZmFsc2U7XG4gICAgcG9zICs9IHNldFtpICsgMV07XG4gICAgaWYgKHBvcyA+PSBjb2RlKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjb2RlKSB7XG4gIGlmIChjb2RlIDwgNjUpIHJldHVybiBjb2RlID09PSAzNjtcbiAgaWYgKGNvZGUgPD0gOTApIHJldHVybiB0cnVlO1xuICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gIGlmIChjb2RlIDw9IDEyMikgcmV0dXJuIHRydWU7XG4gIGlmIChjb2RlIDw9IDB4ZmZmZikge1xuICAgIHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgfVxuICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2Rlcyk7XG59XG5mdW5jdGlvbiBpc0lkZW50aWZpZXJDaGFyKGNvZGUpIHtcbiAgaWYgKGNvZGUgPCA0OCkgcmV0dXJuIGNvZGUgPT09IDM2O1xuICBpZiAoY29kZSA8IDU4KSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNvZGUgPCA2NSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoY29kZSA8PSA5MCkgcmV0dXJuIHRydWU7XG4gIGlmIChjb2RlIDwgOTcpIHJldHVybiBjb2RlID09PSA5NTtcbiAgaWYgKGNvZGUgPD0gMTIyKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNvZGUgPD0gMHhmZmZmKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgfVxuICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcykgfHwgaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyQ29kZXMpO1xufVxuY29uc3QgcmVzZXJ2ZWRXb3JkcyA9IHtcbiAga2V5d29yZDogW1wiYnJlYWtcIiwgXCJjYXNlXCIsIFwiY2F0Y2hcIiwgXCJjb250aW51ZVwiLCBcImRlYnVnZ2VyXCIsIFwiZGVmYXVsdFwiLCBcImRvXCIsIFwiZWxzZVwiLCBcImZpbmFsbHlcIiwgXCJmb3JcIiwgXCJmdW5jdGlvblwiLCBcImlmXCIsIFwicmV0dXJuXCIsIFwic3dpdGNoXCIsIFwidGhyb3dcIiwgXCJ0cnlcIiwgXCJ2YXJcIiwgXCJjb25zdFwiLCBcIndoaWxlXCIsIFwid2l0aFwiLCBcIm5ld1wiLCBcInRoaXNcIiwgXCJzdXBlclwiLCBcImNsYXNzXCIsIFwiZXh0ZW5kc1wiLCBcImV4cG9ydFwiLCBcImltcG9ydFwiLCBcIm51bGxcIiwgXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJpblwiLCBcImluc3RhbmNlb2ZcIiwgXCJ0eXBlb2ZcIiwgXCJ2b2lkXCIsIFwiZGVsZXRlXCJdLFxuICBzdHJpY3Q6IFtcImltcGxlbWVudHNcIiwgXCJpbnRlcmZhY2VcIiwgXCJsZXRcIiwgXCJwYWNrYWdlXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCBcInB1YmxpY1wiLCBcInN0YXRpY1wiLCBcInlpZWxkXCJdLFxuICBzdHJpY3RCaW5kOiBbXCJldmFsXCIsIFwiYXJndW1lbnRzXCJdXG59O1xuY29uc3Qga2V5d29yZHMgPSBuZXcgU2V0KHJlc2VydmVkV29yZHMua2V5d29yZCk7XG5jb25zdCByZXNlcnZlZFdvcmRzU3RyaWN0U2V0ID0gbmV3IFNldChyZXNlcnZlZFdvcmRzLnN0cmljdCk7XG5jb25zdCByZXNlcnZlZFdvcmRzU3RyaWN0QmluZFNldCA9IG5ldyBTZXQocmVzZXJ2ZWRXb3Jkcy5zdHJpY3RCaW5kKTtcbmZ1bmN0aW9uIGlzUmVzZXJ2ZWRXb3JkKHdvcmQsIGluTW9kdWxlKSB7XG4gIHJldHVybiBpbk1vZHVsZSAmJiB3b3JkID09PSBcImF3YWl0XCIgfHwgd29yZCA9PT0gXCJlbnVtXCI7XG59XG5mdW5jdGlvbiBpc1N0cmljdFJlc2VydmVkV29yZCh3b3JkLCBpbk1vZHVsZSkge1xuICByZXR1cm4gaXNSZXNlcnZlZFdvcmQod29yZCwgaW5Nb2R1bGUpIHx8IHJlc2VydmVkV29yZHNTdHJpY3RTZXQuaGFzKHdvcmQpO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RCaW5kT25seVJlc2VydmVkV29yZCh3b3JkKSB7XG4gIHJldHVybiByZXNlcnZlZFdvcmRzU3RyaWN0QmluZFNldC5oYXMod29yZCk7XG59XG5mdW5jdGlvbiBpc1N0cmljdEJpbmRSZXNlcnZlZFdvcmQod29yZCwgaW5Nb2R1bGUpIHtcbiAgcmV0dXJuIGlzU3RyaWN0UmVzZXJ2ZWRXb3JkKHdvcmQsIGluTW9kdWxlKSB8fCBpc1N0cmljdEJpbmRPbmx5UmVzZXJ2ZWRXb3JkKHdvcmQpO1xufVxuZnVuY3Rpb24gaXNLZXl3b3JkKHdvcmQpIHtcbiAgcmV0dXJuIGtleXdvcmRzLmhhcyh3b3JkKTtcbn1cbmZ1bmN0aW9uIGlzSXRlcmF0b3JTdGFydChjdXJyZW50LCBuZXh0LCBuZXh0Mikge1xuICByZXR1cm4gY3VycmVudCA9PT0gNjQgJiYgbmV4dCA9PT0gNjQgJiYgaXNJZGVudGlmaWVyU3RhcnQobmV4dDIpO1xufVxuY29uc3QgcmVzZXJ2ZWRXb3JkTGlrZVNldCA9IG5ldyBTZXQoW1wiYnJlYWtcIiwgXCJjYXNlXCIsIFwiY2F0Y2hcIiwgXCJjb250aW51ZVwiLCBcImRlYnVnZ2VyXCIsIFwiZGVmYXVsdFwiLCBcImRvXCIsIFwiZWxzZVwiLCBcImZpbmFsbHlcIiwgXCJmb3JcIiwgXCJmdW5jdGlvblwiLCBcImlmXCIsIFwicmV0dXJuXCIsIFwic3dpdGNoXCIsIFwidGhyb3dcIiwgXCJ0cnlcIiwgXCJ2YXJcIiwgXCJjb25zdFwiLCBcIndoaWxlXCIsIFwid2l0aFwiLCBcIm5ld1wiLCBcInRoaXNcIiwgXCJzdXBlclwiLCBcImNsYXNzXCIsIFwiZXh0ZW5kc1wiLCBcImV4cG9ydFwiLCBcImltcG9ydFwiLCBcIm51bGxcIiwgXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJpblwiLCBcImluc3RhbmNlb2ZcIiwgXCJ0eXBlb2ZcIiwgXCJ2b2lkXCIsIFwiZGVsZXRlXCIsIFwiaW1wbGVtZW50c1wiLCBcImludGVyZmFjZVwiLCBcImxldFwiLCBcInBhY2thZ2VcIiwgXCJwcml2YXRlXCIsIFwicHJvdGVjdGVkXCIsIFwicHVibGljXCIsIFwic3RhdGljXCIsIFwieWllbGRcIiwgXCJldmFsXCIsIFwiYXJndW1lbnRzXCIsIFwiZW51bVwiLCBcImF3YWl0XCJdKTtcbmZ1bmN0aW9uIGNhbkJlUmVzZXJ2ZWRXb3JkKHdvcmQpIHtcbiAgcmV0dXJuIHJlc2VydmVkV29yZExpa2VTZXQuaGFzKHdvcmQpO1xufVxuY2xhc3MgU2NvcGUge1xuICBjb25zdHJ1Y3RvcihmbGFncykge1xuICAgIHRoaXMuZmxhZ3MgPSAwO1xuICAgIHRoaXMubmFtZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5maXJzdExleGljYWxOYW1lID0gXCJcIjtcbiAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gIH1cbn1cbmNsYXNzIFNjb3BlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlciwgaW5Nb2R1bGUpIHtcbiAgICB0aGlzLnBhcnNlciA9IHZvaWQgMDtcbiAgICB0aGlzLnNjb3BlU3RhY2sgPSBbXTtcbiAgICB0aGlzLmluTW9kdWxlID0gdm9pZCAwO1xuICAgIHRoaXMudW5kZWZpbmVkRXhwb3J0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLmluTW9kdWxlID0gaW5Nb2R1bGU7XG4gIH1cbiAgZ2V0IGluVG9wTGV2ZWwoKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRTY29wZSgpLmZsYWdzICYgMSkgPiAwO1xuICB9XG4gIGdldCBpbkZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGVGbGFncygpICYgMikgPiAwO1xuICB9XG4gIGdldCBhbGxvd1N1cGVyKCkge1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlRmxhZ3MoKSAmIDE2KSA+IDA7XG4gIH1cbiAgZ2V0IGFsbG93RGlyZWN0U3VwZXIoKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRUaGlzU2NvcGVGbGFncygpICYgMzIpID4gMDtcbiAgfVxuICBnZXQgaW5DbGFzcygpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZUZsYWdzKCkgJiA2NCkgPiAwO1xuICB9XG4gIGdldCBpbkNsYXNzQW5kTm90SW5Ob25BcnJvd0Z1bmN0aW9uKCkge1xuICAgIGNvbnN0IGZsYWdzID0gdGhpcy5jdXJyZW50VGhpc1Njb3BlRmxhZ3MoKTtcbiAgICByZXR1cm4gKGZsYWdzICYgNjQpID4gMCAmJiAoZmxhZ3MgJiAyKSA9PT0gMDtcbiAgfVxuICBnZXQgaW5TdGF0aWNCbG9jaygpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmxhZ3NcbiAgICAgIH0gPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICBpZiAoZmxhZ3MgJiAxMjgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZmxhZ3MgJiAoMzg3IHwgNjQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IGluTm9uQXJyb3dGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZUZsYWdzKCkgJiAyKSA+IDA7XG4gIH1cbiAgZ2V0IHRyZWF0RnVuY3Rpb25zQXNWYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUodGhpcy5jdXJyZW50U2NvcGUoKSk7XG4gIH1cbiAgY3JlYXRlU2NvcGUoZmxhZ3MpIHtcbiAgICByZXR1cm4gbmV3IFNjb3BlKGZsYWdzKTtcbiAgfVxuICBlbnRlcihmbGFncykge1xuICAgIHRoaXMuc2NvcGVTdGFjay5wdXNoKHRoaXMuY3JlYXRlU2NvcGUoZmxhZ3MpKTtcbiAgfVxuICBleGl0KCkge1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZVN0YWNrLnBvcCgpO1xuICAgIHJldHVybiBzY29wZS5mbGFncztcbiAgfVxuICB0cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZShzY29wZSkge1xuICAgIHJldHVybiAhIShzY29wZS5mbGFncyAmICgyIHwgMTI4KSB8fCAhdGhpcy5wYXJzZXIuaW5Nb2R1bGUgJiYgc2NvcGUuZmxhZ3MgJiAxKTtcbiAgfVxuICBkZWNsYXJlTmFtZShuYW1lLCBiaW5kaW5nVHlwZSwgbG9jKSB7XG4gICAgbGV0IHNjb3BlID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICBpZiAoYmluZGluZ1R5cGUgJiA4IHx8IGJpbmRpbmdUeXBlICYgMTYpIHtcbiAgICAgIHRoaXMuY2hlY2tSZWRlY2xhcmF0aW9uSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUsIGxvYyk7XG4gICAgICBsZXQgdHlwZSA9IHNjb3BlLm5hbWVzLmdldChuYW1lKSB8fCAwO1xuICAgICAgaWYgKGJpbmRpbmdUeXBlICYgMTYpIHtcbiAgICAgICAgdHlwZSA9IHR5cGUgfCA0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFzY29wZS5maXJzdExleGljYWxOYW1lKSB7XG4gICAgICAgICAgc2NvcGUuZmlyc3RMZXhpY2FsTmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdHlwZSA9IHR5cGUgfCAyO1xuICAgICAgfVxuICAgICAgc2NvcGUubmFtZXMuc2V0KG5hbWUsIHR5cGUpO1xuICAgICAgaWYgKGJpbmRpbmdUeXBlICYgOCkge1xuICAgICAgICB0aGlzLm1heWJlRXhwb3J0RGVmaW5lZChzY29wZSwgbmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChiaW5kaW5nVHlwZSAmIDQpIHtcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICAgIHRoaXMuY2hlY2tSZWRlY2xhcmF0aW9uSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUsIGxvYyk7XG4gICAgICAgIHNjb3BlLm5hbWVzLnNldChuYW1lLCAoc2NvcGUubmFtZXMuZ2V0KG5hbWUpIHx8IDApIHwgMSk7XG4gICAgICAgIHRoaXMubWF5YmVFeHBvcnREZWZpbmVkKHNjb3BlLCBuYW1lKTtcbiAgICAgICAgaWYgKHNjb3BlLmZsYWdzICYgMzg3KSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMucGFyc2VyLmluTW9kdWxlICYmIHNjb3BlLmZsYWdzICYgMSkge1xuICAgICAgdGhpcy51bmRlZmluZWRFeHBvcnRzLmRlbGV0ZShuYW1lKTtcbiAgICB9XG4gIH1cbiAgbWF5YmVFeHBvcnREZWZpbmVkKHNjb3BlLCBuYW1lKSB7XG4gICAgaWYgKHRoaXMucGFyc2VyLmluTW9kdWxlICYmIHNjb3BlLmZsYWdzICYgMSkge1xuICAgICAgdGhpcy51bmRlZmluZWRFeHBvcnRzLmRlbGV0ZShuYW1lKTtcbiAgICB9XG4gIH1cbiAgY2hlY2tSZWRlY2xhcmF0aW9uSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUsIGxvYykge1xuICAgIGlmICh0aGlzLmlzUmVkZWNsYXJlZEluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlKSkge1xuICAgICAgdGhpcy5wYXJzZXIucmFpc2UoRXJyb3JzLlZhclJlZGVjbGFyYXRpb24sIGxvYywge1xuICAgICAgICBpZGVudGlmaWVyTmFtZTogbmFtZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlzUmVkZWNsYXJlZEluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlKSB7XG4gICAgaWYgKCEoYmluZGluZ1R5cGUgJiAxKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChiaW5kaW5nVHlwZSAmIDgpIHtcbiAgICAgIHJldHVybiBzY29wZS5uYW1lcy5oYXMobmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBzY29wZS5uYW1lcy5nZXQobmFtZSk7XG4gICAgaWYgKGJpbmRpbmdUeXBlICYgMTYpIHtcbiAgICAgIHJldHVybiAodHlwZSAmIDIpID4gMCB8fCAhdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZShzY29wZSkgJiYgKHR5cGUgJiAxKSA+IDA7XG4gICAgfVxuICAgIHJldHVybiAodHlwZSAmIDIpID4gMCAmJiAhKHNjb3BlLmZsYWdzICYgOCAmJiBzY29wZS5maXJzdExleGljYWxOYW1lID09PSBuYW1lKSB8fCAhdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZShzY29wZSkgJiYgKHR5cGUgJiA0KSA+IDA7XG4gIH1cbiAgY2hlY2tMb2NhbEV4cG9ydChpZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWVcbiAgICB9ID0gaWQ7XG4gICAgY29uc3QgdG9wTGV2ZWxTY29wZSA9IHRoaXMuc2NvcGVTdGFja1swXTtcbiAgICBpZiAoIXRvcExldmVsU2NvcGUubmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICB0aGlzLnVuZGVmaW5lZEV4cG9ydHMuc2V0KG5hbWUsIGlkLmxvYy5zdGFydCk7XG4gICAgfVxuICB9XG4gIGN1cnJlbnRTY29wZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY29wZVN0YWNrW3RoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxXTtcbiAgfVxuICBjdXJyZW50VmFyU2NvcGVGbGFncygpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmxhZ3NcbiAgICAgIH0gPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICBpZiAoZmxhZ3MgJiAzODcpIHtcbiAgICAgICAgcmV0dXJuIGZsYWdzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjdXJyZW50VGhpc1Njb3BlRmxhZ3MoKSB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOzsgaS0tKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZsYWdzXG4gICAgICB9ID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgICAgaWYgKGZsYWdzICYgKDM4NyB8IDY0KSAmJiAhKGZsYWdzICYgNCkpIHtcbiAgICAgICAgcmV0dXJuIGZsYWdzO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuY2xhc3MgRmxvd1Njb3BlIGV4dGVuZHMgU2NvcGUge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgdGhpcy5kZWNsYXJlRnVuY3Rpb25zID0gbmV3IFNldCgpO1xuICB9XG59XG5jbGFzcyBGbG93U2NvcGVIYW5kbGVyIGV4dGVuZHMgU2NvcGVIYW5kbGVyIHtcbiAgY3JlYXRlU2NvcGUoZmxhZ3MpIHtcbiAgICByZXR1cm4gbmV3IEZsb3dTY29wZShmbGFncyk7XG4gIH1cbiAgZGVjbGFyZU5hbWUobmFtZSwgYmluZGluZ1R5cGUsIGxvYykge1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICBpZiAoYmluZGluZ1R5cGUgJiAyMDQ4KSB7XG4gICAgICB0aGlzLmNoZWNrUmVkZWNsYXJhdGlvbkluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlLCBsb2MpO1xuICAgICAgdGhpcy5tYXliZUV4cG9ydERlZmluZWQoc2NvcGUsIG5hbWUpO1xuICAgICAgc2NvcGUuZGVjbGFyZUZ1bmN0aW9ucy5hZGQobmFtZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmRlY2xhcmVOYW1lKG5hbWUsIGJpbmRpbmdUeXBlLCBsb2MpO1xuICB9XG4gIGlzUmVkZWNsYXJlZEluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlKSB7XG4gICAgaWYgKHN1cGVyLmlzUmVkZWNsYXJlZEluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGJpbmRpbmdUeXBlICYgMjA0OCAmJiAhc2NvcGUuZGVjbGFyZUZ1bmN0aW9ucy5oYXMobmFtZSkpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBzY29wZS5uYW1lcy5nZXQobmFtZSk7XG4gICAgICByZXR1cm4gKHR5cGUgJiA0KSA+IDAgfHwgKHR5cGUgJiAyKSA+IDA7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjaGVja0xvY2FsRXhwb3J0KGlkKSB7XG4gICAgaWYgKCF0aGlzLnNjb3BlU3RhY2tbMF0uZGVjbGFyZUZ1bmN0aW9ucy5oYXMoaWQubmFtZSkpIHtcbiAgICAgIHN1cGVyLmNoZWNrTG9jYWxFeHBvcnQoaWQpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgQmFzZVBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2F3VW5hbWJpZ3VvdXNFU00gPSBmYWxzZTtcbiAgICB0aGlzLmFtYmlndW91c1NjcmlwdERpZmZlcmVudEFzdCA9IGZhbHNlO1xuICB9XG4gIHNvdXJjZVRvT2Zmc2V0UG9zKHNvdXJjZVBvcykge1xuICAgIHJldHVybiBzb3VyY2VQb3MgKyB0aGlzLnN0YXJ0SW5kZXg7XG4gIH1cbiAgb2Zmc2V0VG9Tb3VyY2VQb3Mob2Zmc2V0UG9zKSB7XG4gICAgcmV0dXJuIG9mZnNldFBvcyAtIHRoaXMuc3RhcnRJbmRleDtcbiAgfVxuICBoYXNQbHVnaW4ocGx1Z2luQ29uZmlnKSB7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW5Db25maWcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLnBsdWdpbnMuaGFzKHBsdWdpbkNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFtwbHVnaW5OYW1lLCBwbHVnaW5PcHRpb25zXSA9IHBsdWdpbkNvbmZpZztcbiAgICAgIGlmICghdGhpcy5oYXNQbHVnaW4ocGx1Z2luTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgYWN0dWFsT3B0aW9ucyA9IHRoaXMucGx1Z2lucy5nZXQocGx1Z2luTmFtZSk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwbHVnaW5PcHRpb25zKSkge1xuICAgICAgICBpZiAoKGFjdHVhbE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGFjdHVhbE9wdGlvbnNba2V5XSkgIT09IHBsdWdpbk9wdGlvbnNba2V5XSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIGdldFBsdWdpbk9wdGlvbihwbHVnaW4sIG5hbWUpIHtcbiAgICB2YXIgX3RoaXMkcGx1Z2lucyRnZXQ7XG4gICAgcmV0dXJuIChfdGhpcyRwbHVnaW5zJGdldCA9IHRoaXMucGx1Z2lucy5nZXQocGx1Z2luKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHBsdWdpbnMkZ2V0W25hbWVdO1xuICB9XG59XG5mdW5jdGlvbiBzZXRUcmFpbGluZ0NvbW1lbnRzKG5vZGUsIGNvbW1lbnRzKSB7XG4gIGlmIChub2RlLnRyYWlsaW5nQ29tbWVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIG5vZGUudHJhaWxpbmdDb21tZW50cyA9IGNvbW1lbnRzO1xuICB9IGVsc2Uge1xuICAgIG5vZGUudHJhaWxpbmdDb21tZW50cy51bnNoaWZ0KC4uLmNvbW1lbnRzKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0TGVhZGluZ0NvbW1lbnRzKG5vZGUsIGNvbW1lbnRzKSB7XG4gIGlmIChub2RlLmxlYWRpbmdDb21tZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbm9kZS5sZWFkaW5nQ29tbWVudHMgPSBjb21tZW50cztcbiAgfSBlbHNlIHtcbiAgICBub2RlLmxlYWRpbmdDb21tZW50cy51bnNoaWZ0KC4uLmNvbW1lbnRzKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0SW5uZXJDb21tZW50cyhub2RlLCBjb21tZW50cykge1xuICBpZiAobm9kZS5pbm5lckNvbW1lbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBub2RlLmlubmVyQ29tbWVudHMgPSBjb21tZW50cztcbiAgfSBlbHNlIHtcbiAgICBub2RlLmlubmVyQ29tbWVudHMudW5zaGlmdCguLi5jb21tZW50cyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkanVzdElubmVyQ29tbWVudHMobm9kZSwgZWxlbWVudHMsIGNvbW1lbnRXUykge1xuICBsZXQgbGFzdEVsZW1lbnQgPSBudWxsO1xuICBsZXQgaSA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgd2hpbGUgKGxhc3RFbGVtZW50ID09PSBudWxsICYmIGkgPiAwKSB7XG4gICAgbGFzdEVsZW1lbnQgPSBlbGVtZW50c1stLWldO1xuICB9XG4gIGlmIChsYXN0RWxlbWVudCA9PT0gbnVsbCB8fCBsYXN0RWxlbWVudC5zdGFydCA+IGNvbW1lbnRXUy5zdGFydCkge1xuICAgIHNldElubmVyQ29tbWVudHMobm9kZSwgY29tbWVudFdTLmNvbW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRUcmFpbGluZ0NvbW1lbnRzKGxhc3RFbGVtZW50LCBjb21tZW50V1MuY29tbWVudHMpO1xuICB9XG59XG5jbGFzcyBDb21tZW50c1BhcnNlciBleHRlbmRzIEJhc2VQYXJzZXIge1xuICBhZGRDb21tZW50KGNvbW1lbnQpIHtcbiAgICBpZiAodGhpcy5maWxlbmFtZSkgY29tbWVudC5sb2MuZmlsZW5hbWUgPSB0aGlzLmZpbGVuYW1lO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1lbnRzTGVuXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHRoaXMuY29tbWVudHMubGVuZ3RoICE9PSBjb21tZW50c0xlbikge1xuICAgICAgdGhpcy5jb21tZW50cy5sZW5ndGggPSBjb21tZW50c0xlbjtcbiAgICB9XG4gICAgdGhpcy5jb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgIHRoaXMuc3RhdGUuY29tbWVudHNMZW4rKztcbiAgfVxuICBwcm9jZXNzQ29tbWVudChub2RlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWVudFN0YWNrXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgY29tbWVudFN0YWNrTGVuZ3RoID0gY29tbWVudFN0YWNrLmxlbmd0aDtcbiAgICBpZiAoY29tbWVudFN0YWNrTGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgbGV0IGkgPSBjb21tZW50U3RhY2tMZW5ndGggLSAxO1xuICAgIGNvbnN0IGxhc3RDb21tZW50V1MgPSBjb21tZW50U3RhY2tbaV07XG4gICAgaWYgKGxhc3RDb21tZW50V1Muc3RhcnQgPT09IG5vZGUuZW5kKSB7XG4gICAgICBsYXN0Q29tbWVudFdTLmxlYWRpbmdOb2RlID0gbm9kZTtcbiAgICAgIGktLTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnQ6IG5vZGVTdGFydFxuICAgIH0gPSBub2RlO1xuICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgY29tbWVudFdTID0gY29tbWVudFN0YWNrW2ldO1xuICAgICAgY29uc3QgY29tbWVudEVuZCA9IGNvbW1lbnRXUy5lbmQ7XG4gICAgICBpZiAoY29tbWVudEVuZCA+IG5vZGVTdGFydCkge1xuICAgICAgICBjb21tZW50V1MuY29udGFpbmluZ05vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmZpbmFsaXplQ29tbWVudChjb21tZW50V1MpO1xuICAgICAgICBjb21tZW50U3RhY2suc3BsaWNlKGksIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvbW1lbnRFbmQgPT09IG5vZGVTdGFydCkge1xuICAgICAgICAgIGNvbW1lbnRXUy50cmFpbGluZ05vZGUgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmaW5hbGl6ZUNvbW1lbnQoY29tbWVudFdTKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWVudHNcbiAgICB9ID0gY29tbWVudFdTO1xuICAgIGlmIChjb21tZW50V1MubGVhZGluZ05vZGUgIT09IG51bGwgfHwgY29tbWVudFdTLnRyYWlsaW5nTm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNvbW1lbnRXUy5sZWFkaW5nTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBzZXRUcmFpbGluZ0NvbW1lbnRzKGNvbW1lbnRXUy5sZWFkaW5nTm9kZSwgY29tbWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbW1lbnRXUy50cmFpbGluZ05vZGUgIT09IG51bGwpIHtcbiAgICAgICAgc2V0TGVhZGluZ0NvbW1lbnRzKGNvbW1lbnRXUy50cmFpbGluZ05vZGUsIGNvbW1lbnRzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb250YWluaW5nTm9kZTogbm9kZSxcbiAgICAgICAgc3RhcnQ6IGNvbW1lbnRTdGFydFxuICAgICAgfSA9IGNvbW1lbnRXUztcbiAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5vZmZzZXRUb1NvdXJjZVBvcyhjb21tZW50U3RhcnQpIC0gMSkgPT09IDQ0KSB7XG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgICAgIGNhc2UgXCJSZWNvcmRFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICBhZGp1c3RJbm5lckNvbW1lbnRzKG5vZGUsIG5vZGUucHJvcGVydGllcywgY29tbWVudFdTKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICBhZGp1c3RJbm5lckNvbW1lbnRzKG5vZGUsIG5vZGUuYXJndW1lbnRzLCBjb21tZW50V1MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjpcbiAgICAgICAgICBjYXNlIFwiRnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIk9iamVjdE1ldGhvZFwiOlxuICAgICAgICAgIGNhc2UgXCJDbGFzc01ldGhvZFwiOlxuICAgICAgICAgIGNhc2UgXCJDbGFzc1ByaXZhdGVNZXRob2RcIjpcbiAgICAgICAgICAgIGFkanVzdElubmVyQ29tbWVudHMobm9kZSwgbm9kZS5wYXJhbXMsIGNvbW1lbnRXUyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgICAgIGNhc2UgXCJUdXBsZUV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIGFkanVzdElubmVyQ29tbWVudHMobm9kZSwgbm9kZS5lbGVtZW50cywgY29tbWVudFdTKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkltcG9ydERlY2xhcmF0aW9uXCI6XG4gICAgICAgICAgICBhZGp1c3RJbm5lckNvbW1lbnRzKG5vZGUsIG5vZGUuc3BlY2lmaWVycywgY29tbWVudFdTKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJUU0VudW1EZWNsYXJhdGlvblwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBhZGp1c3RJbm5lckNvbW1lbnRzKG5vZGUsIG5vZGUubWVtYmVycywgY29tbWVudFdTKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJUU0VudW1Cb2R5XCI6XG4gICAgICAgICAgICBhZGp1c3RJbm5lckNvbW1lbnRzKG5vZGUsIG5vZGUubWVtYmVycywgY29tbWVudFdTKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHNldElubmVyQ29tbWVudHMobm9kZSwgY29tbWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRJbm5lckNvbW1lbnRzKG5vZGUsIGNvbW1lbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZmluYWxpemVSZW1haW5pbmdDb21tZW50cygpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21tZW50U3RhY2tcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBmb3IgKGxldCBpID0gY29tbWVudFN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLmZpbmFsaXplQ29tbWVudChjb21tZW50U3RhY2tbaV0pO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLmNvbW1lbnRTdGFjayA9IFtdO1xuICB9XG4gIHJlc2V0UHJldmlvdXNOb2RlVHJhaWxpbmdDb21tZW50cyhub2RlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWVudFN0YWNrXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qge1xuICAgICAgbGVuZ3RoXG4gICAgfSA9IGNvbW1lbnRTdGFjaztcbiAgICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgY29uc3QgY29tbWVudFdTID0gY29tbWVudFN0YWNrW2xlbmd0aCAtIDFdO1xuICAgIGlmIChjb21tZW50V1MubGVhZGluZ05vZGUgPT09IG5vZGUpIHtcbiAgICAgIGNvbW1lbnRXUy5sZWFkaW5nTm9kZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIHJlc2V0UHJldmlvdXNJZGVudGlmaWVyTGVhZGluZ0NvbW1lbnRzKG5vZGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21tZW50U3RhY2tcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7XG4gICAgICBsZW5ndGhcbiAgICB9ID0gY29tbWVudFN0YWNrO1xuICAgIGlmIChsZW5ndGggPT09IDApIHJldHVybjtcbiAgICBpZiAoY29tbWVudFN0YWNrW2xlbmd0aCAtIDFdLnRyYWlsaW5nTm9kZSA9PT0gbm9kZSkge1xuICAgICAgY29tbWVudFN0YWNrW2xlbmd0aCAtIDFdLnRyYWlsaW5nTm9kZSA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChsZW5ndGggPj0gMiAmJiBjb21tZW50U3RhY2tbbGVuZ3RoIC0gMl0udHJhaWxpbmdOb2RlID09PSBub2RlKSB7XG4gICAgICBjb21tZW50U3RhY2tbbGVuZ3RoIC0gMl0udHJhaWxpbmdOb2RlID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgdGFrZVN1cnJvdW5kaW5nQ29tbWVudHMobm9kZSwgc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1lbnRTdGFja1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGNvbW1lbnRTdGFja0xlbmd0aCA9IGNvbW1lbnRTdGFjay5sZW5ndGg7XG4gICAgaWYgKGNvbW1lbnRTdGFja0xlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGxldCBpID0gY29tbWVudFN0YWNrTGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGNvbW1lbnRXUyA9IGNvbW1lbnRTdGFja1tpXTtcbiAgICAgIGNvbnN0IGNvbW1lbnRFbmQgPSBjb21tZW50V1MuZW5kO1xuICAgICAgY29uc3QgY29tbWVudFN0YXJ0ID0gY29tbWVudFdTLnN0YXJ0O1xuICAgICAgaWYgKGNvbW1lbnRTdGFydCA9PT0gZW5kKSB7XG4gICAgICAgIGNvbW1lbnRXUy5sZWFkaW5nTm9kZSA9IG5vZGU7XG4gICAgICB9IGVsc2UgaWYgKGNvbW1lbnRFbmQgPT09IHN0YXJ0KSB7XG4gICAgICAgIGNvbW1lbnRXUy50cmFpbGluZ05vZGUgPSBub2RlO1xuICAgICAgfSBlbHNlIGlmIChjb21tZW50RW5kIDwgc3RhcnQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jb25zdCBsaW5lQnJlYWsgPSAvXFxyXFxufFtcXHJcXG5cXHUyMDI4XFx1MjAyOV0vO1xuY29uc3QgbGluZUJyZWFrRyA9IG5ldyBSZWdFeHAobGluZUJyZWFrLnNvdXJjZSwgXCJnXCIpO1xuZnVuY3Rpb24gaXNOZXdMaW5lKGNvZGUpIHtcbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAxMDpcbiAgICBjYXNlIDEzOlxuICAgIGNhc2UgODIzMjpcbiAgICBjYXNlIDgyMzM6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBoYXNOZXdMaW5lKGlucHV0LCBzdGFydCwgZW5kKSB7XG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGlzTmV3TGluZShpbnB1dC5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IHNraXBXaGl0ZVNwYWNlID0gLyg/Olxcc3xcXC9cXC8uKnxcXC9cXCpbXl0qP1xcKlxcLykqL2c7XG5jb25zdCBza2lwV2hpdGVTcGFjZUluTGluZSA9IC8oPzpbXlxcU1xcblxcclxcdTIwMjhcXHUyMDI5XXxcXC9cXC8uKnxcXC9cXCouKj9cXCpcXC8pKi9nO1xuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGNvZGUpIHtcbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAweDAwMDk6XG4gICAgY2FzZSAweDAwMGI6XG4gICAgY2FzZSAweDAwMGM6XG4gICAgY2FzZSAzMjpcbiAgICBjYXNlIDE2MDpcbiAgICBjYXNlIDU3NjA6XG4gICAgY2FzZSAweDIwMDA6XG4gICAgY2FzZSAweDIwMDE6XG4gICAgY2FzZSAweDIwMDI6XG4gICAgY2FzZSAweDIwMDM6XG4gICAgY2FzZSAweDIwMDQ6XG4gICAgY2FzZSAweDIwMDU6XG4gICAgY2FzZSAweDIwMDY6XG4gICAgY2FzZSAweDIwMDc6XG4gICAgY2FzZSAweDIwMDg6XG4gICAgY2FzZSAweDIwMDk6XG4gICAgY2FzZSAweDIwMGE6XG4gICAgY2FzZSAweDIwMmY6XG4gICAgY2FzZSAweDIwNWY6XG4gICAgY2FzZSAweDMwMDA6XG4gICAgY2FzZSAweGZlZmY6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5jbGFzcyBTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZmxhZ3MgPSAxMDI0O1xuICAgIHRoaXMuc3RhcnRJbmRleCA9IHZvaWQgMDtcbiAgICB0aGlzLmN1ckxpbmUgPSB2b2lkIDA7XG4gICAgdGhpcy5saW5lU3RhcnQgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFydExvYyA9IHZvaWQgMDtcbiAgICB0aGlzLmVuZExvYyA9IHZvaWQgMDtcbiAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIHRoaXMucG90ZW50aWFsQXJyb3dBdCA9IC0xO1xuICAgIHRoaXMubm9BcnJvd0F0ID0gW107XG4gICAgdGhpcy5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0ID0gW107XG4gICAgdGhpcy50b3BpY0NvbnRleHQgPSB7XG4gICAgICBtYXhOdW1PZlJlc29sdmFibGVUb3BpY3M6IDAsXG4gICAgICBtYXhUb3BpY0luZGV4OiBudWxsXG4gICAgfTtcbiAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgIHRoaXMuY29tbWVudHNMZW4gPSAwO1xuICAgIHRoaXMuY29tbWVudFN0YWNrID0gW107XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMudHlwZSA9IDE0MDtcbiAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLmVuZCA9IDA7XG4gICAgdGhpcy5sYXN0VG9rRW5kTG9jID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUb2tTdGFydExvYyA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0ID0gW3R5cGVzLmJyYWNlXTtcbiAgICB0aGlzLmZpcnN0SW52YWxpZFRlbXBsYXRlRXNjYXBlUG9zID0gbnVsbDtcbiAgICB0aGlzLnN0cmljdEVycm9ycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnRva2Vuc0xlbmd0aCA9IDA7XG4gIH1cbiAgZ2V0IHN0cmljdCgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxKSA+IDA7XG4gIH1cbiAgc2V0IHN0cmljdCh2KSB7XG4gICAgaWYgKHYpIHRoaXMuZmxhZ3MgfD0gMTtlbHNlIHRoaXMuZmxhZ3MgJj0gLTI7XG4gIH1cbiAgaW5pdCh7XG4gICAgc3RyaWN0TW9kZSxcbiAgICBzb3VyY2VUeXBlLFxuICAgIHN0YXJ0SW5kZXgsXG4gICAgc3RhcnRMaW5lLFxuICAgIHN0YXJ0Q29sdW1uXG4gIH0pIHtcbiAgICB0aGlzLnN0cmljdCA9IHN0cmljdE1vZGUgPT09IGZhbHNlID8gZmFsc2UgOiBzdHJpY3RNb2RlID09PSB0cnVlID8gdHJ1ZSA6IHNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCI7XG4gICAgdGhpcy5zdGFydEluZGV4ID0gc3RhcnRJbmRleDtcbiAgICB0aGlzLmN1ckxpbmUgPSBzdGFydExpbmU7XG4gICAgdGhpcy5saW5lU3RhcnQgPSAtc3RhcnRDb2x1bW47XG4gICAgdGhpcy5zdGFydExvYyA9IHRoaXMuZW5kTG9jID0gbmV3IFBvc2l0aW9uKHN0YXJ0TGluZSwgc3RhcnRDb2x1bW4sIHN0YXJ0SW5kZXgpO1xuICB9XG4gIGdldCBtYXliZUluQXJyb3dQYXJhbWV0ZXJzKCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDIpID4gMDtcbiAgfVxuICBzZXQgbWF5YmVJbkFycm93UGFyYW1ldGVycyh2KSB7XG4gICAgaWYgKHYpIHRoaXMuZmxhZ3MgfD0gMjtlbHNlIHRoaXMuZmxhZ3MgJj0gLTM7XG4gIH1cbiAgZ2V0IGluVHlwZSgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0KSA+IDA7XG4gIH1cbiAgc2V0IGluVHlwZSh2KSB7XG4gICAgaWYgKHYpIHRoaXMuZmxhZ3MgfD0gNDtlbHNlIHRoaXMuZmxhZ3MgJj0gLTU7XG4gIH1cbiAgZ2V0IG5vQW5vbkZ1bmN0aW9uVHlwZSgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA4KSA+IDA7XG4gIH1cbiAgc2V0IG5vQW5vbkZ1bmN0aW9uVHlwZSh2KSB7XG4gICAgaWYgKHYpIHRoaXMuZmxhZ3MgfD0gODtlbHNlIHRoaXMuZmxhZ3MgJj0gLTk7XG4gIH1cbiAgZ2V0IGhhc0Zsb3dDb21tZW50KCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDE2KSA+IDA7XG4gIH1cbiAgc2V0IGhhc0Zsb3dDb21tZW50KHYpIHtcbiAgICBpZiAodikgdGhpcy5mbGFncyB8PSAxNjtlbHNlIHRoaXMuZmxhZ3MgJj0gLTE3O1xuICB9XG4gIGdldCBpc0FtYmllbnRDb250ZXh0KCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDMyKSA+IDA7XG4gIH1cbiAgc2V0IGlzQW1iaWVudENvbnRleHQodikge1xuICAgIGlmICh2KSB0aGlzLmZsYWdzIHw9IDMyO2Vsc2UgdGhpcy5mbGFncyAmPSAtMzM7XG4gIH1cbiAgZ2V0IGluQWJzdHJhY3RDbGFzcygpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA2NCkgPiAwO1xuICB9XG4gIHNldCBpbkFic3RyYWN0Q2xhc3Modikge1xuICAgIGlmICh2KSB0aGlzLmZsYWdzIHw9IDY0O2Vsc2UgdGhpcy5mbGFncyAmPSAtNjU7XG4gIH1cbiAgZ2V0IGluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxMjgpID4gMDtcbiAgfVxuICBzZXQgaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0KHYpIHtcbiAgICBpZiAodikgdGhpcy5mbGFncyB8PSAxMjg7ZWxzZSB0aGlzLmZsYWdzICY9IC0xMjk7XG4gIH1cbiAgZ2V0IHNvbG9Bd2FpdCgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyNTYpID4gMDtcbiAgfVxuICBzZXQgc29sb0F3YWl0KHYpIHtcbiAgICBpZiAodikgdGhpcy5mbGFncyB8PSAyNTY7ZWxzZSB0aGlzLmZsYWdzICY9IC0yNTc7XG4gIH1cbiAgZ2V0IGluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5KCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDUxMikgPiAwO1xuICB9XG4gIHNldCBpbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSh2KSB7XG4gICAgaWYgKHYpIHRoaXMuZmxhZ3MgfD0gNTEyO2Vsc2UgdGhpcy5mbGFncyAmPSAtNTEzO1xuICB9XG4gIGdldCBjYW5TdGFydEpTWEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMTAyNCkgPiAwO1xuICB9XG4gIHNldCBjYW5TdGFydEpTWEVsZW1lbnQodikge1xuICAgIGlmICh2KSB0aGlzLmZsYWdzIHw9IDEwMjQ7ZWxzZSB0aGlzLmZsYWdzICY9IC0xMDI1O1xuICB9XG4gIGdldCBjb250YWluc0VzYygpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyMDQ4KSA+IDA7XG4gIH1cbiAgc2V0IGNvbnRhaW5zRXNjKHYpIHtcbiAgICBpZiAodikgdGhpcy5mbGFncyB8PSAyMDQ4O2Vsc2UgdGhpcy5mbGFncyAmPSAtMjA0OTtcbiAgfVxuICBnZXQgaGFzVG9wTGV2ZWxBd2FpdCgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0MDk2KSA+IDA7XG4gIH1cbiAgc2V0IGhhc1RvcExldmVsQXdhaXQodikge1xuICAgIGlmICh2KSB0aGlzLmZsYWdzIHw9IDQwOTY7ZWxzZSB0aGlzLmZsYWdzICY9IC00MDk3O1xuICB9XG4gIGN1clBvc2l0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5jdXJMaW5lLCB0aGlzLnBvcyAtIHRoaXMubGluZVN0YXJ0LCB0aGlzLnBvcyArIHRoaXMuc3RhcnRJbmRleCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgICBzdGF0ZS5mbGFncyA9IHRoaXMuZmxhZ3M7XG4gICAgc3RhdGUuc3RhcnRJbmRleCA9IHRoaXMuc3RhcnRJbmRleDtcbiAgICBzdGF0ZS5jdXJMaW5lID0gdGhpcy5jdXJMaW5lO1xuICAgIHN0YXRlLmxpbmVTdGFydCA9IHRoaXMubGluZVN0YXJ0O1xuICAgIHN0YXRlLnN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICBzdGF0ZS5lbmRMb2MgPSB0aGlzLmVuZExvYztcbiAgICBzdGF0ZS5lcnJvcnMgPSB0aGlzLmVycm9ycy5zbGljZSgpO1xuICAgIHN0YXRlLnBvdGVudGlhbEFycm93QXQgPSB0aGlzLnBvdGVudGlhbEFycm93QXQ7XG4gICAgc3RhdGUubm9BcnJvd0F0ID0gdGhpcy5ub0Fycm93QXQuc2xpY2UoKTtcbiAgICBzdGF0ZS5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0ID0gdGhpcy5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0LnNsaWNlKCk7XG4gICAgc3RhdGUudG9waWNDb250ZXh0ID0gdGhpcy50b3BpY0NvbnRleHQ7XG4gICAgc3RhdGUubGFiZWxzID0gdGhpcy5sYWJlbHMuc2xpY2UoKTtcbiAgICBzdGF0ZS5jb21tZW50c0xlbiA9IHRoaXMuY29tbWVudHNMZW47XG4gICAgc3RhdGUuY29tbWVudFN0YWNrID0gdGhpcy5jb21tZW50U3RhY2suc2xpY2UoKTtcbiAgICBzdGF0ZS5wb3MgPSB0aGlzLnBvcztcbiAgICBzdGF0ZS50eXBlID0gdGhpcy50eXBlO1xuICAgIHN0YXRlLnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICBzdGF0ZS5zdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgc3RhdGUuZW5kID0gdGhpcy5lbmQ7XG4gICAgc3RhdGUubGFzdFRva0VuZExvYyA9IHRoaXMubGFzdFRva0VuZExvYztcbiAgICBzdGF0ZS5sYXN0VG9rU3RhcnRMb2MgPSB0aGlzLmxhc3RUb2tTdGFydExvYztcbiAgICBzdGF0ZS5jb250ZXh0ID0gdGhpcy5jb250ZXh0LnNsaWNlKCk7XG4gICAgc3RhdGUuZmlyc3RJbnZhbGlkVGVtcGxhdGVFc2NhcGVQb3MgPSB0aGlzLmZpcnN0SW52YWxpZFRlbXBsYXRlRXNjYXBlUG9zO1xuICAgIHN0YXRlLnN0cmljdEVycm9ycyA9IHRoaXMuc3RyaWN0RXJyb3JzO1xuICAgIHN0YXRlLnRva2Vuc0xlbmd0aCA9IHRoaXMudG9rZW5zTGVuZ3RoO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxudmFyIF9pc0RpZ2l0ID0gZnVuY3Rpb24gaXNEaWdpdChjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTc7XG59O1xuY29uc3QgZm9yYmlkZGVuTnVtZXJpY1NlcGFyYXRvclNpYmxpbmdzID0ge1xuICBkZWNCaW5PY3Q6IG5ldyBTZXQoWzQ2LCA2NiwgNjksIDc5LCA5NSwgOTgsIDEwMSwgMTExXSksXG4gIGhleDogbmV3IFNldChbNDYsIDg4LCA5NSwgMTIwXSlcbn07XG5jb25zdCBpc0FsbG93ZWROdW1lcmljU2VwYXJhdG9yU2libGluZyA9IHtcbiAgYmluOiBjaCA9PiBjaCA9PT0gNDggfHwgY2ggPT09IDQ5LFxuICBvY3Q6IGNoID0+IGNoID49IDQ4ICYmIGNoIDw9IDU1LFxuICBkZWM6IGNoID0+IGNoID49IDQ4ICYmIGNoIDw9IDU3LFxuICBoZXg6IGNoID0+IGNoID49IDQ4ICYmIGNoIDw9IDU3IHx8IGNoID49IDY1ICYmIGNoIDw9IDcwIHx8IGNoID49IDk3ICYmIGNoIDw9IDEwMlxufTtcbmZ1bmN0aW9uIHJlYWRTdHJpbmdDb250ZW50cyh0eXBlLCBpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIGVycm9ycykge1xuICBjb25zdCBpbml0aWFsUG9zID0gcG9zO1xuICBjb25zdCBpbml0aWFsTGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICBjb25zdCBpbml0aWFsQ3VyTGluZSA9IGN1ckxpbmU7XG4gIGxldCBvdXQgPSBcIlwiO1xuICBsZXQgZmlyc3RJbnZhbGlkTG9jID0gbnVsbDtcbiAgbGV0IGNodW5rU3RhcnQgPSBwb3M7XG4gIGNvbnN0IHtcbiAgICBsZW5ndGhcbiAgfSA9IGlucHV0O1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHBvcyA+PSBsZW5ndGgpIHtcbiAgICAgIGVycm9ycy51bnRlcm1pbmF0ZWQoaW5pdGlhbFBvcywgaW5pdGlhbExpbmVTdGFydCwgaW5pdGlhbEN1ckxpbmUpO1xuICAgICAgb3V0ICs9IGlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHBvcyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGlzU3RyaW5nRW5kKHR5cGUsIGNoLCBpbnB1dCwgcG9zKSkge1xuICAgICAgb3V0ICs9IGlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHBvcyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGNoID09PSA5Mikge1xuICAgICAgb3V0ICs9IGlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHBvcyk7XG4gICAgICBjb25zdCByZXMgPSByZWFkRXNjYXBlZENoYXIoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCB0eXBlID09PSBcInRlbXBsYXRlXCIsIGVycm9ycyk7XG4gICAgICBpZiAocmVzLmNoID09PSBudWxsICYmICFmaXJzdEludmFsaWRMb2MpIHtcbiAgICAgICAgZmlyc3RJbnZhbGlkTG9jID0ge1xuICAgICAgICAgIHBvcyxcbiAgICAgICAgICBsaW5lU3RhcnQsXG4gICAgICAgICAgY3VyTGluZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9IHJlcy5jaDtcbiAgICAgIH1cbiAgICAgICh7XG4gICAgICAgIHBvcyxcbiAgICAgICAgbGluZVN0YXJ0LFxuICAgICAgICBjdXJMaW5lXG4gICAgICB9ID0gcmVzKTtcbiAgICAgIGNodW5rU3RhcnQgPSBwb3M7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gODIzMiB8fCBjaCA9PT0gODIzMykge1xuICAgICAgKytwb3M7XG4gICAgICArK2N1ckxpbmU7XG4gICAgICBsaW5lU3RhcnQgPSBwb3M7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMTAgfHwgY2ggPT09IDEzKSB7XG4gICAgICBpZiAodHlwZSA9PT0gXCJ0ZW1wbGF0ZVwiKSB7XG4gICAgICAgIG91dCArPSBpbnB1dC5zbGljZShjaHVua1N0YXJ0LCBwb3MpICsgXCJcXG5cIjtcbiAgICAgICAgKytwb3M7XG4gICAgICAgIGlmIChjaCA9PT0gMTMgJiYgaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAxMCkge1xuICAgICAgICAgICsrcG9zO1xuICAgICAgICB9XG4gICAgICAgICsrY3VyTGluZTtcbiAgICAgICAgY2h1bmtTdGFydCA9IGxpbmVTdGFydCA9IHBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9ycy51bnRlcm1pbmF0ZWQoaW5pdGlhbFBvcywgaW5pdGlhbExpbmVTdGFydCwgaW5pdGlhbEN1ckxpbmUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICArK3BvcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwb3MsXG4gICAgc3RyOiBvdXQsXG4gICAgZmlyc3RJbnZhbGlkTG9jLFxuICAgIGxpbmVTdGFydCxcbiAgICBjdXJMaW5lLFxuICAgIGNvbnRhaW5zSW52YWxpZDogISFmaXJzdEludmFsaWRMb2NcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nRW5kKHR5cGUsIGNoLCBpbnB1dCwgcG9zKSB7XG4gIGlmICh0eXBlID09PSBcInRlbXBsYXRlXCIpIHtcbiAgICByZXR1cm4gY2ggPT09IDk2IHx8IGNoID09PSAzNiAmJiBpbnB1dC5jaGFyQ29kZUF0KHBvcyArIDEpID09PSAxMjM7XG4gIH1cbiAgcmV0dXJuIGNoID09PSAodHlwZSA9PT0gXCJkb3VibGVcIiA/IDM0IDogMzkpO1xufVxuZnVuY3Rpb24gcmVhZEVzY2FwZWRDaGFyKGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgaW5UZW1wbGF0ZSwgZXJyb3JzKSB7XG4gIGNvbnN0IHRocm93T25JbnZhbGlkID0gIWluVGVtcGxhdGU7XG4gIHBvcysrO1xuICBjb25zdCByZXMgPSBjaCA9PiAoe1xuICAgIHBvcyxcbiAgICBjaCxcbiAgICBsaW5lU3RhcnQsXG4gICAgY3VyTGluZVxuICB9KTtcbiAgY29uc3QgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHBvcysrKTtcbiAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMTEwOlxuICAgICAgcmV0dXJuIHJlcyhcIlxcblwiKTtcbiAgICBjYXNlIDExNDpcbiAgICAgIHJldHVybiByZXMoXCJcXHJcIik7XG4gICAgY2FzZSAxMjA6XG4gICAgICB7XG4gICAgICAgIGxldCBjb2RlO1xuICAgICAgICAoe1xuICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgcG9zXG4gICAgICAgIH0gPSByZWFkSGV4Q2hhcihpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIDIsIGZhbHNlLCB0aHJvd09uSW52YWxpZCwgZXJyb3JzKSk7XG4gICAgICAgIHJldHVybiByZXMoY29kZSA9PT0gbnVsbCA/IG51bGwgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgICAgIH1cbiAgICBjYXNlIDExNzpcbiAgICAgIHtcbiAgICAgICAgbGV0IGNvZGU7XG4gICAgICAgICh7XG4gICAgICAgICAgY29kZSxcbiAgICAgICAgICBwb3NcbiAgICAgICAgfSA9IHJlYWRDb2RlUG9pbnQoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCB0aHJvd09uSW52YWxpZCwgZXJyb3JzKSk7XG4gICAgICAgIHJldHVybiByZXMoY29kZSA9PT0gbnVsbCA/IG51bGwgOiBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlKSk7XG4gICAgICB9XG4gICAgY2FzZSAxMTY6XG4gICAgICByZXR1cm4gcmVzKFwiXFx0XCIpO1xuICAgIGNhc2UgOTg6XG4gICAgICByZXR1cm4gcmVzKFwiXFxiXCIpO1xuICAgIGNhc2UgMTE4OlxuICAgICAgcmV0dXJuIHJlcyhcIlxcdTAwMGJcIik7XG4gICAgY2FzZSAxMDI6XG4gICAgICByZXR1cm4gcmVzKFwiXFxmXCIpO1xuICAgIGNhc2UgMTM6XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAxMCkge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICBjYXNlIDEwOlxuICAgICAgbGluZVN0YXJ0ID0gcG9zO1xuICAgICAgKytjdXJMaW5lO1xuICAgIGNhc2UgODIzMjpcbiAgICBjYXNlIDgyMzM6XG4gICAgICByZXR1cm4gcmVzKFwiXCIpO1xuICAgIGNhc2UgNTY6XG4gICAgY2FzZSA1NzpcbiAgICAgIGlmIChpblRlbXBsYXRlKSB7XG4gICAgICAgIHJldHVybiByZXMobnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcnMuc3RyaWN0TnVtZXJpY0VzY2FwZShwb3MgLSAxLCBsaW5lU3RhcnQsIGN1ckxpbmUpO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoY2ggPj0gNDggJiYgY2ggPD0gNTUpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRQb3MgPSBwb3MgLSAxO1xuICAgICAgICBjb25zdCBtYXRjaCA9IC9eWzAtN10rLy5leGVjKGlucHV0LnNsaWNlKHN0YXJ0UG9zLCBwb3MgKyAyKSk7XG4gICAgICAgIGxldCBvY3RhbFN0ciA9IG1hdGNoWzBdO1xuICAgICAgICBsZXQgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICAgIGlmIChvY3RhbCA+IDI1NSkge1xuICAgICAgICAgIG9jdGFsU3RyID0gb2N0YWxTdHIuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgIG9jdGFsID0gcGFyc2VJbnQob2N0YWxTdHIsIDgpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBvY3RhbFN0ci5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAob2N0YWxTdHIgIT09IFwiMFwiIHx8IG5leHQgPT09IDU2IHx8IG5leHQgPT09IDU3KSB7XG4gICAgICAgICAgaWYgKGluVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMobnVsbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycy5zdHJpY3ROdW1lcmljRXNjYXBlKHN0YXJ0UG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzKFN0cmluZy5mcm9tQ2hhckNvZGUob2N0YWwpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXMoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpO1xuICB9XG59XG5mdW5jdGlvbiByZWFkSGV4Q2hhcihpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIGxlbiwgZm9yY2VMZW4sIHRocm93T25JbnZhbGlkLCBlcnJvcnMpIHtcbiAgY29uc3QgaW5pdGlhbFBvcyA9IHBvcztcbiAgbGV0IG47XG4gICh7XG4gICAgbixcbiAgICBwb3NcbiAgfSA9IHJlYWRJbnQoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCAxNiwgbGVuLCBmb3JjZUxlbiwgZmFsc2UsIGVycm9ycywgIXRocm93T25JbnZhbGlkKSk7XG4gIGlmIChuID09PSBudWxsKSB7XG4gICAgaWYgKHRocm93T25JbnZhbGlkKSB7XG4gICAgICBlcnJvcnMuaW52YWxpZEVzY2FwZVNlcXVlbmNlKGluaXRpYWxQb3MsIGxpbmVTdGFydCwgY3VyTGluZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcyA9IGluaXRpYWxQb3MgLSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGNvZGU6IG4sXG4gICAgcG9zXG4gIH07XG59XG5mdW5jdGlvbiByZWFkSW50KGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgcmFkaXgsIGxlbiwgZm9yY2VMZW4sIGFsbG93TnVtU2VwYXJhdG9yLCBlcnJvcnMsIGJhaWxPbkVycm9yKSB7XG4gIGNvbnN0IHN0YXJ0ID0gcG9zO1xuICBjb25zdCBmb3JiaWRkZW5TaWJsaW5ncyA9IHJhZGl4ID09PSAxNiA/IGZvcmJpZGRlbk51bWVyaWNTZXBhcmF0b3JTaWJsaW5ncy5oZXggOiBmb3JiaWRkZW5OdW1lcmljU2VwYXJhdG9yU2libGluZ3MuZGVjQmluT2N0O1xuICBjb25zdCBpc0FsbG93ZWRTaWJsaW5nID0gcmFkaXggPT09IDE2ID8gaXNBbGxvd2VkTnVtZXJpY1NlcGFyYXRvclNpYmxpbmcuaGV4IDogcmFkaXggPT09IDEwID8gaXNBbGxvd2VkTnVtZXJpY1NlcGFyYXRvclNpYmxpbmcuZGVjIDogcmFkaXggPT09IDggPyBpc0FsbG93ZWROdW1lcmljU2VwYXJhdG9yU2libGluZy5vY3QgOiBpc0FsbG93ZWROdW1lcmljU2VwYXJhdG9yU2libGluZy5iaW47XG4gIGxldCBpbnZhbGlkID0gZmFsc2U7XG4gIGxldCB0b3RhbCA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCBlID0gbGVuID09IG51bGwgPyBJbmZpbml0eSA6IGxlbjsgaSA8IGU7ICsraSkge1xuICAgIGNvbnN0IGNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgbGV0IHZhbDtcbiAgICBpZiAoY29kZSA9PT0gOTUgJiYgYWxsb3dOdW1TZXBhcmF0b3IgIT09IFwiYmFpbFwiKSB7XG4gICAgICBjb25zdCBwcmV2ID0gaW5wdXQuY2hhckNvZGVBdChwb3MgLSAxKTtcbiAgICAgIGNvbnN0IG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICAgICAgaWYgKCFhbGxvd051bVNlcGFyYXRvcikge1xuICAgICAgICBpZiAoYmFpbE9uRXJyb3IpIHJldHVybiB7XG4gICAgICAgICAgbjogbnVsbCxcbiAgICAgICAgICBwb3NcbiAgICAgICAgfTtcbiAgICAgICAgZXJyb3JzLm51bWVyaWNTZXBhcmF0b3JJbkVzY2FwZVNlcXVlbmNlKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKTtcbiAgICAgIH0gZWxzZSBpZiAoTnVtYmVyLmlzTmFOKG5leHQpIHx8ICFpc0FsbG93ZWRTaWJsaW5nKG5leHQpIHx8IGZvcmJpZGRlblNpYmxpbmdzLmhhcyhwcmV2KSB8fCBmb3JiaWRkZW5TaWJsaW5ncy5oYXMobmV4dCkpIHtcbiAgICAgICAgaWYgKGJhaWxPbkVycm9yKSByZXR1cm4ge1xuICAgICAgICAgIG46IG51bGwsXG4gICAgICAgICAgcG9zXG4gICAgICAgIH07XG4gICAgICAgIGVycm9ycy51bmV4cGVjdGVkTnVtZXJpY1NlcGFyYXRvcihwb3MsIGxpbmVTdGFydCwgY3VyTGluZSk7XG4gICAgICB9XG4gICAgICArK3BvcztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY29kZSA+PSA5Nykge1xuICAgICAgdmFsID0gY29kZSAtIDk3ICsgMTA7XG4gICAgfSBlbHNlIGlmIChjb2RlID49IDY1KSB7XG4gICAgICB2YWwgPSBjb2RlIC0gNjUgKyAxMDtcbiAgICB9IGVsc2UgaWYgKF9pc0RpZ2l0KGNvZGUpKSB7XG4gICAgICB2YWwgPSBjb2RlIC0gNDg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IEluZmluaXR5O1xuICAgIH1cbiAgICBpZiAodmFsID49IHJhZGl4KSB7XG4gICAgICBpZiAodmFsIDw9IDkgJiYgYmFpbE9uRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuOiBudWxsLFxuICAgICAgICAgIHBvc1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh2YWwgPD0gOSAmJiBlcnJvcnMuaW52YWxpZERpZ2l0KHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCByYWRpeCkpIHtcbiAgICAgICAgdmFsID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoZm9yY2VMZW4pIHtcbiAgICAgICAgdmFsID0gMDtcbiAgICAgICAgaW52YWxpZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgKytwb3M7XG4gICAgdG90YWwgPSB0b3RhbCAqIHJhZGl4ICsgdmFsO1xuICB9XG4gIGlmIChwb3MgPT09IHN0YXJ0IHx8IGxlbiAhPSBudWxsICYmIHBvcyAtIHN0YXJ0ICE9PSBsZW4gfHwgaW52YWxpZCkge1xuICAgIHJldHVybiB7XG4gICAgICBuOiBudWxsLFxuICAgICAgcG9zXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG46IHRvdGFsLFxuICAgIHBvc1xuICB9O1xufVxuZnVuY3Rpb24gcmVhZENvZGVQb2ludChpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIHRocm93T25JbnZhbGlkLCBlcnJvcnMpIHtcbiAgY29uc3QgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyk7XG4gIGxldCBjb2RlO1xuICBpZiAoY2ggPT09IDEyMykge1xuICAgICsrcG9zO1xuICAgICh7XG4gICAgICBjb2RlLFxuICAgICAgcG9zXG4gICAgfSA9IHJlYWRIZXhDaGFyKGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgaW5wdXQuaW5kZXhPZihcIn1cIiwgcG9zKSAtIHBvcywgdHJ1ZSwgdGhyb3dPbkludmFsaWQsIGVycm9ycykpO1xuICAgICsrcG9zO1xuICAgIGlmIChjb2RlICE9PSBudWxsICYmIGNvZGUgPiAweDEwZmZmZikge1xuICAgICAgaWYgKHRocm93T25JbnZhbGlkKSB7XG4gICAgICAgIGVycm9ycy5pbnZhbGlkQ29kZVBvaW50KHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29kZTogbnVsbCxcbiAgICAgICAgICBwb3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgKHtcbiAgICAgIGNvZGUsXG4gICAgICBwb3NcbiAgICB9ID0gcmVhZEhleENoYXIoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCA0LCBmYWxzZSwgdGhyb3dPbkludmFsaWQsIGVycm9ycykpO1xuICB9XG4gIHJldHVybiB7XG4gICAgY29kZSxcbiAgICBwb3NcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUG9zaXRpb24ocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpIHtcbiAgcmV0dXJuIG5ldyBQb3NpdGlvbihjdXJMaW5lLCBwb3MgLSBsaW5lU3RhcnQsIHBvcyk7XG59XG5jb25zdCBWQUxJRF9SRUdFWF9GTEFHUyA9IG5ldyBTZXQoWzEwMywgMTA5LCAxMTUsIDEwNSwgMTIxLCAxMTcsIDEwMCwgMTE4XSk7XG5jbGFzcyBUb2tlbiB7XG4gIGNvbnN0cnVjdG9yKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IHN0YXRlLnN0YXJ0SW5kZXggfHwgMDtcbiAgICB0aGlzLnR5cGUgPSBzdGF0ZS50eXBlO1xuICAgIHRoaXMudmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnRJbmRleCArIHN0YXRlLnN0YXJ0O1xuICAgIHRoaXMuZW5kID0gc3RhcnRJbmRleCArIHN0YXRlLmVuZDtcbiAgICB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbihzdGF0ZS5zdGFydExvYywgc3RhdGUuZW5kTG9jKTtcbiAgfVxufVxuY2xhc3MgVG9rZW5pemVyIGV4dGVuZHMgQ29tbWVudHNQYXJzZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBpbnB1dCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pc0xvb2thaGVhZCA9IHZvaWQgMDtcbiAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkSW50ID0ge1xuICAgICAgaW52YWxpZERpZ2l0OiAocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIHJhZGl4KSA9PiB7XG4gICAgICAgIGlmICghKHRoaXMub3B0aW9uRmxhZ3MgJiAyMDQ4KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkRGlnaXQsIGJ1aWxkUG9zaXRpb24ocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpLCB7XG4gICAgICAgICAgcmFkaXhcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIG51bWVyaWNTZXBhcmF0b3JJbkVzY2FwZVNlcXVlbmNlOiB0aGlzLmVycm9yQnVpbGRlcihFcnJvcnMuTnVtZXJpY1NlcGFyYXRvckluRXNjYXBlU2VxdWVuY2UpLFxuICAgICAgdW5leHBlY3RlZE51bWVyaWNTZXBhcmF0b3I6IHRoaXMuZXJyb3JCdWlsZGVyKEVycm9ycy5VbmV4cGVjdGVkTnVtZXJpY1NlcGFyYXRvcilcbiAgICB9O1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkQ29kZVBvaW50ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5lcnJvckhhbmRsZXJzX3JlYWRJbnQsIHtcbiAgICAgIGludmFsaWRFc2NhcGVTZXF1ZW5jZTogdGhpcy5lcnJvckJ1aWxkZXIoRXJyb3JzLkludmFsaWRFc2NhcGVTZXF1ZW5jZSksXG4gICAgICBpbnZhbGlkQ29kZVBvaW50OiB0aGlzLmVycm9yQnVpbGRlcihFcnJvcnMuSW52YWxpZENvZGVQb2ludClcbiAgICB9KTtcbiAgICB0aGlzLmVycm9ySGFuZGxlcnNfcmVhZFN0cmluZ0NvbnRlbnRzX3N0cmluZyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkQ29kZVBvaW50LCB7XG4gICAgICBzdHJpY3ROdW1lcmljRXNjYXBlOiAocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpID0+IHtcbiAgICAgICAgdGhpcy5yZWNvcmRTdHJpY3RNb2RlRXJyb3JzKEVycm9ycy5TdHJpY3ROdW1lcmljRXNjYXBlLCBidWlsZFBvc2l0aW9uKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKSk7XG4gICAgICB9LFxuICAgICAgdW50ZXJtaW5hdGVkOiAocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpID0+IHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW50ZXJtaW5hdGVkU3RyaW5nLCBidWlsZFBvc2l0aW9uKHBvcyAtIDEsIGxpbmVTdGFydCwgY3VyTGluZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkU3RyaW5nQ29udGVudHNfdGVtcGxhdGUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmVycm9ySGFuZGxlcnNfcmVhZENvZGVQb2ludCwge1xuICAgICAgc3RyaWN0TnVtZXJpY0VzY2FwZTogdGhpcy5lcnJvckJ1aWxkZXIoRXJyb3JzLlN0cmljdE51bWVyaWNFc2NhcGUpLFxuICAgICAgdW50ZXJtaW5hdGVkOiAocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpID0+IHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW50ZXJtaW5hdGVkVGVtcGxhdGUsIGJ1aWxkUG9zaXRpb24ocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnN0YXRlID0gbmV3IFN0YXRlKCk7XG4gICAgdGhpcy5zdGF0ZS5pbml0KG9wdGlvbnMpO1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLmxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICB0aGlzLmNvbW1lbnRzID0gW107XG4gICAgdGhpcy5pc0xvb2thaGVhZCA9IGZhbHNlO1xuICB9XG4gIHB1c2hUb2tlbih0b2tlbikge1xuICAgIHRoaXMudG9rZW5zLmxlbmd0aCA9IHRoaXMuc3RhdGUudG9rZW5zTGVuZ3RoO1xuICAgIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICAgICsrdGhpcy5zdGF0ZS50b2tlbnNMZW5ndGg7XG4gIH1cbiAgbmV4dCgpIHtcbiAgICB0aGlzLmNoZWNrS2V5d29yZEVzY2FwZXMoKTtcbiAgICBpZiAodGhpcy5vcHRpb25GbGFncyAmIDI1Nikge1xuICAgICAgdGhpcy5wdXNoVG9rZW4obmV3IFRva2VuKHRoaXMuc3RhdGUpKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jID0gdGhpcy5zdGF0ZS5lbmRMb2M7XG4gICAgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIHRoaXMubmV4dFRva2VuKCk7XG4gIH1cbiAgZWF0KHR5cGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBtYXRjaCh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUudHlwZSA9PT0gdHlwZTtcbiAgfVxuICBjcmVhdGVMb29rYWhlYWRTdGF0ZShzdGF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBwb3M6IHN0YXRlLnBvcyxcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgdHlwZTogc3RhdGUudHlwZSxcbiAgICAgIHN0YXJ0OiBzdGF0ZS5zdGFydCxcbiAgICAgIGVuZDogc3RhdGUuZW5kLFxuICAgICAgY29udGV4dDogW3RoaXMuY3VyQ29udGV4dCgpXSxcbiAgICAgIGluVHlwZTogc3RhdGUuaW5UeXBlLFxuICAgICAgc3RhcnRMb2M6IHN0YXRlLnN0YXJ0TG9jLFxuICAgICAgbGFzdFRva0VuZExvYzogc3RhdGUubGFzdFRva0VuZExvYyxcbiAgICAgIGN1ckxpbmU6IHN0YXRlLmN1ckxpbmUsXG4gICAgICBsaW5lU3RhcnQ6IHN0YXRlLmxpbmVTdGFydCxcbiAgICAgIGN1clBvc2l0aW9uOiBzdGF0ZS5jdXJQb3NpdGlvblxuICAgIH07XG4gIH1cbiAgbG9va2FoZWFkKCkge1xuICAgIGNvbnN0IG9sZCA9IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMuY3JlYXRlTG9va2FoZWFkU3RhdGUob2xkKTtcbiAgICB0aGlzLmlzTG9va2FoZWFkID0gdHJ1ZTtcbiAgICB0aGlzLm5leHRUb2tlbigpO1xuICAgIHRoaXMuaXNMb29rYWhlYWQgPSBmYWxzZTtcbiAgICBjb25zdCBjdXJyID0gdGhpcy5zdGF0ZTtcbiAgICB0aGlzLnN0YXRlID0gb2xkO1xuICAgIHJldHVybiBjdXJyO1xuICB9XG4gIG5leHRUb2tlblN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLm5leHRUb2tlblN0YXJ0U2luY2UodGhpcy5zdGF0ZS5wb3MpO1xuICB9XG4gIG5leHRUb2tlblN0YXJ0U2luY2UocG9zKSB7XG4gICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gcG9zO1xuICAgIHJldHVybiBza2lwV2hpdGVTcGFjZS50ZXN0KHRoaXMuaW5wdXQpID8gc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4IDogcG9zO1xuICB9XG4gIGxvb2thaGVhZENoYXJDb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5uZXh0VG9rZW5TdGFydCgpKTtcbiAgfVxuICBuZXh0VG9rZW5JbkxpbmVTdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW5JbkxpbmVTdGFydFNpbmNlKHRoaXMuc3RhdGUucG9zKTtcbiAgfVxuICBuZXh0VG9rZW5JbkxpbmVTdGFydFNpbmNlKHBvcykge1xuICAgIHNraXBXaGl0ZVNwYWNlSW5MaW5lLmxhc3RJbmRleCA9IHBvcztcbiAgICByZXR1cm4gc2tpcFdoaXRlU3BhY2VJbkxpbmUudGVzdCh0aGlzLmlucHV0KSA/IHNraXBXaGl0ZVNwYWNlSW5MaW5lLmxhc3RJbmRleCA6IHBvcztcbiAgfVxuICBsb29rYWhlYWRJbkxpbmVDaGFyQ29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMubmV4dFRva2VuSW5MaW5lU3RhcnQoKSk7XG4gIH1cbiAgY29kZVBvaW50QXRQb3MocG9zKSB7XG4gICAgbGV0IGNwID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKChjcCAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiArK3BvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICBjb25zdCB0cmFpbCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKCh0cmFpbCAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjcCA9IDB4MTAwMDAgKyAoKGNwICYgMHgzZmYpIDw8IDEwKSArICh0cmFpbCAmIDB4M2ZmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNwO1xuICB9XG4gIHNldFN0cmljdChzdHJpY3QpIHtcbiAgICB0aGlzLnN0YXRlLnN0cmljdCA9IHN0cmljdDtcbiAgICBpZiAoc3RyaWN0KSB7XG4gICAgICB0aGlzLnN0YXRlLnN0cmljdEVycm9ycy5mb3JFYWNoKChbdG9QYXJzZUVycm9yLCBhdF0pID0+IHRoaXMucmFpc2UodG9QYXJzZUVycm9yLCBhdCkpO1xuICAgICAgdGhpcy5zdGF0ZS5zdHJpY3RFcnJvcnMuY2xlYXIoKTtcbiAgICB9XG4gIH1cbiAgY3VyQ29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5jb250ZXh0W3RoaXMuc3RhdGUuY29udGV4dC5sZW5ndGggLSAxXTtcbiAgfVxuICBuZXh0VG9rZW4oKSB7XG4gICAgdGhpcy5za2lwU3BhY2UoKTtcbiAgICB0aGlzLnN0YXRlLnN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgaWYgKCF0aGlzLmlzTG9va2FoZWFkKSB0aGlzLnN0YXRlLnN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpO1xuICAgIGlmICh0aGlzLnN0YXRlLnBvcyA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxNDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmdldFRva2VuRnJvbUNvZGUodGhpcy5jb2RlUG9pbnRBdFBvcyh0aGlzLnN0YXRlLnBvcykpO1xuICB9XG4gIHNraXBCbG9ja0NvbW1lbnQoY29tbWVudEVuZCkge1xuICAgIGxldCBzdGFydExvYztcbiAgICBpZiAoIXRoaXMuaXNMb29rYWhlYWQpIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgY29uc3QgZW5kID0gdGhpcy5pbnB1dC5pbmRleE9mKGNvbW1lbnRFbmQsIHN0YXJ0ICsgMik7XG4gICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVudGVybWluYXRlZENvbW1lbnQsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUucG9zID0gZW5kICsgY29tbWVudEVuZC5sZW5ndGg7XG4gICAgbGluZUJyZWFrRy5sYXN0SW5kZXggPSBzdGFydCArIDI7XG4gICAgd2hpbGUgKGxpbmVCcmVha0cudGVzdCh0aGlzLmlucHV0KSAmJiBsaW5lQnJlYWtHLmxhc3RJbmRleCA8PSBlbmQpIHtcbiAgICAgICsrdGhpcy5zdGF0ZS5jdXJMaW5lO1xuICAgICAgdGhpcy5zdGF0ZS5saW5lU3RhcnQgPSBsaW5lQnJlYWtHLmxhc3RJbmRleDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNMb29rYWhlYWQpIHJldHVybjtcbiAgICBjb25zdCBjb21tZW50ID0ge1xuICAgICAgdHlwZTogXCJDb21tZW50QmxvY2tcIixcbiAgICAgIHZhbHVlOiB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgMiwgZW5kKSxcbiAgICAgIHN0YXJ0OiB0aGlzLnNvdXJjZVRvT2Zmc2V0UG9zKHN0YXJ0KSxcbiAgICAgIGVuZDogdGhpcy5zb3VyY2VUb09mZnNldFBvcyhlbmQgKyBjb21tZW50RW5kLmxlbmd0aCksXG4gICAgICBsb2M6IG5ldyBTb3VyY2VMb2NhdGlvbihzdGFydExvYywgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKVxuICAgIH07XG4gICAgaWYgKHRoaXMub3B0aW9uRmxhZ3MgJiAyNTYpIHRoaXMucHVzaFRva2VuKGNvbW1lbnQpO1xuICAgIHJldHVybiBjb21tZW50O1xuICB9XG4gIHNraXBMaW5lQ29tbWVudChzdGFydFNraXApIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIGxldCBzdGFydExvYztcbiAgICBpZiAoIXRoaXMuaXNMb29rYWhlYWQpIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpO1xuICAgIGxldCBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArPSBzdGFydFNraXApO1xuICAgIGlmICh0aGlzLnN0YXRlLnBvcyA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICB3aGlsZSAoIWlzTmV3TGluZShjaCkgJiYgKyt0aGlzLnN0YXRlLnBvcyA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuaXNMb29rYWhlYWQpIHJldHVybjtcbiAgICBjb25zdCBlbmQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQgKyBzdGFydFNraXAsIGVuZCk7XG4gICAgY29uc3QgY29tbWVudCA9IHtcbiAgICAgIHR5cGU6IFwiQ29tbWVudExpbmVcIixcbiAgICAgIHZhbHVlLFxuICAgICAgc3RhcnQ6IHRoaXMuc291cmNlVG9PZmZzZXRQb3Moc3RhcnQpLFxuICAgICAgZW5kOiB0aGlzLnNvdXJjZVRvT2Zmc2V0UG9zKGVuZCksXG4gICAgICBsb2M6IG5ldyBTb3VyY2VMb2NhdGlvbihzdGFydExvYywgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKVxuICAgIH07XG4gICAgaWYgKHRoaXMub3B0aW9uRmxhZ3MgJiAyNTYpIHRoaXMucHVzaFRva2VuKGNvbW1lbnQpO1xuICAgIHJldHVybiBjb21tZW50O1xuICB9XG4gIHNraXBTcGFjZSgpIHtcbiAgICBjb25zdCBzcGFjZVN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgY29uc3QgY29tbWVudHMgPSB0aGlzLm9wdGlvbkZsYWdzICYgNDA5NiA/IFtdIDogbnVsbDtcbiAgICBsb29wOiB3aGlsZSAodGhpcy5zdGF0ZS5wb3MgPCB0aGlzLmxlbmd0aCkge1xuICAgICAgY29uc3QgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlIDMyOlxuICAgICAgICBjYXNlIDE2MDpcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpID09PSAxMCkge1xuICAgICAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgIGNhc2UgODIzMjpcbiAgICAgICAgY2FzZSA4MjMzOlxuICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgKyt0aGlzLnN0YXRlLmN1ckxpbmU7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5saW5lU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpKSB7XG4gICAgICAgICAgICBjYXNlIDQyOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IHRoaXMuc2tpcEJsb2NrQ29tbWVudChcIiovXCIpO1xuICAgICAgICAgICAgICAgIGlmIChjb21tZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29tbWVudChjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgIGNvbW1lbnRzID09IG51bGwgfHwgY29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21tZW50ID0gdGhpcy5za2lwTGluZUNvbW1lbnQoMik7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5hZGRDb21tZW50KGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgY29tbWVudHMgPT0gbnVsbCB8fCBjb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjaCkpIHtcbiAgICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gNDUgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5vcHRpb25GbGFncyAmIDgxOTIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MgKyAxKSA9PT0gNDUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyArIDIpID09PSA2MiAmJiAoc3BhY2VTdGFydCA9PT0gMCB8fCB0aGlzLnN0YXRlLmxpbmVTdGFydCA+IHNwYWNlU3RhcnQpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSB0aGlzLnNraXBMaW5lQ29tbWVudCgzKTtcbiAgICAgICAgICAgICAgaWYgKGNvbW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29tbWVudChjb21tZW50KTtcbiAgICAgICAgICAgICAgICBjb21tZW50cyA9PSBudWxsIHx8IGNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gNjAgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5vcHRpb25GbGFncyAmIDgxOTIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MgKyAxKSA9PT0gMzMgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyArIDIpID09PSA0NSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zICsgMykgPT09IDQ1KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSB0aGlzLnNraXBMaW5lQ29tbWVudCg0KTtcbiAgICAgICAgICAgICAgaWYgKGNvbW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29tbWVudChjb21tZW50KTtcbiAgICAgICAgICAgICAgICBjb21tZW50cyA9PSBudWxsIHx8IGNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKGNvbW1lbnRzID09IG51bGwgPyB2b2lkIDAgOiBjb21tZW50cy5sZW5ndGgpID4gMCkge1xuICAgICAgY29uc3QgZW5kID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgICBjb25zdCBjb21tZW50V2hpdGVzcGFjZSA9IHtcbiAgICAgICAgc3RhcnQ6IHRoaXMuc291cmNlVG9PZmZzZXRQb3Moc3BhY2VTdGFydCksXG4gICAgICAgIGVuZDogdGhpcy5zb3VyY2VUb09mZnNldFBvcyhlbmQpLFxuICAgICAgICBjb21tZW50cyxcbiAgICAgICAgbGVhZGluZ05vZGU6IG51bGwsXG4gICAgICAgIHRyYWlsaW5nTm9kZTogbnVsbCxcbiAgICAgICAgY29udGFpbmluZ05vZGU6IG51bGxcbiAgICAgIH07XG4gICAgICB0aGlzLnN0YXRlLmNvbW1lbnRTdGFjay5wdXNoKGNvbW1lbnRXaGl0ZXNwYWNlKTtcbiAgICB9XG4gIH1cbiAgZmluaXNoVG9rZW4odHlwZSwgdmFsKSB7XG4gICAgdGhpcy5zdGF0ZS5lbmQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICB0aGlzLnN0YXRlLmVuZExvYyA9IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKTtcbiAgICBjb25zdCBwcmV2VHlwZSA9IHRoaXMuc3RhdGUudHlwZTtcbiAgICB0aGlzLnN0YXRlLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuc3RhdGUudmFsdWUgPSB2YWw7XG4gICAgaWYgKCF0aGlzLmlzTG9va2FoZWFkKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNvbnRleHQocHJldlR5cGUpO1xuICAgIH1cbiAgfVxuICByZXBsYWNlVG9rZW4odHlwZSkge1xuICAgIHRoaXMuc3RhdGUudHlwZSA9IHR5cGU7XG4gICAgdGhpcy51cGRhdGVDb250ZXh0KCk7XG4gIH1cbiAgcmVhZFRva2VuX251bWJlclNpZ24oKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUucG9zID09PSAwICYmIHRoaXMucmVhZFRva2VuX2ludGVycHJldGVyKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV4dFBvcyA9IHRoaXMuc3RhdGUucG9zICsgMTtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5jb2RlUG9pbnRBdFBvcyhuZXh0UG9zKTtcbiAgICBpZiAobmV4dCA+PSA0OCAmJiBuZXh0IDw9IDU3KSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkRGlnaXRBZnRlckhhc2gsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgfVxuICAgIGlmIChuZXh0ID09PSAxMjMgfHwgbmV4dCA9PT0gOTEgJiYgdGhpcy5oYXNQbHVnaW4oXCJyZWNvcmRBbmRUdXBsZVwiKSkge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJyZWNvcmRBbmRUdXBsZVwiKTtcbiAgICAgIGlmICh0aGlzLmdldFBsdWdpbk9wdGlvbihcInJlY29yZEFuZFR1cGxlXCIsIFwic3ludGF4VHlwZVwiKSA9PT0gXCJiYXJcIikge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKG5leHQgPT09IDEyMyA/IEVycm9ycy5SZWNvcmRFeHByZXNzaW9uSGFzaEluY29ycmVjdFN0YXJ0U3ludGF4VHlwZSA6IEVycm9ycy5UdXBsZUV4cHJlc3Npb25IYXNoSW5jb3JyZWN0U3RhcnRTeW50YXhUeXBlLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gMjtcbiAgICAgIGlmIChuZXh0ID09PSAxMjMpIHtcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbig3KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0lkZW50aWZpZXJTdGFydChuZXh0KSkge1xuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTM5LCB0aGlzLnJlYWRXb3JkMShuZXh0KSk7XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSA5Mikge1xuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTM5LCB0aGlzLnJlYWRXb3JkMSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5maW5pc2hPcCgyNywgMSk7XG4gICAgfVxuICB9XG4gIHJlYWRUb2tlbl9kb3QoKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID49IDQ4ICYmIG5leHQgPD0gNTcpIHtcbiAgICAgIHRoaXMucmVhZE51bWJlcih0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDQ2ICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDIpID09PSA0Nikge1xuICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gMztcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMjEpO1xuICAgIH0gZWxzZSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxNik7XG4gICAgfVxuICB9XG4gIHJlYWRUb2tlbl9zbGFzaCgpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDYxKSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDMxLCAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5maW5pc2hPcCg1NiwgMSk7XG4gICAgfVxuICB9XG4gIHJlYWRUb2tlbl9pbnRlcnByZXRlcigpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5wb3MgIT09IDAgfHwgdGhpcy5sZW5ndGggPCAyKSByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKGNoICE9PSAzMykgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgdGhpcy5zdGF0ZS5wb3MgKz0gMTtcbiAgICB3aGlsZSAoIWlzTmV3TGluZShjaCkgJiYgKyt0aGlzLnN0YXRlLnBvcyA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCArIDIsIHRoaXMuc3RhdGUucG9zKTtcbiAgICB0aGlzLmZpbmlzaFRva2VuKDI4LCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmVhZFRva2VuX211bHRfbW9kdWxvKGNvZGUpIHtcbiAgICBsZXQgdHlwZSA9IGNvZGUgPT09IDQyID8gNTUgOiA1NDtcbiAgICBsZXQgd2lkdGggPSAxO1xuICAgIGxldCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKGNvZGUgPT09IDQyICYmIG5leHQgPT09IDQyKSB7XG4gICAgICB3aWR0aCsrO1xuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDIpO1xuICAgICAgdHlwZSA9IDU3O1xuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNjEgJiYgIXRoaXMuc3RhdGUuaW5UeXBlKSB7XG4gICAgICB3aWR0aCsrO1xuICAgICAgdHlwZSA9IGNvZGUgPT09IDM3ID8gMzMgOiAzMDtcbiAgICB9XG4gICAgdGhpcy5maW5pc2hPcCh0eXBlLCB3aWR0aCk7XG4gIH1cbiAgcmVhZFRva2VuX3BpcGVfYW1wKGNvZGUpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAyKSA9PT0gNjEpIHtcbiAgICAgICAgdGhpcy5maW5pc2hPcCgzMCwgMyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IDQxIDogNDIsIDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gMTI0KSB7XG4gICAgICBpZiAobmV4dCA9PT0gNjIpIHtcbiAgICAgICAgdGhpcy5maW5pc2hPcCgzOSwgMik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpICYmIG5leHQgPT09IDEyNSkge1xuICAgICAgICBpZiAodGhpcy5nZXRQbHVnaW5PcHRpb24oXCJyZWNvcmRBbmRUdXBsZVwiLCBcInN5bnRheFR5cGVcIikgIT09IFwiYmFyXCIpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5SZWNvcmRFeHByZXNzaW9uQmFySW5jb3JyZWN0RW5kU3ludGF4VHlwZSwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJyZWNvcmRBbmRUdXBsZVwiKSAmJiBuZXh0ID09PSA5Mykge1xuICAgICAgICBpZiAodGhpcy5nZXRQbHVnaW5PcHRpb24oXCJyZWNvcmRBbmRUdXBsZVwiLCBcInN5bnRheFR5cGVcIikgIT09IFwiYmFyXCIpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5UdXBsZUV4cHJlc3Npb25CYXJJbmNvcnJlY3RFbmRTeW50YXhUeXBlLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUucG9zICs9IDI7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDYxKSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDMwLCAyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5maW5pc2hPcChjb2RlID09PSAxMjQgPyA0MyA6IDQ1LCAxKTtcbiAgfVxuICByZWFkVG9rZW5fY2FyZXQoKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSA2MSAmJiAhdGhpcy5zdGF0ZS5pblR5cGUpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoMzIsIDIpO1xuICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gOTQgJiYgdGhpcy5oYXNQbHVnaW4oW1wicGlwZWxpbmVPcGVyYXRvclwiLCB7XG4gICAgICBwcm9wb3NhbDogXCJoYWNrXCIsXG4gICAgICB0b3BpY1Rva2VuOiBcIl5eXCJcbiAgICB9XSkpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoMzcsIDIpO1xuICAgICAgY29uc3QgbG9va2FoZWFkQ2ggPSB0aGlzLmlucHV0LmNvZGVQb2ludEF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICAgIGlmIChsb29rYWhlYWRDaCA9PT0gOTQpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoNDQsIDEpO1xuICAgIH1cbiAgfVxuICByZWFkVG9rZW5fYXRTaWduKCkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjQgJiYgdGhpcy5oYXNQbHVnaW4oW1wicGlwZWxpbmVPcGVyYXRvclwiLCB7XG4gICAgICBwcm9wb3NhbDogXCJoYWNrXCIsXG4gICAgICB0b3BpY1Rva2VuOiBcIkBAXCJcbiAgICB9XSkpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoMzgsIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDI2LCAxKTtcbiAgICB9XG4gIH1cbiAgcmVhZFRva2VuX3BsdXNfbWluKGNvZGUpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoMzQsIDIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoMzAsIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDUzLCAxKTtcbiAgICB9XG4gIH1cbiAgcmVhZFRva2VuX2x0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBvc1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDYwKSB7XG4gICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyArIDIpID09PSA2MSkge1xuICAgICAgICB0aGlzLmZpbmlzaE9wKDMwLCAzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5maW5pc2hPcCg1MSwgMik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuZXh0ID09PSA2MSkge1xuICAgICAgdGhpcy5maW5pc2hPcCg0OSwgMik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZmluaXNoT3AoNDcsIDEpO1xuICB9XG4gIHJlYWRUb2tlbl9ndCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBwb3NcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSA2Mikge1xuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MgKyAyKSA9PT0gNjIgPyAzIDogMjtcbiAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zICsgc2l6ZSkgPT09IDYxKSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AoMzAsIHNpemUgKyAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5maW5pc2hPcCg1Miwgc2l6ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuZXh0ID09PSA2MSkge1xuICAgICAgdGhpcy5maW5pc2hPcCg0OSwgMik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZmluaXNoT3AoNDgsIDEpO1xuICB9XG4gIHJlYWRUb2tlbl9lcV9leGNsKGNvZGUpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDYxKSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDQ2LCB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAyKSA9PT0gNjEgPyAzIDogMik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjb2RlID09PSA2MSAmJiBuZXh0ID09PSA2Mikge1xuICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gMjtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDYxID8gMjkgOiAzNSwgMSk7XG4gIH1cbiAgcmVhZFRva2VuX3F1ZXN0aW9uKCkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBjb25zdCBuZXh0MiA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDIpO1xuICAgIGlmIChuZXh0ID09PSA2Mykge1xuICAgICAgaWYgKG5leHQyID09PSA2MSkge1xuICAgICAgICB0aGlzLmZpbmlzaE9wKDMwLCAzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AoNDAsIDIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gNDYgJiYgIShuZXh0MiA+PSA0OCAmJiBuZXh0MiA8PSA1NykpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zICs9IDI7XG4gICAgICB0aGlzLmZpbmlzaFRva2VuKDE4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTcpO1xuICAgIH1cbiAgfVxuICBnZXRUb2tlbkZyb21Db2RlKGNvZGUpIHtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgIGNhc2UgNDY6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX2RvdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDQwOlxuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDEwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA0MTpcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbigxMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNTk6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTMpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDQ0OlxuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDEyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA5MTpcbiAgICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwicmVjb3JkQW5kVHVwbGVcIikgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSkgPT09IDEyNCkge1xuICAgICAgICAgIGlmICh0aGlzLmdldFBsdWdpbk9wdGlvbihcInJlY29yZEFuZFR1cGxlXCIsIFwic3ludGF4VHlwZVwiKSAhPT0gXCJiYXJcIikge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVHVwbGVFeHByZXNzaW9uQmFySW5jb3JyZWN0U3RhcnRTeW50YXhUeXBlLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgOTM6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgMTIzOlxuICAgICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJyZWNvcmRBbmRUdXBsZVwiKSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKSA9PT0gMTI0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwicmVjb3JkQW5kVHVwbGVcIiwgXCJzeW50YXhUeXBlXCIpICE9PSBcImJhclwiKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5SZWNvcmRFeHByZXNzaW9uQmFySW5jb3JyZWN0U3RhcnRTeW50YXhUeXBlLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgICAgIHRoaXMuZmluaXNoVG9rZW4oNik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgMTI1OlxuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDU4OlxuICAgICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJmdW5jdGlvbkJpbmRcIikgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSkgPT09IDU4KSB7XG4gICAgICAgICAgdGhpcy5maW5pc2hPcCgxNSwgMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDE0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDYzOlxuICAgICAgICB0aGlzLnJlYWRUb2tlbl9xdWVzdGlvbigpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDk2OlxuICAgICAgICB0aGlzLnJlYWRUZW1wbGF0ZVRva2VuKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNDg6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPT09IDEyMCB8fCBuZXh0ID09PSA4OCkge1xuICAgICAgICAgICAgdGhpcy5yZWFkUmFkaXhOdW1iZXIoMTYpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV4dCA9PT0gMTExIHx8IG5leHQgPT09IDc5KSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRSYWRpeE51bWJlcig4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5leHQgPT09IDk4IHx8IG5leHQgPT09IDY2KSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRSYWRpeE51bWJlcigyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGNhc2UgNDk6XG4gICAgICBjYXNlIDUwOlxuICAgICAgY2FzZSA1MTpcbiAgICAgIGNhc2UgNTI6XG4gICAgICBjYXNlIDUzOlxuICAgICAgY2FzZSA1NDpcbiAgICAgIGNhc2UgNTU6XG4gICAgICBjYXNlIDU2OlxuICAgICAgY2FzZSA1NzpcbiAgICAgICAgdGhpcy5yZWFkTnVtYmVyKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSAzNDpcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIHRoaXMucmVhZFN0cmluZyhjb2RlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA0NzpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fc2xhc2goKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSAzNzpcbiAgICAgIGNhc2UgNDI6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX211bHRfbW9kdWxvKGNvZGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDEyNDpcbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX3BpcGVfYW1wKGNvZGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDk0OlxuICAgICAgICB0aGlzLnJlYWRUb2tlbl9jYXJldCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDQzOlxuICAgICAgY2FzZSA0NTpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fcGx1c19taW4oY29kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNjA6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX2x0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNjI6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX2d0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNjE6XG4gICAgICBjYXNlIDMzOlxuICAgICAgICB0aGlzLnJlYWRUb2tlbl9lcV9leGNsKGNvZGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDEyNjpcbiAgICAgICAgdGhpcy5maW5pc2hPcCgzNiwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNjQ6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX2F0U2lnbigpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDM1OlxuICAgICAgICB0aGlzLnJlYWRUb2tlbl9udW1iZXJTaWduKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgOTI6XG4gICAgICAgIHRoaXMucmVhZFdvcmQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNvZGUpKSB7XG4gICAgICAgICAgdGhpcy5yZWFkV29yZChjb2RlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZE9yVW5leHBlY3RlZFRva2VuLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCksIHtcbiAgICAgIHVuZXhwZWN0ZWQ6IFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGUpXG4gICAgfSk7XG4gIH1cbiAgZmluaXNoT3AodHlwZSwgc2l6ZSkge1xuICAgIGNvbnN0IHN0ciA9IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGF0ZS5wb3MsIHRoaXMuc3RhdGUucG9zICsgc2l6ZSk7XG4gICAgdGhpcy5zdGF0ZS5wb3MgKz0gc2l6ZTtcbiAgICB0aGlzLmZpbmlzaFRva2VuKHR5cGUsIHN0cik7XG4gIH1cbiAgcmVhZFJlZ2V4cCgpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXRlLnN0YXJ0ICsgMTtcbiAgICBsZXQgZXNjYXBlZCwgaW5DbGFzcztcbiAgICBsZXQge1xuICAgICAgcG9zXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgZm9yICg7OyArK3Bvcykge1xuICAgICAgaWYgKHBvcyA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbnRlcm1pbmF0ZWRSZWdFeHAsIGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldChzdGFydExvYywgMSkpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVudGVybWluYXRlZFJlZ0V4cCwgY3JlYXRlUG9zaXRpb25XaXRoQ29sdW1uT2Zmc2V0KHN0YXJ0TG9jLCAxKSk7XG4gICAgICB9XG4gICAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgICBlc2NhcGVkID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY2ggPT09IDkxKSB7XG4gICAgICAgICAgaW5DbGFzcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDkzICYmIGluQ2xhc3MpIHtcbiAgICAgICAgICBpbkNsYXNzID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDQ3ICYmICFpbkNsYXNzKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZXNjYXBlZCA9IGNoID09PSA5MjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY29udGVudCA9IHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHBvcyk7XG4gICAgKytwb3M7XG4gICAgbGV0IG1vZHMgPSBcIlwiO1xuICAgIGNvbnN0IG5leHRQb3MgPSAoKSA9PiBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQoc3RhcnRMb2MsIHBvcyArIDIgLSBzdGFydCk7XG4gICAgd2hpbGUgKHBvcyA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBjcCA9IHRoaXMuY29kZVBvaW50QXRQb3MocG9zKTtcbiAgICAgIGNvbnN0IGNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNwKTtcbiAgICAgIGlmIChWQUxJRF9SRUdFWF9GTEFHUy5oYXMoY3ApKSB7XG4gICAgICAgIGlmIChjcCA9PT0gMTE4KSB7XG4gICAgICAgICAgaWYgKG1vZHMuaW5jbHVkZXMoXCJ1XCIpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbmNvbXBhdGlibGVSZWdFeHBVVkZsYWdzLCBuZXh0UG9zKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjcCA9PT0gMTE3KSB7XG4gICAgICAgICAgaWYgKG1vZHMuaW5jbHVkZXMoXCJ2XCIpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbmNvbXBhdGlibGVSZWdFeHBVVkZsYWdzLCBuZXh0UG9zKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kcy5pbmNsdWRlcyhjaGFyKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkR1cGxpY2F0ZVJlZ0V4cEZsYWdzLCBuZXh0UG9zKCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzSWRlbnRpZmllckNoYXIoY3ApIHx8IGNwID09PSA5Mikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5NYWxmb3JtZWRSZWdFeHBGbGFncywgbmV4dFBvcygpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgKytwb3M7XG4gICAgICBtb2RzICs9IGNoYXI7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUucG9zID0gcG9zO1xuICAgIHRoaXMuZmluaXNoVG9rZW4oMTM4LCB7XG4gICAgICBwYXR0ZXJuOiBjb250ZW50LFxuICAgICAgZmxhZ3M6IG1vZHNcbiAgICB9KTtcbiAgfVxuICByZWFkSW50KHJhZGl4LCBsZW4sIGZvcmNlTGVuID0gZmFsc2UsIGFsbG93TnVtU2VwYXJhdG9yID0gdHJ1ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG4sXG4gICAgICBwb3NcbiAgICB9ID0gcmVhZEludCh0aGlzLmlucHV0LCB0aGlzLnN0YXRlLnBvcywgdGhpcy5zdGF0ZS5saW5lU3RhcnQsIHRoaXMuc3RhdGUuY3VyTGluZSwgcmFkaXgsIGxlbiwgZm9yY2VMZW4sIGFsbG93TnVtU2VwYXJhdG9yLCB0aGlzLmVycm9ySGFuZGxlcnNfcmVhZEludCwgZmFsc2UpO1xuICAgIHRoaXMuc3RhdGUucG9zID0gcG9zO1xuICAgIHJldHVybiBuO1xuICB9XG4gIHJlYWRSYWRpeE51bWJlcihyYWRpeCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCk7XG4gICAgbGV0IGlzQmlnSW50ID0gZmFsc2U7XG4gICAgdGhpcy5zdGF0ZS5wb3MgKz0gMjtcbiAgICBjb25zdCB2YWwgPSB0aGlzLnJlYWRJbnQocmFkaXgpO1xuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZERpZ2l0LCBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQoc3RhcnRMb2MsIDIpLCB7XG4gICAgICAgIHJhZGl4XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgaWYgKG5leHQgPT09IDExMCkge1xuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIGlzQmlnSW50ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKG5leHQgPT09IDEwOSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZERlY2ltYWwsIHN0YXJ0TG9jKTtcbiAgICB9XG4gICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuY29kZVBvaW50QXRQb3ModGhpcy5zdGF0ZS5wb3MpKSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuTnVtYmVySWRlbnRpZmllciwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICB9XG4gICAgaWYgKGlzQmlnSW50KSB7XG4gICAgICBjb25zdCBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnN0YXRlLnBvcykucmVwbGFjZSgvW19uXS9nLCBcIlwiKTtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTM2LCBzdHIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZpbmlzaFRva2VuKDEzNSwgdmFsKTtcbiAgfVxuICByZWFkTnVtYmVyKHN0YXJ0c1dpdGhEb3QpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpO1xuICAgIGxldCBpc0Zsb2F0ID0gZmFsc2U7XG4gICAgbGV0IGlzQmlnSW50ID0gZmFsc2U7XG4gICAgbGV0IGhhc0V4cG9uZW50ID0gZmFsc2U7XG4gICAgbGV0IGlzT2N0YWwgPSBmYWxzZTtcbiAgICBpZiAoIXN0YXJ0c1dpdGhEb3QgJiYgdGhpcy5yZWFkSW50KDEwKSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZE51bWJlciwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICB9XG4gICAgY29uc3QgaGFzTGVhZGluZ1plcm8gPSB0aGlzLnN0YXRlLnBvcyAtIHN0YXJ0ID49IDIgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHN0YXJ0KSA9PT0gNDg7XG4gICAgaWYgKGhhc0xlYWRpbmdaZXJvKSB7XG4gICAgICBjb25zdCBpbnRlZ2VyID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgdGhpcy5yZWNvcmRTdHJpY3RNb2RlRXJyb3JzKEVycm9ycy5TdHJpY3RPY3RhbExpdGVyYWwsIHN0YXJ0TG9jKTtcbiAgICAgIGlmICghdGhpcy5zdGF0ZS5zdHJpY3QpIHtcbiAgICAgICAgY29uc3QgdW5kZXJzY29yZVBvcyA9IGludGVnZXIuaW5kZXhPZihcIl9cIik7XG4gICAgICAgIGlmICh1bmRlcnNjb3JlUG9zID4gMCkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlplcm9EaWdpdE51bWVyaWNTZXBhcmF0b3IsIGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldChzdGFydExvYywgdW5kZXJzY29yZVBvcykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpc09jdGFsID0gaGFzTGVhZGluZ1plcm8gJiYgIS9bODldLy50ZXN0KGludGVnZXIpO1xuICAgIH1cbiAgICBsZXQgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgaWYgKG5leHQgPT09IDQ2ICYmICFpc09jdGFsKSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgdGhpcy5yZWFkSW50KDEwKTtcbiAgICAgIGlzRmxvYXQgPSB0cnVlO1xuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgfVxuICAgIGlmICgobmV4dCA9PT0gNjkgfHwgbmV4dCA9PT0gMTAxKSAmJiAhaXNPY3RhbCkge1xuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMuc3RhdGUucG9zKTtcbiAgICAgIGlmIChuZXh0ID09PSA0MyB8fCBuZXh0ID09PSA0NSkge1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZE9yTWlzc2luZ0V4cG9uZW50LCBzdGFydExvYyk7XG4gICAgICB9XG4gICAgICBpc0Zsb2F0ID0gdHJ1ZTtcbiAgICAgIGhhc0V4cG9uZW50ID0gdHJ1ZTtcbiAgICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpO1xuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gMTEwKSB7XG4gICAgICBpZiAoaXNGbG9hdCB8fCBoYXNMZWFkaW5nWmVybykge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkQmlnSW50TGl0ZXJhbCwgc3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIGlzQmlnSW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDEwOSkge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJkZWNpbWFsXCIsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICBpZiAoaGFzRXhwb25lbnQgfHwgaGFzTGVhZGluZ1plcm8pIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZERlY2ltYWwsIHN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB2YXIgaXNEZWNpbWFsID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuY29kZVBvaW50QXRQb3ModGhpcy5zdGF0ZS5wb3MpKSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuTnVtYmVySWRlbnRpZmllciwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICB9XG4gICAgY29uc3Qgc3RyID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5zdGF0ZS5wb3MpLnJlcGxhY2UoL1tfbW5dL2csIFwiXCIpO1xuICAgIGlmIChpc0JpZ0ludCkge1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxMzYsIHN0cik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0RlY2ltYWwpIHtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTM3LCBzdHIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2YWwgPSBpc09jdGFsID8gcGFyc2VJbnQoc3RyLCA4KSA6IHBhcnNlRmxvYXQoc3RyKTtcbiAgICB0aGlzLmZpbmlzaFRva2VuKDEzNSwgdmFsKTtcbiAgfVxuICByZWFkQ29kZVBvaW50KHRocm93T25JbnZhbGlkKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29kZSxcbiAgICAgIHBvc1xuICAgIH0gPSByZWFkQ29kZVBvaW50KHRoaXMuaW5wdXQsIHRoaXMuc3RhdGUucG9zLCB0aGlzLnN0YXRlLmxpbmVTdGFydCwgdGhpcy5zdGF0ZS5jdXJMaW5lLCB0aHJvd09uSW52YWxpZCwgdGhpcy5lcnJvckhhbmRsZXJzX3JlYWRDb2RlUG9pbnQpO1xuICAgIHRoaXMuc3RhdGUucG9zID0gcG9zO1xuICAgIHJldHVybiBjb2RlO1xuICB9XG4gIHJlYWRTdHJpbmcocXVvdGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdHIsXG4gICAgICBwb3MsXG4gICAgICBjdXJMaW5lLFxuICAgICAgbGluZVN0YXJ0XG4gICAgfSA9IHJlYWRTdHJpbmdDb250ZW50cyhxdW90ZSA9PT0gMzQgPyBcImRvdWJsZVwiIDogXCJzaW5nbGVcIiwgdGhpcy5pbnB1dCwgdGhpcy5zdGF0ZS5wb3MgKyAxLCB0aGlzLnN0YXRlLmxpbmVTdGFydCwgdGhpcy5zdGF0ZS5jdXJMaW5lLCB0aGlzLmVycm9ySGFuZGxlcnNfcmVhZFN0cmluZ0NvbnRlbnRzX3N0cmluZyk7XG4gICAgdGhpcy5zdGF0ZS5wb3MgPSBwb3MgKyAxO1xuICAgIHRoaXMuc3RhdGUubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgIHRoaXMuc3RhdGUuY3VyTGluZSA9IGN1ckxpbmU7XG4gICAgdGhpcy5maW5pc2hUb2tlbigxMzQsIHN0cik7XG4gIH1cbiAgcmVhZFRlbXBsYXRlQ29udGludWF0aW9uKCkge1xuICAgIGlmICghdGhpcy5tYXRjaCg4KSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKG51bGwsIDgpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLnBvcy0tO1xuICAgIHRoaXMucmVhZFRlbXBsYXRlVG9rZW4oKTtcbiAgfVxuICByZWFkVGVtcGxhdGVUb2tlbigpIHtcbiAgICBjb25zdCBvcGVuaW5nID0gdGhpcy5pbnB1dFt0aGlzLnN0YXRlLnBvc107XG4gICAgY29uc3Qge1xuICAgICAgc3RyLFxuICAgICAgZmlyc3RJbnZhbGlkTG9jLFxuICAgICAgcG9zLFxuICAgICAgY3VyTGluZSxcbiAgICAgIGxpbmVTdGFydFxuICAgIH0gPSByZWFkU3RyaW5nQ29udGVudHMoXCJ0ZW1wbGF0ZVwiLCB0aGlzLmlucHV0LCB0aGlzLnN0YXRlLnBvcyArIDEsIHRoaXMuc3RhdGUubGluZVN0YXJ0LCB0aGlzLnN0YXRlLmN1ckxpbmUsIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkU3RyaW5nQ29udGVudHNfdGVtcGxhdGUpO1xuICAgIHRoaXMuc3RhdGUucG9zID0gcG9zICsgMTtcbiAgICB0aGlzLnN0YXRlLmxpbmVTdGFydCA9IGxpbmVTdGFydDtcbiAgICB0aGlzLnN0YXRlLmN1ckxpbmUgPSBjdXJMaW5lO1xuICAgIGlmIChmaXJzdEludmFsaWRMb2MpIHtcbiAgICAgIHRoaXMuc3RhdGUuZmlyc3RJbnZhbGlkVGVtcGxhdGVFc2NhcGVQb3MgPSBuZXcgUG9zaXRpb24oZmlyc3RJbnZhbGlkTG9jLmN1ckxpbmUsIGZpcnN0SW52YWxpZExvYy5wb3MgLSBmaXJzdEludmFsaWRMb2MubGluZVN0YXJ0LCB0aGlzLnNvdXJjZVRvT2Zmc2V0UG9zKGZpcnN0SW52YWxpZExvYy5wb3MpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5wdXQuY29kZVBvaW50QXQocG9zKSA9PT0gOTYpIHtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMjQsIGZpcnN0SW52YWxpZExvYyA/IG51bGwgOiBvcGVuaW5nICsgc3RyICsgXCJgXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlLnBvcysrO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigyNSwgZmlyc3RJbnZhbGlkTG9jID8gbnVsbCA6IG9wZW5pbmcgKyBzdHIgKyBcIiR7XCIpO1xuICAgIH1cbiAgfVxuICByZWNvcmRTdHJpY3RNb2RlRXJyb3JzKHRvUGFyc2VFcnJvciwgYXQpIHtcbiAgICBjb25zdCBpbmRleCA9IGF0LmluZGV4O1xuICAgIGlmICh0aGlzLnN0YXRlLnN0cmljdCAmJiAhdGhpcy5zdGF0ZS5zdHJpY3RFcnJvcnMuaGFzKGluZGV4KSkge1xuICAgICAgdGhpcy5yYWlzZSh0b1BhcnNlRXJyb3IsIGF0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZS5zdHJpY3RFcnJvcnMuc2V0KGluZGV4LCBbdG9QYXJzZUVycm9yLCBhdF0pO1xuICAgIH1cbiAgfVxuICByZWFkV29yZDEoZmlyc3RDb2RlKSB7XG4gICAgdGhpcy5zdGF0ZS5jb250YWluc0VzYyA9IGZhbHNlO1xuICAgIGxldCB3b3JkID0gXCJcIjtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIGxldCBjaHVua1N0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgaWYgKGZpcnN0Q29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnN0YXRlLnBvcyArPSBmaXJzdENvZGUgPD0gMHhmZmZmID8gMSA6IDI7XG4gICAgfVxuICAgIHdoaWxlICh0aGlzLnN0YXRlLnBvcyA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBjaCA9IHRoaXMuY29kZVBvaW50QXRQb3ModGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgaWYgKGlzSWRlbnRpZmllckNoYXIoY2gpKSB7XG4gICAgICAgIHRoaXMuc3RhdGUucG9zICs9IGNoIDw9IDB4ZmZmZiA/IDEgOiAyO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gOTIpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5jb250YWluc0VzYyA9IHRydWU7XG4gICAgICAgIHdvcmQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICAgIGNvbnN0IGVzY1N0YXJ0ID0gdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpO1xuICAgICAgICBjb25zdCBpZGVudGlmaWVyQ2hlY2sgPSB0aGlzLnN0YXRlLnBvcyA9PT0gc3RhcnQgPyBpc0lkZW50aWZpZXJTdGFydCA6IGlzSWRlbnRpZmllckNoYXI7XG4gICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnN0YXRlLnBvcykgIT09IDExNykge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk1pc3NpbmdVbmljb2RlRXNjYXBlLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnN0YXRlLnBvcyAtIDE7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgY29uc3QgZXNjID0gdGhpcy5yZWFkQ29kZVBvaW50KHRydWUpO1xuICAgICAgICBpZiAoZXNjICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKCFpZGVudGlmaWVyQ2hlY2soZXNjKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRXNjYXBlZENoYXJOb3RBbklkZW50aWZpZXIsIGVzY1N0YXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd29yZCArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChlc2MpO1xuICAgICAgICB9XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd29yZCArIHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICB9XG4gIHJlYWRXb3JkKGZpcnN0Q29kZSkge1xuICAgIGNvbnN0IHdvcmQgPSB0aGlzLnJlYWRXb3JkMShmaXJzdENvZGUpO1xuICAgIGNvbnN0IHR5cGUgPSBrZXl3b3JkcyQxLmdldCh3b3JkKTtcbiAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmZpbmlzaFRva2VuKHR5cGUsIHRva2VuTGFiZWxOYW1lKHR5cGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxMzIsIHdvcmQpO1xuICAgIH1cbiAgfVxuICBjaGVja0tleXdvcmRFc2NhcGVzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodG9rZW5Jc0tleXdvcmQodHlwZSkgJiYgdGhpcy5zdGF0ZS5jb250YWluc0VzYykge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZEVzY2FwZWRSZXNlcnZlZFdvcmQsIHRoaXMuc3RhdGUuc3RhcnRMb2MsIHtcbiAgICAgICAgcmVzZXJ2ZWRXb3JkOiB0b2tlbkxhYmVsTmFtZSh0eXBlKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJhaXNlKHRvUGFyc2VFcnJvciwgYXQsIGRldGFpbHMgPSB7fSkge1xuICAgIGNvbnN0IGxvYyA9IGF0IGluc3RhbmNlb2YgUG9zaXRpb24gPyBhdCA6IGF0LmxvYy5zdGFydDtcbiAgICBjb25zdCBlcnJvciA9IHRvUGFyc2VFcnJvcihsb2MsIGRldGFpbHMpO1xuICAgIGlmICghKHRoaXMub3B0aW9uRmxhZ3MgJiAyMDQ4KSkgdGhyb3cgZXJyb3I7XG4gICAgaWYgKCF0aGlzLmlzTG9va2FoZWFkKSB0aGlzLnN0YXRlLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgcmFpc2VPdmVyd3JpdGUodG9QYXJzZUVycm9yLCBhdCwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3QgbG9jID0gYXQgaW5zdGFuY2VvZiBQb3NpdGlvbiA/IGF0IDogYXQubG9jLnN0YXJ0O1xuICAgIGNvbnN0IHBvcyA9IGxvYy5pbmRleDtcbiAgICBjb25zdCBlcnJvcnMgPSB0aGlzLnN0YXRlLmVycm9ycztcbiAgICBmb3IgKGxldCBpID0gZXJyb3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBlcnJvciA9IGVycm9yc1tpXTtcbiAgICAgIGlmIChlcnJvci5sb2MuaW5kZXggPT09IHBvcykge1xuICAgICAgICByZXR1cm4gZXJyb3JzW2ldID0gdG9QYXJzZUVycm9yKGxvYywgZGV0YWlscyk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IubG9jLmluZGV4IDwgcG9zKSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmFpc2UodG9QYXJzZUVycm9yLCBhdCwgZGV0YWlscyk7XG4gIH1cbiAgdXBkYXRlQ29udGV4dChwcmV2VHlwZSkge31cbiAgdW5leHBlY3RlZChsb2MsIHR5cGUpIHtcbiAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkVG9rZW4sIGxvYyAhPSBudWxsID8gbG9jIDogdGhpcy5zdGF0ZS5zdGFydExvYywge1xuICAgICAgZXhwZWN0ZWQ6IHR5cGUgPyB0b2tlbkxhYmVsTmFtZSh0eXBlKSA6IG51bGxcbiAgICB9KTtcbiAgfVxuICBleHBlY3RQbHVnaW4ocGx1Z2luTmFtZSwgbG9jKSB7XG4gICAgaWYgKHRoaXMuaGFzUGx1Z2luKHBsdWdpbk5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuTWlzc2luZ1BsdWdpbiwgbG9jICE9IG51bGwgPyBsb2MgOiB0aGlzLnN0YXRlLnN0YXJ0TG9jLCB7XG4gICAgICBtaXNzaW5nUGx1Z2luOiBbcGx1Z2luTmFtZV1cbiAgICB9KTtcbiAgfVxuICBleHBlY3RPbmVQbHVnaW4ocGx1Z2luTmFtZXMpIHtcbiAgICBpZiAoIXBsdWdpbk5hbWVzLnNvbWUobmFtZSA9PiB0aGlzLmhhc1BsdWdpbihuYW1lKSkpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLk1pc3NpbmdPbmVPZlBsdWdpbnMsIHRoaXMuc3RhdGUuc3RhcnRMb2MsIHtcbiAgICAgICAgbWlzc2luZ1BsdWdpbjogcGx1Z2luTmFtZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBlcnJvckJ1aWxkZXIoZXJyb3IpIHtcbiAgICByZXR1cm4gKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKSA9PiB7XG4gICAgICB0aGlzLnJhaXNlKGVycm9yLCBidWlsZFBvc2l0aW9uKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKSk7XG4gICAgfTtcbiAgfVxufVxuY2xhc3MgQ2xhc3NTY29wZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucHJpdmF0ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgIHRoaXMubG9uZUFjY2Vzc29ycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnVuZGVmaW5lZFByaXZhdGVOYW1lcyA9IG5ldyBNYXAoKTtcbiAgfVxufVxuY2xhc3MgQ2xhc3NTY29wZUhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YWNrID0gW107XG4gICAgdGhpcy51bmRlZmluZWRQcml2YXRlTmFtZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gIH1cbiAgY3VycmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICB9XG4gIGVudGVyKCkge1xuICAgIHRoaXMuc3RhY2sucHVzaChuZXcgQ2xhc3NTY29wZSgpKTtcbiAgfVxuICBleGl0KCkge1xuICAgIGNvbnN0IG9sZENsYXNzU2NvcGUgPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQoKTtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBsb2NdIG9mIEFycmF5LmZyb20ob2xkQ2xhc3NTY29wZS51bmRlZmluZWRQcml2YXRlTmFtZXMpKSB7XG4gICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICBpZiAoIWN1cnJlbnQudW5kZWZpbmVkUHJpdmF0ZU5hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICAgIGN1cnJlbnQudW5kZWZpbmVkUHJpdmF0ZU5hbWVzLnNldChuYW1lLCBsb2MpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcnNlci5yYWlzZShFcnJvcnMuSW52YWxpZFByaXZhdGVGaWVsZFJlc29sdXRpb24sIGxvYywge1xuICAgICAgICAgIGlkZW50aWZpZXJOYW1lOiBuYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkZWNsYXJlUHJpdmF0ZU5hbWUobmFtZSwgZWxlbWVudFR5cGUsIGxvYykge1xuICAgIGNvbnN0IHtcbiAgICAgIHByaXZhdGVOYW1lcyxcbiAgICAgIGxvbmVBY2Nlc3NvcnMsXG4gICAgICB1bmRlZmluZWRQcml2YXRlTmFtZXNcbiAgICB9ID0gdGhpcy5jdXJyZW50KCk7XG4gICAgbGV0IHJlZGVmaW5lZCA9IHByaXZhdGVOYW1lcy5oYXMobmFtZSk7XG4gICAgaWYgKGVsZW1lbnRUeXBlICYgMykge1xuICAgICAgY29uc3QgYWNjZXNzb3IgPSByZWRlZmluZWQgJiYgbG9uZUFjY2Vzc29ycy5nZXQobmFtZSk7XG4gICAgICBpZiAoYWNjZXNzb3IpIHtcbiAgICAgICAgY29uc3Qgb2xkU3RhdGljID0gYWNjZXNzb3IgJiA0O1xuICAgICAgICBjb25zdCBuZXdTdGF0aWMgPSBlbGVtZW50VHlwZSAmIDQ7XG4gICAgICAgIGNvbnN0IG9sZEtpbmQgPSBhY2Nlc3NvciAmIDM7XG4gICAgICAgIGNvbnN0IG5ld0tpbmQgPSBlbGVtZW50VHlwZSAmIDM7XG4gICAgICAgIHJlZGVmaW5lZCA9IG9sZEtpbmQgPT09IG5ld0tpbmQgfHwgb2xkU3RhdGljICE9PSBuZXdTdGF0aWM7XG4gICAgICAgIGlmICghcmVkZWZpbmVkKSBsb25lQWNjZXNzb3JzLmRlbGV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoIXJlZGVmaW5lZCkge1xuICAgICAgICBsb25lQWNjZXNzb3JzLnNldChuYW1lLCBlbGVtZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZWRlZmluZWQpIHtcbiAgICAgIHRoaXMucGFyc2VyLnJhaXNlKEVycm9ycy5Qcml2YXRlTmFtZVJlZGVjbGFyYXRpb24sIGxvYywge1xuICAgICAgICBpZGVudGlmaWVyTmFtZTogbmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHByaXZhdGVOYW1lcy5hZGQobmFtZSk7XG4gICAgdW5kZWZpbmVkUHJpdmF0ZU5hbWVzLmRlbGV0ZShuYW1lKTtcbiAgfVxuICB1c2VQcml2YXRlTmFtZShuYW1lLCBsb2MpIHtcbiAgICBsZXQgY2xhc3NTY29wZTtcbiAgICBmb3IgKGNsYXNzU2NvcGUgb2YgdGhpcy5zdGFjaykge1xuICAgICAgaWYgKGNsYXNzU2NvcGUucHJpdmF0ZU5hbWVzLmhhcyhuYW1lKSkgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2xhc3NTY29wZSkge1xuICAgICAgY2xhc3NTY29wZS51bmRlZmluZWRQcml2YXRlTmFtZXMuc2V0KG5hbWUsIGxvYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyc2VyLnJhaXNlKEVycm9ycy5JbnZhbGlkUHJpdmF0ZUZpZWxkUmVzb2x1dGlvbiwgbG9jLCB7XG4gICAgICAgIGlkZW50aWZpZXJOYW1lOiBuYW1lXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEV4cHJlc3Npb25TY29wZSB7XG4gIGNvbnN0cnVjdG9yKHR5cGUgPSAwKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuICBjYW5CZUFycm93UGFyYW1ldGVyRGVjbGFyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gMiB8fCB0aGlzLnR5cGUgPT09IDE7XG4gIH1cbiAgaXNDZXJ0YWlubHlQYXJhbWV0ZXJEZWNsYXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSAzO1xuICB9XG59XG5jbGFzcyBBcnJvd0hlYWRQYXJzaW5nU2NvcGUgZXh0ZW5kcyBFeHByZXNzaW9uU2NvcGUge1xuICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgc3VwZXIodHlwZSk7XG4gICAgdGhpcy5kZWNsYXJhdGlvbkVycm9ycyA9IG5ldyBNYXAoKTtcbiAgfVxuICByZWNvcmREZWNsYXJhdGlvbkVycm9yKFBhcnNpbmdFcnJvckNsYXNzLCBhdCkge1xuICAgIGNvbnN0IGluZGV4ID0gYXQuaW5kZXg7XG4gICAgdGhpcy5kZWNsYXJhdGlvbkVycm9ycy5zZXQoaW5kZXgsIFtQYXJzaW5nRXJyb3JDbGFzcywgYXRdKTtcbiAgfVxuICBjbGVhckRlY2xhcmF0aW9uRXJyb3IoaW5kZXgpIHtcbiAgICB0aGlzLmRlY2xhcmF0aW9uRXJyb3JzLmRlbGV0ZShpbmRleCk7XG4gIH1cbiAgaXRlcmF0ZUVycm9ycyhpdGVyYXRvcikge1xuICAgIHRoaXMuZGVjbGFyYXRpb25FcnJvcnMuZm9yRWFjaChpdGVyYXRvcik7XG4gIH1cbn1cbmNsYXNzIEV4cHJlc3Npb25TY29wZUhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YWNrID0gW25ldyBFeHByZXNzaW9uU2NvcGUoKV07XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gIH1cbiAgZW50ZXIoc2NvcGUpIHtcbiAgICB0aGlzLnN0YWNrLnB1c2goc2NvcGUpO1xuICB9XG4gIGV4aXQoKSB7XG4gICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgfVxuICByZWNvcmRQYXJhbWV0ZXJJbml0aWFsaXplckVycm9yKHRvUGFyc2VFcnJvciwgbm9kZSkge1xuICAgIGNvbnN0IG9yaWdpbiA9IG5vZGUubG9jLnN0YXJ0O1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWNrXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IGkgPSBzdGFjay5sZW5ndGggLSAxO1xuICAgIGxldCBzY29wZSA9IHN0YWNrW2ldO1xuICAgIHdoaWxlICghc2NvcGUuaXNDZXJ0YWlubHlQYXJhbWV0ZXJEZWNsYXJhdGlvbigpKSB7XG4gICAgICBpZiAoc2NvcGUuY2FuQmVBcnJvd1BhcmFtZXRlckRlY2xhcmF0aW9uKCkpIHtcbiAgICAgICAgc2NvcGUucmVjb3JkRGVjbGFyYXRpb25FcnJvcih0b1BhcnNlRXJyb3IsIG9yaWdpbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzY29wZSA9IHN0YWNrWy0taV07XG4gICAgfVxuICAgIHRoaXMucGFyc2VyLnJhaXNlKHRvUGFyc2VFcnJvciwgb3JpZ2luKTtcbiAgfVxuICByZWNvcmRBcnJvd1BhcmFtZXRlckJpbmRpbmdFcnJvcihlcnJvciwgbm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWNrXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2NvcGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBvcmlnaW4gPSBub2RlLmxvYy5zdGFydDtcbiAgICBpZiAoc2NvcGUuaXNDZXJ0YWlubHlQYXJhbWV0ZXJEZWNsYXJhdGlvbigpKSB7XG4gICAgICB0aGlzLnBhcnNlci5yYWlzZShlcnJvciwgb3JpZ2luKTtcbiAgICB9IGVsc2UgaWYgKHNjb3BlLmNhbkJlQXJyb3dQYXJhbWV0ZXJEZWNsYXJhdGlvbigpKSB7XG4gICAgICBzY29wZS5yZWNvcmREZWNsYXJhdGlvbkVycm9yKGVycm9yLCBvcmlnaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHJlY29yZEFzeW5jQXJyb3dQYXJhbWV0ZXJzRXJyb3IoYXQpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFja1xuICAgIH0gPSB0aGlzO1xuICAgIGxldCBpID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgICBsZXQgc2NvcGUgPSBzdGFja1tpXTtcbiAgICB3aGlsZSAoc2NvcGUuY2FuQmVBcnJvd1BhcmFtZXRlckRlY2xhcmF0aW9uKCkpIHtcbiAgICAgIGlmIChzY29wZS50eXBlID09PSAyKSB7XG4gICAgICAgIHNjb3BlLnJlY29yZERlY2xhcmF0aW9uRXJyb3IoRXJyb3JzLkF3YWl0QmluZGluZ0lkZW50aWZpZXIsIGF0KTtcbiAgICAgIH1cbiAgICAgIHNjb3BlID0gc3RhY2tbLS1pXTtcbiAgICB9XG4gIH1cbiAgdmFsaWRhdGVBc1BhdHRlcm4oKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhY2tcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBjdXJyZW50U2NvcGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICBpZiAoIWN1cnJlbnRTY29wZS5jYW5CZUFycm93UGFyYW1ldGVyRGVjbGFyYXRpb24oKSkgcmV0dXJuO1xuICAgIGN1cnJlbnRTY29wZS5pdGVyYXRlRXJyb3JzKChbdG9QYXJzZUVycm9yLCBsb2NdKSA9PiB7XG4gICAgICB0aGlzLnBhcnNlci5yYWlzZSh0b1BhcnNlRXJyb3IsIGxvYyk7XG4gICAgICBsZXQgaSA9IHN0YWNrLmxlbmd0aCAtIDI7XG4gICAgICBsZXQgc2NvcGUgPSBzdGFja1tpXTtcbiAgICAgIHdoaWxlIChzY29wZS5jYW5CZUFycm93UGFyYW1ldGVyRGVjbGFyYXRpb24oKSkge1xuICAgICAgICBzY29wZS5jbGVhckRlY2xhcmF0aW9uRXJyb3IobG9jLmluZGV4KTtcbiAgICAgICAgc2NvcGUgPSBzdGFja1stLWldO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBuZXdQYXJhbWV0ZXJEZWNsYXJhdGlvblNjb3BlKCkge1xuICByZXR1cm4gbmV3IEV4cHJlc3Npb25TY29wZSgzKTtcbn1cbmZ1bmN0aW9uIG5ld0Fycm93SGVhZFNjb3BlKCkge1xuICByZXR1cm4gbmV3IEFycm93SGVhZFBhcnNpbmdTY29wZSgxKTtcbn1cbmZ1bmN0aW9uIG5ld0FzeW5jQXJyb3dTY29wZSgpIHtcbiAgcmV0dXJuIG5ldyBBcnJvd0hlYWRQYXJzaW5nU2NvcGUoMik7XG59XG5mdW5jdGlvbiBuZXdFeHByZXNzaW9uU2NvcGUoKSB7XG4gIHJldHVybiBuZXcgRXhwcmVzc2lvblNjb3BlKCk7XG59XG5jbGFzcyBQcm9kdWN0aW9uUGFyYW1ldGVySGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhY2tzID0gW107XG4gIH1cbiAgZW50ZXIoZmxhZ3MpIHtcbiAgICB0aGlzLnN0YWNrcy5wdXNoKGZsYWdzKTtcbiAgfVxuICBleGl0KCkge1xuICAgIHRoaXMuc3RhY2tzLnBvcCgpO1xuICB9XG4gIGN1cnJlbnRGbGFncygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFja3NbdGhpcy5zdGFja3MubGVuZ3RoIC0gMV07XG4gIH1cbiAgZ2V0IGhhc0F3YWl0KCkge1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50RmxhZ3MoKSAmIDIpID4gMDtcbiAgfVxuICBnZXQgaGFzWWllbGQoKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRGbGFncygpICYgMSkgPiAwO1xuICB9XG4gIGdldCBoYXNSZXR1cm4oKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRGbGFncygpICYgNCkgPiAwO1xuICB9XG4gIGdldCBoYXNJbigpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudEZsYWdzKCkgJiA4KSA+IDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uRmxhZ3MoaXNBc3luYywgaXNHZW5lcmF0b3IpIHtcbiAgcmV0dXJuIChpc0FzeW5jID8gMiA6IDApIHwgKGlzR2VuZXJhdG9yID8gMSA6IDApO1xufVxuY2xhc3MgVXRpbFBhcnNlciBleHRlbmRzIFRva2VuaXplciB7XG4gIGFkZEV4dHJhKG5vZGUsIGtleSwgdmFsdWUsIGVudW1lcmFibGUgPSB0cnVlKSB7XG4gICAgaWYgKCFub2RlKSByZXR1cm47XG4gICAgbGV0IHtcbiAgICAgIGV4dHJhXG4gICAgfSA9IG5vZGU7XG4gICAgaWYgKGV4dHJhID09IG51bGwpIHtcbiAgICAgIGV4dHJhID0ge307XG4gICAgICBub2RlLmV4dHJhID0gZXh0cmE7XG4gICAgfVxuICAgIGlmIChlbnVtZXJhYmxlKSB7XG4gICAgICBleHRyYVtrZXldID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHRyYSwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGUsXG4gICAgICAgIHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaXNDb250ZXh0dWFsKHRva2VuKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUudHlwZSA9PT0gdG9rZW4gJiYgIXRoaXMuc3RhdGUuY29udGFpbnNFc2M7XG4gIH1cbiAgaXNVbnBhcnNlZENvbnRleHR1YWwobmFtZVN0YXJ0LCBuYW1lKSB7XG4gICAgY29uc3QgbmFtZUVuZCA9IG5hbWVTdGFydCArIG5hbWUubGVuZ3RoO1xuICAgIGlmICh0aGlzLmlucHV0LnNsaWNlKG5hbWVTdGFydCwgbmFtZUVuZCkgPT09IG5hbWUpIHtcbiAgICAgIGNvbnN0IG5leHRDaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuYW1lRW5kKTtcbiAgICAgIHJldHVybiAhKGlzSWRlbnRpZmllckNoYXIobmV4dENoKSB8fCAobmV4dENoICYgMHhmYzAwKSA9PT0gMHhkODAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlzTG9va2FoZWFkQ29udGV4dHVhbChuYW1lKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuU3RhcnQoKTtcbiAgICByZXR1cm4gdGhpcy5pc1VucGFyc2VkQ29udGV4dHVhbChuZXh0LCBuYW1lKTtcbiAgfVxuICBlYXRDb250ZXh0dWFsKHRva2VuKSB7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKHRva2VuKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGV4cGVjdENvbnRleHR1YWwodG9rZW4sIHRvUGFyc2VFcnJvcikge1xuICAgIGlmICghdGhpcy5lYXRDb250ZXh0dWFsKHRva2VuKSkge1xuICAgICAgaWYgKHRvUGFyc2VFcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UodG9QYXJzZUVycm9yLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCB0b2tlbik7XG4gICAgfVxuICB9XG4gIGNhbkluc2VydFNlbWljb2xvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgxNDApIHx8IHRoaXMubWF0Y2goOCkgfHwgdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKTtcbiAgfVxuICBoYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSB7XG4gICAgcmV0dXJuIGhhc05ld0xpbmUodGhpcy5pbnB1dCwgdGhpcy5vZmZzZXRUb1NvdXJjZVBvcyh0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MuaW5kZXgpLCB0aGlzLnN0YXRlLnN0YXJ0KTtcbiAgfVxuICBoYXNGb2xsb3dpbmdMaW5lQnJlYWsoKSB7XG4gICAgcmV0dXJuIGhhc05ld0xpbmUodGhpcy5pbnB1dCwgdGhpcy5zdGF0ZS5lbmQsIHRoaXMubmV4dFRva2VuU3RhcnQoKSk7XG4gIH1cbiAgaXNMaW5lVGVybWluYXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5lYXQoMTMpIHx8IHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCk7XG4gIH1cbiAgc2VtaWNvbG9uKGFsbG93QXNpID0gdHJ1ZSkge1xuICAgIGlmIChhbGxvd0FzaSA/IHRoaXMuaXNMaW5lVGVybWluYXRvcigpIDogdGhpcy5lYXQoMTMpKSByZXR1cm47XG4gICAgdGhpcy5yYWlzZShFcnJvcnMuTWlzc2luZ1NlbWljb2xvbiwgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jKTtcbiAgfVxuICBleHBlY3QodHlwZSwgbG9jKSB7XG4gICAgaWYgKCF0aGlzLmVhdCh0eXBlKSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKGxvYywgdHlwZSk7XG4gICAgfVxuICB9XG4gIHRyeVBhcnNlKGZuLCBvbGRTdGF0ZSA9IHRoaXMuc3RhdGUuY2xvbmUoKSkge1xuICAgIGNvbnN0IGFib3J0U2lnbmFsID0ge1xuICAgICAgbm9kZTogbnVsbFxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG5vZGUgPSBmbigobm9kZSA9IG51bGwpID0+IHtcbiAgICAgICAgYWJvcnRTaWduYWwubm9kZSA9IG5vZGU7XG4gICAgICAgIHRocm93IGFib3J0U2lnbmFsO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5lcnJvcnMubGVuZ3RoID4gb2xkU3RhdGUuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBmYWlsU3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICB0aGlzLnN0YXRlID0gb2xkU3RhdGU7XG4gICAgICAgIHRoaXMuc3RhdGUudG9rZW5zTGVuZ3RoID0gZmFpbFN0YXRlLnRva2Vuc0xlbmd0aDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIGVycm9yOiBmYWlsU3RhdGUuZXJyb3JzW29sZFN0YXRlLmVycm9ycy5sZW5ndGhdLFxuICAgICAgICAgIHRocm93bjogZmFsc2UsXG4gICAgICAgICAgYWJvcnRlZDogZmFsc2UsXG4gICAgICAgICAgZmFpbFN0YXRlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgdGhyb3duOiBmYWxzZSxcbiAgICAgICAgYWJvcnRlZDogZmFsc2UsXG4gICAgICAgIGZhaWxTdGF0ZTogbnVsbFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZmFpbFN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIHRoaXMuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFN5bnRheEVycm9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbnVsbCxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICB0aHJvd246IHRydWUsXG4gICAgICAgICAgYWJvcnRlZDogZmFsc2UsXG4gICAgICAgICAgZmFpbFN0YXRlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IgPT09IGFib3J0U2lnbmFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogYWJvcnRTaWduYWwubm9kZSxcbiAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB0aHJvd246IGZhbHNlLFxuICAgICAgICAgIGFib3J0ZWQ6IHRydWUsXG4gICAgICAgICAgZmFpbFN0YXRlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFuZFRocm93KSB7XG4gICAgaWYgKCFyZWZFeHByZXNzaW9uRXJyb3JzKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3Qge1xuICAgICAgc2hvcnRoYW5kQXNzaWduTG9jLFxuICAgICAgZG91YmxlUHJvdG9Mb2MsXG4gICAgICBwcml2YXRlS2V5TG9jLFxuICAgICAgb3B0aW9uYWxQYXJhbWV0ZXJzTG9jXG4gICAgfSA9IHJlZkV4cHJlc3Npb25FcnJvcnM7XG4gICAgY29uc3QgaGFzRXJyb3JzID0gISFzaG9ydGhhbmRBc3NpZ25Mb2MgfHwgISFkb3VibGVQcm90b0xvYyB8fCAhIW9wdGlvbmFsUGFyYW1ldGVyc0xvYyB8fCAhIXByaXZhdGVLZXlMb2M7XG4gICAgaWYgKCFhbmRUaHJvdykge1xuICAgICAgcmV0dXJuIGhhc0Vycm9ycztcbiAgICB9XG4gICAgaWYgKHNob3J0aGFuZEFzc2lnbkxvYyAhPSBudWxsKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkQ292ZXJJbml0aWFsaXplZE5hbWUsIHNob3J0aGFuZEFzc2lnbkxvYyk7XG4gICAgfVxuICAgIGlmIChkb3VibGVQcm90b0xvYyAhPSBudWxsKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5EdXBsaWNhdGVQcm90bywgZG91YmxlUHJvdG9Mb2MpO1xuICAgIH1cbiAgICBpZiAocHJpdmF0ZUtleUxvYyAhPSBudWxsKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkUHJpdmF0ZUZpZWxkLCBwcml2YXRlS2V5TG9jKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbmFsUGFyYW1ldGVyc0xvYyAhPSBudWxsKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQob3B0aW9uYWxQYXJhbWV0ZXJzTG9jKTtcbiAgICB9XG4gIH1cbiAgaXNMaXRlcmFsUHJvcGVydHlOYW1lKCkge1xuICAgIHJldHVybiB0b2tlbklzTGl0ZXJhbFByb3BlcnR5TmFtZSh0aGlzLnN0YXRlLnR5cGUpO1xuICB9XG4gIGlzUHJpdmF0ZU5hbWUobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiUHJpdmF0ZU5hbWVcIjtcbiAgfVxuICBnZXRQcml2YXRlTmFtZVNWKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5pZC5uYW1lO1xuICB9XG4gIGhhc1Byb3BlcnR5QXNQcml2YXRlTmFtZShub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIikgJiYgdGhpcy5pc1ByaXZhdGVOYW1lKG5vZGUucHJvcGVydHkpO1xuICB9XG4gIGlzT2JqZWN0UHJvcGVydHkobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiT2JqZWN0UHJvcGVydHlcIjtcbiAgfVxuICBpc09iamVjdE1ldGhvZChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJPYmplY3RNZXRob2RcIjtcbiAgfVxuICBpbml0aWFsaXplU2NvcGVzKGluTW9kdWxlID0gdGhpcy5vcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCIpIHtcbiAgICBjb25zdCBvbGRMYWJlbHMgPSB0aGlzLnN0YXRlLmxhYmVscztcbiAgICB0aGlzLnN0YXRlLmxhYmVscyA9IFtdO1xuICAgIGNvbnN0IG9sZEV4cG9ydGVkSWRlbnRpZmllcnMgPSB0aGlzLmV4cG9ydGVkSWRlbnRpZmllcnM7XG4gICAgdGhpcy5leHBvcnRlZElkZW50aWZpZXJzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IG9sZEluTW9kdWxlID0gdGhpcy5pbk1vZHVsZTtcbiAgICB0aGlzLmluTW9kdWxlID0gaW5Nb2R1bGU7XG4gICAgY29uc3Qgb2xkU2NvcGUgPSB0aGlzLnNjb3BlO1xuICAgIGNvbnN0IFNjb3BlSGFuZGxlciA9IHRoaXMuZ2V0U2NvcGVIYW5kbGVyKCk7XG4gICAgdGhpcy5zY29wZSA9IG5ldyBTY29wZUhhbmRsZXIodGhpcywgaW5Nb2R1bGUpO1xuICAgIGNvbnN0IG9sZFByb2RQYXJhbSA9IHRoaXMucHJvZFBhcmFtO1xuICAgIHRoaXMucHJvZFBhcmFtID0gbmV3IFByb2R1Y3Rpb25QYXJhbWV0ZXJIYW5kbGVyKCk7XG4gICAgY29uc3Qgb2xkQ2xhc3NTY29wZSA9IHRoaXMuY2xhc3NTY29wZTtcbiAgICB0aGlzLmNsYXNzU2NvcGUgPSBuZXcgQ2xhc3NTY29wZUhhbmRsZXIodGhpcyk7XG4gICAgY29uc3Qgb2xkRXhwcmVzc2lvblNjb3BlID0gdGhpcy5leHByZXNzaW9uU2NvcGU7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUgPSBuZXcgRXhwcmVzc2lvblNjb3BlSGFuZGxlcih0aGlzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZS5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gICAgICB0aGlzLmV4cG9ydGVkSWRlbnRpZmllcnMgPSBvbGRFeHBvcnRlZElkZW50aWZpZXJzO1xuICAgICAgdGhpcy5pbk1vZHVsZSA9IG9sZEluTW9kdWxlO1xuICAgICAgdGhpcy5zY29wZSA9IG9sZFNjb3BlO1xuICAgICAgdGhpcy5wcm9kUGFyYW0gPSBvbGRQcm9kUGFyYW07XG4gICAgICB0aGlzLmNsYXNzU2NvcGUgPSBvbGRDbGFzc1Njb3BlO1xuICAgICAgdGhpcy5leHByZXNzaW9uU2NvcGUgPSBvbGRFeHByZXNzaW9uU2NvcGU7XG4gICAgfTtcbiAgfVxuICBlbnRlckluaXRpYWxTY29wZXMoKSB7XG4gICAgbGV0IHBhcmFtRmxhZ3MgPSAwO1xuICAgIGlmICh0aGlzLmluTW9kdWxlKSB7XG4gICAgICBwYXJhbUZsYWdzIHw9IDI7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbkZsYWdzICYgMzIpIHtcbiAgICAgIHBhcmFtRmxhZ3MgfD0gMTtcbiAgICB9XG4gICAgdGhpcy5zY29wZS5lbnRlcigxKTtcbiAgICB0aGlzLnByb2RQYXJhbS5lbnRlcihwYXJhbUZsYWdzKTtcbiAgfVxuICBjaGVja0Rlc3RydWN0dXJpbmdQcml2YXRlKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBwcml2YXRlS2V5TG9jXG4gICAgfSA9IHJlZkV4cHJlc3Npb25FcnJvcnM7XG4gICAgaWYgKHByaXZhdGVLZXlMb2MgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiZGVzdHJ1Y3R1cmluZ1ByaXZhdGVcIiwgcHJpdmF0ZUtleUxvYyk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBFeHByZXNzaW9uRXJyb3JzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zaG9ydGhhbmRBc3NpZ25Mb2MgPSBudWxsO1xuICAgIHRoaXMuZG91YmxlUHJvdG9Mb2MgPSBudWxsO1xuICAgIHRoaXMucHJpdmF0ZUtleUxvYyA9IG51bGw7XG4gICAgdGhpcy5vcHRpb25hbFBhcmFtZXRlcnNMb2MgPSBudWxsO1xuICB9XG59XG5jbGFzcyBOb2RlIHtcbiAgY29uc3RydWN0b3IocGFyc2VyLCBwb3MsIGxvYykge1xuICAgIHRoaXMudHlwZSA9IFwiXCI7XG4gICAgdGhpcy5zdGFydCA9IHBvcztcbiAgICB0aGlzLmVuZCA9IDA7XG4gICAgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24obG9jKTtcbiAgICBpZiAoKHBhcnNlciA9PSBudWxsID8gdm9pZCAwIDogcGFyc2VyLm9wdGlvbkZsYWdzKSAmIDEyOCkgdGhpcy5yYW5nZSA9IFtwb3MsIDBdO1xuICAgIGlmIChwYXJzZXIgIT0gbnVsbCAmJiBwYXJzZXIuZmlsZW5hbWUpIHRoaXMubG9jLmZpbGVuYW1lID0gcGFyc2VyLmZpbGVuYW1lO1xuICB9XG59XG5jb25zdCBOb2RlUHJvdG90eXBlID0gTm9kZS5wcm90b3R5cGU7XG57XG4gIE5vZGVQcm90b3R5cGUuX19jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBuZXdOb2RlID0gbmV3IE5vZGUodW5kZWZpbmVkLCB0aGlzLnN0YXJ0LCB0aGlzLmxvYy5zdGFydCk7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKGtleSAhPT0gXCJsZWFkaW5nQ29tbWVudHNcIiAmJiBrZXkgIT09IFwidHJhaWxpbmdDb21tZW50c1wiICYmIGtleSAhPT0gXCJpbm5lckNvbW1lbnRzXCIpIHtcbiAgICAgICAgbmV3Tm9kZVtrZXldID0gdGhpc1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3Tm9kZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNsb25lUGxhY2Vob2xkZXIobm9kZSkge1xuICByZXR1cm4gY2xvbmVJZGVudGlmaWVyKG5vZGUpO1xufVxuZnVuY3Rpb24gY2xvbmVJZGVudGlmaWVyKG5vZGUpIHtcbiAgY29uc3Qge1xuICAgIHR5cGUsXG4gICAgc3RhcnQsXG4gICAgZW5kLFxuICAgIGxvYyxcbiAgICByYW5nZSxcbiAgICBleHRyYSxcbiAgICBuYW1lXG4gIH0gPSBub2RlO1xuICBjb25zdCBjbG9uZWQgPSBPYmplY3QuY3JlYXRlKE5vZGVQcm90b3R5cGUpO1xuICBjbG9uZWQudHlwZSA9IHR5cGU7XG4gIGNsb25lZC5zdGFydCA9IHN0YXJ0O1xuICBjbG9uZWQuZW5kID0gZW5kO1xuICBjbG9uZWQubG9jID0gbG9jO1xuICBjbG9uZWQucmFuZ2UgPSByYW5nZTtcbiAgY2xvbmVkLmV4dHJhID0gZXh0cmE7XG4gIGNsb25lZC5uYW1lID0gbmFtZTtcbiAgaWYgKHR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIikge1xuICAgIGNsb25lZC5leHBlY3RlZE5vZGUgPSBub2RlLmV4cGVjdGVkTm9kZTtcbiAgfVxuICByZXR1cm4gY2xvbmVkO1xufVxuZnVuY3Rpb24gY2xvbmVTdHJpbmdMaXRlcmFsKG5vZGUpIHtcbiAgY29uc3Qge1xuICAgIHR5cGUsXG4gICAgc3RhcnQsXG4gICAgZW5kLFxuICAgIGxvYyxcbiAgICByYW5nZSxcbiAgICBleHRyYVxuICB9ID0gbm9kZTtcbiAgaWYgKHR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIikge1xuICAgIHJldHVybiBjbG9uZVBsYWNlaG9sZGVyKG5vZGUpO1xuICB9XG4gIGNvbnN0IGNsb25lZCA9IE9iamVjdC5jcmVhdGUoTm9kZVByb3RvdHlwZSk7XG4gIGNsb25lZC50eXBlID0gdHlwZTtcbiAgY2xvbmVkLnN0YXJ0ID0gc3RhcnQ7XG4gIGNsb25lZC5lbmQgPSBlbmQ7XG4gIGNsb25lZC5sb2MgPSBsb2M7XG4gIGNsb25lZC5yYW5nZSA9IHJhbmdlO1xuICBpZiAobm9kZS5yYXcgIT09IHVuZGVmaW5lZCkge1xuICAgIGNsb25lZC5yYXcgPSBub2RlLnJhdztcbiAgfSBlbHNlIHtcbiAgICBjbG9uZWQuZXh0cmEgPSBleHRyYTtcbiAgfVxuICBjbG9uZWQudmFsdWUgPSBub2RlLnZhbHVlO1xuICByZXR1cm4gY2xvbmVkO1xufVxuY2xhc3MgTm9kZVV0aWxzIGV4dGVuZHMgVXRpbFBhcnNlciB7XG4gIHN0YXJ0Tm9kZSgpIHtcbiAgICBjb25zdCBsb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCBsb2MuaW5kZXgsIGxvYyk7XG4gIH1cbiAgc3RhcnROb2RlQXQobG9jKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIGxvYy5pbmRleCwgbG9jKTtcbiAgfVxuICBzdGFydE5vZGVBdE5vZGUodHlwZSkge1xuICAgIHJldHVybiB0aGlzLnN0YXJ0Tm9kZUF0KHR5cGUubG9jLnN0YXJ0KTtcbiAgfVxuICBmaW5pc2hOb2RlKG5vZGUsIHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jKTtcbiAgfVxuICBmaW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgZW5kTG9jKSB7XG4gICAgbm9kZS50eXBlID0gdHlwZTtcbiAgICBub2RlLmVuZCA9IGVuZExvYy5pbmRleDtcbiAgICBub2RlLmxvYy5lbmQgPSBlbmRMb2M7XG4gICAgaWYgKHRoaXMub3B0aW9uRmxhZ3MgJiAxMjgpIG5vZGUucmFuZ2VbMV0gPSBlbmRMb2MuaW5kZXg7XG4gICAgaWYgKHRoaXMub3B0aW9uRmxhZ3MgJiA0MDk2KSB7XG4gICAgICB0aGlzLnByb2Nlc3NDb21tZW50KG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICByZXNldFN0YXJ0TG9jYXRpb24obm9kZSwgc3RhcnRMb2MpIHtcbiAgICBub2RlLnN0YXJ0ID0gc3RhcnRMb2MuaW5kZXg7XG4gICAgbm9kZS5sb2Muc3RhcnQgPSBzdGFydExvYztcbiAgICBpZiAodGhpcy5vcHRpb25GbGFncyAmIDEyOCkgbm9kZS5yYW5nZVswXSA9IHN0YXJ0TG9jLmluZGV4O1xuICB9XG4gIHJlc2V0RW5kTG9jYXRpb24obm9kZSwgZW5kTG9jID0gdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jKSB7XG4gICAgbm9kZS5lbmQgPSBlbmRMb2MuaW5kZXg7XG4gICAgbm9kZS5sb2MuZW5kID0gZW5kTG9jO1xuICAgIGlmICh0aGlzLm9wdGlvbkZsYWdzICYgMTI4KSBub2RlLnJhbmdlWzFdID0gZW5kTG9jLmluZGV4O1xuICB9XG4gIHJlc2V0U3RhcnRMb2NhdGlvbkZyb21Ob2RlKG5vZGUsIGxvY2F0aW9uTm9kZSkge1xuICAgIHRoaXMucmVzZXRTdGFydExvY2F0aW9uKG5vZGUsIGxvY2F0aW9uTm9kZS5sb2Muc3RhcnQpO1xuICB9XG59XG5jb25zdCByZXNlcnZlZFR5cGVzID0gbmV3IFNldChbXCJfXCIsIFwiYW55XCIsIFwiYm9vbFwiLCBcImJvb2xlYW5cIiwgXCJlbXB0eVwiLCBcImV4dGVuZHNcIiwgXCJmYWxzZVwiLCBcImludGVyZmFjZVwiLCBcIm1peGVkXCIsIFwibnVsbFwiLCBcIm51bWJlclwiLCBcInN0YXRpY1wiLCBcInN0cmluZ1wiLCBcInRydWVcIiwgXCJ0eXBlb2ZcIiwgXCJ2b2lkXCJdKTtcbmNvbnN0IEZsb3dFcnJvcnMgPSBQYXJzZUVycm9yRW51bWBmbG93YCh7XG4gIEFtYmlndW91c0NvbmRpdGlvbmFsQXJyb3c6IFwiQW1iaWd1b3VzIGV4cHJlc3Npb246IHdyYXAgdGhlIGFycm93IGZ1bmN0aW9ucyBpbiBwYXJlbnRoZXNlcyB0byBkaXNhbWJpZ3VhdGUuXCIsXG4gIEFtYmlndW91c0RlY2xhcmVNb2R1bGVLaW5kOiBcIkZvdW5kIGJvdGggYGRlY2xhcmUgbW9kdWxlLmV4cG9ydHNgIGFuZCBgZGVjbGFyZSBleHBvcnRgIGluIHRoZSBzYW1lIG1vZHVsZS4gTW9kdWxlcyBjYW4gb25seSBoYXZlIDEgc2luY2UgdGhleSBhcmUgZWl0aGVyIGFuIEVTIG1vZHVsZSBvciB0aGV5IGFyZSBhIENvbW1vbkpTIG1vZHVsZS5cIixcbiAgQXNzaWduUmVzZXJ2ZWRUeXBlOiAoe1xuICAgIHJlc2VydmVkVHlwZVxuICB9KSA9PiBgQ2Fubm90IG92ZXJ3cml0ZSByZXNlcnZlZCB0eXBlICR7cmVzZXJ2ZWRUeXBlfS5gLFxuICBEZWNsYXJlQ2xhc3NFbGVtZW50OiBcIlRoZSBgZGVjbGFyZWAgbW9kaWZpZXIgY2FuIG9ubHkgYXBwZWFyIG9uIGNsYXNzIGZpZWxkcy5cIixcbiAgRGVjbGFyZUNsYXNzRmllbGRJbml0aWFsaXplcjogXCJJbml0aWFsaXplcnMgYXJlIG5vdCBhbGxvd2VkIGluIGZpZWxkcyB3aXRoIHRoZSBgZGVjbGFyZWAgbW9kaWZpZXIuXCIsXG4gIER1cGxpY2F0ZURlY2xhcmVNb2R1bGVFeHBvcnRzOiBcIkR1cGxpY2F0ZSBgZGVjbGFyZSBtb2R1bGUuZXhwb3J0c2Agc3RhdGVtZW50LlwiLFxuICBFbnVtQm9vbGVhbk1lbWJlck5vdEluaXRpYWxpemVkOiAoe1xuICAgIG1lbWJlck5hbWUsXG4gICAgZW51bU5hbWVcbiAgfSkgPT4gYEJvb2xlYW4gZW51bSBtZW1iZXJzIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQuIFVzZSBlaXRoZXIgXFxgJHttZW1iZXJOYW1lfSA9IHRydWUsXFxgIG9yIFxcYCR7bWVtYmVyTmFtZX0gPSBmYWxzZSxcXGAgaW4gZW51bSBcXGAke2VudW1OYW1lfVxcYC5gLFxuICBFbnVtRHVwbGljYXRlTWVtYmVyTmFtZTogKHtcbiAgICBtZW1iZXJOYW1lLFxuICAgIGVudW1OYW1lXG4gIH0pID0+IGBFbnVtIG1lbWJlciBuYW1lcyBuZWVkIHRvIGJlIHVuaXF1ZSwgYnV0IHRoZSBuYW1lIFxcYCR7bWVtYmVyTmFtZX1cXGAgaGFzIGFscmVhZHkgYmVlbiB1c2VkIGJlZm9yZSBpbiBlbnVtIFxcYCR7ZW51bU5hbWV9XFxgLmAsXG4gIEVudW1JbmNvbnNpc3RlbnRNZW1iZXJWYWx1ZXM6ICh7XG4gICAgZW51bU5hbWVcbiAgfSkgPT4gYEVudW0gXFxgJHtlbnVtTmFtZX1cXGAgaGFzIGluY29uc2lzdGVudCBtZW1iZXIgaW5pdGlhbGl6ZXJzLiBFaXRoZXIgdXNlIG5vIGluaXRpYWxpemVycywgb3IgY29uc2lzdGVudGx5IHVzZSBsaXRlcmFscyAoZWl0aGVyIGJvb2xlYW5zLCBudW1iZXJzLCBvciBzdHJpbmdzKSBmb3IgYWxsIG1lbWJlciBpbml0aWFsaXplcnMuYCxcbiAgRW51bUludmFsaWRFeHBsaWNpdFR5cGU6ICh7XG4gICAgaW52YWxpZEVudW1UeXBlLFxuICAgIGVudW1OYW1lXG4gIH0pID0+IGBFbnVtIHR5cGUgXFxgJHtpbnZhbGlkRW51bVR5cGV9XFxgIGlzIG5vdCB2YWxpZC4gVXNlIG9uZSBvZiBcXGBib29sZWFuXFxgLCBcXGBudW1iZXJcXGAsIFxcYHN0cmluZ1xcYCwgb3IgXFxgc3ltYm9sXFxgIGluIGVudW0gXFxgJHtlbnVtTmFtZX1cXGAuYCxcbiAgRW51bUludmFsaWRFeHBsaWNpdFR5cGVVbmtub3duU3VwcGxpZWQ6ICh7XG4gICAgZW51bU5hbWVcbiAgfSkgPT4gYFN1cHBsaWVkIGVudW0gdHlwZSBpcyBub3QgdmFsaWQuIFVzZSBvbmUgb2YgXFxgYm9vbGVhblxcYCwgXFxgbnVtYmVyXFxgLCBcXGBzdHJpbmdcXGAsIG9yIFxcYHN5bWJvbFxcYCBpbiBlbnVtIFxcYCR7ZW51bU5hbWV9XFxgLmAsXG4gIEVudW1JbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXJQcmltYXJ5VHlwZTogKHtcbiAgICBlbnVtTmFtZSxcbiAgICBtZW1iZXJOYW1lLFxuICAgIGV4cGxpY2l0VHlwZVxuICB9KSA9PiBgRW51bSBcXGAke2VudW1OYW1lfVxcYCBoYXMgdHlwZSBcXGAke2V4cGxpY2l0VHlwZX1cXGAsIHNvIHRoZSBpbml0aWFsaXplciBvZiBcXGAke21lbWJlck5hbWV9XFxgIG5lZWRzIHRvIGJlIGEgJHtleHBsaWNpdFR5cGV9IGxpdGVyYWwuYCxcbiAgRW51bUludmFsaWRNZW1iZXJJbml0aWFsaXplclN5bWJvbFR5cGU6ICh7XG4gICAgZW51bU5hbWUsXG4gICAgbWVtYmVyTmFtZVxuICB9KSA9PiBgU3ltYm9sIGVudW0gbWVtYmVycyBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQuIFVzZSBcXGAke21lbWJlck5hbWV9LFxcYCBpbiBlbnVtIFxcYCR7ZW51bU5hbWV9XFxgLmAsXG4gIEVudW1JbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXJVbmtub3duVHlwZTogKHtcbiAgICBlbnVtTmFtZSxcbiAgICBtZW1iZXJOYW1lXG4gIH0pID0+IGBUaGUgZW51bSBtZW1iZXIgaW5pdGlhbGl6ZXIgZm9yIFxcYCR7bWVtYmVyTmFtZX1cXGAgbmVlZHMgdG8gYmUgYSBsaXRlcmFsIChlaXRoZXIgYSBib29sZWFuLCBudW1iZXIsIG9yIHN0cmluZykgaW4gZW51bSBcXGAke2VudW1OYW1lfVxcYC5gLFxuICBFbnVtSW52YWxpZE1lbWJlck5hbWU6ICh7XG4gICAgZW51bU5hbWUsXG4gICAgbWVtYmVyTmFtZSxcbiAgICBzdWdnZXN0aW9uXG4gIH0pID0+IGBFbnVtIG1lbWJlciBuYW1lcyBjYW5ub3Qgc3RhcnQgd2l0aCBsb3dlcmNhc2UgJ2EnIHRocm91Z2ggJ3onLiBJbnN0ZWFkIG9mIHVzaW5nIFxcYCR7bWVtYmVyTmFtZX1cXGAsIGNvbnNpZGVyIHVzaW5nIFxcYCR7c3VnZ2VzdGlvbn1cXGAsIGluIGVudW0gXFxgJHtlbnVtTmFtZX1cXGAuYCxcbiAgRW51bU51bWJlck1lbWJlck5vdEluaXRpYWxpemVkOiAoe1xuICAgIGVudW1OYW1lLFxuICAgIG1lbWJlck5hbWVcbiAgfSkgPT4gYE51bWJlciBlbnVtIG1lbWJlcnMgbmVlZCB0byBiZSBpbml0aWFsaXplZCwgZS5nLiBcXGAke21lbWJlck5hbWV9ID0gMVxcYCBpbiBlbnVtIFxcYCR7ZW51bU5hbWV9XFxgLmAsXG4gIEVudW1TdHJpbmdNZW1iZXJJbmNvbnNpc3RlbnRseUluaXRpYWxpemVkOiAoe1xuICAgIGVudW1OYW1lXG4gIH0pID0+IGBTdHJpbmcgZW51bSBtZW1iZXJzIG5lZWQgdG8gY29uc2lzdGVudGx5IGVpdGhlciBhbGwgdXNlIGluaXRpYWxpemVycywgb3IgdXNlIG5vIGluaXRpYWxpemVycywgaW4gZW51bSBcXGAke2VudW1OYW1lfVxcYC5gLFxuICBHZXR0ZXJNYXlOb3RIYXZlVGhpc1BhcmFtOiBcIkEgZ2V0dGVyIGNhbm5vdCBoYXZlIGEgYHRoaXNgIHBhcmFtZXRlci5cIixcbiAgSW1wb3J0UmVmbGVjdGlvbkhhc0ltcG9ydFR5cGU6IFwiQW4gYGltcG9ydCBtb2R1bGVgIGRlY2xhcmF0aW9uIGNhbiBub3QgdXNlIGB0eXBlYCBvciBgdHlwZW9mYCBrZXl3b3JkLlwiLFxuICBJbXBvcnRUeXBlU2hvcnRoYW5kT25seUluUHVyZUltcG9ydDogXCJUaGUgYHR5cGVgIGFuZCBgdHlwZW9mYCBrZXl3b3JkcyBvbiBuYW1lZCBpbXBvcnRzIGNhbiBvbmx5IGJlIHVzZWQgb24gcmVndWxhciBgaW1wb3J0YCBzdGF0ZW1lbnRzLiBJdCBjYW5ub3QgYmUgdXNlZCB3aXRoIGBpbXBvcnQgdHlwZWAgb3IgYGltcG9ydCB0eXBlb2ZgIHN0YXRlbWVudHMuXCIsXG4gIEluZXhhY3RJbnNpZGVFeGFjdDogXCJFeHBsaWNpdCBpbmV4YWN0IHN5bnRheCBjYW5ub3QgYXBwZWFyIGluc2lkZSBhbiBleHBsaWNpdCBleGFjdCBvYmplY3QgdHlwZS5cIixcbiAgSW5leGFjdEluc2lkZU5vbk9iamVjdDogXCJFeHBsaWNpdCBpbmV4YWN0IHN5bnRheCBjYW5ub3QgYXBwZWFyIGluIGNsYXNzIG9yIGludGVyZmFjZSBkZWZpbml0aW9ucy5cIixcbiAgSW5leGFjdFZhcmlhbmNlOiBcIkV4cGxpY2l0IGluZXhhY3Qgc3ludGF4IGNhbm5vdCBoYXZlIHZhcmlhbmNlLlwiLFxuICBJbnZhbGlkTm9uVHlwZUltcG9ydEluRGVjbGFyZU1vZHVsZTogXCJJbXBvcnRzIHdpdGhpbiBhIGBkZWNsYXJlIG1vZHVsZWAgYm9keSBtdXN0IGFsd2F5cyBiZSBgaW1wb3J0IHR5cGVgIG9yIGBpbXBvcnQgdHlwZW9mYC5cIixcbiAgTWlzc2luZ1R5cGVQYXJhbURlZmF1bHQ6IFwiVHlwZSBwYXJhbWV0ZXIgZGVjbGFyYXRpb24gbmVlZHMgYSBkZWZhdWx0LCBzaW5jZSBhIHByZWNlZGluZyB0eXBlIHBhcmFtZXRlciBkZWNsYXJhdGlvbiBoYXMgYSBkZWZhdWx0LlwiLFxuICBOZXN0ZWREZWNsYXJlTW9kdWxlOiBcImBkZWNsYXJlIG1vZHVsZWAgY2Fubm90IGJlIHVzZWQgaW5zaWRlIGFub3RoZXIgYGRlY2xhcmUgbW9kdWxlYC5cIixcbiAgTmVzdGVkRmxvd0NvbW1lbnQ6IFwiQ2Fubm90IGhhdmUgYSBmbG93IGNvbW1lbnQgaW5zaWRlIGFub3RoZXIgZmxvdyBjb21tZW50LlwiLFxuICBQYXR0ZXJuSXNPcHRpb25hbDogT2JqZWN0LmFzc2lnbih7XG4gICAgbWVzc2FnZTogXCJBIGJpbmRpbmcgcGF0dGVybiBwYXJhbWV0ZXIgY2Fubm90IGJlIG9wdGlvbmFsIGluIGFuIGltcGxlbWVudGF0aW9uIHNpZ25hdHVyZS5cIlxuICB9LCB7XG4gICAgcmVhc29uQ29kZTogXCJPcHRpb25hbEJpbmRpbmdQYXR0ZXJuXCJcbiAgfSksXG4gIFNldHRlck1heU5vdEhhdmVUaGlzUGFyYW06IFwiQSBzZXR0ZXIgY2Fubm90IGhhdmUgYSBgdGhpc2AgcGFyYW1ldGVyLlwiLFxuICBTcHJlYWRWYXJpYW5jZTogXCJTcHJlYWQgcHJvcGVydGllcyBjYW5ub3QgaGF2ZSB2YXJpYW5jZS5cIixcbiAgVGhpc1BhcmFtQW5ub3RhdGlvblJlcXVpcmVkOiBcIkEgdHlwZSBhbm5vdGF0aW9uIGlzIHJlcXVpcmVkIGZvciB0aGUgYHRoaXNgIHBhcmFtZXRlci5cIixcbiAgVGhpc1BhcmFtQmFubmVkSW5Db25zdHJ1Y3RvcjogXCJDb25zdHJ1Y3RvcnMgY2Fubm90IGhhdmUgYSBgdGhpc2AgcGFyYW1ldGVyOyBjb25zdHJ1Y3RvcnMgZG9uJ3QgYmluZCBgdGhpc2AgbGlrZSBvdGhlciBmdW5jdGlvbnMuXCIsXG4gIFRoaXNQYXJhbU1heU5vdEJlT3B0aW9uYWw6IFwiVGhlIGB0aGlzYCBwYXJhbWV0ZXIgY2Fubm90IGJlIG9wdGlvbmFsLlwiLFxuICBUaGlzUGFyYW1NdXN0QmVGaXJzdDogXCJUaGUgYHRoaXNgIHBhcmFtZXRlciBtdXN0IGJlIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXJhbWV0ZXIuXCIsXG4gIFRoaXNQYXJhbU5vRGVmYXVsdDogXCJUaGUgYHRoaXNgIHBhcmFtZXRlciBtYXkgbm90IGhhdmUgYSBkZWZhdWx0IHZhbHVlLlwiLFxuICBUeXBlQmVmb3JlSW5pdGlhbGl6ZXI6IFwiVHlwZSBhbm5vdGF0aW9ucyBtdXN0IGNvbWUgYmVmb3JlIGRlZmF1bHQgYXNzaWdubWVudHMsIGUuZy4gaW5zdGVhZCBvZiBgYWdlID0gMjU6IG51bWJlcmAgdXNlIGBhZ2U6IG51bWJlciA9IDI1YC5cIixcbiAgVHlwZUNhc3RJblBhdHRlcm46IFwiVGhlIHR5cGUgY2FzdCBleHByZXNzaW9uIGlzIGV4cGVjdGVkIHRvIGJlIHdyYXBwZWQgd2l0aCBwYXJlbnRoZXNpcy5cIixcbiAgVW5leHBlY3RlZEV4cGxpY2l0SW5leGFjdEluT2JqZWN0OiBcIkV4cGxpY2l0IGluZXhhY3Qgc3ludGF4IG11c3QgYXBwZWFyIGF0IHRoZSBlbmQgb2YgYW4gaW5leGFjdCBvYmplY3QuXCIsXG4gIFVuZXhwZWN0ZWRSZXNlcnZlZFR5cGU6ICh7XG4gICAgcmVzZXJ2ZWRUeXBlXG4gIH0pID0+IGBVbmV4cGVjdGVkIHJlc2VydmVkIHR5cGUgJHtyZXNlcnZlZFR5cGV9LmAsXG4gIFVuZXhwZWN0ZWRSZXNlcnZlZFVuZGVyc2NvcmU6IFwiYF9gIGlzIG9ubHkgYWxsb3dlZCBhcyBhIHR5cGUgYXJndW1lbnQgdG8gY2FsbCBvciBuZXcuXCIsXG4gIFVuZXhwZWN0ZWRTcGFjZUJldHdlZW5Nb2R1bG9DaGVja3M6IFwiU3BhY2VzIGJldHdlZW4gYCVgIGFuZCBgY2hlY2tzYCBhcmUgbm90IGFsbG93ZWQgaGVyZS5cIixcbiAgVW5leHBlY3RlZFNwcmVhZFR5cGU6IFwiU3ByZWFkIG9wZXJhdG9yIGNhbm5vdCBhcHBlYXIgaW4gY2xhc3Mgb3IgaW50ZXJmYWNlIGRlZmluaXRpb25zLlwiLFxuICBVbmV4cGVjdGVkU3VidHJhY3Rpb25PcGVyYW5kOiAnVW5leHBlY3RlZCB0b2tlbiwgZXhwZWN0ZWQgXCJudW1iZXJcIiBvciBcImJpZ2ludFwiLicsXG4gIFVuZXhwZWN0ZWRUb2tlbkFmdGVyVHlwZVBhcmFtZXRlcjogXCJFeHBlY3RlZCBhbiBhcnJvdyBmdW5jdGlvbiBhZnRlciB0aGlzIHR5cGUgcGFyYW1ldGVyIGRlY2xhcmF0aW9uLlwiLFxuICBVbmV4cGVjdGVkVHlwZVBhcmFtZXRlckJlZm9yZUFzeW5jQXJyb3dGdW5jdGlvbjogXCJUeXBlIHBhcmFtZXRlcnMgbXVzdCBjb21lIGFmdGVyIHRoZSBhc3luYyBrZXl3b3JkLCBlLmcuIGluc3RlYWQgb2YgYDxUPiBhc3luYyAoKSA9PiB7fWAsIHVzZSBgYXN5bmMgPFQ+KCkgPT4ge31gLlwiLFxuICBVbnN1cHBvcnRlZERlY2xhcmVFeHBvcnRLaW5kOiAoe1xuICAgIHVuc3VwcG9ydGVkRXhwb3J0S2luZCxcbiAgICBzdWdnZXN0aW9uXG4gIH0pID0+IGBcXGBkZWNsYXJlIGV4cG9ydCAke3Vuc3VwcG9ydGVkRXhwb3J0S2luZH1cXGAgaXMgbm90IHN1cHBvcnRlZC4gVXNlIFxcYCR7c3VnZ2VzdGlvbn1cXGAgaW5zdGVhZC5gLFxuICBVbnN1cHBvcnRlZFN0YXRlbWVudEluRGVjbGFyZU1vZHVsZTogXCJPbmx5IGRlY2xhcmVzIGFuZCB0eXBlIGltcG9ydHMgYXJlIGFsbG93ZWQgaW5zaWRlIGRlY2xhcmUgbW9kdWxlLlwiLFxuICBVbnRlcm1pbmF0ZWRGbG93Q29tbWVudDogXCJVbnRlcm1pbmF0ZWQgZmxvdy1jb21tZW50LlwiXG59KTtcbmZ1bmN0aW9uIGlzRXNNb2R1bGVUeXBlKGJvZHlFbGVtZW50KSB7XG4gIHJldHVybiBib2R5RWxlbWVudC50eXBlID09PSBcIkRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvblwiIHx8IGJvZHlFbGVtZW50LnR5cGUgPT09IFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIgJiYgKCFib2R5RWxlbWVudC5kZWNsYXJhdGlvbiB8fCBib2R5RWxlbWVudC5kZWNsYXJhdGlvbi50eXBlICE9PSBcIlR5cGVBbGlhc1wiICYmIGJvZHlFbGVtZW50LmRlY2xhcmF0aW9uLnR5cGUgIT09IFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIik7XG59XG5mdW5jdGlvbiBoYXNUeXBlSW1wb3J0S2luZChub2RlKSB7XG4gIHJldHVybiBub2RlLmltcG9ydEtpbmQgPT09IFwidHlwZVwiIHx8IG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlb2ZcIjtcbn1cbmNvbnN0IGV4cG9ydFN1Z2dlc3Rpb25zID0ge1xuICBjb25zdDogXCJkZWNsYXJlIGV4cG9ydCB2YXJcIixcbiAgbGV0OiBcImRlY2xhcmUgZXhwb3J0IHZhclwiLFxuICB0eXBlOiBcImV4cG9ydCB0eXBlXCIsXG4gIGludGVyZmFjZTogXCJleHBvcnQgaW50ZXJmYWNlXCJcbn07XG5mdW5jdGlvbiBwYXJ0aXRpb24obGlzdCwgdGVzdCkge1xuICBjb25zdCBsaXN0MSA9IFtdO1xuICBjb25zdCBsaXN0MiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAodGVzdChsaXN0W2ldLCBpLCBsaXN0KSA/IGxpc3QxIDogbGlzdDIpLnB1c2gobGlzdFtpXSk7XG4gIH1cbiAgcmV0dXJuIFtsaXN0MSwgbGlzdDJdO1xufVxuY29uc3QgRkxPV19QUkFHTUFfUkVHRVggPSAvXFwqP1xccypAKCg/Om5vKT9mbG93KVxcYi87XG52YXIgZmxvdyA9IHN1cGVyQ2xhc3MgPT4gY2xhc3MgRmxvd1BhcnNlck1peGluIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLmZsb3dQcmFnbWEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0U2NvcGVIYW5kbGVyKCkge1xuICAgIHJldHVybiBGbG93U2NvcGVIYW5kbGVyO1xuICB9XG4gIHNob3VsZFBhcnNlVHlwZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZmxvd1wiLCBcImFsbFwiKSB8fCB0aGlzLmZsb3dQcmFnbWEgPT09IFwiZmxvd1wiO1xuICB9XG4gIGZpbmlzaFRva2VuKHR5cGUsIHZhbCkge1xuICAgIGlmICh0eXBlICE9PSAxMzQgJiYgdHlwZSAhPT0gMTMgJiYgdHlwZSAhPT0gMjgpIHtcbiAgICAgIGlmICh0aGlzLmZsb3dQcmFnbWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmZsb3dQcmFnbWEgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlci5maW5pc2hUb2tlbih0eXBlLCB2YWwpO1xuICB9XG4gIGFkZENvbW1lbnQoY29tbWVudCkge1xuICAgIGlmICh0aGlzLmZsb3dQcmFnbWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IEZMT1dfUFJBR01BX1JFR0VYLmV4ZWMoY29tbWVudC52YWx1ZSk7XG4gICAgICBpZiAoIW1hdGNoZXMpIDtlbHNlIGlmIChtYXRjaGVzWzFdID09PSBcImZsb3dcIikge1xuICAgICAgICB0aGlzLmZsb3dQcmFnbWEgPSBcImZsb3dcIjtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2hlc1sxXSA9PT0gXCJub2Zsb3dcIikge1xuICAgICAgICB0aGlzLmZsb3dQcmFnbWEgPSBcIm5vZmxvd1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBmbG93IHByYWdtYVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIuYWRkQ29tbWVudChjb21tZW50KTtcbiAgfVxuICBmbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIodG9rKSB7XG4gICAgY29uc3Qgb2xkSW5UeXBlID0gdGhpcy5zdGF0ZS5pblR5cGU7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuICAgIHRoaXMuZXhwZWN0KHRvayB8fCAxNCk7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gb2xkSW5UeXBlO1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIGZsb3dQYXJzZVByZWRpY2F0ZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBtb2R1bG9Mb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCgxMTApO1xuICAgIGlmICh0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYy5pbmRleCA+IG1vZHVsb0xvYy5pbmRleCArIDEpIHtcbiAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5VbmV4cGVjdGVkU3BhY2VCZXR3ZWVuTW9kdWxvQ2hlY2tzLCBtb2R1bG9Mb2MpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lYXQoMTApKSB7XG4gICAgICBub2RlLnZhbHVlID0gc3VwZXIucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZWRQcmVkaWNhdGVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbmZlcnJlZFByZWRpY2F0ZVwiKTtcbiAgICB9XG4gIH1cbiAgZmxvd1BhcnNlVHlwZUFuZFByZWRpY2F0ZUluaXRpYWxpc2VyKCkge1xuICAgIGNvbnN0IG9sZEluVHlwZSA9IHRoaXMuc3RhdGUuaW5UeXBlO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gdHJ1ZTtcbiAgICB0aGlzLmV4cGVjdCgxNCk7XG4gICAgbGV0IHR5cGUgPSBudWxsO1xuICAgIGxldCBwcmVkaWNhdGUgPSBudWxsO1xuICAgIGlmICh0aGlzLm1hdGNoKDU0KSkge1xuICAgICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgICBwcmVkaWNhdGUgPSB0aGlzLmZsb3dQYXJzZVByZWRpY2F0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDU0KSkge1xuICAgICAgICBwcmVkaWNhdGUgPSB0aGlzLmZsb3dQYXJzZVByZWRpY2F0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3R5cGUsIHByZWRpY2F0ZV07XG4gIH1cbiAgZmxvd1BhcnNlRGVjbGFyZUNsYXNzKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmZsb3dQYXJzZUludGVyZmFjZWlzaChub2RlLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZUNsYXNzXCIpO1xuICB9XG4gIGZsb3dQYXJzZURlY2xhcmVGdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgY29uc3QgaWQgPSBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICBjb25zdCB0eXBlTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgdHlwZUNvbnRhaW5lciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICB0eXBlTm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVOb2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5leHBlY3QoMTApO1xuICAgIGNvbnN0IHRtcCA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKCk7XG4gICAgdHlwZU5vZGUucGFyYW1zID0gdG1wLnBhcmFtcztcbiAgICB0eXBlTm9kZS5yZXN0ID0gdG1wLnJlc3Q7XG4gICAgdHlwZU5vZGUudGhpcyA9IHRtcC5fdGhpcztcbiAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgW3R5cGVOb2RlLnJldHVyblR5cGUsIG5vZGUucHJlZGljYXRlXSA9IHRoaXMuZmxvd1BhcnNlVHlwZUFuZFByZWRpY2F0ZUluaXRpYWxpc2VyKCk7XG4gICAgdHlwZUNvbnRhaW5lci50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmluaXNoTm9kZSh0eXBlTm9kZSwgXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIpO1xuICAgIGlkLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5maW5pc2hOb2RlKHR5cGVDb250YWluZXIsIFwiVHlwZUFubm90YXRpb25cIik7XG4gICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKGlkKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHRoaXMuc2NvcGUuZGVjbGFyZU5hbWUobm9kZS5pZC5uYW1lLCAyMDQ4LCBub2RlLmlkLmxvYy5zdGFydCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVGdW5jdGlvblwiKTtcbiAgfVxuICBmbG93UGFyc2VEZWNsYXJlKG5vZGUsIGluc2lkZU1vZHVsZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDgwKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZUNsYXNzKG5vZGUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCg2OCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVGdW5jdGlvbihub2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goNzQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlVmFyaWFibGUobm9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVhdENvbnRleHR1YWwoMTI3KSkge1xuICAgICAgaWYgKHRoaXMubWF0Y2goMTYpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVNb2R1bGVFeHBvcnRzKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGluc2lkZU1vZHVsZSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5OZXN0ZWREZWNsYXJlTW9kdWxlLCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZU1vZHVsZShub2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEzMCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVUeXBlQWxpYXMobm9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMzEpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlT3BhcXVlVHlwZShub2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEyOSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVJbnRlcmZhY2Uobm9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKDgyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUsIGluc2lkZU1vZHVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgfVxuICBmbG93UGFyc2VEZWNsYXJlVmFyaWFibGUobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0YWJsZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgdGhpcy5zY29wZS5kZWNsYXJlTmFtZShub2RlLmlkLm5hbWUsIDUsIG5vZGUuaWQubG9jLnN0YXJ0KTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlVmFyaWFibGVcIik7XG4gIH1cbiAgZmxvd1BhcnNlRGVjbGFyZU1vZHVsZShub2RlKSB7XG4gICAgdGhpcy5zY29wZS5lbnRlcigwKTtcbiAgICBpZiAodGhpcy5tYXRjaCgxMzQpKSB7XG4gICAgICBub2RlLmlkID0gc3VwZXIucGFyc2VFeHByQXRvbSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICB9XG4gICAgY29uc3QgYm9keU5vZGUgPSBub2RlLmJvZHkgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNvbnN0IGJvZHkgPSBib2R5Tm9kZS5ib2R5ID0gW107XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKDgpKSB7XG4gICAgICBsZXQgYm9keU5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgaWYgKHRoaXMubWF0Y2goODMpKSB7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKDEzMCkgJiYgIXRoaXMubWF0Y2goODcpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkludmFsaWROb25UeXBlSW1wb3J0SW5EZWNsYXJlTW9kdWxlLCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIucGFyc2VJbXBvcnQoYm9keU5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKDEyNSwgRmxvd0Vycm9ycy5VbnN1cHBvcnRlZFN0YXRlbWVudEluRGVjbGFyZU1vZHVsZSk7XG4gICAgICAgIGJvZHlOb2RlID0gdGhpcy5mbG93UGFyc2VEZWNsYXJlKGJvZHlOb2RlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGJvZHkucHVzaChib2R5Tm9kZSk7XG4gICAgfVxuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgIHRoaXMuZmluaXNoTm9kZShib2R5Tm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKTtcbiAgICBsZXQga2luZCA9IG51bGw7XG4gICAgbGV0IGhhc01vZHVsZUV4cG9ydCA9IGZhbHNlO1xuICAgIGJvZHkuZm9yRWFjaChib2R5RWxlbWVudCA9PiB7XG4gICAgICBpZiAoaXNFc01vZHVsZVR5cGUoYm9keUVsZW1lbnQpKSB7XG4gICAgICAgIGlmIChraW5kID09PSBcIkNvbW1vbkpTXCIpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuQW1iaWd1b3VzRGVjbGFyZU1vZHVsZUtpbmQsIGJvZHlFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBraW5kID0gXCJFU1wiO1xuICAgICAgfSBlbHNlIGlmIChib2R5RWxlbWVudC50eXBlID09PSBcIkRlY2xhcmVNb2R1bGVFeHBvcnRzXCIpIHtcbiAgICAgICAgaWYgKGhhc01vZHVsZUV4cG9ydCkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5EdXBsaWNhdGVEZWNsYXJlTW9kdWxlRXhwb3J0cywgYm9keUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChraW5kID09PSBcIkVTXCIpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuQW1iaWd1b3VzRGVjbGFyZU1vZHVsZUtpbmQsIGJvZHlFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBraW5kID0gXCJDb21tb25KU1wiO1xuICAgICAgICBoYXNNb2R1bGVFeHBvcnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG5vZGUua2luZCA9IGtpbmQgfHwgXCJDb21tb25KU1wiO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlTW9kdWxlXCIpO1xuICB9XG4gIGZsb3dQYXJzZURlY2xhcmVFeHBvcnREZWNsYXJhdGlvbihub2RlLCBpbnNpZGVNb2R1bGUpIHtcbiAgICB0aGlzLmV4cGVjdCg4Mik7XG4gICAgaWYgKHRoaXMuZWF0KDY1KSkge1xuICAgICAgaWYgKHRoaXMubWF0Y2goNjgpIHx8IHRoaXMubWF0Y2goODApKSB7XG4gICAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLmZsb3dQYXJzZURlY2xhcmUodGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgICB9XG4gICAgICBub2RlLmRlZmF1bHQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMubWF0Y2goNzUpIHx8IHRoaXMuaXNMZXQoKSB8fCAodGhpcy5pc0NvbnRleHR1YWwoMTMwKSB8fCB0aGlzLmlzQ29udGV4dHVhbCgxMjkpKSAmJiAhaW5zaWRlTW9kdWxlKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShGbG93RXJyb3JzLlVuc3VwcG9ydGVkRGVjbGFyZUV4cG9ydEtpbmQsIHRoaXMuc3RhdGUuc3RhcnRMb2MsIHtcbiAgICAgICAgICB1bnN1cHBvcnRlZEV4cG9ydEtpbmQ6IGxhYmVsLFxuICAgICAgICAgIHN1Z2dlc3Rpb246IGV4cG9ydFN1Z2dlc3Rpb25zW2xhYmVsXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1hdGNoKDc0KSB8fCB0aGlzLm1hdGNoKDY4KSB8fCB0aGlzLm1hdGNoKDgwKSB8fCB0aGlzLmlzQ29udGV4dHVhbCgxMzEpKSB7XG4gICAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLmZsb3dQYXJzZURlY2xhcmUodGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICAgIG5vZGUuZGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKDU1KSB8fCB0aGlzLm1hdGNoKDUpIHx8IHRoaXMuaXNDb250ZXh0dWFsKDEyOSkgfHwgdGhpcy5pc0NvbnRleHR1YWwoMTMwKSB8fCB0aGlzLmlzQ29udGV4dHVhbCgxMzEpKSB7XG4gICAgICAgIG5vZGUgPSB0aGlzLnBhcnNlRXhwb3J0KG5vZGUsIG51bGwpO1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIikge1xuICAgICAgICAgIG5vZGUudHlwZSA9IFwiRXhwb3J0RGVjbGFyYXRpb25cIjtcbiAgICAgICAgICBub2RlLmRlZmF1bHQgPSBmYWxzZTtcbiAgICAgICAgICBkZWxldGUgbm9kZS5leHBvcnRLaW5kO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUudHlwZSA9IFwiRGVjbGFyZVwiICsgbm9kZS50eXBlO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbiAgZmxvd1BhcnNlRGVjbGFyZU1vZHVsZUV4cG9ydHMobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCgxMTEpO1xuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZU1vZHVsZUV4cG9ydHNcIik7XG4gIH1cbiAgZmxvd1BhcnNlRGVjbGFyZVR5cGVBbGlhcyhub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgY29uc3QgZmluaXNoZWQgPSB0aGlzLmZsb3dQYXJzZVR5cGVBbGlhcyhub2RlKTtcbiAgICBmaW5pc2hlZC50eXBlID0gXCJEZWNsYXJlVHlwZUFsaWFzXCI7XG4gICAgcmV0dXJuIGZpbmlzaGVkO1xuICB9XG4gIGZsb3dQYXJzZURlY2xhcmVPcGFxdWVUeXBlKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBjb25zdCBmaW5pc2hlZCA9IHRoaXMuZmxvd1BhcnNlT3BhcXVlVHlwZShub2RlLCB0cnVlKTtcbiAgICBmaW5pc2hlZC50eXBlID0gXCJEZWNsYXJlT3BhcXVlVHlwZVwiO1xuICAgIHJldHVybiBmaW5pc2hlZDtcbiAgfVxuICBmbG93UGFyc2VEZWNsYXJlSW50ZXJmYWNlKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmZsb3dQYXJzZUludGVyZmFjZWlzaChub2RlLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVJbnRlcmZhY2VcIik7XG4gIH1cbiAgZmxvd1BhcnNlSW50ZXJmYWNlaXNoKG5vZGUsIGlzQ2xhc3MpIHtcbiAgICBub2RlLmlkID0gdGhpcy5mbG93UGFyc2VSZXN0cmljdGVkSWRlbnRpZmllcighaXNDbGFzcywgdHJ1ZSk7XG4gICAgdGhpcy5zY29wZS5kZWNsYXJlTmFtZShub2RlLmlkLm5hbWUsIGlzQ2xhc3MgPyAxNyA6IDgyMDEsIG5vZGUuaWQubG9jLnN0YXJ0KTtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICB9XG4gICAgbm9kZS5leHRlbmRzID0gW107XG4gICAgaWYgKHRoaXMuZWF0KDgxKSkge1xuICAgICAgZG8ge1xuICAgICAgICBub2RlLmV4dGVuZHMucHVzaCh0aGlzLmZsb3dQYXJzZUludGVyZmFjZUV4dGVuZHMoKSk7XG4gICAgICB9IHdoaWxlICghaXNDbGFzcyAmJiB0aGlzLmVhdCgxMikpO1xuICAgIH1cbiAgICBpZiAoaXNDbGFzcykge1xuICAgICAgbm9kZS5pbXBsZW1lbnRzID0gW107XG4gICAgICBub2RlLm1peGlucyA9IFtdO1xuICAgICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbCgxMTcpKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBub2RlLm1peGlucy5wdXNoKHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlRXh0ZW5kcygpKTtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5lYXQoMTIpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoMTEzKSkge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgbm9kZS5pbXBsZW1lbnRzLnB1c2godGhpcy5mbG93UGFyc2VJbnRlcmZhY2VFeHRlbmRzKCkpO1xuICAgICAgICB9IHdoaWxlICh0aGlzLmVhdCgxMikpO1xuICAgICAgfVxuICAgIH1cbiAgICBub2RlLmJvZHkgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGUoe1xuICAgICAgYWxsb3dTdGF0aWM6IGlzQ2xhc3MsXG4gICAgICBhbGxvd0V4YWN0OiBmYWxzZSxcbiAgICAgIGFsbG93U3ByZWFkOiBmYWxzZSxcbiAgICAgIGFsbG93UHJvdG86IGlzQ2xhc3MsXG4gICAgICBhbGxvd0luZXhhY3Q6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgZmxvd1BhcnNlSW50ZXJmYWNlRXh0ZW5kcygpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLmlkID0gdGhpcy5mbG93UGFyc2VRdWFsaWZpZWRUeXBlSWRlbnRpZmllcigpO1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbnRlcmZhY2VFeHRlbmRzXCIpO1xuICB9XG4gIGZsb3dQYXJzZUludGVyZmFjZShub2RlKSB7XG4gICAgdGhpcy5mbG93UGFyc2VJbnRlcmZhY2Vpc2gobm9kZSwgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbnRlcmZhY2VEZWNsYXJhdGlvblwiKTtcbiAgfVxuICBjaGVja05vdFVuZGVyc2NvcmUod29yZCkge1xuICAgIGlmICh3b3JkID09PSBcIl9cIikge1xuICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlVuZXhwZWN0ZWRSZXNlcnZlZFVuZGVyc2NvcmUsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgIH1cbiAgfVxuICBjaGVja1Jlc2VydmVkVHlwZSh3b3JkLCBzdGFydExvYywgZGVjbGFyYXRpb24pIHtcbiAgICBpZiAoIXJlc2VydmVkVHlwZXMuaGFzKHdvcmQpKSByZXR1cm47XG4gICAgdGhpcy5yYWlzZShkZWNsYXJhdGlvbiA/IEZsb3dFcnJvcnMuQXNzaWduUmVzZXJ2ZWRUeXBlIDogRmxvd0Vycm9ycy5VbmV4cGVjdGVkUmVzZXJ2ZWRUeXBlLCBzdGFydExvYywge1xuICAgICAgcmVzZXJ2ZWRUeXBlOiB3b3JkXG4gICAgfSk7XG4gIH1cbiAgZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIobGliZXJhbCwgZGVjbGFyYXRpb24pIHtcbiAgICB0aGlzLmNoZWNrUmVzZXJ2ZWRUeXBlKHRoaXMuc3RhdGUudmFsdWUsIHRoaXMuc3RhdGUuc3RhcnRMb2MsIGRlY2xhcmF0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUlkZW50aWZpZXIobGliZXJhbCk7XG4gIH1cbiAgZmxvd1BhcnNlVHlwZUFsaWFzKG5vZGUpIHtcbiAgICBub2RlLmlkID0gdGhpcy5mbG93UGFyc2VSZXN0cmljdGVkSWRlbnRpZmllcihmYWxzZSwgdHJ1ZSk7XG4gICAgdGhpcy5zY29wZS5kZWNsYXJlTmFtZShub2RlLmlkLm5hbWUsIDgyMDEsIG5vZGUuaWQubG9jLnN0YXJ0KTtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICB9XG4gICAgbm9kZS5yaWdodCA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKDI5KTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUeXBlQWxpYXNcIik7XG4gIH1cbiAgZmxvd1BhcnNlT3BhcXVlVHlwZShub2RlLCBkZWNsYXJlKSB7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKDEzMCk7XG4gICAgbm9kZS5pZCA9IHRoaXMuZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIodHJ1ZSwgdHJ1ZSk7XG4gICAgdGhpcy5zY29wZS5kZWNsYXJlTmFtZShub2RlLmlkLm5hbWUsIDgyMDEsIG5vZGUuaWQubG9jLnN0YXJ0KTtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICB9XG4gICAgbm9kZS5zdXBlcnR5cGUgPSBudWxsO1xuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgbm9kZS5zdXBlcnR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigxNCk7XG4gICAgfVxuICAgIG5vZGUuaW1wbHR5cGUgPSBudWxsO1xuICAgIGlmICghZGVjbGFyZSkge1xuICAgICAgbm9kZS5pbXBsdHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKDI5KTtcbiAgICB9XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT3BhcXVlVHlwZVwiKTtcbiAgfVxuICBmbG93UGFyc2VUeXBlUGFyYW1ldGVyKHJlcXVpcmVEZWZhdWx0ID0gZmFsc2UpIHtcbiAgICBjb25zdCBub2RlU3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNvbnN0IHZhcmlhbmNlID0gdGhpcy5mbG93UGFyc2VWYXJpYW5jZSgpO1xuICAgIGNvbnN0IGlkZW50ID0gdGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGFibGVJZGVudGlmaWVyKCk7XG4gICAgbm9kZS5uYW1lID0gaWRlbnQubmFtZTtcbiAgICBub2RlLnZhcmlhbmNlID0gdmFyaWFuY2U7XG4gICAgbm9kZS5ib3VuZCA9IGlkZW50LnR5cGVBbm5vdGF0aW9uO1xuICAgIGlmICh0aGlzLm1hdGNoKDI5KSkge1xuICAgICAgdGhpcy5lYXQoMjkpO1xuICAgICAgbm9kZS5kZWZhdWx0ID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZXF1aXJlRGVmYXVsdCkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuTWlzc2luZ1R5cGVQYXJhbURlZmF1bHQsIG5vZGVTdGFydExvYyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUeXBlUGFyYW1ldGVyXCIpO1xuICB9XG4gIGZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpIHtcbiAgICBjb25zdCBvbGRJblR5cGUgPSB0aGlzLnN0YXRlLmluVHlwZTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnBhcmFtcyA9IFtdO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykgfHwgdGhpcy5tYXRjaCgxNDMpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIGxldCBkZWZhdWx0UmVxdWlyZWQgPSBmYWxzZTtcbiAgICBkbyB7XG4gICAgICBjb25zdCB0eXBlUGFyYW1ldGVyID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyKGRlZmF1bHRSZXF1aXJlZCk7XG4gICAgICBub2RlLnBhcmFtcy5wdXNoKHR5cGVQYXJhbWV0ZXIpO1xuICAgICAgaWYgKHR5cGVQYXJhbWV0ZXIuZGVmYXVsdCkge1xuICAgICAgICBkZWZhdWx0UmVxdWlyZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLm1hdGNoKDQ4KSkge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoIXRoaXMubWF0Y2goNDgpKTtcbiAgICB0aGlzLmV4cGVjdCg0OCk7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKTtcbiAgfVxuICBmbG93SW5Ub3BMZXZlbENvbnRleHQoY2IpIHtcbiAgICBpZiAodGhpcy5jdXJDb250ZXh0KCkgIT09IHR5cGVzLmJyYWNlKSB7XG4gICAgICBjb25zdCBvbGRDb250ZXh0ID0gdGhpcy5zdGF0ZS5jb250ZXh0O1xuICAgICAgdGhpcy5zdGF0ZS5jb250ZXh0ID0gW29sZENvbnRleHRbMF1dO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnN0YXRlLmNvbnRleHQgPSBvbGRDb250ZXh0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2IoKTtcbiAgICB9XG4gIH1cbiAgZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25JbkV4cHJlc3Npb24oKSB7XG4gICAgaWYgKHRoaXMucmVTY2FuX2x0KCkgIT09IDQ3KSByZXR1cm47XG4gICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24oKTtcbiAgfVxuICBmbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbigpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBvbGRJblR5cGUgPSB0aGlzLnN0YXRlLmluVHlwZTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IHRydWU7XG4gICAgbm9kZS5wYXJhbXMgPSBbXTtcbiAgICB0aGlzLmZsb3dJblRvcExldmVsQ29udGV4dCgoKSA9PiB7XG4gICAgICB0aGlzLmV4cGVjdCg0Nyk7XG4gICAgICBjb25zdCBvbGROb0Fub25GdW5jdGlvblR5cGUgPSB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZTtcbiAgICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gZmFsc2U7XG4gICAgICB3aGlsZSAoIXRoaXMubWF0Y2goNDgpKSB7XG4gICAgICAgIG5vZGUucGFyYW1zLnB1c2godGhpcy5mbG93UGFyc2VUeXBlKCkpO1xuICAgICAgICBpZiAoIXRoaXMubWF0Y2goNDgpKSB7XG4gICAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IG9sZE5vQW5vbkZ1bmN0aW9uVHlwZTtcbiAgICB9KTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcbiAgICBpZiAoIXRoaXMuc3RhdGUuaW5UeXBlICYmIHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcy5icmFjZSkge1xuICAgICAgdGhpcy5yZVNjYW5fbHRfZ3QoKTtcbiAgICB9XG4gICAgdGhpcy5leHBlY3QoNDgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKTtcbiAgfVxuICBmbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbkNhbGxPck5ldygpIHtcbiAgICBpZiAodGhpcy5yZVNjYW5fbHQoKSAhPT0gNDcpIHJldHVybjtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBvbGRJblR5cGUgPSB0aGlzLnN0YXRlLmluVHlwZTtcbiAgICBub2RlLnBhcmFtcyA9IFtdO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gdHJ1ZTtcbiAgICB0aGlzLmV4cGVjdCg0Nyk7XG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKDQ4KSkge1xuICAgICAgbm9kZS5wYXJhbXMucHVzaCh0aGlzLmZsb3dQYXJzZVR5cGVPckltcGxpY2l0SW5zdGFudGlhdGlvbigpKTtcbiAgICAgIGlmICghdGhpcy5tYXRjaCg0OCkpIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmV4cGVjdCg0OCk7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpO1xuICB9XG4gIGZsb3dQYXJzZUludGVyZmFjZVR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKDEyOSk7XG4gICAgbm9kZS5leHRlbmRzID0gW107XG4gICAgaWYgKHRoaXMuZWF0KDgxKSkge1xuICAgICAgZG8ge1xuICAgICAgICBub2RlLmV4dGVuZHMucHVzaCh0aGlzLmZsb3dQYXJzZUludGVyZmFjZUV4dGVuZHMoKSk7XG4gICAgICB9IHdoaWxlICh0aGlzLmVhdCgxMikpO1xuICAgIH1cbiAgICBub2RlLmJvZHkgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGUoe1xuICAgICAgYWxsb3dTdGF0aWM6IGZhbHNlLFxuICAgICAgYWxsb3dFeGFjdDogZmFsc2UsXG4gICAgICBhbGxvd1NwcmVhZDogZmFsc2UsXG4gICAgICBhbGxvd1Byb3RvOiBmYWxzZSxcbiAgICAgIGFsbG93SW5leGFjdDogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW50ZXJmYWNlVHlwZUFubm90YXRpb25cIik7XG4gIH1cbiAgZmxvd1BhcnNlT2JqZWN0UHJvcGVydHlLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMTM1KSB8fCB0aGlzLm1hdGNoKDEzNCkgPyBzdXBlci5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgfVxuICBmbG93UGFyc2VPYmplY3RUeXBlSW5kZXhlcihub2RlLCBpc1N0YXRpYywgdmFyaWFuY2UpIHtcbiAgICBub2RlLnN0YXRpYyA9IGlzU3RhdGljO1xuICAgIGlmICh0aGlzLmxvb2thaGVhZCgpLnR5cGUgPT09IDE0KSB7XG4gICAgICBub2RlLmlkID0gdGhpcy5mbG93UGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgbm9kZS5rZXkgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmlkID0gbnVsbDtcbiAgICAgIG5vZGUua2V5ID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDMpO1xuICAgIG5vZGUudmFsdWUgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpO1xuICAgIG5vZGUudmFyaWFuY2UgPSB2YXJpYW5jZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0VHlwZUluZGV4ZXJcIik7XG4gIH1cbiAgZmxvd1BhcnNlT2JqZWN0VHlwZUludGVybmFsU2xvdChub2RlLCBpc1N0YXRpYykge1xuICAgIG5vZGUuc3RhdGljID0gaXNTdGF0aWM7XG4gICAgbm9kZS5pZCA9IHRoaXMuZmxvd1BhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykgfHwgdGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgIG5vZGUubWV0aG9kID0gdHJ1ZTtcbiAgICAgIG5vZGUub3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgIG5vZGUudmFsdWUgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVNZXRob2Rpc2godGhpcy5zdGFydE5vZGVBdChub2RlLmxvYy5zdGFydCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLm1ldGhvZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgICBub2RlLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG5vZGUudmFsdWUgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0VHlwZUludGVybmFsU2xvdFwiKTtcbiAgfVxuICBmbG93UGFyc2VPYmplY3RUeXBlTWV0aG9kaXNoKG5vZGUpIHtcbiAgICBub2RlLnBhcmFtcyA9IFtdO1xuICAgIG5vZGUucmVzdCA9IG51bGw7XG4gICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IG51bGw7XG4gICAgbm9kZS50aGlzID0gbnVsbDtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgaWYgKHRoaXMubWF0Y2goNzgpKSB7XG4gICAgICBub2RlLnRoaXMgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtKHRydWUpO1xuICAgICAgbm9kZS50aGlzLm5hbWUgPSBudWxsO1xuICAgICAgaWYgKCF0aGlzLm1hdGNoKDExKSkge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICB9XG4gICAgfVxuICAgIHdoaWxlICghdGhpcy5tYXRjaCgxMSkgJiYgIXRoaXMubWF0Y2goMjEpKSB7XG4gICAgICBub2RlLnBhcmFtcy5wdXNoKHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW0oZmFsc2UpKTtcbiAgICAgIGlmICghdGhpcy5tYXRjaCgxMSkpIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5lYXQoMjEpKSB7XG4gICAgICBub2RlLnJlc3QgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtKGZhbHNlKTtcbiAgICB9XG4gICAgdGhpcy5leHBlY3QoMTEpO1xuICAgIG5vZGUucmV0dXJuVHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIik7XG4gIH1cbiAgZmxvd1BhcnNlT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eShub2RlLCBpc1N0YXRpYykge1xuICAgIGNvbnN0IHZhbHVlTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYztcbiAgICBub2RlLnZhbHVlID0gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlTWV0aG9kaXNoKHZhbHVlTm9kZSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk9iamVjdFR5cGVDYWxsUHJvcGVydHlcIik7XG4gIH1cbiAgZmxvd1BhcnNlT2JqZWN0VHlwZSh7XG4gICAgYWxsb3dTdGF0aWMsXG4gICAgYWxsb3dFeGFjdCxcbiAgICBhbGxvd1NwcmVhZCxcbiAgICBhbGxvd1Byb3RvLFxuICAgIGFsbG93SW5leGFjdFxuICB9KSB7XG4gICAgY29uc3Qgb2xkSW5UeXBlID0gdGhpcy5zdGF0ZS5pblR5cGU7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuICAgIGNvbnN0IG5vZGVTdGFydCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZVN0YXJ0LmNhbGxQcm9wZXJ0aWVzID0gW107XG4gICAgbm9kZVN0YXJ0LnByb3BlcnRpZXMgPSBbXTtcbiAgICBub2RlU3RhcnQuaW5kZXhlcnMgPSBbXTtcbiAgICBub2RlU3RhcnQuaW50ZXJuYWxTbG90cyA9IFtdO1xuICAgIGxldCBlbmREZWxpbTtcbiAgICBsZXQgZXhhY3Q7XG4gICAgbGV0IGluZXhhY3QgPSBmYWxzZTtcbiAgICBpZiAoYWxsb3dFeGFjdCAmJiB0aGlzLm1hdGNoKDYpKSB7XG4gICAgICB0aGlzLmV4cGVjdCg2KTtcbiAgICAgIGVuZERlbGltID0gOTtcbiAgICAgIGV4YWN0ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5leHBlY3QoNSk7XG4gICAgICBlbmREZWxpbSA9IDg7XG4gICAgICBleGFjdCA9IGZhbHNlO1xuICAgIH1cbiAgICBub2RlU3RhcnQuZXhhY3QgPSBleGFjdDtcbiAgICB3aGlsZSAoIXRoaXMubWF0Y2goZW5kRGVsaW0pKSB7XG4gICAgICBsZXQgaXNTdGF0aWMgPSBmYWxzZTtcbiAgICAgIGxldCBwcm90b1N0YXJ0TG9jID0gbnVsbDtcbiAgICAgIGxldCBpbmV4YWN0U3RhcnRMb2MgPSBudWxsO1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBpZiAoYWxsb3dQcm90byAmJiB0aGlzLmlzQ29udGV4dHVhbCgxMTgpKSB7XG4gICAgICAgIGNvbnN0IGxvb2thaGVhZCA9IHRoaXMubG9va2FoZWFkKCk7XG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSAhPT0gMTQgJiYgbG9va2FoZWFkLnR5cGUgIT09IDE3KSB7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgcHJvdG9TdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICAgICAgYWxsb3dTdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFsbG93U3RhdGljICYmIHRoaXMuaXNDb250ZXh0dWFsKDEwNikpIHtcbiAgICAgICAgY29uc3QgbG9va2FoZWFkID0gdGhpcy5sb29rYWhlYWQoKTtcbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSAxNCAmJiBsb29rYWhlYWQudHlwZSAhPT0gMTcpIHtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBpc1N0YXRpYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhcmlhbmNlID0gdGhpcy5mbG93UGFyc2VWYXJpYW5jZSgpO1xuICAgICAgaWYgKHRoaXMuZWF0KDApKSB7XG4gICAgICAgIGlmIChwcm90b1N0YXJ0TG9jICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQocHJvdG9TdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZWF0KDApKSB7XG4gICAgICAgICAgaWYgKHZhcmlhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQodmFyaWFuY2UubG9jLnN0YXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZVN0YXJ0LmludGVybmFsU2xvdHMucHVzaCh0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVJbnRlcm5hbFNsb3Qobm9kZSwgaXNTdGF0aWMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlU3RhcnQuaW5kZXhlcnMucHVzaCh0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVJbmRleGVyKG5vZGUsIGlzU3RhdGljLCB2YXJpYW5jZSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goMTApIHx8IHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICAgIGlmIChwcm90b1N0YXJ0TG9jICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQocHJvdG9TdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhcmlhbmNlKSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKHZhcmlhbmNlLmxvYy5zdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZVN0YXJ0LmNhbGxQcm9wZXJ0aWVzLnB1c2godGhpcy5mbG93UGFyc2VPYmplY3RUeXBlQ2FsbFByb3BlcnR5KG5vZGUsIGlzU3RhdGljKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQga2luZCA9IFwiaW5pdFwiO1xuICAgICAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoOTkpIHx8IHRoaXMuaXNDb250ZXh0dWFsKDEwNCkpIHtcbiAgICAgICAgICBjb25zdCBsb29rYWhlYWQgPSB0aGlzLmxvb2thaGVhZCgpO1xuICAgICAgICAgIGlmICh0b2tlbklzTGl0ZXJhbFByb3BlcnR5TmFtZShsb29rYWhlYWQudHlwZSkpIHtcbiAgICAgICAgICAgIGtpbmQgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3BPckluZXhhY3QgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVQcm9wZXJ0eShub2RlLCBpc1N0YXRpYywgcHJvdG9TdGFydExvYywgdmFyaWFuY2UsIGtpbmQsIGFsbG93U3ByZWFkLCBhbGxvd0luZXhhY3QgIT0gbnVsbCA/IGFsbG93SW5leGFjdCA6ICFleGFjdCk7XG4gICAgICAgIGlmIChwcm9wT3JJbmV4YWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgaW5leGFjdCA9IHRydWU7XG4gICAgICAgICAgaW5leGFjdFN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZVN0YXJ0LnByb3BlcnRpZXMucHVzaChwcm9wT3JJbmV4YWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5mbG93T2JqZWN0VHlwZVNlbWljb2xvbigpO1xuICAgICAgaWYgKGluZXhhY3RTdGFydExvYyAmJiAhdGhpcy5tYXRjaCg4KSAmJiAhdGhpcy5tYXRjaCg5KSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVW5leHBlY3RlZEV4cGxpY2l0SW5leGFjdEluT2JqZWN0LCBpbmV4YWN0U3RhcnRMb2MpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmV4cGVjdChlbmREZWxpbSk7XG4gICAgaWYgKGFsbG93U3ByZWFkKSB7XG4gICAgICBub2RlU3RhcnQuaW5leGFjdCA9IGluZXhhY3Q7XG4gICAgfVxuICAgIGNvbnN0IG91dCA9IHRoaXMuZmluaXNoTm9kZShub2RlU3RhcnQsIFwiT2JqZWN0VHlwZUFubm90YXRpb25cIik7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICBmbG93UGFyc2VPYmplY3RUeXBlUHJvcGVydHkobm9kZSwgaXNTdGF0aWMsIHByb3RvU3RhcnRMb2MsIHZhcmlhbmNlLCBraW5kLCBhbGxvd1NwcmVhZCwgYWxsb3dJbmV4YWN0KSB7XG4gICAgaWYgKHRoaXMuZWF0KDIxKSkge1xuICAgICAgY29uc3QgaXNJbmV4YWN0VG9rZW4gPSB0aGlzLm1hdGNoKDEyKSB8fCB0aGlzLm1hdGNoKDEzKSB8fCB0aGlzLm1hdGNoKDgpIHx8IHRoaXMubWF0Y2goOSk7XG4gICAgICBpZiAoaXNJbmV4YWN0VG9rZW4pIHtcbiAgICAgICAgaWYgKCFhbGxvd1NwcmVhZCkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5JbmV4YWN0SW5zaWRlTm9uT2JqZWN0LCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWFsbG93SW5leGFjdCkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5JbmV4YWN0SW5zaWRlRXhhY3QsIHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFyaWFuY2UpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuSW5leGFjdFZhcmlhbmNlLCB2YXJpYW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIWFsbG93U3ByZWFkKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5VbmV4cGVjdGVkU3ByZWFkVHlwZSwgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgaWYgKHByb3RvU3RhcnRMb2MgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQocHJvdG9TdGFydExvYyk7XG4gICAgICB9XG4gICAgICBpZiAodmFyaWFuY2UpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlNwcmVhZFZhcmlhbmNlLCB2YXJpYW5jZSk7XG4gICAgICB9XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmtleSA9IHRoaXMuZmxvd1BhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgIG5vZGUuc3RhdGljID0gaXNTdGF0aWM7XG4gICAgICBub2RlLnByb3RvID0gcHJvdG9TdGFydExvYyAhPSBudWxsO1xuICAgICAgbm9kZS5raW5kID0ga2luZDtcbiAgICAgIGxldCBvcHRpb25hbCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMubWF0Y2goNDcpIHx8IHRoaXMubWF0Y2goMTApKSB7XG4gICAgICAgIG5vZGUubWV0aG9kID0gdHJ1ZTtcbiAgICAgICAgaWYgKHByb3RvU3RhcnRMb2MgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMudW5leHBlY3RlZChwcm90b1N0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFyaWFuY2UpIHtcbiAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQodmFyaWFuY2UubG9jLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnZhbHVlID0gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlTWV0aG9kaXNoKHRoaXMuc3RhcnROb2RlQXQobm9kZS5sb2Muc3RhcnQpKTtcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiZ2V0XCIgfHwga2luZCA9PT0gXCJzZXRcIikge1xuICAgICAgICAgIHRoaXMuZmxvd0NoZWNrR2V0dGVyU2V0dGVyUGFyYW1zKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWxsb3dTcHJlYWQgJiYgbm9kZS5rZXkubmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiICYmIG5vZGUudmFsdWUudGhpcykge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5UaGlzUGFyYW1CYW5uZWRJbkNvbnN0cnVjdG9yLCBub2RlLnZhbHVlLnRoaXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoa2luZCAhPT0gXCJpbml0XCIpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICBub2RlLm1ldGhvZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5lYXQoMTcpKSB7XG4gICAgICAgICAgb3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUudmFsdWUgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpO1xuICAgICAgICBub2RlLnZhcmlhbmNlID0gdmFyaWFuY2U7XG4gICAgICB9XG4gICAgICBub2RlLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0VHlwZVByb3BlcnR5XCIpO1xuICAgIH1cbiAgfVxuICBmbG93Q2hlY2tHZXR0ZXJTZXR0ZXJQYXJhbXMocHJvcGVydHkpIHtcbiAgICBjb25zdCBwYXJhbUNvdW50ID0gcHJvcGVydHkua2luZCA9PT0gXCJnZXRcIiA/IDAgOiAxO1xuICAgIGNvbnN0IGxlbmd0aCA9IHByb3BlcnR5LnZhbHVlLnBhcmFtcy5sZW5ndGggKyAocHJvcGVydHkudmFsdWUucmVzdCA/IDEgOiAwKTtcbiAgICBpZiAocHJvcGVydHkudmFsdWUudGhpcykge1xuICAgICAgdGhpcy5yYWlzZShwcm9wZXJ0eS5raW5kID09PSBcImdldFwiID8gRmxvd0Vycm9ycy5HZXR0ZXJNYXlOb3RIYXZlVGhpc1BhcmFtIDogRmxvd0Vycm9ycy5TZXR0ZXJNYXlOb3RIYXZlVGhpc1BhcmFtLCBwcm9wZXJ0eS52YWx1ZS50aGlzKTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCAhPT0gcGFyYW1Db3VudCkge1xuICAgICAgdGhpcy5yYWlzZShwcm9wZXJ0eS5raW5kID09PSBcImdldFwiID8gRXJyb3JzLkJhZEdldHRlckFyaXR5IDogRXJyb3JzLkJhZFNldHRlckFyaXR5LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIGlmIChwcm9wZXJ0eS5raW5kID09PSBcInNldFwiICYmIHByb3BlcnR5LnZhbHVlLnJlc3QpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkJhZFNldHRlclJlc3RQYXJhbWV0ZXIsIHByb3BlcnR5KTtcbiAgICB9XG4gIH1cbiAgZmxvd09iamVjdFR5cGVTZW1pY29sb24oKSB7XG4gICAgaWYgKCF0aGlzLmVhdCgxMykgJiYgIXRoaXMuZWF0KDEyKSAmJiAhdGhpcy5tYXRjaCg4KSAmJiAhdGhpcy5tYXRjaCg5KSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICB9XG4gIGZsb3dQYXJzZVF1YWxpZmllZFR5cGVJZGVudGlmaWVyKHN0YXJ0TG9jLCBpZCkge1xuICAgIHN0YXJ0TG9jICE9IG51bGwgPyBzdGFydExvYyA6IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBsZXQgbm9kZSA9IGlkIHx8IHRoaXMuZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIodHJ1ZSk7XG4gICAgd2hpbGUgKHRoaXMuZWF0KDE2KSkge1xuICAgICAgY29uc3Qgbm9kZTIgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUyLnF1YWxpZmljYXRpb24gPSBub2RlO1xuICAgICAgbm9kZTIuaWQgPSB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKHRydWUpO1xuICAgICAgbm9kZSA9IHRoaXMuZmluaXNoTm9kZShub2RlMiwgXCJRdWFsaWZpZWRUeXBlSWRlbnRpZmllclwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgZmxvd1BhcnNlR2VuZXJpY1R5cGUoc3RhcnRMb2MsIGlkKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVF1YWxpZmllZFR5cGVJZGVudGlmaWVyKHN0YXJ0TG9jLCBpZCk7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiR2VuZXJpY1R5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG4gIGZsb3dQYXJzZVR5cGVvZlR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3QoODcpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLmZsb3dQYXJzZVByaW1hcnlUeXBlKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlR5cGVvZlR5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG4gIGZsb3dQYXJzZVR1cGxlVHlwZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnR5cGVzID0gW107XG4gICAgdGhpcy5leHBlY3QoMCk7XG4gICAgd2hpbGUgKHRoaXMuc3RhdGUucG9zIDwgdGhpcy5sZW5ndGggJiYgIXRoaXMubWF0Y2goMykpIHtcbiAgICAgIG5vZGUudHlwZXMucHVzaCh0aGlzLmZsb3dQYXJzZVR5cGUoKSk7XG4gICAgICBpZiAodGhpcy5tYXRjaCgzKSkgYnJlYWs7XG4gICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDMpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG4gIGZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtKGZpcnN0KSB7XG4gICAgbGV0IG5hbWUgPSBudWxsO1xuICAgIGxldCBvcHRpb25hbCA9IGZhbHNlO1xuICAgIGxldCB0eXBlQW5ub3RhdGlvbiA9IG51bGw7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgbGggPSB0aGlzLmxvb2thaGVhZCgpO1xuICAgIGNvbnN0IGlzVGhpcyA9IHRoaXMuc3RhdGUudHlwZSA9PT0gNzg7XG4gICAgaWYgKGxoLnR5cGUgPT09IDE0IHx8IGxoLnR5cGUgPT09IDE3KSB7XG4gICAgICBpZiAoaXNUaGlzICYmICFmaXJzdCkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVGhpc1BhcmFtTXVzdEJlRmlyc3QsIG5vZGUpO1xuICAgICAgfVxuICAgICAgbmFtZSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKGlzVGhpcyk7XG4gICAgICBpZiAodGhpcy5lYXQoMTcpKSB7XG4gICAgICAgIG9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgICAgaWYgKGlzVGhpcykge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5UaGlzUGFyYW1NYXlOb3RCZU9wdGlvbmFsLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgIH1cbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICAgIG5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdHlwZUFubm90YXRpb247XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uVHlwZVBhcmFtXCIpO1xuICB9XG4gIHJlaW50ZXJwcmV0VHlwZUFzRnVuY3Rpb25UeXBlUGFyYW0odHlwZSkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHR5cGUubG9jLnN0YXJ0KTtcbiAgICBub2RlLm5hbWUgPSBudWxsO1xuICAgIG5vZGUub3B0aW9uYWwgPSBmYWxzZTtcbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdHlwZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25UeXBlUGFyYW1cIik7XG4gIH1cbiAgZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKHBhcmFtcyA9IFtdKSB7XG4gICAgbGV0IHJlc3QgPSBudWxsO1xuICAgIGxldCBfdGhpcyA9IG51bGw7XG4gICAgaWYgKHRoaXMubWF0Y2goNzgpKSB7XG4gICAgICBfdGhpcyA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW0odHJ1ZSk7XG4gICAgICBfdGhpcy5uYW1lID0gbnVsbDtcbiAgICAgIGlmICghdGhpcy5tYXRjaCgxMSkpIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoIXRoaXMubWF0Y2goMTEpICYmICF0aGlzLm1hdGNoKDIxKSkge1xuICAgICAgcGFyYW1zLnB1c2godGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbShmYWxzZSkpO1xuICAgICAgaWYgKCF0aGlzLm1hdGNoKDExKSkge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmVhdCgyMSkpIHtcbiAgICAgIHJlc3QgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtKGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmFtcyxcbiAgICAgIHJlc3QsXG4gICAgICBfdGhpc1xuICAgIH07XG4gIH1cbiAgZmxvd0lkZW50VG9UeXBlQW5ub3RhdGlvbihzdGFydExvYywgbm9kZSwgaWQpIHtcbiAgICBzd2l0Y2ggKGlkLm5hbWUpIHtcbiAgICAgIGNhc2UgXCJhbnlcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFueVR5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCb29sZWFuVHlwZUFubm90YXRpb25cIik7XG4gICAgICBjYXNlIFwibWl4ZWRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1peGVkVHlwZUFubm90YXRpb25cIik7XG4gICAgICBjYXNlIFwiZW1wdHlcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVtcHR5VHlwZUFubm90YXRpb25cIik7XG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJOdW1iZXJUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN0cmluZ1R5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3ltYm9sVHlwZUFubm90YXRpb25cIik7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmNoZWNrTm90VW5kZXJzY29yZShpZC5uYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlR2VuZXJpY1R5cGUoc3RhcnRMb2MsIGlkKTtcbiAgICB9XG4gIH1cbiAgZmxvd1BhcnNlUHJpbWFyeVR5cGUoKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGxldCB0bXA7XG4gICAgbGV0IHR5cGU7XG4gICAgbGV0IGlzR3JvdXBlZFR5cGUgPSBmYWxzZTtcbiAgICBjb25zdCBvbGROb0Fub25GdW5jdGlvblR5cGUgPSB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZTtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlKHtcbiAgICAgICAgICBhbGxvd1N0YXRpYzogZmFsc2UsXG4gICAgICAgICAgYWxsb3dFeGFjdDogZmFsc2UsXG4gICAgICAgICAgYWxsb3dTcHJlYWQ6IHRydWUsXG4gICAgICAgICAgYWxsb3dQcm90bzogZmFsc2UsXG4gICAgICAgICAgYWxsb3dJbmV4YWN0OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSA2OlxuICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlKHtcbiAgICAgICAgICBhbGxvd1N0YXRpYzogZmFsc2UsXG4gICAgICAgICAgYWxsb3dFeGFjdDogdHJ1ZSxcbiAgICAgICAgICBhbGxvd1NwcmVhZDogdHJ1ZSxcbiAgICAgICAgICBhbGxvd1Byb3RvOiBmYWxzZSxcbiAgICAgICAgICBhbGxvd0luZXhhY3Q6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSAwOlxuICAgICAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IGZhbHNlO1xuICAgICAgICB0eXBlID0gdGhpcy5mbG93UGFyc2VUdXBsZVR5cGUoKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSBvbGROb0Fub25GdW5jdGlvblR5cGU7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgY2FzZSA0NzpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0KDEwKTtcbiAgICAgICAgICB0bXAgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtcygpO1xuICAgICAgICAgIG5vZGUucGFyYW1zID0gdG1wLnBhcmFtcztcbiAgICAgICAgICBub2RlLnJlc3QgPSB0bXAucmVzdDtcbiAgICAgICAgICBub2RlLnRoaXMgPSB0bXAuX3RoaXM7XG4gICAgICAgICAgdGhpcy5leHBlY3QoMTEpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0KDE5KTtcbiAgICAgICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAxMDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgxMSkgJiYgIXRoaXMubWF0Y2goMjEpKSB7XG4gICAgICAgICAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSB8fCB0aGlzLm1hdGNoKDc4KSkge1xuICAgICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMubG9va2FoZWFkKCkudHlwZTtcbiAgICAgICAgICAgICAgaXNHcm91cGVkVHlwZSA9IHRva2VuICE9PSAxNyAmJiB0b2tlbiAhPT0gMTQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpc0dyb3VwZWRUeXBlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzR3JvdXBlZFR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gZmFsc2U7XG4gICAgICAgICAgICB0eXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IG9sZE5vQW5vbkZ1bmN0aW9uVHlwZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSB8fCAhKHRoaXMubWF0Y2goMTIpIHx8IHRoaXMubWF0Y2goMTEpICYmIHRoaXMubG9va2FoZWFkKCkudHlwZSA9PT0gMTkpKSB7XG4gICAgICAgICAgICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmVhdCgxMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICB0bXAgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtcyhbdGhpcy5yZWludGVycHJldFR5cGVBc0Z1bmN0aW9uVHlwZVBhcmFtKHR5cGUpXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRtcCA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUucGFyYW1zID0gdG1wLnBhcmFtcztcbiAgICAgICAgICBub2RlLnJlc3QgPSB0bXAucmVzdDtcbiAgICAgICAgICBub2RlLnRoaXMgPSB0bXAuX3RoaXM7XG4gICAgICAgICAgdGhpcy5leHBlY3QoMTEpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0KDE5KTtcbiAgICAgICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICAgICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAxMzQ6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlLCBcIlN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgODU6XG4gICAgICBjYXNlIDg2OlxuICAgICAgICBub2RlLnZhbHVlID0gdGhpcy5tYXRjaCg4NSk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgNTM6XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnZhbHVlID09PSBcIi1cIikge1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIGlmICh0aGlzLm1hdGNoKDEzNSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbEF0Tm9kZSgtdGhpcy5zdGF0ZS52YWx1ZSwgXCJOdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb25cIiwgbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLm1hdGNoKDEzNikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbEF0Tm9kZSgtdGhpcy5zdGF0ZS52YWx1ZSwgXCJCaWdJbnRMaXRlcmFsVHlwZUFubm90YXRpb25cIiwgbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRmxvd0Vycm9ycy5VbmV4cGVjdGVkU3VidHJhY3Rpb25PcGVyYW5kLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSAxMzU6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlLCBcIk51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgMTM2OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSwgXCJCaWdJbnRMaXRlcmFsVHlwZUFubm90YXRpb25cIik7XG4gICAgICBjYXNlIDg4OlxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlZvaWRUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgODQ6XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgNzg6XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhpc1R5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgY2FzZSA1NTpcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeGlzdHNUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgODc6XG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZVR5cGVvZlR5cGUoKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0b2tlbklzS2V5d29yZCh0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgICAgY29uc3QgbGFiZWwgPSB0b2tlbkxhYmVsTmFtZSh0aGlzLnN0YXRlLnR5cGUpO1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIHJldHVybiBzdXBlci5jcmVhdGVJZGVudGlmaWVyKG5vZGUsIGxhYmVsKTtcbiAgICAgICAgfSBlbHNlIGlmICh0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEyOSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZUludGVyZmFjZVR5cGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmxvd0lkZW50VG9UeXBlQW5ub3RhdGlvbihzdGFydExvYywgbm9kZSwgdGhpcy5wYXJzZUlkZW50aWZpZXIoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbiAgZmxvd1BhcnNlUG9zdGZpeFR5cGUoKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGxldCB0eXBlID0gdGhpcy5mbG93UGFyc2VQcmltYXJ5VHlwZSgpO1xuICAgIGxldCBzZWVuT3B0aW9uYWxJbmRleGVkQWNjZXNzID0gZmFsc2U7XG4gICAgd2hpbGUgKCh0aGlzLm1hdGNoKDApIHx8IHRoaXMubWF0Y2goMTgpKSAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgY29uc3Qgb3B0aW9uYWwgPSB0aGlzLmVhdCgxOCk7XG4gICAgICBzZWVuT3B0aW9uYWxJbmRleGVkQWNjZXNzID0gc2Vlbk9wdGlvbmFsSW5kZXhlZEFjY2VzcyB8fCBvcHRpb25hbDtcbiAgICAgIHRoaXMuZXhwZWN0KDApO1xuICAgICAgaWYgKCFvcHRpb25hbCAmJiB0aGlzLm1hdGNoKDMpKSB7XG4gICAgICAgIG5vZGUuZWxlbWVudFR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgdHlwZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycmF5VHlwZUFubm90YXRpb25cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLm9iamVjdFR5cGUgPSB0eXBlO1xuICAgICAgICBub2RlLmluZGV4VHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgICAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICAgICAgaWYgKHNlZW5PcHRpb25hbEluZGV4ZWRBY2Nlc3MpIHtcbiAgICAgICAgICBub2RlLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICAgICAgdHlwZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGVcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHlwZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkluZGV4ZWRBY2Nlc3NUeXBlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIGZsb3dQYXJzZVByZWZpeFR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlUHJlZml4VHlwZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk51bGxhYmxlVHlwZUFubm90YXRpb25cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZVBvc3RmaXhUeXBlKCk7XG4gICAgfVxuICB9XG4gIGZsb3dQYXJzZUFub25GdW5jdGlvbldpdGhvdXRQYXJlbnMoKSB7XG4gICAgY29uc3QgcGFyYW0gPSB0aGlzLmZsb3dQYXJzZVByZWZpeFR5cGUoKTtcbiAgICBpZiAoIXRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlICYmIHRoaXMuZWF0KDE5KSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQocGFyYW0ubG9jLnN0YXJ0KTtcbiAgICAgIG5vZGUucGFyYW1zID0gW3RoaXMucmVpbnRlcnByZXRUeXBlQXNGdW5jdGlvblR5cGVQYXJhbShwYXJhbSldO1xuICAgICAgbm9kZS5yZXN0ID0gbnVsbDtcbiAgICAgIG5vZGUudGhpcyA9IG51bGw7XG4gICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIik7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbTtcbiAgfVxuICBmbG93UGFyc2VJbnRlcnNlY3Rpb25UeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMuZWF0KDQ1KTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5mbG93UGFyc2VBbm9uRnVuY3Rpb25XaXRob3V0UGFyZW5zKCk7XG4gICAgbm9kZS50eXBlcyA9IFt0eXBlXTtcbiAgICB3aGlsZSAodGhpcy5lYXQoNDUpKSB7XG4gICAgICBub2RlLnR5cGVzLnB1c2godGhpcy5mbG93UGFyc2VBbm9uRnVuY3Rpb25XaXRob3V0UGFyZW5zKCkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS50eXBlcy5sZW5ndGggPT09IDEgPyB0eXBlIDogdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb25cIik7XG4gIH1cbiAgZmxvd1BhcnNlVW5pb25UeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMuZWF0KDQzKTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5mbG93UGFyc2VJbnRlcnNlY3Rpb25UeXBlKCk7XG4gICAgbm9kZS50eXBlcyA9IFt0eXBlXTtcbiAgICB3aGlsZSAodGhpcy5lYXQoNDMpKSB7XG4gICAgICBub2RlLnR5cGVzLnB1c2godGhpcy5mbG93UGFyc2VJbnRlcnNlY3Rpb25UeXBlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS50eXBlcy5sZW5ndGggPT09IDEgPyB0eXBlIDogdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVW5pb25UeXBlQW5ub3RhdGlvblwiKTtcbiAgfVxuICBmbG93UGFyc2VUeXBlKCkge1xuICAgIGNvbnN0IG9sZEluVHlwZSA9IHRoaXMuc3RhdGUuaW5UeXBlO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gdHJ1ZTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5mbG93UGFyc2VVbmlvblR5cGUoKTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICBmbG93UGFyc2VUeXBlT3JJbXBsaWNpdEluc3RhbnRpYXRpb24oKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUudHlwZSA9PT0gMTMyICYmIHRoaXMuc3RhdGUudmFsdWUgPT09IFwiX1wiKSB7XG4gICAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZUdlbmVyaWNUeXBlKHN0YXJ0TG9jLCBub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgIH1cbiAgfVxuICBmbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZUFubm90YXRpb25cIik7XG4gIH1cbiAgZmxvd1BhcnNlVHlwZUFubm90YXRhYmxlSWRlbnRpZmllcihhbGxvd1ByaW1pdGl2ZU92ZXJyaWRlKSB7XG4gICAgY29uc3QgaWRlbnQgPSBhbGxvd1ByaW1pdGl2ZU92ZXJyaWRlID8gdGhpcy5wYXJzZUlkZW50aWZpZXIoKSA6IHRoaXMuZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIoKTtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIGlkZW50LnR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKGlkZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGlkZW50O1xuICB9XG4gIHR5cGVDYXN0VG9QYXJhbWV0ZXIobm9kZSkge1xuICAgIG5vZGUuZXhwcmVzc2lvbi50eXBlQW5ub3RhdGlvbiA9IG5vZGUudHlwZUFubm90YXRpb247XG4gICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50eXBlQW5ub3RhdGlvbi5sb2MuZW5kKTtcbiAgICByZXR1cm4gbm9kZS5leHByZXNzaW9uO1xuICB9XG4gIGZsb3dQYXJzZVZhcmlhbmNlKCkge1xuICAgIGxldCB2YXJpYW5jZSA9IG51bGw7XG4gICAgaWYgKHRoaXMubWF0Y2goNTMpKSB7XG4gICAgICB2YXJpYW5jZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBpZiAodGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCIrXCIpIHtcbiAgICAgICAgdmFyaWFuY2Uua2luZCA9IFwicGx1c1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyaWFuY2Uua2luZCA9IFwibWludXNcIjtcbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZSh2YXJpYW5jZSwgXCJWYXJpYW5jZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhcmlhbmNlO1xuICB9XG4gIHBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGFsbG93RXhwcmVzc2lvbkJvZHksIGlzTWV0aG9kID0gZmFsc2UpIHtcbiAgICBpZiAoYWxsb3dFeHByZXNzaW9uQm9keSkge1xuICAgICAgdGhpcy5mb3J3YXJkTm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdChub2RlLCAoKSA9PiBzdXBlci5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCB0cnVlLCBpc01ldGhvZCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBmYWxzZSwgaXNNZXRob2QpO1xuICB9XG4gIHBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIHR5cGUsIGlzTWV0aG9kID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIGNvbnN0IHR5cGVOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIFt0eXBlTm9kZS50eXBlQW5ub3RhdGlvbiwgbm9kZS5wcmVkaWNhdGVdID0gdGhpcy5mbG93UGFyc2VUeXBlQW5kUHJlZGljYXRlSW5pdGlhbGlzZXIoKTtcbiAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHR5cGVOb2RlLnR5cGVBbm5vdGF0aW9uID8gdGhpcy5maW5pc2hOb2RlKHR5cGVOb2RlLCBcIlR5cGVBbm5vdGF0aW9uXCIpIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIHR5cGUsIGlzTWV0aG9kKTtcbiAgfVxuICBwYXJzZVN0YXRlbWVudExpa2UoZmxhZ3MpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5zdHJpY3QgJiYgdGhpcy5pc0NvbnRleHR1YWwoMTI5KSkge1xuICAgICAgY29uc3QgbG9va2FoZWFkID0gdGhpcy5sb29rYWhlYWQoKTtcbiAgICAgIGlmICh0b2tlbklzS2V5d29yZE9ySWRlbnRpZmllcihsb29rYWhlYWQudHlwZSkpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VJbnRlcmZhY2Uobm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMjYpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRW51bURlY2xhcmF0aW9uKG5vZGUpO1xuICAgIH1cbiAgICBjb25zdCBzdG10ID0gc3VwZXIucGFyc2VTdGF0ZW1lbnRMaWtlKGZsYWdzKTtcbiAgICBpZiAodGhpcy5mbG93UHJhZ21hID09PSB1bmRlZmluZWQgJiYgIXRoaXMuaXNWYWxpZERpcmVjdGl2ZShzdG10KSkge1xuICAgICAgdGhpcy5mbG93UHJhZ21hID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHN0bXQ7XG4gIH1cbiAgcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIsIGRlY29yYXRvcnMpIHtcbiAgICBpZiAoZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgaWYgKGV4cHIubmFtZSA9PT0gXCJkZWNsYXJlXCIpIHtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2goODApIHx8IHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkgfHwgdGhpcy5tYXRjaCg2OCkgfHwgdGhpcy5tYXRjaCg3NCkgfHwgdGhpcy5tYXRjaCg4MikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgICAgaWYgKGV4cHIubmFtZSA9PT0gXCJpbnRlcmZhY2VcIikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZUludGVyZmFjZShub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChleHByLm5hbWUgPT09IFwidHlwZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlVHlwZUFsaWFzKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGV4cHIubmFtZSA9PT0gXCJvcGFxdWVcIikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZU9wYXF1ZVR5cGUobm9kZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwciwgZGVjb3JhdG9ycyk7XG4gIH1cbiAgc2hvdWxkUGFyc2VFeHBvcnREZWNsYXJhdGlvbigpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHR5cGUgPT09IDEyNiB8fCB0b2tlbklzRmxvd0ludGVyZmFjZU9yVHlwZU9yT3BhcXVlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gIXRoaXMuc3RhdGUuY29udGFpbnNFc2M7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5zaG91bGRQYXJzZUV4cG9ydERlY2xhcmF0aW9uKCk7XG4gIH1cbiAgaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodHlwZSA9PT0gMTI2IHx8IHRva2VuSXNGbG93SW50ZXJmYWNlT3JUeXBlT3JPcGFxdWUodHlwZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlLmNvbnRhaW5zRXNjO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKCk7XG4gIH1cbiAgcGFyc2VFeHBvcnREZWZhdWx0RXhwcmVzc2lvbigpIHtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTI2KSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZUVudW1EZWNsYXJhdGlvbihub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlRXhwb3J0RGVmYXVsdEV4cHJlc3Npb24oKTtcbiAgfVxuICBwYXJzZUNvbmRpdGlvbmFsKGV4cHIsIHN0YXJ0TG9jLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDE3KSkgcmV0dXJuIGV4cHI7XG4gICAgaWYgKHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycykge1xuICAgICAgY29uc3QgbmV4dENoID0gdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpO1xuICAgICAgaWYgKG5leHRDaCA9PT0gNDQgfHwgbmV4dENoID09PSA2MSB8fCBuZXh0Q2ggPT09IDU4IHx8IG5leHRDaCA9PT0gNDEpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25hbFBhcmFtZXRlcnNFcnJvcihyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDE3KTtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUuY2xvbmUoKTtcbiAgICBjb25zdCBvcmlnaW5hbE5vQXJyb3dBdCA9IHRoaXMuc3RhdGUubm9BcnJvd0F0O1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICBsZXQge1xuICAgICAgY29uc2VxdWVudCxcbiAgICAgIGZhaWxlZFxuICAgIH0gPSB0aGlzLnRyeVBhcnNlQ29uZGl0aW9uYWxDb25zZXF1ZW50KCk7XG4gICAgbGV0IFt2YWxpZCwgaW52YWxpZF0gPSB0aGlzLmdldEFycm93TGlrZUV4cHJlc3Npb25zKGNvbnNlcXVlbnQpO1xuICAgIGlmIChmYWlsZWQgfHwgaW52YWxpZC5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBub0Fycm93QXQgPSBbLi4ub3JpZ2luYWxOb0Fycm93QXRdO1xuICAgICAgaWYgKGludmFsaWQubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuc3RhdGUubm9BcnJvd0F0ID0gbm9BcnJvd0F0O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGludmFsaWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub0Fycm93QXQucHVzaChpbnZhbGlkW2ldLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICAoe1xuICAgICAgICAgIGNvbnNlcXVlbnQsXG4gICAgICAgICAgZmFpbGVkXG4gICAgICAgIH0gPSB0aGlzLnRyeVBhcnNlQ29uZGl0aW9uYWxDb25zZXF1ZW50KCkpO1xuICAgICAgICBbdmFsaWQsIGludmFsaWRdID0gdGhpcy5nZXRBcnJvd0xpa2VFeHByZXNzaW9ucyhjb25zZXF1ZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChmYWlsZWQgJiYgdmFsaWQubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuQW1iaWd1b3VzQ29uZGl0aW9uYWxBcnJvdywgc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgaWYgKGZhaWxlZCAmJiB2YWxpZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICBub0Fycm93QXQucHVzaCh2YWxpZFswXS5zdGFydCk7XG4gICAgICAgIHRoaXMuc3RhdGUubm9BcnJvd0F0ID0gbm9BcnJvd0F0O1xuICAgICAgICAoe1xuICAgICAgICAgIGNvbnNlcXVlbnQsXG4gICAgICAgICAgZmFpbGVkXG4gICAgICAgIH0gPSB0aGlzLnRyeVBhcnNlQ29uZGl0aW9uYWxDb25zZXF1ZW50KCkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmdldEFycm93TGlrZUV4cHJlc3Npb25zKGNvbnNlcXVlbnQsIHRydWUpO1xuICAgIHRoaXMuc3RhdGUubm9BcnJvd0F0ID0gb3JpZ2luYWxOb0Fycm93QXQ7XG4gICAgdGhpcy5leHBlY3QoMTQpO1xuICAgIG5vZGUudGVzdCA9IGV4cHI7XG4gICAgbm9kZS5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcbiAgICBub2RlLmFsdGVybmF0ZSA9IHRoaXMuZm9yd2FyZE5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQobm9kZSwgKCkgPT4gdGhpcy5wYXJzZU1heWJlQXNzaWduKHVuZGVmaW5lZCwgdW5kZWZpbmVkKSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKTtcbiAgfVxuICB0cnlQYXJzZUNvbmRpdGlvbmFsQ29uc2VxdWVudCgpIHtcbiAgICB0aGlzLnN0YXRlLm5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQucHVzaCh0aGlzLnN0YXRlLnN0YXJ0KTtcbiAgICBjb25zdCBjb25zZXF1ZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbigpO1xuICAgIGNvbnN0IGZhaWxlZCA9ICF0aGlzLm1hdGNoKDE0KTtcbiAgICB0aGlzLnN0YXRlLm5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQucG9wKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnNlcXVlbnQsXG4gICAgICBmYWlsZWRcbiAgICB9O1xuICB9XG4gIGdldEFycm93TGlrZUV4cHJlc3Npb25zKG5vZGUsIGRpc2FsbG93SW52YWxpZCkge1xuICAgIGNvbnN0IHN0YWNrID0gW25vZGVdO1xuICAgIGNvbnN0IGFycm93cyA9IFtdO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggIT09IDApIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBzdGFjay5wb3AoKTtcbiAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiBub2RlLmJvZHkudHlwZSAhPT0gXCJCbG9ja1N0YXRlbWVudFwiKSB7XG4gICAgICAgIGlmIChub2RlLnR5cGVQYXJhbWV0ZXJzIHx8ICFub2RlLnJldHVyblR5cGUpIHtcbiAgICAgICAgICB0aGlzLmZpbmlzaEFycm93VmFsaWRhdGlvbihub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcnJvd3MucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wdXNoKG5vZGUuYm9keSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIikge1xuICAgICAgICBzdGFjay5wdXNoKG5vZGUuY29uc2VxdWVudCk7XG4gICAgICAgIHN0YWNrLnB1c2gobm9kZS5hbHRlcm5hdGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGlzYWxsb3dJbnZhbGlkKSB7XG4gICAgICBhcnJvd3MuZm9yRWFjaChub2RlID0+IHRoaXMuZmluaXNoQXJyb3dWYWxpZGF0aW9uKG5vZGUpKTtcbiAgICAgIHJldHVybiBbYXJyb3dzLCBbXV07XG4gICAgfVxuICAgIHJldHVybiBwYXJ0aXRpb24oYXJyb3dzLCBub2RlID0+IG5vZGUucGFyYW1zLmV2ZXJ5KHBhcmFtID0+IHRoaXMuaXNBc3NpZ25hYmxlKHBhcmFtLCB0cnVlKSkpO1xuICB9XG4gIGZpbmlzaEFycm93VmFsaWRhdGlvbihub2RlKSB7XG4gICAgdmFyIF9ub2RlJGV4dHJhO1xuICAgIHRoaXMudG9Bc3NpZ25hYmxlTGlzdChub2RlLnBhcmFtcywgKF9ub2RlJGV4dHJhID0gbm9kZS5leHRyYSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGV4dHJhLnRyYWlsaW5nQ29tbWFMb2MsIGZhbHNlKTtcbiAgICB0aGlzLnNjb3BlLmVudGVyKDIgfCA0KTtcbiAgICBzdXBlci5jaGVja1BhcmFtcyhub2RlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgdGhpcy5zY29wZS5leGl0KCk7XG4gIH1cbiAgZm9yd2FyZE5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQobm9kZSwgcGFyc2UpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICh0aGlzLnN0YXRlLm5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQuaW5jbHVkZXModGhpcy5vZmZzZXRUb1NvdXJjZVBvcyhub2RlLnN0YXJ0KSkpIHtcbiAgICAgIHRoaXMuc3RhdGUubm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdC5wdXNoKHRoaXMuc3RhdGUuc3RhcnQpO1xuICAgICAgcmVzdWx0ID0gcGFyc2UoKTtcbiAgICAgIHRoaXMuc3RhdGUubm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdC5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gcGFyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBwYXJzZVBhcmVuSXRlbShub2RlLCBzdGFydExvYykge1xuICAgIGNvbnN0IG5ld05vZGUgPSBzdXBlci5wYXJzZVBhcmVuSXRlbShub2RlLCBzdGFydExvYyk7XG4gICAgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgbmV3Tm9kZS5vcHRpb25hbCA9IHRydWU7XG4gICAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24obm9kZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgY29uc3QgdHlwZUNhc3ROb2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICB0eXBlQ2FzdE5vZGUuZXhwcmVzc2lvbiA9IG5ld05vZGU7XG4gICAgICB0eXBlQ2FzdE5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHR5cGVDYXN0Tm9kZSwgXCJUeXBlQ2FzdEV4cHJlc3Npb25cIik7XG4gICAgfVxuICAgIHJldHVybiBuZXdOb2RlO1xuICB9XG4gIGFzc2VydE1vZHVsZU5vZGVBbGxvd2VkKG5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIkltcG9ydERlY2xhcmF0aW9uXCIgJiYgKG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlXCIgfHwgbm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVvZlwiKSB8fCBub2RlLnR5cGUgPT09IFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiICYmIG5vZGUuZXhwb3J0S2luZCA9PT0gXCJ0eXBlXCIgfHwgbm9kZS50eXBlID09PSBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIgJiYgbm9kZS5leHBvcnRLaW5kID09PSBcInR5cGVcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5hc3NlcnRNb2R1bGVOb2RlQWxsb3dlZChub2RlKTtcbiAgfVxuICBwYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTMwKSkge1xuICAgICAgbm9kZS5leHBvcnRLaW5kID0gXCJ0eXBlXCI7XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy5tYXRjaCg1KSkge1xuICAgICAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVycyh0cnVlKTtcbiAgICAgICAgc3VwZXIucGFyc2VFeHBvcnRGcm9tKG5vZGUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZVR5cGVBbGlhcyhkZWNsYXJhdGlvbk5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTMxKSkge1xuICAgICAgbm9kZS5leHBvcnRLaW5kID0gXCJ0eXBlXCI7XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VPcGFxdWVUeXBlKGRlY2xhcmF0aW9uTm9kZSwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTI5KSkge1xuICAgICAgbm9kZS5leHBvcnRLaW5kID0gXCJ0eXBlXCI7XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VJbnRlcmZhY2UoZGVjbGFyYXRpb25Ob2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEyNikpIHtcbiAgICAgIG5vZGUuZXhwb3J0S2luZCA9IFwidmFsdWVcIjtcbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9uTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZUVudW1EZWNsYXJhdGlvbihkZWNsYXJhdGlvbk5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIucGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKTtcbiAgICB9XG4gIH1cbiAgZWF0RXhwb3J0U3Rhcihub2RlKSB7XG4gICAgaWYgKHN1cGVyLmVhdEV4cG9ydFN0YXIobm9kZSkpIHJldHVybiB0cnVlO1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMzApICYmIHRoaXMubG9va2FoZWFkKCkudHlwZSA9PT0gNTUpIHtcbiAgICAgIG5vZGUuZXhwb3J0S2luZCA9IFwidHlwZVwiO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWF5YmVQYXJzZUV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcihub2RlKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRMb2NcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBoYXNOYW1lc3BhY2UgPSBzdXBlci5tYXliZVBhcnNlRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyKG5vZGUpO1xuICAgIGlmIChoYXNOYW1lc3BhY2UgJiYgbm9kZS5leHBvcnRLaW5kID09PSBcInR5cGVcIikge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKHN0YXJ0TG9jKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc05hbWVzcGFjZTtcbiAgfVxuICBwYXJzZUNsYXNzSWQobm9kZSwgaXNTdGF0ZW1lbnQsIG9wdGlvbmFsSWQpIHtcbiAgICBzdXBlci5wYXJzZUNsYXNzSWQobm9kZSwgaXNTdGF0ZW1lbnQsIG9wdGlvbmFsSWQpO1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfVxuICB9XG4gIHBhcnNlQ2xhc3NNZW1iZXIoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRMb2NcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTI1KSkge1xuICAgICAgaWYgKHN1cGVyLnBhcnNlQ2xhc3NNZW1iZXJGcm9tTW9kaWZpZXIoY2xhc3NCb2R5LCBtZW1iZXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1lbWJlci5kZWNsYXJlID0gdHJ1ZTtcbiAgICB9XG4gICAgc3VwZXIucGFyc2VDbGFzc01lbWJlcihjbGFzc0JvZHksIG1lbWJlciwgc3RhdGUpO1xuICAgIGlmIChtZW1iZXIuZGVjbGFyZSkge1xuICAgICAgaWYgKG1lbWJlci50eXBlICE9PSBcIkNsYXNzUHJvcGVydHlcIiAmJiBtZW1iZXIudHlwZSAhPT0gXCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwiICYmIG1lbWJlci50eXBlICE9PSBcIlByb3BlcnR5RGVmaW5pdGlvblwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5EZWNsYXJlQ2xhc3NFbGVtZW50LCBzdGFydExvYyk7XG4gICAgICB9IGVsc2UgaWYgKG1lbWJlci52YWx1ZSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuRGVjbGFyZUNsYXNzRmllbGRJbml0aWFsaXplciwgbWVtYmVyLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaXNJdGVyYXRvcih3b3JkKSB7XG4gICAgcmV0dXJuIHdvcmQgPT09IFwiaXRlcmF0b3JcIiB8fCB3b3JkID09PSBcImFzeW5jSXRlcmF0b3JcIjtcbiAgfVxuICByZWFkSXRlcmF0b3IoKSB7XG4gICAgY29uc3Qgd29yZCA9IHN1cGVyLnJlYWRXb3JkMSgpO1xuICAgIGNvbnN0IGZ1bGxXb3JkID0gXCJAQFwiICsgd29yZDtcbiAgICBpZiAoIXRoaXMuaXNJdGVyYXRvcih3b3JkKSB8fCAhdGhpcy5zdGF0ZS5pblR5cGUpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRJZGVudGlmaWVyLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCksIHtcbiAgICAgICAgaWRlbnRpZmllck5hbWU6IGZ1bGxXb3JkXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5maW5pc2hUb2tlbigxMzIsIGZ1bGxXb3JkKTtcbiAgfVxuICBnZXRUb2tlbkZyb21Db2RlKGNvZGUpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKGNvZGUgPT09IDEyMyAmJiBuZXh0ID09PSAxMjQpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoNiwgMik7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmluVHlwZSAmJiAoY29kZSA9PT0gNjIgfHwgY29kZSA9PT0gNjApKSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDYyID8gNDggOiA0NywgMSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmluVHlwZSAmJiBjb2RlID09PSA2Mykge1xuICAgICAgaWYgKG5leHQgPT09IDQ2KSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AoMTgsIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5maW5pc2hPcCgxNywgMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0l0ZXJhdG9yU3RhcnQoY29kZSwgbmV4dCwgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMikpKSB7XG4gICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgdGhpcy5yZWFkSXRlcmF0b3IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKTtcbiAgICB9XG4gIH1cbiAgaXNBc3NpZ25hYmxlKG5vZGUsIGlzQmluZGluZykge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzQXNzaWduYWJsZShub2RlLmV4cHJlc3Npb24sIGlzQmluZGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdXBlci5pc0Fzc2lnbmFibGUobm9kZSwgaXNCaW5kaW5nKTtcbiAgICB9XG4gIH1cbiAgdG9Bc3NpZ25hYmxlKG5vZGUsIGlzTEhTID0gZmFsc2UpIHtcbiAgICBpZiAoIWlzTEhTICYmIG5vZGUudHlwZSA9PT0gXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiICYmIG5vZGUubGVmdC50eXBlID09PSBcIlR5cGVDYXN0RXhwcmVzc2lvblwiKSB7XG4gICAgICBub2RlLmxlZnQgPSB0aGlzLnR5cGVDYXN0VG9QYXJhbWV0ZXIobm9kZS5sZWZ0KTtcbiAgICB9XG4gICAgc3VwZXIudG9Bc3NpZ25hYmxlKG5vZGUsIGlzTEhTKTtcbiAgfVxuICB0b0Fzc2lnbmFibGVMaXN0KGV4cHJMaXN0LCB0cmFpbGluZ0NvbW1hTG9jLCBpc0xIUykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwckxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGV4cHIgPSBleHByTGlzdFtpXTtcbiAgICAgIGlmICgoZXhwciA9PSBudWxsID8gdm9pZCAwIDogZXhwci50eXBlKSA9PT0gXCJUeXBlQ2FzdEV4cHJlc3Npb25cIikge1xuICAgICAgICBleHByTGlzdFtpXSA9IHRoaXMudHlwZUNhc3RUb1BhcmFtZXRlcihleHByKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIudG9Bc3NpZ25hYmxlTGlzdChleHByTGlzdCwgdHJhaWxpbmdDb21tYUxvYywgaXNMSFMpO1xuICB9XG4gIHRvUmVmZXJlbmNlZExpc3QoZXhwckxpc3QsIGlzUGFyZW50aGVzaXplZEV4cHIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHJMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX2V4cHIkZXh0cmE7XG4gICAgICBjb25zdCBleHByID0gZXhwckxpc3RbaV07XG4gICAgICBpZiAoZXhwciAmJiBleHByLnR5cGUgPT09IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIgJiYgISgoX2V4cHIkZXh0cmEgPSBleHByLmV4dHJhKSAhPSBudWxsICYmIF9leHByJGV4dHJhLnBhcmVudGhlc2l6ZWQpICYmIChleHByTGlzdC5sZW5ndGggPiAxIHx8ICFpc1BhcmVudGhlc2l6ZWRFeHByKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVHlwZUNhc3RJblBhdHRlcm4sIGV4cHIudHlwZUFubm90YXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwckxpc3Q7XG4gIH1cbiAgcGFyc2VBcnJheUxpa2UoY2xvc2UsIGNhbkJlUGF0dGVybiwgaXNUdXBsZSwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5wYXJzZUFycmF5TGlrZShjbG9zZSwgY2FuQmVQYXR0ZXJuLCBpc1R1cGxlLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICBpZiAoY2FuQmVQYXR0ZXJuICYmICF0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMpIHtcbiAgICAgIHRoaXMudG9SZWZlcmVuY2VkTGlzdChub2RlLmVsZW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgaXNWYWxpZExWYWwodHlwZSwgaXNQYXJlbnRoZXNpemVkLCBiaW5kaW5nKSB7XG4gICAgcmV0dXJuIHR5cGUgPT09IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIgfHwgc3VwZXIuaXNWYWxpZExWYWwodHlwZSwgaXNQYXJlbnRoZXNpemVkLCBiaW5kaW5nKTtcbiAgfVxuICBwYXJzZUNsYXNzUHJvcGVydHkobm9kZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQ2xhc3NQcm9wZXJ0eShub2RlKTtcbiAgfVxuICBwYXJzZUNsYXNzUHJpdmF0ZVByb3BlcnR5KG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZUNsYXNzUHJpdmF0ZVByb3BlcnR5KG5vZGUpO1xuICB9XG4gIGlzQ2xhc3NNZXRob2QoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goNDcpIHx8IHN1cGVyLmlzQ2xhc3NNZXRob2QoKTtcbiAgfVxuICBpc0NsYXNzUHJvcGVydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMTQpIHx8IHN1cGVyLmlzQ2xhc3NQcm9wZXJ0eSgpO1xuICB9XG4gIGlzTm9uc3RhdGljQ29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgcmV0dXJuICF0aGlzLm1hdGNoKDE0KSAmJiBzdXBlci5pc05vbnN0YXRpY0NvbnN0cnVjdG9yKG1ldGhvZCk7XG4gIH1cbiAgcHVzaENsYXNzTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNDb25zdHJ1Y3RvciwgYWxsb3dzRGlyZWN0U3VwZXIpIHtcbiAgICBpZiAobWV0aG9kLnZhcmlhbmNlKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQobWV0aG9kLnZhcmlhbmNlLmxvYy5zdGFydCk7XG4gICAgfVxuICAgIGRlbGV0ZSBtZXRob2QudmFyaWFuY2U7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBtZXRob2QudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgIH1cbiAgICBzdXBlci5wdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd3NEaXJlY3RTdXBlcik7XG4gICAgaWYgKG1ldGhvZC5wYXJhbXMgJiYgaXNDb25zdHJ1Y3Rvcikge1xuICAgICAgY29uc3QgcGFyYW1zID0gbWV0aG9kLnBhcmFtcztcbiAgICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMCAmJiB0aGlzLmlzVGhpc1BhcmFtKHBhcmFtc1swXSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlRoaXNQYXJhbUJhbm5lZEluQ29uc3RydWN0b3IsIG1ldGhvZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtZXRob2QudHlwZSA9PT0gXCJNZXRob2REZWZpbml0aW9uXCIgJiYgaXNDb25zdHJ1Y3RvciAmJiBtZXRob2QudmFsdWUucGFyYW1zKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBtZXRob2QudmFsdWUucGFyYW1zO1xuICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwICYmIHRoaXMuaXNUaGlzUGFyYW0ocGFyYW1zWzBdKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVGhpc1BhcmFtQmFubmVkSW5Db25zdHJ1Y3RvciwgbWV0aG9kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcHVzaENsYXNzUHJpdmF0ZU1ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMpIHtcbiAgICBpZiAobWV0aG9kLnZhcmlhbmNlKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQobWV0aG9kLnZhcmlhbmNlLmxvYy5zdGFydCk7XG4gICAgfVxuICAgIGRlbGV0ZSBtZXRob2QudmFyaWFuY2U7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBtZXRob2QudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgIH1cbiAgICBzdXBlci5wdXNoQ2xhc3NQcml2YXRlTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYyk7XG4gIH1cbiAgcGFyc2VDbGFzc1N1cGVyKG5vZGUpIHtcbiAgICBzdXBlci5wYXJzZUNsYXNzU3VwZXIobm9kZSk7XG4gICAgaWYgKG5vZGUuc3VwZXJDbGFzcyAmJiAodGhpcy5tYXRjaCg0NykgfHwgdGhpcy5tYXRjaCg1MSkpKSB7XG4gICAgICB7XG4gICAgICAgIG5vZGUuc3VwZXJUeXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25JbkV4cHJlc3Npb24oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDExMykpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgY29uc3QgaW1wbGVtZW50ZWQgPSBub2RlLmltcGxlbWVudHMgPSBbXTtcbiAgICAgIGRvIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKHRydWUpO1xuICAgICAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGltcGxlbWVudGVkLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ2xhc3NJbXBsZW1lbnRzXCIpKTtcbiAgICAgIH0gd2hpbGUgKHRoaXMuZWF0KDEyKSk7XG4gICAgfVxuICB9XG4gIGNoZWNrR2V0dGVyU2V0dGVyUGFyYW1zKG1ldGhvZCkge1xuICAgIHN1cGVyLmNoZWNrR2V0dGVyU2V0dGVyUGFyYW1zKG1ldGhvZCk7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5nZXRPYmplY3RPckNsYXNzTWV0aG9kUGFyYW1zKG1ldGhvZCk7XG4gICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHBhcmFtc1swXTtcbiAgICAgIGlmICh0aGlzLmlzVGhpc1BhcmFtKHBhcmFtKSAmJiBtZXRob2Qua2luZCA9PT0gXCJnZXRcIikge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuR2V0dGVyTWF5Tm90SGF2ZVRoaXNQYXJhbSwgcGFyYW0pO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzVGhpc1BhcmFtKHBhcmFtKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuU2V0dGVyTWF5Tm90SGF2ZVRoaXNQYXJhbSwgcGFyYW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXJzZVByb3BlcnR5TmFtZVByZWZpeE9wZXJhdG9yKG5vZGUpIHtcbiAgICBub2RlLnZhcmlhbmNlID0gdGhpcy5mbG93UGFyc2VWYXJpYW5jZSgpO1xuICB9XG4gIHBhcnNlT2JqUHJvcFZhbHVlKHByb3AsIHN0YXJ0TG9jLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNQYXR0ZXJuLCBpc0FjY2Vzc29yLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKHByb3AudmFyaWFuY2UpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChwcm9wLnZhcmlhbmNlLmxvYy5zdGFydCk7XG4gICAgfVxuICAgIGRlbGV0ZSBwcm9wLnZhcmlhbmNlO1xuICAgIGxldCB0eXBlUGFyYW1ldGVycztcbiAgICBpZiAodGhpcy5tYXRjaCg0NykgJiYgIWlzQWNjZXNzb3IpIHtcbiAgICAgIHR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICAgIGlmICghdGhpcy5tYXRjaCgxMCkpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBzdXBlci5wYXJzZU9ialByb3BWYWx1ZShwcm9wLCBzdGFydExvYywgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzUGF0dGVybiwgaXNBY2Nlc3NvciwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgaWYgKHR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgICAocmVzdWx0LnZhbHVlIHx8IHJlc3VsdCkudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uUGFyYW1UeXBlKHBhcmFtKSB7XG4gICAgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgaWYgKHBhcmFtLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5QYXR0ZXJuSXNPcHRpb25hbCwgcGFyYW0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNUaGlzUGFyYW0ocGFyYW0pKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5UaGlzUGFyYW1NYXlOb3RCZU9wdGlvbmFsLCBwYXJhbSk7XG4gICAgICB9XG4gICAgICBwYXJhbS5vcHRpb25hbCA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgcGFyYW0udHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzVGhpc1BhcmFtKHBhcmFtKSkge1xuICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlRoaXNQYXJhbUFubm90YXRpb25SZXF1aXJlZCwgcGFyYW0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCgyOSkgJiYgdGhpcy5pc1RoaXNQYXJhbShwYXJhbSkpIHtcbiAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5UaGlzUGFyYW1Ob0RlZmF1bHQsIHBhcmFtKTtcbiAgICB9XG4gICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKHBhcmFtKTtcbiAgICByZXR1cm4gcGFyYW07XG4gIH1cbiAgcGFyc2VNYXliZURlZmF1bHQoc3RhcnRMb2MsIGxlZnQpIHtcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VNYXliZURlZmF1bHQoc3RhcnRMb2MsIGxlZnQpO1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIiAmJiBub2RlLnR5cGVBbm5vdGF0aW9uICYmIG5vZGUucmlnaHQuc3RhcnQgPCBub2RlLnR5cGVBbm5vdGF0aW9uLnN0YXJ0KSB7XG4gICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVHlwZUJlZm9yZUluaXRpYWxpemVyLCBub2RlLnR5cGVBbm5vdGF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgY2hlY2tJbXBvcnRSZWZsZWN0aW9uKG5vZGUpIHtcbiAgICBzdXBlci5jaGVja0ltcG9ydFJlZmxlY3Rpb24obm9kZSk7XG4gICAgaWYgKG5vZGUubW9kdWxlICYmIG5vZGUuaW1wb3J0S2luZCAhPT0gXCJ2YWx1ZVwiKSB7XG4gICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuSW1wb3J0UmVmbGVjdGlvbkhhc0ltcG9ydFR5cGUsIG5vZGUuc3BlY2lmaWVyc1swXS5sb2Muc3RhcnQpO1xuICAgIH1cbiAgfVxuICBwYXJzZUltcG9ydFNwZWNpZmllckxvY2FsKG5vZGUsIHNwZWNpZmllciwgdHlwZSkge1xuICAgIHNwZWNpZmllci5sb2NhbCA9IGhhc1R5cGVJbXBvcnRLaW5kKG5vZGUpID8gdGhpcy5mbG93UGFyc2VSZXN0cmljdGVkSWRlbnRpZmllcih0cnVlLCB0cnVlKSA6IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgbm9kZS5zcGVjaWZpZXJzLnB1c2godGhpcy5maW5pc2hJbXBvcnRTcGVjaWZpZXIoc3BlY2lmaWVyLCB0eXBlKSk7XG4gIH1cbiAgaXNQb3RlbnRpYWxJbXBvcnRQaGFzZShpc0V4cG9ydCkge1xuICAgIGlmIChzdXBlci5pc1BvdGVudGlhbEltcG9ydFBoYXNlKGlzRXhwb3J0KSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEzMCkpIHtcbiAgICAgIGlmICghaXNFeHBvcnQpIHJldHVybiB0cnVlO1xuICAgICAgY29uc3QgY2ggPSB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCk7XG4gICAgICByZXR1cm4gY2ggPT09IDEyMyB8fCBjaCA9PT0gNDI7XG4gICAgfVxuICAgIHJldHVybiAhaXNFeHBvcnQgJiYgdGhpcy5pc0NvbnRleHR1YWwoODcpO1xuICB9XG4gIGFwcGx5SW1wb3J0UGhhc2Uobm9kZSwgaXNFeHBvcnQsIHBoYXNlLCBsb2MpIHtcbiAgICBzdXBlci5hcHBseUltcG9ydFBoYXNlKG5vZGUsIGlzRXhwb3J0LCBwaGFzZSwgbG9jKTtcbiAgICBpZiAoaXNFeHBvcnQpIHtcbiAgICAgIGlmICghcGhhc2UgJiYgdGhpcy5tYXRjaCg2NSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9kZS5leHBvcnRLaW5kID0gcGhhc2UgPT09IFwidHlwZVwiID8gcGhhc2UgOiBcInZhbHVlXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwaGFzZSA9PT0gXCJ0eXBlXCIgJiYgdGhpcy5tYXRjaCg1NSkpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgbm9kZS5pbXBvcnRLaW5kID0gcGhhc2UgPT09IFwidHlwZVwiIHx8IHBoYXNlID09PSBcInR5cGVvZlwiID8gcGhhc2UgOiBcInZhbHVlXCI7XG4gICAgfVxuICB9XG4gIHBhcnNlSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgaW1wb3J0ZWRJc1N0cmluZywgaXNJblR5cGVPbmx5SW1wb3J0LCBpc01heWJlVHlwZU9ubHksIGJpbmRpbmdUeXBlKSB7XG4gICAgY29uc3QgZmlyc3RJZGVudCA9IHNwZWNpZmllci5pbXBvcnRlZDtcbiAgICBsZXQgc3BlY2lmaWVyVHlwZUtpbmQgPSBudWxsO1xuICAgIGlmIChmaXJzdElkZW50LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICBpZiAoZmlyc3RJZGVudC5uYW1lID09PSBcInR5cGVcIikge1xuICAgICAgICBzcGVjaWZpZXJUeXBlS2luZCA9IFwidHlwZVwiO1xuICAgICAgfSBlbHNlIGlmIChmaXJzdElkZW50Lm5hbWUgPT09IFwidHlwZW9mXCIpIHtcbiAgICAgICAgc3BlY2lmaWVyVHlwZUtpbmQgPSBcInR5cGVvZlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgaXNCaW5kaW5nID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDkzKSAmJiAhdGhpcy5pc0xvb2thaGVhZENvbnRleHR1YWwoXCJhc1wiKSkge1xuICAgICAgY29uc3QgYXNfaWRlbnQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgIGlmIChzcGVjaWZpZXJUeXBlS2luZCAhPT0gbnVsbCAmJiAhdG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICBzcGVjaWZpZXIuaW1wb3J0ZWQgPSBhc19pZGVudDtcbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydEtpbmQgPSBzcGVjaWZpZXJUeXBlS2luZDtcbiAgICAgICAgc3BlY2lmaWVyLmxvY2FsID0gY2xvbmVJZGVudGlmaWVyKGFzX2lkZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwZWNpZmllci5pbXBvcnRlZCA9IGZpcnN0SWRlbnQ7XG4gICAgICAgIHNwZWNpZmllci5pbXBvcnRLaW5kID0gbnVsbDtcbiAgICAgICAgc3BlY2lmaWVyLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNwZWNpZmllclR5cGVLaW5kICE9PSBudWxsICYmIHRva2VuSXNLZXl3b3JkT3JJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydGVkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgICAgIHNwZWNpZmllci5pbXBvcnRLaW5kID0gc3BlY2lmaWVyVHlwZUtpbmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW1wb3J0ZWRJc1N0cmluZykge1xuICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydEJpbmRpbmdJc1N0cmluZywgc3BlY2lmaWVyLCB7XG4gICAgICAgICAgICBpbXBvcnROYW1lOiBmaXJzdElkZW50LnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydGVkID0gZmlyc3RJZGVudDtcbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydEtpbmQgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbCg5MykpIHtcbiAgICAgICAgc3BlY2lmaWVyLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzQmluZGluZyA9IHRydWU7XG4gICAgICAgIHNwZWNpZmllci5sb2NhbCA9IGNsb25lSWRlbnRpZmllcihzcGVjaWZpZXIuaW1wb3J0ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzcGVjaWZpZXJJc1R5cGVJbXBvcnQgPSBoYXNUeXBlSW1wb3J0S2luZChzcGVjaWZpZXIpO1xuICAgIGlmIChpc0luVHlwZU9ubHlJbXBvcnQgJiYgc3BlY2lmaWVySXNUeXBlSW1wb3J0KSB7XG4gICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuSW1wb3J0VHlwZVNob3J0aGFuZE9ubHlJblB1cmVJbXBvcnQsIHNwZWNpZmllcik7XG4gICAgfVxuICAgIGlmIChpc0luVHlwZU9ubHlJbXBvcnQgfHwgc3BlY2lmaWVySXNUeXBlSW1wb3J0KSB7XG4gICAgICB0aGlzLmNoZWNrUmVzZXJ2ZWRUeXBlKHNwZWNpZmllci5sb2NhbC5uYW1lLCBzcGVjaWZpZXIubG9jYWwubG9jLnN0YXJ0LCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGlzQmluZGluZyAmJiAhaXNJblR5cGVPbmx5SW1wb3J0ICYmICFzcGVjaWZpZXJJc1R5cGVJbXBvcnQpIHtcbiAgICAgIHRoaXMuY2hlY2tSZXNlcnZlZFdvcmQoc3BlY2lmaWVyLmxvY2FsLm5hbWUsIHNwZWNpZmllci5sb2Muc3RhcnQsIHRydWUsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hJbXBvcnRTcGVjaWZpZXIoc3BlY2lmaWVyLCBcIkltcG9ydFNwZWNpZmllclwiKTtcbiAgfVxuICBwYXJzZUJpbmRpbmdBdG9tKCkge1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIDc4OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3VwZXIucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgIH1cbiAgfVxuICBwYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUsIGlzQ29uc3RydWN0b3IpIHtcbiAgICBjb25zdCBraW5kID0gbm9kZS5raW5kO1xuICAgIGlmIChraW5kICE9PSBcImdldFwiICYmIGtpbmQgIT09IFwic2V0XCIgJiYgdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgIH1cbiAgICBzdXBlci5wYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUsIGlzQ29uc3RydWN0b3IpO1xuICB9XG4gIHBhcnNlVmFySWQoZGVjbCwga2luZCkge1xuICAgIHN1cGVyLnBhcnNlVmFySWQoZGVjbCwga2luZCk7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBkZWNsLmlkLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKGRlY2wuaWQpO1xuICAgIH1cbiAgfVxuICBwYXJzZUFzeW5jQXJyb3dGcm9tQ2FsbEV4cHJlc3Npb24obm9kZSwgY2FsbCkge1xuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgY29uc3Qgb2xkTm9Bbm9uRnVuY3Rpb25UeXBlID0gdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGU7XG4gICAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IHRydWU7XG4gICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IG9sZE5vQW5vbkZ1bmN0aW9uVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQXN5bmNBcnJvd0Zyb21DYWxsRXhwcmVzc2lvbihub2RlLCBjYWxsKTtcbiAgfVxuICBzaG91bGRQYXJzZUFzeW5jQXJyb3coKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMTQpIHx8IHN1cGVyLnNob3VsZFBhcnNlQXN5bmNBcnJvdygpO1xuICB9XG4gIHBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpIHtcbiAgICB2YXIgX2pzeDtcbiAgICBsZXQgc3RhdGUgPSBudWxsO1xuICAgIGxldCBqc3g7XG4gICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwianN4XCIpICYmICh0aGlzLm1hdGNoKDE0MykgfHwgdGhpcy5tYXRjaCg0NykpKSB7XG4gICAgICBzdGF0ZSA9IHRoaXMuc3RhdGUuY2xvbmUoKTtcbiAgICAgIGpzeCA9IHRoaXMudHJ5UGFyc2UoKCkgPT4gc3VwZXIucGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSksIHN0YXRlKTtcbiAgICAgIGlmICghanN4LmVycm9yKSByZXR1cm4ganN4Lm5vZGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgY3VycmVudENvbnRleHQgPSBjb250ZXh0W2NvbnRleHQubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoY3VycmVudENvbnRleHQgPT09IHR5cGVzLmpfb1RhZyB8fCBjdXJyZW50Q29udGV4dCA9PT0gdHlwZXMual9leHByKSB7XG4gICAgICAgIGNvbnRleHQucG9wKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgoX2pzeCA9IGpzeCkgIT0gbnVsbCAmJiBfanN4LmVycm9yIHx8IHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICB2YXIgX2pzeDIsIF9qc3gzO1xuICAgICAgc3RhdGUgPSBzdGF0ZSB8fCB0aGlzLnN0YXRlLmNsb25lKCk7XG4gICAgICBsZXQgdHlwZVBhcmFtZXRlcnM7XG4gICAgICBjb25zdCBhcnJvdyA9IHRoaXMudHJ5UGFyc2UoYWJvcnQgPT4ge1xuICAgICAgICB2YXIgX2Fycm93RXhwcmVzc2lvbiRleHRyO1xuICAgICAgICB0eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgICAgIGNvbnN0IGFycm93RXhwcmVzc2lvbiA9IHRoaXMuZm9yd2FyZE5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQodHlwZVBhcmFtZXRlcnMsICgpID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5wYXJzZU1heWJlQXNzaWduKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKTtcbiAgICAgICAgICB0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbkZyb21Ob2RlKHJlc3VsdCwgdHlwZVBhcmFtZXRlcnMpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoKF9hcnJvd0V4cHJlc3Npb24kZXh0ciA9IGFycm93RXhwcmVzc2lvbi5leHRyYSkgIT0gbnVsbCAmJiBfYXJyb3dFeHByZXNzaW9uJGV4dHIucGFyZW50aGVzaXplZCkgYWJvcnQoKTtcbiAgICAgICAgY29uc3QgZXhwciA9IHRoaXMubWF5YmVVbndyYXBUeXBlQ2FzdEV4cHJlc3Npb24oYXJyb3dFeHByZXNzaW9uKTtcbiAgICAgICAgaWYgKGV4cHIudHlwZSAhPT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKSBhYm9ydCgpO1xuICAgICAgICBleHByLnR5cGVQYXJhbWV0ZXJzID0gdHlwZVBhcmFtZXRlcnM7XG4gICAgICAgIHRoaXMucmVzZXRTdGFydExvY2F0aW9uRnJvbU5vZGUoZXhwciwgdHlwZVBhcmFtZXRlcnMpO1xuICAgICAgICByZXR1cm4gYXJyb3dFeHByZXNzaW9uO1xuICAgICAgfSwgc3RhdGUpO1xuICAgICAgbGV0IGFycm93RXhwcmVzc2lvbiA9IG51bGw7XG4gICAgICBpZiAoYXJyb3cubm9kZSAmJiB0aGlzLm1heWJlVW53cmFwVHlwZUNhc3RFeHByZXNzaW9uKGFycm93Lm5vZGUpLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIikge1xuICAgICAgICBpZiAoIWFycm93LmVycm9yICYmICFhcnJvdy5hYm9ydGVkKSB7XG4gICAgICAgICAgaWYgKGFycm93Lm5vZGUuYXN5bmMpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5VbmV4cGVjdGVkVHlwZVBhcmFtZXRlckJlZm9yZUFzeW5jQXJyb3dGdW5jdGlvbiwgdHlwZVBhcmFtZXRlcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXJyb3cubm9kZTtcbiAgICAgICAgfVxuICAgICAgICBhcnJvd0V4cHJlc3Npb24gPSBhcnJvdy5ub2RlO1xuICAgICAgfVxuICAgICAgaWYgKChfanN4MiA9IGpzeCkgIT0gbnVsbCAmJiBfanN4Mi5ub2RlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBqc3guZmFpbFN0YXRlO1xuICAgICAgICByZXR1cm4ganN4Lm5vZGU7XG4gICAgICB9XG4gICAgICBpZiAoYXJyb3dFeHByZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBhcnJvdy5mYWlsU3RhdGU7XG4gICAgICAgIHJldHVybiBhcnJvd0V4cHJlc3Npb247XG4gICAgICB9XG4gICAgICBpZiAoKF9qc3gzID0ganN4KSAhPSBudWxsICYmIF9qc3gzLnRocm93bikgdGhyb3cganN4LmVycm9yO1xuICAgICAgaWYgKGFycm93LnRocm93bikgdGhyb3cgYXJyb3cuZXJyb3I7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVW5leHBlY3RlZFRva2VuQWZ0ZXJUeXBlUGFyYW1ldGVyLCB0eXBlUGFyYW1ldGVycyk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZU1heWJlQXNzaWduKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKTtcbiAgfVxuICBwYXJzZUFycm93KG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudHJ5UGFyc2UoKCkgPT4ge1xuICAgICAgICBjb25zdCBvbGROb0Fub25GdW5jdGlvblR5cGUgPSB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZTtcbiAgICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSB0cnVlO1xuICAgICAgICBjb25zdCB0eXBlTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIFt0eXBlTm9kZS50eXBlQW5ub3RhdGlvbiwgbm9kZS5wcmVkaWNhdGVdID0gdGhpcy5mbG93UGFyc2VUeXBlQW5kUHJlZGljYXRlSW5pdGlhbGlzZXIoKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSBvbGROb0Fub25GdW5jdGlvblR5cGU7XG4gICAgICAgIGlmICh0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgaWYgKCF0aGlzLm1hdGNoKDE5KSkgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgIHJldHVybiB0eXBlTm9kZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlc3VsdC50aHJvd24pIHJldHVybiBudWxsO1xuICAgICAgaWYgKHJlc3VsdC5lcnJvcikgdGhpcy5zdGF0ZSA9IHJlc3VsdC5mYWlsU3RhdGU7XG4gICAgICBub2RlLnJldHVyblR5cGUgPSByZXN1bHQubm9kZS50eXBlQW5ub3RhdGlvbiA/IHRoaXMuZmluaXNoTm9kZShyZXN1bHQubm9kZSwgXCJUeXBlQW5ub3RhdGlvblwiKSA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZUFycm93KG5vZGUpO1xuICB9XG4gIHNob3VsZFBhcnNlQXJyb3cocGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMTQpIHx8IHN1cGVyLnNob3VsZFBhcnNlQXJyb3cocGFyYW1zKTtcbiAgfVxuICBzZXRBcnJvd0Z1bmN0aW9uUGFyYW1ldGVycyhub2RlLCBwYXJhbXMpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0LmluY2x1ZGVzKHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3Mobm9kZS5zdGFydCkpKSB7XG4gICAgICBub2RlLnBhcmFtcyA9IHBhcmFtcztcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuc2V0QXJyb3dGdW5jdGlvblBhcmFtZXRlcnMobm9kZSwgcGFyYW1zKTtcbiAgICB9XG4gIH1cbiAgY2hlY2tQYXJhbXMobm9kZSwgYWxsb3dEdXBsaWNhdGVzLCBpc0Fycm93RnVuY3Rpb24sIHN0cmljdE1vZGVDaGFuZ2VkID0gdHJ1ZSkge1xuICAgIGlmIChpc0Fycm93RnVuY3Rpb24gJiYgdGhpcy5zdGF0ZS5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0LmluY2x1ZGVzKHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3Mobm9kZS5zdGFydCkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmlzVGhpc1BhcmFtKG5vZGUucGFyYW1zW2ldKSAmJiBpID4gMCkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVGhpc1BhcmFtTXVzdEJlRmlyc3QsIG5vZGUucGFyYW1zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIuY2hlY2tQYXJhbXMobm9kZSwgYWxsb3dEdXBsaWNhdGVzLCBpc0Fycm93RnVuY3Rpb24sIHN0cmljdE1vZGVDaGFuZ2VkKTtcbiAgfVxuICBwYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uKGNhbkJlQXJyb3cpIHtcbiAgICByZXR1cm4gc3VwZXIucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93ICYmICF0aGlzLnN0YXRlLm5vQXJyb3dBdC5pbmNsdWRlcyh0aGlzLnNvdXJjZVRvT2Zmc2V0UG9zKHRoaXMuc3RhdGUuc3RhcnQpKSk7XG4gIH1cbiAgcGFyc2VTdWJzY3JpcHRzKGJhc2UsIHN0YXJ0TG9jLCBub0NhbGxzKSB7XG4gICAgaWYgKGJhc2UudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgYmFzZS5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcy5zdGF0ZS5ub0Fycm93QXQuaW5jbHVkZXMoc3RhcnRMb2MuaW5kZXgpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUuY2FsbGVlID0gYmFzZTtcbiAgICAgIG5vZGUuYXJndW1lbnRzID0gc3VwZXIucGFyc2VDYWxsRXhwcmVzc2lvbkFyZ3VtZW50cygxMSk7XG4gICAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ2FsbEV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIGlmIChiYXNlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGJhc2UubmFtZSA9PT0gXCJhc3luY1wiICYmIHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUuY2xvbmUoKTtcbiAgICAgIGNvbnN0IGFycm93ID0gdGhpcy50cnlQYXJzZShhYm9ydCA9PiB0aGlzLnBhcnNlQXN5bmNBcnJvd1dpdGhUeXBlUGFyYW1ldGVycyhzdGFydExvYykgfHwgYWJvcnQoKSwgc3RhdGUpO1xuICAgICAgaWYgKCFhcnJvdy5lcnJvciAmJiAhYXJyb3cuYWJvcnRlZCkgcmV0dXJuIGFycm93Lm5vZGU7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRyeVBhcnNlKCgpID0+IHN1cGVyLnBhcnNlU3Vic2NyaXB0cyhiYXNlLCBzdGFydExvYywgbm9DYWxscyksIHN0YXRlKTtcbiAgICAgIGlmIChyZXN1bHQubm9kZSAmJiAhcmVzdWx0LmVycm9yKSByZXR1cm4gcmVzdWx0Lm5vZGU7XG4gICAgICBpZiAoYXJyb3cubm9kZSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gYXJyb3cuZmFpbFN0YXRlO1xuICAgICAgICByZXR1cm4gYXJyb3cubm9kZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQubm9kZSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gcmVzdWx0LmZhaWxTdGF0ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5ub2RlO1xuICAgICAgfVxuICAgICAgdGhyb3cgYXJyb3cuZXJyb3IgfHwgcmVzdWx0LmVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VTdWJzY3JpcHRzKGJhc2UsIHN0YXJ0TG9jLCBub0NhbGxzKTtcbiAgfVxuICBwYXJzZVN1YnNjcmlwdChiYXNlLCBzdGFydExvYywgbm9DYWxscywgc3Vic2NyaXB0U3RhdGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxOCkgJiYgdGhpcy5pc0xvb2thaGVhZFRva2VuX2x0KCkpIHtcbiAgICAgIHN1YnNjcmlwdFN0YXRlLm9wdGlvbmFsQ2hhaW5NZW1iZXIgPSB0cnVlO1xuICAgICAgaWYgKG5vQ2FsbHMpIHtcbiAgICAgICAgc3Vic2NyaXB0U3RhdGUuc3RvcCA9IHRydWU7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgfVxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBub2RlLmNhbGxlZSA9IGJhc2U7XG4gICAgICBub2RlLnR5cGVBcmd1bWVudHMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uSW5FeHByZXNzaW9uKCk7XG4gICAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgICBub2RlLmFyZ3VtZW50cyA9IHRoaXMucGFyc2VDYWxsRXhwcmVzc2lvbkFyZ3VtZW50cygxMSk7XG4gICAgICBub2RlLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaENhbGxFeHByZXNzaW9uKG5vZGUsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoIW5vQ2FsbHMgJiYgdGhpcy5zaG91bGRQYXJzZVR5cGVzKCkgJiYgKHRoaXMubWF0Y2goNDcpIHx8IHRoaXMubWF0Y2goNTEpKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgbm9kZS5jYWxsZWUgPSBiYXNlO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy50cnlQYXJzZSgoKSA9PiB7XG4gICAgICAgIG5vZGUudHlwZUFyZ3VtZW50cyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25DYWxsT3JOZXcoKTtcbiAgICAgICAgdGhpcy5leHBlY3QoMTApO1xuICAgICAgICBub2RlLmFyZ3VtZW50cyA9IHN1cGVyLnBhcnNlQ2FsbEV4cHJlc3Npb25Bcmd1bWVudHMoMTEpO1xuICAgICAgICBpZiAoc3Vic2NyaXB0U3RhdGUub3B0aW9uYWxDaGFpbk1lbWJlcikge1xuICAgICAgICAgIG5vZGUub3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hDYWxsRXhwcmVzc2lvbihub2RlLCBzdWJzY3JpcHRTdGF0ZS5vcHRpb25hbENoYWluTWVtYmVyKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlc3VsdC5ub2RlKSB7XG4gICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHRoaXMuc3RhdGUgPSByZXN1bHQuZmFpbFN0YXRlO1xuICAgICAgICByZXR1cm4gcmVzdWx0Lm5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZVN1YnNjcmlwdChiYXNlLCBzdGFydExvYywgbm9DYWxscywgc3Vic2NyaXB0U3RhdGUpO1xuICB9XG4gIHBhcnNlTmV3Q2FsbGVlKG5vZGUpIHtcbiAgICBzdXBlci5wYXJzZU5ld0NhbGxlZShub2RlKTtcbiAgICBsZXQgdGFyZ3MgPSBudWxsO1xuICAgIGlmICh0aGlzLnNob3VsZFBhcnNlVHlwZXMoKSAmJiB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgdGFyZ3MgPSB0aGlzLnRyeVBhcnNlKCgpID0+IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25DYWxsT3JOZXcoKSkubm9kZTtcbiAgICB9XG4gICAgbm9kZS50eXBlQXJndW1lbnRzID0gdGFyZ3M7XG4gIH1cbiAgcGFyc2VBc3luY0Fycm93V2l0aFR5cGVQYXJhbWV0ZXJzKHN0YXJ0TG9jKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgIHRoaXMucGFyc2VGdW5jdGlvblBhcmFtcyhub2RlLCBmYWxzZSk7XG4gICAgaWYgKCF0aGlzLnBhcnNlQXJyb3cobm9kZSkpIHJldHVybjtcbiAgICByZXR1cm4gc3VwZXIucGFyc2VBcnJvd0V4cHJlc3Npb24obm9kZSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgfVxuICByZWFkVG9rZW5fbXVsdF9tb2R1bG8oY29kZSkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAoY29kZSA9PT0gNDIgJiYgbmV4dCA9PT0gNDcgJiYgdGhpcy5zdGF0ZS5oYXNGbG93Q29tbWVudCkge1xuICAgICAgdGhpcy5zdGF0ZS5oYXNGbG93Q29tbWVudCA9IGZhbHNlO1xuICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gMjtcbiAgICAgIHRoaXMubmV4dFRva2VuKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnJlYWRUb2tlbl9tdWx0X21vZHVsbyhjb2RlKTtcbiAgfVxuICByZWFkVG9rZW5fcGlwZV9hbXAoY29kZSkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAoY29kZSA9PT0gMTI0ICYmIG5leHQgPT09IDEyNSkge1xuICAgICAgdGhpcy5maW5pc2hPcCg5LCAyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucmVhZFRva2VuX3BpcGVfYW1wKGNvZGUpO1xuICB9XG4gIHBhcnNlVG9wTGV2ZWwoZmlsZSwgcHJvZ3JhbSkge1xuICAgIGNvbnN0IGZpbGVOb2RlID0gc3VwZXIucGFyc2VUb3BMZXZlbChmaWxlLCBwcm9ncmFtKTtcbiAgICBpZiAodGhpcy5zdGF0ZS5oYXNGbG93Q29tbWVudCkge1xuICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlVudGVybWluYXRlZEZsb3dDb21tZW50LCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgIH1cbiAgICByZXR1cm4gZmlsZU5vZGU7XG4gIH1cbiAgc2tpcEJsb2NrQ29tbWVudCgpIHtcbiAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJmbG93Q29tbWVudHNcIikgJiYgdGhpcy5za2lwRmxvd0NvbW1lbnQoKSkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUuaGFzRmxvd0NvbW1lbnQpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShGbG93RXJyb3JzLk5lc3RlZEZsb3dDb21tZW50LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGFzRmxvd0NvbW1lbnRDb21wbGV0aW9uKCk7XG4gICAgICBjb25zdCBjb21tZW50U2tpcCA9IHRoaXMuc2tpcEZsb3dDb21tZW50KCk7XG4gICAgICBpZiAoY29tbWVudFNraXApIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gY29tbWVudFNraXA7XG4gICAgICAgIHRoaXMuc3RhdGUuaGFzRmxvd0NvbW1lbnQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuc2tpcEJsb2NrQ29tbWVudCh0aGlzLnN0YXRlLmhhc0Zsb3dDb21tZW50ID8gXCIqLS9cIiA6IFwiKi9cIik7XG4gIH1cbiAgc2tpcEZsb3dDb21tZW50KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBvc1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCBzaGlmdFRvRmlyc3ROb25XaGl0ZVNwYWNlID0gMjtcbiAgICB3aGlsZSAoWzMyLCA5XS5pbmNsdWRlcyh0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zICsgc2hpZnRUb0ZpcnN0Tm9uV2hpdGVTcGFjZSkpKSB7XG4gICAgICBzaGlmdFRvRmlyc3ROb25XaGl0ZVNwYWNlKys7XG4gICAgfVxuICAgIGNvbnN0IGNoMiA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChzaGlmdFRvRmlyc3ROb25XaGl0ZVNwYWNlICsgcG9zKTtcbiAgICBjb25zdCBjaDMgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoc2hpZnRUb0ZpcnN0Tm9uV2hpdGVTcGFjZSArIHBvcyArIDEpO1xuICAgIGlmIChjaDIgPT09IDU4ICYmIGNoMyA9PT0gNTgpIHtcbiAgICAgIHJldHVybiBzaGlmdFRvRmlyc3ROb25XaGl0ZVNwYWNlICsgMjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5wdXQuc2xpY2Uoc2hpZnRUb0ZpcnN0Tm9uV2hpdGVTcGFjZSArIHBvcywgc2hpZnRUb0ZpcnN0Tm9uV2hpdGVTcGFjZSArIHBvcyArIDEyKSA9PT0gXCJmbG93LWluY2x1ZGVcIikge1xuICAgICAgcmV0dXJuIHNoaWZ0VG9GaXJzdE5vbldoaXRlU3BhY2UgKyAxMjtcbiAgICB9XG4gICAgaWYgKGNoMiA9PT0gNTggJiYgY2gzICE9PSA1OCkge1xuICAgICAgcmV0dXJuIHNoaWZ0VG9GaXJzdE5vbldoaXRlU3BhY2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBoYXNGbG93Q29tbWVudENvbXBsZXRpb24oKSB7XG4gICAgY29uc3QgZW5kID0gdGhpcy5pbnB1dC5pbmRleE9mKFwiKi9cIiwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbnRlcm1pbmF0ZWRDb21tZW50LCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgIH1cbiAgfVxuICBmbG93RW51bUVycm9yQm9vbGVhbk1lbWJlck5vdEluaXRpYWxpemVkKGxvYywge1xuICAgIGVudW1OYW1lLFxuICAgIG1lbWJlck5hbWVcbiAgfSkge1xuICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5FbnVtQm9vbGVhbk1lbWJlck5vdEluaXRpYWxpemVkLCBsb2MsIHtcbiAgICAgIG1lbWJlck5hbWUsXG4gICAgICBlbnVtTmFtZVxuICAgIH0pO1xuICB9XG4gIGZsb3dFbnVtRXJyb3JJbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXIobG9jLCBlbnVtQ29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLnJhaXNlKCFlbnVtQ29udGV4dC5leHBsaWNpdFR5cGUgPyBGbG93RXJyb3JzLkVudW1JbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXJVbmtub3duVHlwZSA6IGVudW1Db250ZXh0LmV4cGxpY2l0VHlwZSA9PT0gXCJzeW1ib2xcIiA/IEZsb3dFcnJvcnMuRW51bUludmFsaWRNZW1iZXJJbml0aWFsaXplclN5bWJvbFR5cGUgOiBGbG93RXJyb3JzLkVudW1JbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXJQcmltYXJ5VHlwZSwgbG9jLCBlbnVtQ29udGV4dCk7XG4gIH1cbiAgZmxvd0VudW1FcnJvck51bWJlck1lbWJlck5vdEluaXRpYWxpemVkKGxvYywgZGV0YWlscykge1xuICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5FbnVtTnVtYmVyTWVtYmVyTm90SW5pdGlhbGl6ZWQsIGxvYywgZGV0YWlscyk7XG4gIH1cbiAgZmxvd0VudW1FcnJvclN0cmluZ01lbWJlckluY29uc2lzdGVudGx5SW5pdGlhbGl6ZWQobm9kZSwgZGV0YWlscykge1xuICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5FbnVtU3RyaW5nTWVtYmVySW5jb25zaXN0ZW50bHlJbml0aWFsaXplZCwgbm9kZSwgZGV0YWlscyk7XG4gIH1cbiAgZmxvd0VudW1NZW1iZXJJbml0KCkge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBlbmRPZkluaXQgPSAoKSA9PiB0aGlzLm1hdGNoKDEyKSB8fCB0aGlzLm1hdGNoKDgpO1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIDEzNTpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGxpdGVyYWwgPSB0aGlzLnBhcnNlTnVtZXJpY0xpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSk7XG4gICAgICAgICAgaWYgKGVuZE9mSW5pdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICBsb2M6IGxpdGVyYWwubG9jLnN0YXJ0LFxuICAgICAgICAgICAgICB2YWx1ZTogbGl0ZXJhbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW52YWxpZFwiLFxuICAgICAgICAgICAgbG9jOiBzdGFydExvY1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMTM0OlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbGl0ZXJhbCA9IHRoaXMucGFyc2VTdHJpbmdMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgICAgIGlmIChlbmRPZkluaXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgbG9jOiBsaXRlcmFsLmxvYy5zdGFydCxcbiAgICAgICAgICAgICAgdmFsdWU6IGxpdGVyYWxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImludmFsaWRcIixcbiAgICAgICAgICAgIGxvYzogc3RhcnRMb2NcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICBjYXNlIDg1OlxuICAgICAgY2FzZSA4NjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGxpdGVyYWwgPSB0aGlzLnBhcnNlQm9vbGVhbkxpdGVyYWwodGhpcy5tYXRjaCg4NSkpO1xuICAgICAgICAgIGlmIChlbmRPZkluaXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIGxvYzogbGl0ZXJhbC5sb2Muc3RhcnQsXG4gICAgICAgICAgICAgIHZhbHVlOiBsaXRlcmFsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkXCIsXG4gICAgICAgICAgICBsb2M6IHN0YXJ0TG9jXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImludmFsaWRcIixcbiAgICAgICAgICBsb2M6IHN0YXJ0TG9jXG4gICAgICAgIH07XG4gICAgfVxuICB9XG4gIGZsb3dFbnVtTWVtYmVyUmF3KCkge1xuICAgIGNvbnN0IGxvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICBjb25zdCBpbml0ID0gdGhpcy5lYXQoMjkpID8gdGhpcy5mbG93RW51bU1lbWJlckluaXQoKSA6IHtcbiAgICAgIHR5cGU6IFwibm9uZVwiLFxuICAgICAgbG9jXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQsXG4gICAgICBpbml0XG4gICAgfTtcbiAgfVxuICBmbG93RW51bUNoZWNrRXhwbGljaXRUeXBlTWlzbWF0Y2gobG9jLCBjb250ZXh0LCBleHBlY3RlZFR5cGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBleHBsaWNpdFR5cGVcbiAgICB9ID0gY29udGV4dDtcbiAgICBpZiAoZXhwbGljaXRUeXBlID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChleHBsaWNpdFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgdGhpcy5mbG93RW51bUVycm9ySW52YWxpZE1lbWJlckluaXRpYWxpemVyKGxvYywgY29udGV4dCk7XG4gICAgfVxuICB9XG4gIGZsb3dFbnVtTWVtYmVycyh7XG4gICAgZW51bU5hbWUsXG4gICAgZXhwbGljaXRUeXBlXG4gIH0pIHtcbiAgICBjb25zdCBzZWVuTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgbWVtYmVycyA9IHtcbiAgICAgIGJvb2xlYW5NZW1iZXJzOiBbXSxcbiAgICAgIG51bWJlck1lbWJlcnM6IFtdLFxuICAgICAgc3RyaW5nTWVtYmVyczogW10sXG4gICAgICBkZWZhdWx0ZWRNZW1iZXJzOiBbXVxuICAgIH07XG4gICAgbGV0IGhhc1Vua25vd25NZW1iZXJzID0gZmFsc2U7XG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKDgpKSB7XG4gICAgICBpZiAodGhpcy5lYXQoMjEpKSB7XG4gICAgICAgIGhhc1Vua25vd25NZW1iZXJzID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBtZW1iZXJOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaWQsXG4gICAgICAgIGluaXRcbiAgICAgIH0gPSB0aGlzLmZsb3dFbnVtTWVtYmVyUmF3KCk7XG4gICAgICBjb25zdCBtZW1iZXJOYW1lID0gaWQubmFtZTtcbiAgICAgIGlmIChtZW1iZXJOYW1lID09PSBcIlwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKC9eW2Etel0vLnRlc3QobWVtYmVyTmFtZSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkVudW1JbnZhbGlkTWVtYmVyTmFtZSwgaWQsIHtcbiAgICAgICAgICBtZW1iZXJOYW1lLFxuICAgICAgICAgIHN1Z2dlc3Rpb246IG1lbWJlck5hbWVbMF0udG9VcHBlckNhc2UoKSArIG1lbWJlck5hbWUuc2xpY2UoMSksXG4gICAgICAgICAgZW51bU5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoc2Vlbk5hbWVzLmhhcyhtZW1iZXJOYW1lKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuRW51bUR1cGxpY2F0ZU1lbWJlck5hbWUsIGlkLCB7XG4gICAgICAgICAgbWVtYmVyTmFtZSxcbiAgICAgICAgICBlbnVtTmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHNlZW5OYW1lcy5hZGQobWVtYmVyTmFtZSk7XG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBlbnVtTmFtZSxcbiAgICAgICAgZXhwbGljaXRUeXBlLFxuICAgICAgICBtZW1iZXJOYW1lXG4gICAgICB9O1xuICAgICAgbWVtYmVyTm9kZS5pZCA9IGlkO1xuICAgICAgc3dpdGNoIChpbml0LnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmZsb3dFbnVtQ2hlY2tFeHBsaWNpdFR5cGVNaXNtYXRjaChpbml0LmxvYywgY29udGV4dCwgXCJib29sZWFuXCIpO1xuICAgICAgICAgICAgbWVtYmVyTm9kZS5pbml0ID0gaW5pdC52YWx1ZTtcbiAgICAgICAgICAgIG1lbWJlcnMuYm9vbGVhbk1lbWJlcnMucHVzaCh0aGlzLmZpbmlzaE5vZGUobWVtYmVyTm9kZSwgXCJFbnVtQm9vbGVhbk1lbWJlclwiKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmZsb3dFbnVtQ2hlY2tFeHBsaWNpdFR5cGVNaXNtYXRjaChpbml0LmxvYywgY29udGV4dCwgXCJudW1iZXJcIik7XG4gICAgICAgICAgICBtZW1iZXJOb2RlLmluaXQgPSBpbml0LnZhbHVlO1xuICAgICAgICAgICAgbWVtYmVycy5udW1iZXJNZW1iZXJzLnB1c2godGhpcy5maW5pc2hOb2RlKG1lbWJlck5vZGUsIFwiRW51bU51bWJlck1lbWJlclwiKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmZsb3dFbnVtQ2hlY2tFeHBsaWNpdFR5cGVNaXNtYXRjaChpbml0LmxvYywgY29udGV4dCwgXCJzdHJpbmdcIik7XG4gICAgICAgICAgICBtZW1iZXJOb2RlLmluaXQgPSBpbml0LnZhbHVlO1xuICAgICAgICAgICAgbWVtYmVycy5zdHJpbmdNZW1iZXJzLnB1c2godGhpcy5maW5pc2hOb2RlKG1lbWJlck5vZGUsIFwiRW51bVN0cmluZ01lbWJlclwiKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJpbnZhbGlkXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5mbG93RW51bUVycm9ySW52YWxpZE1lbWJlckluaXRpYWxpemVyKGluaXQubG9jLCBjb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJub25lXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgc3dpdGNoIChleHBsaWNpdFR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dFbnVtRXJyb3JCb29sZWFuTWVtYmVyTm90SW5pdGlhbGl6ZWQoaW5pdC5sb2MsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93RW51bUVycm9yTnVtYmVyTWVtYmVyTm90SW5pdGlhbGl6ZWQoaW5pdC5sb2MsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG1lbWJlcnMuZGVmYXVsdGVkTWVtYmVycy5wdXNoKHRoaXMuZmluaXNoTm9kZShtZW1iZXJOb2RlLCBcIkVudW1EZWZhdWx0ZWRNZW1iZXJcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5tYXRjaCg4KSkge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtZW1iZXJzLFxuICAgICAgaGFzVW5rbm93bk1lbWJlcnNcbiAgICB9O1xuICB9XG4gIGZsb3dFbnVtU3RyaW5nTWVtYmVycyhpbml0aWFsaXplZE1lbWJlcnMsIGRlZmF1bHRlZE1lbWJlcnMsIHtcbiAgICBlbnVtTmFtZVxuICB9KSB7XG4gICAgaWYgKGluaXRpYWxpemVkTWVtYmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBkZWZhdWx0ZWRNZW1iZXJzO1xuICAgIH0gZWxzZSBpZiAoZGVmYXVsdGVkTWVtYmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBpbml0aWFsaXplZE1lbWJlcnM7XG4gICAgfSBlbHNlIGlmIChkZWZhdWx0ZWRNZW1iZXJzLmxlbmd0aCA+IGluaXRpYWxpemVkTWVtYmVycy5sZW5ndGgpIHtcbiAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIGluaXRpYWxpemVkTWVtYmVycykge1xuICAgICAgICB0aGlzLmZsb3dFbnVtRXJyb3JTdHJpbmdNZW1iZXJJbmNvbnNpc3RlbnRseUluaXRpYWxpemVkKG1lbWJlciwge1xuICAgICAgICAgIGVudW1OYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmF1bHRlZE1lbWJlcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIGRlZmF1bHRlZE1lbWJlcnMpIHtcbiAgICAgICAgdGhpcy5mbG93RW51bUVycm9yU3RyaW5nTWVtYmVySW5jb25zaXN0ZW50bHlJbml0aWFsaXplZChtZW1iZXIsIHtcbiAgICAgICAgICBlbnVtTmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbml0aWFsaXplZE1lbWJlcnM7XG4gICAgfVxuICB9XG4gIGZsb3dFbnVtUGFyc2VFeHBsaWNpdFR5cGUoe1xuICAgIGVudW1OYW1lXG4gIH0pIHtcbiAgICBpZiAoIXRoaXMuZWF0Q29udGV4dHVhbCgxMDIpKSByZXR1cm4gbnVsbDtcbiAgICBpZiAoIXRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRmxvd0Vycm9ycy5FbnVtSW52YWxpZEV4cGxpY2l0VHlwZVVua25vd25TdXBwbGllZCwgdGhpcy5zdGF0ZS5zdGFydExvYywge1xuICAgICAgICBlbnVtTmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHZhbHVlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHZhbHVlICE9PSBcImJvb2xlYW5cIiAmJiB2YWx1ZSAhPT0gXCJudW1iZXJcIiAmJiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSAhPT0gXCJzeW1ib2xcIikge1xuICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkVudW1JbnZhbGlkRXhwbGljaXRUeXBlLCB0aGlzLnN0YXRlLnN0YXJ0TG9jLCB7XG4gICAgICAgIGVudW1OYW1lLFxuICAgICAgICBpbnZhbGlkRW51bVR5cGU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZsb3dFbnVtQm9keShub2RlLCBpZCkge1xuICAgIGNvbnN0IGVudW1OYW1lID0gaWQubmFtZTtcbiAgICBjb25zdCBuYW1lTG9jID0gaWQubG9jLnN0YXJ0O1xuICAgIGNvbnN0IGV4cGxpY2l0VHlwZSA9IHRoaXMuZmxvd0VudW1QYXJzZUV4cGxpY2l0VHlwZSh7XG4gICAgICBlbnVtTmFtZVxuICAgIH0pO1xuICAgIHRoaXMuZXhwZWN0KDUpO1xuICAgIGNvbnN0IHtcbiAgICAgIG1lbWJlcnMsXG4gICAgICBoYXNVbmtub3duTWVtYmVyc1xuICAgIH0gPSB0aGlzLmZsb3dFbnVtTWVtYmVycyh7XG4gICAgICBlbnVtTmFtZSxcbiAgICAgIGV4cGxpY2l0VHlwZVxuICAgIH0pO1xuICAgIG5vZGUuaGFzVW5rbm93bk1lbWJlcnMgPSBoYXNVbmtub3duTWVtYmVycztcbiAgICBzd2l0Y2ggKGV4cGxpY2l0VHlwZSkge1xuICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgbm9kZS5leHBsaWNpdFR5cGUgPSB0cnVlO1xuICAgICAgICBub2RlLm1lbWJlcnMgPSBtZW1iZXJzLmJvb2xlYW5NZW1iZXJzO1xuICAgICAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVudW1Cb29sZWFuQm9keVwiKTtcbiAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgbm9kZS5leHBsaWNpdFR5cGUgPSB0cnVlO1xuICAgICAgICBub2RlLm1lbWJlcnMgPSBtZW1iZXJzLm51bWJlck1lbWJlcnM7XG4gICAgICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW51bU51bWJlckJvZHlcIik7XG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIG5vZGUuZXhwbGljaXRUeXBlID0gdHJ1ZTtcbiAgICAgICAgbm9kZS5tZW1iZXJzID0gdGhpcy5mbG93RW51bVN0cmluZ01lbWJlcnMobWVtYmVycy5zdHJpbmdNZW1iZXJzLCBtZW1iZXJzLmRlZmF1bHRlZE1lbWJlcnMsIHtcbiAgICAgICAgICBlbnVtTmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5leHBlY3QoOCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbnVtU3RyaW5nQm9keVwiKTtcbiAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgbm9kZS5tZW1iZXJzID0gbWVtYmVycy5kZWZhdWx0ZWRNZW1iZXJzO1xuICAgICAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVudW1TeW1ib2xCb2R5XCIpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGVtcHR5ID0gKCkgPT4ge1xuICAgICAgICAgICAgbm9kZS5tZW1iZXJzID0gW107XG4gICAgICAgICAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbnVtU3RyaW5nQm9keVwiKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIG5vZGUuZXhwbGljaXRUeXBlID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgYm9vbHNMZW4gPSBtZW1iZXJzLmJvb2xlYW5NZW1iZXJzLmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBudW1zTGVuID0gbWVtYmVycy5udW1iZXJNZW1iZXJzLmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBzdHJzTGVuID0gbWVtYmVycy5zdHJpbmdNZW1iZXJzLmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBkZWZhdWx0ZWRMZW4gPSBtZW1iZXJzLmRlZmF1bHRlZE1lbWJlcnMubGVuZ3RoO1xuICAgICAgICAgIGlmICghYm9vbHNMZW4gJiYgIW51bXNMZW4gJiYgIXN0cnNMZW4gJiYgIWRlZmF1bHRlZExlbikge1xuICAgICAgICAgICAgcmV0dXJuIGVtcHR5KCk7XG4gICAgICAgICAgfSBlbHNlIGlmICghYm9vbHNMZW4gJiYgIW51bXNMZW4pIHtcbiAgICAgICAgICAgIG5vZGUubWVtYmVycyA9IHRoaXMuZmxvd0VudW1TdHJpbmdNZW1iZXJzKG1lbWJlcnMuc3RyaW5nTWVtYmVycywgbWVtYmVycy5kZWZhdWx0ZWRNZW1iZXJzLCB7XG4gICAgICAgICAgICAgIGVudW1OYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVudW1TdHJpbmdCb2R5XCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIW51bXNMZW4gJiYgIXN0cnNMZW4gJiYgYm9vbHNMZW4gPj0gZGVmYXVsdGVkTGVuKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBtZW1iZXJzLmRlZmF1bHRlZE1lbWJlcnMpIHtcbiAgICAgICAgICAgICAgdGhpcy5mbG93RW51bUVycm9yQm9vbGVhbk1lbWJlck5vdEluaXRpYWxpemVkKG1lbWJlci5sb2Muc3RhcnQsIHtcbiAgICAgICAgICAgICAgICBlbnVtTmFtZSxcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lOiBtZW1iZXIuaWQubmFtZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUubWVtYmVycyA9IG1lbWJlcnMuYm9vbGVhbk1lbWJlcnM7XG4gICAgICAgICAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbnVtQm9vbGVhbkJvZHlcIik7XG4gICAgICAgICAgfSBlbHNlIGlmICghYm9vbHNMZW4gJiYgIXN0cnNMZW4gJiYgbnVtc0xlbiA+PSBkZWZhdWx0ZWRMZW4pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIG1lbWJlcnMuZGVmYXVsdGVkTWVtYmVycykge1xuICAgICAgICAgICAgICB0aGlzLmZsb3dFbnVtRXJyb3JOdW1iZXJNZW1iZXJOb3RJbml0aWFsaXplZChtZW1iZXIubG9jLnN0YXJ0LCB7XG4gICAgICAgICAgICAgICAgZW51bU5hbWUsXG4gICAgICAgICAgICAgICAgbWVtYmVyTmFtZTogbWVtYmVyLmlkLm5hbWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLm1lbWJlcnMgPSBtZW1iZXJzLm51bWJlck1lbWJlcnM7XG4gICAgICAgICAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbnVtTnVtYmVyQm9keVwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkVudW1JbmNvbnNpc3RlbnRNZW1iZXJWYWx1ZXMsIG5hbWVMb2MsIHtcbiAgICAgICAgICAgICAgZW51bU5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGVtcHR5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG4gIGZsb3dQYXJzZUVudW1EZWNsYXJhdGlvbihub2RlKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIG5vZGUuaWQgPSBpZDtcbiAgICBub2RlLmJvZHkgPSB0aGlzLmZsb3dFbnVtQm9keSh0aGlzLnN0YXJ0Tm9kZSgpLCBpZCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVudW1EZWNsYXJhdGlvblwiKTtcbiAgfVxuICBqc3hQYXJzZU9wZW5pbmdFbGVtZW50QWZ0ZXJOYW1lKG5vZGUpIHtcbiAgICBpZiAodGhpcy5zaG91bGRQYXJzZVR5cGVzKCkpIHtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDQ3KSB8fCB0aGlzLm1hdGNoKDUxKSkge1xuICAgICAgICBub2RlLnR5cGVBcmd1bWVudHMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uSW5FeHByZXNzaW9uKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5qc3hQYXJzZU9wZW5pbmdFbGVtZW50QWZ0ZXJOYW1lKG5vZGUpO1xuICB9XG4gIGlzTG9va2FoZWFkVG9rZW5fbHQoKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuU3RhcnQoKTtcbiAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpID09PSA2MCkge1xuICAgICAgY29uc3QgYWZ0ZXJOZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQgKyAxKTtcbiAgICAgIHJldHVybiBhZnRlck5leHQgIT09IDYwICYmIGFmdGVyTmV4dCAhPT0gNjE7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZVNjYW5fbHRfZ3QoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0eXBlID09PSA0Nykge1xuICAgICAgdGhpcy5zdGF0ZS5wb3MgLT0gMTtcbiAgICAgIHRoaXMucmVhZFRva2VuX2x0KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSA0OCkge1xuICAgICAgdGhpcy5zdGF0ZS5wb3MgLT0gMTtcbiAgICAgIHRoaXMucmVhZFRva2VuX2d0KCk7XG4gICAgfVxuICB9XG4gIHJlU2Nhbl9sdCgpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHR5cGUgPT09IDUxKSB7XG4gICAgICB0aGlzLnN0YXRlLnBvcyAtPSAyO1xuICAgICAgdGhpcy5maW5pc2hPcCg0NywgMSk7XG4gICAgICByZXR1cm4gNDc7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIG1heWJlVW53cmFwVHlwZUNhc3RFeHByZXNzaW9uKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIlR5cGVDYXN0RXhwcmVzc2lvblwiID8gbm9kZS5leHByZXNzaW9uIDogbm9kZTtcbiAgfVxufTtcbmNvbnN0IGVudGl0aWVzID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIHF1b3Q6IFwiXFx1MDAyMlwiLFxuICBhbXA6IFwiJlwiLFxuICBhcG9zOiBcIlxcdTAwMjdcIixcbiAgbHQ6IFwiPFwiLFxuICBndDogXCI+XCIsXG4gIG5ic3A6IFwiXFx1MDBBMFwiLFxuICBpZXhjbDogXCJcXHUwMEExXCIsXG4gIGNlbnQ6IFwiXFx1MDBBMlwiLFxuICBwb3VuZDogXCJcXHUwMEEzXCIsXG4gIGN1cnJlbjogXCJcXHUwMEE0XCIsXG4gIHllbjogXCJcXHUwMEE1XCIsXG4gIGJydmJhcjogXCJcXHUwMEE2XCIsXG4gIHNlY3Q6IFwiXFx1MDBBN1wiLFxuICB1bWw6IFwiXFx1MDBBOFwiLFxuICBjb3B5OiBcIlxcdTAwQTlcIixcbiAgb3JkZjogXCJcXHUwMEFBXCIsXG4gIGxhcXVvOiBcIlxcdTAwQUJcIixcbiAgbm90OiBcIlxcdTAwQUNcIixcbiAgc2h5OiBcIlxcdTAwQURcIixcbiAgcmVnOiBcIlxcdTAwQUVcIixcbiAgbWFjcjogXCJcXHUwMEFGXCIsXG4gIGRlZzogXCJcXHUwMEIwXCIsXG4gIHBsdXNtbjogXCJcXHUwMEIxXCIsXG4gIHN1cDI6IFwiXFx1MDBCMlwiLFxuICBzdXAzOiBcIlxcdTAwQjNcIixcbiAgYWN1dGU6IFwiXFx1MDBCNFwiLFxuICBtaWNybzogXCJcXHUwMEI1XCIsXG4gIHBhcmE6IFwiXFx1MDBCNlwiLFxuICBtaWRkb3Q6IFwiXFx1MDBCN1wiLFxuICBjZWRpbDogXCJcXHUwMEI4XCIsXG4gIHN1cDE6IFwiXFx1MDBCOVwiLFxuICBvcmRtOiBcIlxcdTAwQkFcIixcbiAgcmFxdW86IFwiXFx1MDBCQlwiLFxuICBmcmFjMTQ6IFwiXFx1MDBCQ1wiLFxuICBmcmFjMTI6IFwiXFx1MDBCRFwiLFxuICBmcmFjMzQ6IFwiXFx1MDBCRVwiLFxuICBpcXVlc3Q6IFwiXFx1MDBCRlwiLFxuICBBZ3JhdmU6IFwiXFx1MDBDMFwiLFxuICBBYWN1dGU6IFwiXFx1MDBDMVwiLFxuICBBY2lyYzogXCJcXHUwMEMyXCIsXG4gIEF0aWxkZTogXCJcXHUwMEMzXCIsXG4gIEF1bWw6IFwiXFx1MDBDNFwiLFxuICBBcmluZzogXCJcXHUwMEM1XCIsXG4gIEFFbGlnOiBcIlxcdTAwQzZcIixcbiAgQ2NlZGlsOiBcIlxcdTAwQzdcIixcbiAgRWdyYXZlOiBcIlxcdTAwQzhcIixcbiAgRWFjdXRlOiBcIlxcdTAwQzlcIixcbiAgRWNpcmM6IFwiXFx1MDBDQVwiLFxuICBFdW1sOiBcIlxcdTAwQ0JcIixcbiAgSWdyYXZlOiBcIlxcdTAwQ0NcIixcbiAgSWFjdXRlOiBcIlxcdTAwQ0RcIixcbiAgSWNpcmM6IFwiXFx1MDBDRVwiLFxuICBJdW1sOiBcIlxcdTAwQ0ZcIixcbiAgRVRIOiBcIlxcdTAwRDBcIixcbiAgTnRpbGRlOiBcIlxcdTAwRDFcIixcbiAgT2dyYXZlOiBcIlxcdTAwRDJcIixcbiAgT2FjdXRlOiBcIlxcdTAwRDNcIixcbiAgT2NpcmM6IFwiXFx1MDBENFwiLFxuICBPdGlsZGU6IFwiXFx1MDBENVwiLFxuICBPdW1sOiBcIlxcdTAwRDZcIixcbiAgdGltZXM6IFwiXFx1MDBEN1wiLFxuICBPc2xhc2g6IFwiXFx1MDBEOFwiLFxuICBVZ3JhdmU6IFwiXFx1MDBEOVwiLFxuICBVYWN1dGU6IFwiXFx1MDBEQVwiLFxuICBVY2lyYzogXCJcXHUwMERCXCIsXG4gIFV1bWw6IFwiXFx1MDBEQ1wiLFxuICBZYWN1dGU6IFwiXFx1MDBERFwiLFxuICBUSE9STjogXCJcXHUwMERFXCIsXG4gIHN6bGlnOiBcIlxcdTAwREZcIixcbiAgYWdyYXZlOiBcIlxcdTAwRTBcIixcbiAgYWFjdXRlOiBcIlxcdTAwRTFcIixcbiAgYWNpcmM6IFwiXFx1MDBFMlwiLFxuICBhdGlsZGU6IFwiXFx1MDBFM1wiLFxuICBhdW1sOiBcIlxcdTAwRTRcIixcbiAgYXJpbmc6IFwiXFx1MDBFNVwiLFxuICBhZWxpZzogXCJcXHUwMEU2XCIsXG4gIGNjZWRpbDogXCJcXHUwMEU3XCIsXG4gIGVncmF2ZTogXCJcXHUwMEU4XCIsXG4gIGVhY3V0ZTogXCJcXHUwMEU5XCIsXG4gIGVjaXJjOiBcIlxcdTAwRUFcIixcbiAgZXVtbDogXCJcXHUwMEVCXCIsXG4gIGlncmF2ZTogXCJcXHUwMEVDXCIsXG4gIGlhY3V0ZTogXCJcXHUwMEVEXCIsXG4gIGljaXJjOiBcIlxcdTAwRUVcIixcbiAgaXVtbDogXCJcXHUwMEVGXCIsXG4gIGV0aDogXCJcXHUwMEYwXCIsXG4gIG50aWxkZTogXCJcXHUwMEYxXCIsXG4gIG9ncmF2ZTogXCJcXHUwMEYyXCIsXG4gIG9hY3V0ZTogXCJcXHUwMEYzXCIsXG4gIG9jaXJjOiBcIlxcdTAwRjRcIixcbiAgb3RpbGRlOiBcIlxcdTAwRjVcIixcbiAgb3VtbDogXCJcXHUwMEY2XCIsXG4gIGRpdmlkZTogXCJcXHUwMEY3XCIsXG4gIG9zbGFzaDogXCJcXHUwMEY4XCIsXG4gIHVncmF2ZTogXCJcXHUwMEY5XCIsXG4gIHVhY3V0ZTogXCJcXHUwMEZBXCIsXG4gIHVjaXJjOiBcIlxcdTAwRkJcIixcbiAgdXVtbDogXCJcXHUwMEZDXCIsXG4gIHlhY3V0ZTogXCJcXHUwMEZEXCIsXG4gIHRob3JuOiBcIlxcdTAwRkVcIixcbiAgeXVtbDogXCJcXHUwMEZGXCIsXG4gIE9FbGlnOiBcIlxcdTAxNTJcIixcbiAgb2VsaWc6IFwiXFx1MDE1M1wiLFxuICBTY2Fyb246IFwiXFx1MDE2MFwiLFxuICBzY2Fyb246IFwiXFx1MDE2MVwiLFxuICBZdW1sOiBcIlxcdTAxNzhcIixcbiAgZm5vZjogXCJcXHUwMTkyXCIsXG4gIGNpcmM6IFwiXFx1MDJDNlwiLFxuICB0aWxkZTogXCJcXHUwMkRDXCIsXG4gIEFscGhhOiBcIlxcdTAzOTFcIixcbiAgQmV0YTogXCJcXHUwMzkyXCIsXG4gIEdhbW1hOiBcIlxcdTAzOTNcIixcbiAgRGVsdGE6IFwiXFx1MDM5NFwiLFxuICBFcHNpbG9uOiBcIlxcdTAzOTVcIixcbiAgWmV0YTogXCJcXHUwMzk2XCIsXG4gIEV0YTogXCJcXHUwMzk3XCIsXG4gIFRoZXRhOiBcIlxcdTAzOThcIixcbiAgSW90YTogXCJcXHUwMzk5XCIsXG4gIEthcHBhOiBcIlxcdTAzOUFcIixcbiAgTGFtYmRhOiBcIlxcdTAzOUJcIixcbiAgTXU6IFwiXFx1MDM5Q1wiLFxuICBOdTogXCJcXHUwMzlEXCIsXG4gIFhpOiBcIlxcdTAzOUVcIixcbiAgT21pY3JvbjogXCJcXHUwMzlGXCIsXG4gIFBpOiBcIlxcdTAzQTBcIixcbiAgUmhvOiBcIlxcdTAzQTFcIixcbiAgU2lnbWE6IFwiXFx1MDNBM1wiLFxuICBUYXU6IFwiXFx1MDNBNFwiLFxuICBVcHNpbG9uOiBcIlxcdTAzQTVcIixcbiAgUGhpOiBcIlxcdTAzQTZcIixcbiAgQ2hpOiBcIlxcdTAzQTdcIixcbiAgUHNpOiBcIlxcdTAzQThcIixcbiAgT21lZ2E6IFwiXFx1MDNBOVwiLFxuICBhbHBoYTogXCJcXHUwM0IxXCIsXG4gIGJldGE6IFwiXFx1MDNCMlwiLFxuICBnYW1tYTogXCJcXHUwM0IzXCIsXG4gIGRlbHRhOiBcIlxcdTAzQjRcIixcbiAgZXBzaWxvbjogXCJcXHUwM0I1XCIsXG4gIHpldGE6IFwiXFx1MDNCNlwiLFxuICBldGE6IFwiXFx1MDNCN1wiLFxuICB0aGV0YTogXCJcXHUwM0I4XCIsXG4gIGlvdGE6IFwiXFx1MDNCOVwiLFxuICBrYXBwYTogXCJcXHUwM0JBXCIsXG4gIGxhbWJkYTogXCJcXHUwM0JCXCIsXG4gIG11OiBcIlxcdTAzQkNcIixcbiAgbnU6IFwiXFx1MDNCRFwiLFxuICB4aTogXCJcXHUwM0JFXCIsXG4gIG9taWNyb246IFwiXFx1MDNCRlwiLFxuICBwaTogXCJcXHUwM0MwXCIsXG4gIHJobzogXCJcXHUwM0MxXCIsXG4gIHNpZ21hZjogXCJcXHUwM0MyXCIsXG4gIHNpZ21hOiBcIlxcdTAzQzNcIixcbiAgdGF1OiBcIlxcdTAzQzRcIixcbiAgdXBzaWxvbjogXCJcXHUwM0M1XCIsXG4gIHBoaTogXCJcXHUwM0M2XCIsXG4gIGNoaTogXCJcXHUwM0M3XCIsXG4gIHBzaTogXCJcXHUwM0M4XCIsXG4gIG9tZWdhOiBcIlxcdTAzQzlcIixcbiAgdGhldGFzeW06IFwiXFx1MDNEMVwiLFxuICB1cHNpaDogXCJcXHUwM0QyXCIsXG4gIHBpdjogXCJcXHUwM0Q2XCIsXG4gIGVuc3A6IFwiXFx1MjAwMlwiLFxuICBlbXNwOiBcIlxcdTIwMDNcIixcbiAgdGhpbnNwOiBcIlxcdTIwMDlcIixcbiAgenduajogXCJcXHUyMDBDXCIsXG4gIHp3ajogXCJcXHUyMDBEXCIsXG4gIGxybTogXCJcXHUyMDBFXCIsXG4gIHJsbTogXCJcXHUyMDBGXCIsXG4gIG5kYXNoOiBcIlxcdTIwMTNcIixcbiAgbWRhc2g6IFwiXFx1MjAxNFwiLFxuICBsc3F1bzogXCJcXHUyMDE4XCIsXG4gIHJzcXVvOiBcIlxcdTIwMTlcIixcbiAgc2JxdW86IFwiXFx1MjAxQVwiLFxuICBsZHF1bzogXCJcXHUyMDFDXCIsXG4gIHJkcXVvOiBcIlxcdTIwMURcIixcbiAgYmRxdW86IFwiXFx1MjAxRVwiLFxuICBkYWdnZXI6IFwiXFx1MjAyMFwiLFxuICBEYWdnZXI6IFwiXFx1MjAyMVwiLFxuICBidWxsOiBcIlxcdTIwMjJcIixcbiAgaGVsbGlwOiBcIlxcdTIwMjZcIixcbiAgcGVybWlsOiBcIlxcdTIwMzBcIixcbiAgcHJpbWU6IFwiXFx1MjAzMlwiLFxuICBQcmltZTogXCJcXHUyMDMzXCIsXG4gIGxzYXF1bzogXCJcXHUyMDM5XCIsXG4gIHJzYXF1bzogXCJcXHUyMDNBXCIsXG4gIG9saW5lOiBcIlxcdTIwM0VcIixcbiAgZnJhc2w6IFwiXFx1MjA0NFwiLFxuICBldXJvOiBcIlxcdTIwQUNcIixcbiAgaW1hZ2U6IFwiXFx1MjExMVwiLFxuICB3ZWllcnA6IFwiXFx1MjExOFwiLFxuICByZWFsOiBcIlxcdTIxMUNcIixcbiAgdHJhZGU6IFwiXFx1MjEyMlwiLFxuICBhbGVmc3ltOiBcIlxcdTIxMzVcIixcbiAgbGFycjogXCJcXHUyMTkwXCIsXG4gIHVhcnI6IFwiXFx1MjE5MVwiLFxuICByYXJyOiBcIlxcdTIxOTJcIixcbiAgZGFycjogXCJcXHUyMTkzXCIsXG4gIGhhcnI6IFwiXFx1MjE5NFwiLFxuICBjcmFycjogXCJcXHUyMUI1XCIsXG4gIGxBcnI6IFwiXFx1MjFEMFwiLFxuICB1QXJyOiBcIlxcdTIxRDFcIixcbiAgckFycjogXCJcXHUyMUQyXCIsXG4gIGRBcnI6IFwiXFx1MjFEM1wiLFxuICBoQXJyOiBcIlxcdTIxRDRcIixcbiAgZm9yYWxsOiBcIlxcdTIyMDBcIixcbiAgcGFydDogXCJcXHUyMjAyXCIsXG4gIGV4aXN0OiBcIlxcdTIyMDNcIixcbiAgZW1wdHk6IFwiXFx1MjIwNVwiLFxuICBuYWJsYTogXCJcXHUyMjA3XCIsXG4gIGlzaW46IFwiXFx1MjIwOFwiLFxuICBub3RpbjogXCJcXHUyMjA5XCIsXG4gIG5pOiBcIlxcdTIyMEJcIixcbiAgcHJvZDogXCJcXHUyMjBGXCIsXG4gIHN1bTogXCJcXHUyMjExXCIsXG4gIG1pbnVzOiBcIlxcdTIyMTJcIixcbiAgbG93YXN0OiBcIlxcdTIyMTdcIixcbiAgcmFkaWM6IFwiXFx1MjIxQVwiLFxuICBwcm9wOiBcIlxcdTIyMURcIixcbiAgaW5maW46IFwiXFx1MjIxRVwiLFxuICBhbmc6IFwiXFx1MjIyMFwiLFxuICBhbmQ6IFwiXFx1MjIyN1wiLFxuICBvcjogXCJcXHUyMjI4XCIsXG4gIGNhcDogXCJcXHUyMjI5XCIsXG4gIGN1cDogXCJcXHUyMjJBXCIsXG4gIGludDogXCJcXHUyMjJCXCIsXG4gIHRoZXJlNDogXCJcXHUyMjM0XCIsXG4gIHNpbTogXCJcXHUyMjNDXCIsXG4gIGNvbmc6IFwiXFx1MjI0NVwiLFxuICBhc3ltcDogXCJcXHUyMjQ4XCIsXG4gIG5lOiBcIlxcdTIyNjBcIixcbiAgZXF1aXY6IFwiXFx1MjI2MVwiLFxuICBsZTogXCJcXHUyMjY0XCIsXG4gIGdlOiBcIlxcdTIyNjVcIixcbiAgc3ViOiBcIlxcdTIyODJcIixcbiAgc3VwOiBcIlxcdTIyODNcIixcbiAgbnN1YjogXCJcXHUyMjg0XCIsXG4gIHN1YmU6IFwiXFx1MjI4NlwiLFxuICBzdXBlOiBcIlxcdTIyODdcIixcbiAgb3BsdXM6IFwiXFx1MjI5NVwiLFxuICBvdGltZXM6IFwiXFx1MjI5N1wiLFxuICBwZXJwOiBcIlxcdTIyQTVcIixcbiAgc2RvdDogXCJcXHUyMkM1XCIsXG4gIGxjZWlsOiBcIlxcdTIzMDhcIixcbiAgcmNlaWw6IFwiXFx1MjMwOVwiLFxuICBsZmxvb3I6IFwiXFx1MjMwQVwiLFxuICByZmxvb3I6IFwiXFx1MjMwQlwiLFxuICBsYW5nOiBcIlxcdTIzMjlcIixcbiAgcmFuZzogXCJcXHUyMzJBXCIsXG4gIGxvejogXCJcXHUyNUNBXCIsXG4gIHNwYWRlczogXCJcXHUyNjYwXCIsXG4gIGNsdWJzOiBcIlxcdTI2NjNcIixcbiAgaGVhcnRzOiBcIlxcdTI2NjVcIixcbiAgZGlhbXM6IFwiXFx1MjY2NlwiXG59O1xuY29uc3QgSnN4RXJyb3JzID0gUGFyc2VFcnJvckVudW1ganN4YCh7XG4gIEF0dHJpYnV0ZUlzRW1wdHk6IFwiSlNYIGF0dHJpYnV0ZXMgbXVzdCBvbmx5IGJlIGFzc2lnbmVkIGEgbm9uLWVtcHR5IGV4cHJlc3Npb24uXCIsXG4gIE1pc3NpbmdDbG9zaW5nVGFnRWxlbWVudDogKHtcbiAgICBvcGVuaW5nVGFnTmFtZVxuICB9KSA9PiBgRXhwZWN0ZWQgY29ycmVzcG9uZGluZyBKU1ggY2xvc2luZyB0YWcgZm9yIDwke29wZW5pbmdUYWdOYW1lfT4uYCxcbiAgTWlzc2luZ0Nsb3NpbmdUYWdGcmFnbWVudDogXCJFeHBlY3RlZCBjb3JyZXNwb25kaW5nIEpTWCBjbG9zaW5nIHRhZyBmb3IgPD4uXCIsXG4gIFVuZXhwZWN0ZWRTZXF1ZW5jZUV4cHJlc3Npb246IFwiU2VxdWVuY2UgZXhwcmVzc2lvbnMgY2Fubm90IGJlIGRpcmVjdGx5IG5lc3RlZCBpbnNpZGUgSlNYLiBEaWQgeW91IG1lYW4gdG8gd3JhcCBpdCBpbiBwYXJlbnRoZXNlcyAoLi4uKT9cIixcbiAgVW5leHBlY3RlZFRva2VuOiAoe1xuICAgIHVuZXhwZWN0ZWQsXG4gICAgSFRNTEVudGl0eVxuICB9KSA9PiBgVW5leHBlY3RlZCB0b2tlbiBcXGAke3VuZXhwZWN0ZWR9XFxgLiBEaWQgeW91IG1lYW4gXFxgJHtIVE1MRW50aXR5fVxcYCBvciBcXGB7JyR7dW5leHBlY3RlZH0nfVxcYD9gLFxuICBVbnN1cHBvcnRlZEpzeFZhbHVlOiBcIkpTWCB2YWx1ZSBzaG91bGQgYmUgZWl0aGVyIGFuIGV4cHJlc3Npb24gb3IgYSBxdW90ZWQgSlNYIHRleHQuXCIsXG4gIFVudGVybWluYXRlZEpzeENvbnRlbnQ6IFwiVW50ZXJtaW5hdGVkIEpTWCBjb250ZW50cy5cIixcbiAgVW53cmFwcGVkQWRqYWNlbnRKU1hFbGVtZW50czogXCJBZGphY2VudCBKU1ggZWxlbWVudHMgbXVzdCBiZSB3cmFwcGVkIGluIGFuIGVuY2xvc2luZyB0YWcuIERpZCB5b3Ugd2FudCBhIEpTWCBmcmFnbWVudCA8Pi4uLjwvPj9cIlxufSk7XG5mdW5jdGlvbiBpc0ZyYWdtZW50KG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID8gb2JqZWN0LnR5cGUgPT09IFwiSlNYT3BlbmluZ0ZyYWdtZW50XCIgfHwgb2JqZWN0LnR5cGUgPT09IFwiSlNYQ2xvc2luZ0ZyYWdtZW50XCIgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFF1YWxpZmllZEpTWE5hbWUob2JqZWN0KSB7XG4gIGlmIChvYmplY3QudHlwZSA9PT0gXCJKU1hJZGVudGlmaWVyXCIpIHtcbiAgICByZXR1cm4gb2JqZWN0Lm5hbWU7XG4gIH1cbiAgaWYgKG9iamVjdC50eXBlID09PSBcIkpTWE5hbWVzcGFjZWROYW1lXCIpIHtcbiAgICByZXR1cm4gb2JqZWN0Lm5hbWVzcGFjZS5uYW1lICsgXCI6XCIgKyBvYmplY3QubmFtZS5uYW1lO1xuICB9XG4gIGlmIChvYmplY3QudHlwZSA9PT0gXCJKU1hNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICByZXR1cm4gZ2V0UXVhbGlmaWVkSlNYTmFtZShvYmplY3Qub2JqZWN0KSArIFwiLlwiICsgZ2V0UXVhbGlmaWVkSlNYTmFtZShvYmplY3QucHJvcGVydHkpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIk5vZGUgaGFkIHVuZXhwZWN0ZWQgdHlwZTogXCIgKyBvYmplY3QudHlwZSk7XG59XG52YXIganN4ID0gc3VwZXJDbGFzcyA9PiBjbGFzcyBKU1hQYXJzZXJNaXhpbiBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuICBqc3hSZWFkVG9rZW4oKSB7XG4gICAgbGV0IG91dCA9IFwiXCI7XG4gICAgbGV0IGNodW5rU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShKc3hFcnJvcnMuVW50ZXJtaW5hdGVkSnN4Q29udGVudCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgIGNhc2UgNjA6XG4gICAgICAgIGNhc2UgMTIzOlxuICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnBvcyA9PT0gdGhpcy5zdGF0ZS5zdGFydCkge1xuICAgICAgICAgICAgaWYgKGNoID09PSA2MCAmJiB0aGlzLnN0YXRlLmNhblN0YXJ0SlNYRWxlbWVudCkge1xuICAgICAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDE0Myk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdXBlci5nZXRUb2tlbkZyb21Db2RlKGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTQyLCBvdXQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICAgICAgb3V0ICs9IHRoaXMuanN4UmVhZEVudGl0eSgpO1xuICAgICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2MjpcbiAgICAgICAgY2FzZSAxMjU6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGlzTmV3TGluZShjaCkpIHtcbiAgICAgICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgICAgIG91dCArPSB0aGlzLmpzeFJlYWROZXdMaW5lKHRydWUpO1xuICAgICAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAganN4UmVhZE5ld0xpbmUobm9ybWFsaXplQ1JMRikge1xuICAgIGNvbnN0IGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICBsZXQgb3V0O1xuICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgaWYgKGNoID09PSAxMyAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpID09PSAxMCkge1xuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIG91dCA9IG5vcm1hbGl6ZUNSTEYgPyBcIlxcblwiIDogXCJcXHJcXG5cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgfVxuICAgICsrdGhpcy5zdGF0ZS5jdXJMaW5lO1xuICAgIHRoaXMuc3RhdGUubGluZVN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICBqc3hSZWFkU3RyaW5nKHF1b3RlKSB7XG4gICAgbGV0IG91dCA9IFwiXCI7XG4gICAgbGV0IGNodW5rU3RhcnQgPSArK3RoaXMuc3RhdGUucG9zO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLnBvcyA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbnRlcm1pbmF0ZWRTdHJpbmcsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgaWYgKGNoID09PSBxdW90ZSkgYnJlYWs7XG4gICAgICBpZiAoY2ggPT09IDM4KSB7XG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgb3V0ICs9IHRoaXMuanN4UmVhZEVudGl0eSgpO1xuICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB9IGVsc2UgaWYgKGlzTmV3TGluZShjaCkpIHtcbiAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgICBvdXQgKz0gdGhpcy5qc3hSZWFkTmV3TGluZShmYWxzZSk7XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB9XG4gICAgfVxuICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKyspO1xuICAgIHRoaXMuZmluaXNoVG9rZW4oMTM0LCBvdXQpO1xuICB9XG4gIGpzeFJlYWRFbnRpdHkoKSB7XG4gICAgY29uc3Qgc3RhcnRQb3MgPSArK3RoaXMuc3RhdGUucG9zO1xuICAgIGlmICh0aGlzLmNvZGVQb2ludEF0UG9zKHRoaXMuc3RhdGUucG9zKSA9PT0gMzUpIHtcbiAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICBsZXQgcmFkaXggPSAxMDtcbiAgICAgIGlmICh0aGlzLmNvZGVQb2ludEF0UG9zKHRoaXMuc3RhdGUucG9zKSA9PT0gMTIwKSB7XG4gICAgICAgIHJhZGl4ID0gMTY7XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB9XG4gICAgICBjb25zdCBjb2RlUG9pbnQgPSB0aGlzLnJlYWRJbnQocmFkaXgsIHVuZGVmaW5lZCwgZmFsc2UsIFwiYmFpbFwiKTtcbiAgICAgIGlmIChjb2RlUG9pbnQgIT09IG51bGwgJiYgdGhpcy5jb2RlUG9pbnRBdFBvcyh0aGlzLnN0YXRlLnBvcykgPT09IDU5KSB7XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlUG9pbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgbGV0IHNlbWkgPSBmYWxzZTtcbiAgICAgIHdoaWxlIChjb3VudCsrIDwgMTAgJiYgdGhpcy5zdGF0ZS5wb3MgPCB0aGlzLmxlbmd0aCAmJiAhKHNlbWkgPSB0aGlzLmNvZGVQb2ludEF0UG9zKHRoaXMuc3RhdGUucG9zKSA9PT0gNTkpKSB7XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB9XG4gICAgICBpZiAoc2VtaSkge1xuICAgICAgICBjb25zdCBkZXNjID0gdGhpcy5pbnB1dC5zbGljZShzdGFydFBvcywgdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgICBjb25zdCBlbnRpdHkgPSBlbnRpdGllc1tkZXNjXTtcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgaWYgKGVudGl0eSkge1xuICAgICAgICAgIHJldHVybiBlbnRpdHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5wb3MgPSBzdGFydFBvcztcbiAgICByZXR1cm4gXCImXCI7XG4gIH1cbiAganN4UmVhZFdvcmQoKSB7XG4gICAgbGV0IGNoO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgZG8ge1xuICAgICAgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnN0YXRlLnBvcyk7XG4gICAgfSB3aGlsZSAoaXNJZGVudGlmaWVyQ2hhcihjaCkgfHwgY2ggPT09IDQ1KTtcbiAgICB0aGlzLmZpbmlzaFRva2VuKDE0MSwgdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5zdGF0ZS5wb3MpKTtcbiAgfVxuICBqc3hQYXJzZUlkZW50aWZpZXIoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQxKSkge1xuICAgICAgbm9kZS5uYW1lID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHRva2VuSXNLZXl3b3JkKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgIG5vZGUubmFtZSA9IHRva2VuTGFiZWxOYW1lKHRoaXMuc3RhdGUudHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSlNYSWRlbnRpZmllclwiKTtcbiAgfVxuICBqc3hQYXJzZU5hbWVzcGFjZWROYW1lKCkge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBuYW1lID0gdGhpcy5qc3hQYXJzZUlkZW50aWZpZXIoKTtcbiAgICBpZiAoIXRoaXMuZWF0KDE0KSkgcmV0dXJuIG5hbWU7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgIG5vZGUubmFtZXNwYWNlID0gbmFtZTtcbiAgICBub2RlLm5hbWUgPSB0aGlzLmpzeFBhcnNlSWRlbnRpZmllcigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hOYW1lc3BhY2VkTmFtZVwiKTtcbiAgfVxuICBqc3hQYXJzZUVsZW1lbnROYW1lKCkge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBsZXQgbm9kZSA9IHRoaXMuanN4UGFyc2VOYW1lc3BhY2VkTmFtZSgpO1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiSlNYTmFtZXNwYWNlZE5hbWVcIikge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHdoaWxlICh0aGlzLmVhdCgxNikpIHtcbiAgICAgIGNvbnN0IG5ld05vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIG5ld05vZGUub2JqZWN0ID0gbm9kZTtcbiAgICAgIG5ld05vZGUucHJvcGVydHkgPSB0aGlzLmpzeFBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgbm9kZSA9IHRoaXMuZmluaXNoTm9kZShuZXdOb2RlLCBcIkpTWE1lbWJlckV4cHJlc3Npb25cIik7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGpzeFBhcnNlQXR0cmlidXRlVmFsdWUoKSB7XG4gICAgbGV0IG5vZGU7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dCh0eXBlcy5icmFjZSk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBub2RlID0gdGhpcy5qc3hQYXJzZUV4cHJlc3Npb25Db250YWluZXIobm9kZSwgdHlwZXMual9vVGFnKTtcbiAgICAgICAgaWYgKG5vZGUuZXhwcmVzc2lvbi50eXBlID09PSBcIkpTWEVtcHR5RXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShKc3hFcnJvcnMuQXR0cmlidXRlSXNFbXB0eSwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICBjYXNlIDE0MzpcbiAgICAgIGNhc2UgMTM0OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEpzeEVycm9ycy5VbnN1cHBvcnRlZEpzeFZhbHVlLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gIH1cbiAganN4UGFyc2VFbXB0eUV4cHJlc3Npb24oKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQodGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlQXQobm9kZSwgXCJKU1hFbXB0eUV4cHJlc3Npb25cIiwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gIH1cbiAganN4UGFyc2VTcHJlYWRDaGlsZChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5leHByZXNzaW9uID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLnNldENvbnRleHQodHlwZXMual9leHByKTtcbiAgICB0aGlzLnN0YXRlLmNhblN0YXJ0SlNYRWxlbWVudCA9IHRydWU7XG4gICAgdGhpcy5leHBlY3QoOCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWFNwcmVhZENoaWxkXCIpO1xuICB9XG4gIGpzeFBhcnNlRXhwcmVzc2lvbkNvbnRhaW5lcihub2RlLCBwcmV2aW91c0NvbnRleHQpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg4KSkge1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gdGhpcy5qc3hQYXJzZUVtcHR5RXhwcmVzc2lvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBleHByZXNzaW9uID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgfVxuICAgIHRoaXMuc2V0Q29udGV4dChwcmV2aW91c0NvbnRleHQpO1xuICAgIHRoaXMuc3RhdGUuY2FuU3RhcnRKU1hFbGVtZW50ID0gdHJ1ZTtcbiAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiKTtcbiAgfVxuICBqc3hQYXJzZUF0dHJpYnV0ZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAodGhpcy5tYXRjaCg1KSkge1xuICAgICAgdGhpcy5zZXRDb250ZXh0KHR5cGVzLmJyYWNlKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5leHBlY3QoMjEpO1xuICAgICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4oKTtcbiAgICAgIHRoaXMuc2V0Q29udGV4dCh0eXBlcy5qX29UYWcpO1xuICAgICAgdGhpcy5zdGF0ZS5jYW5TdGFydEpTWEVsZW1lbnQgPSB0cnVlO1xuICAgICAgdGhpcy5leHBlY3QoOCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSlNYU3ByZWFkQXR0cmlidXRlXCIpO1xuICAgIH1cbiAgICBub2RlLm5hbWUgPSB0aGlzLmpzeFBhcnNlTmFtZXNwYWNlZE5hbWUoKTtcbiAgICBub2RlLnZhbHVlID0gdGhpcy5lYXQoMjkpID8gdGhpcy5qc3hQYXJzZUF0dHJpYnV0ZVZhbHVlKCkgOiBudWxsO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hBdHRyaWJ1dGVcIik7XG4gIH1cbiAganN4UGFyc2VPcGVuaW5nRWxlbWVudEF0KHN0YXJ0TG9jKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgIGlmICh0aGlzLmVhdCgxNDQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSlNYT3BlbmluZ0ZyYWdtZW50XCIpO1xuICAgIH1cbiAgICBub2RlLm5hbWUgPSB0aGlzLmpzeFBhcnNlRWxlbWVudE5hbWUoKTtcbiAgICByZXR1cm4gdGhpcy5qc3hQYXJzZU9wZW5pbmdFbGVtZW50QWZ0ZXJOYW1lKG5vZGUpO1xuICB9XG4gIGpzeFBhcnNlT3BlbmluZ0VsZW1lbnRBZnRlck5hbWUobm9kZSkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBbXTtcbiAgICB3aGlsZSAoIXRoaXMubWF0Y2goNTYpICYmICF0aGlzLm1hdGNoKDE0NCkpIHtcbiAgICAgIGF0dHJpYnV0ZXMucHVzaCh0aGlzLmpzeFBhcnNlQXR0cmlidXRlKCkpO1xuICAgIH1cbiAgICBub2RlLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgIG5vZGUuc2VsZkNsb3NpbmcgPSB0aGlzLmVhdCg1Nik7XG4gICAgdGhpcy5leHBlY3QoMTQ0KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSlNYT3BlbmluZ0VsZW1lbnRcIik7XG4gIH1cbiAganN4UGFyc2VDbG9zaW5nRWxlbWVudEF0KHN0YXJ0TG9jKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgIGlmICh0aGlzLmVhdCgxNDQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSlNYQ2xvc2luZ0ZyYWdtZW50XCIpO1xuICAgIH1cbiAgICBub2RlLm5hbWUgPSB0aGlzLmpzeFBhcnNlRWxlbWVudE5hbWUoKTtcbiAgICB0aGlzLmV4cGVjdCgxNDQpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hDbG9zaW5nRWxlbWVudFwiKTtcbiAgfVxuICBqc3hQYXJzZUVsZW1lbnRBdChzdGFydExvYykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgIGNvbnN0IG9wZW5pbmdFbGVtZW50ID0gdGhpcy5qc3hQYXJzZU9wZW5pbmdFbGVtZW50QXQoc3RhcnRMb2MpO1xuICAgIGxldCBjbG9zaW5nRWxlbWVudCA9IG51bGw7XG4gICAgaWYgKCFvcGVuaW5nRWxlbWVudC5zZWxmQ2xvc2luZykge1xuICAgICAgY29udGVudHM6IGZvciAoOzspIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIDE0MzpcbiAgICAgICAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZWF0KDU2KSkge1xuICAgICAgICAgICAgICBjbG9zaW5nRWxlbWVudCA9IHRoaXMuanN4UGFyc2VDbG9zaW5nRWxlbWVudEF0KHN0YXJ0TG9jKTtcbiAgICAgICAgICAgICAgYnJlYWsgY29udGVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuanN4UGFyc2VFbGVtZW50QXQoc3RhcnRMb2MpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTQyOlxuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlLCBcIkpTWFRleHRcIikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICAgICAgdGhpcy5zZXRDb250ZXh0KHR5cGVzLmJyYWNlKTtcbiAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKDIxKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5qc3hQYXJzZVNwcmVhZENoaWxkKG5vZGUpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuanN4UGFyc2VFeHByZXNzaW9uQ29udGFpbmVyKG5vZGUsIHR5cGVzLmpfZXhwcikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRnJhZ21lbnQob3BlbmluZ0VsZW1lbnQpICYmICFpc0ZyYWdtZW50KGNsb3NpbmdFbGVtZW50KSAmJiBjbG9zaW5nRWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJhaXNlKEpzeEVycm9ycy5NaXNzaW5nQ2xvc2luZ1RhZ0ZyYWdtZW50LCBjbG9zaW5nRWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0ZyYWdtZW50KG9wZW5pbmdFbGVtZW50KSAmJiBpc0ZyYWdtZW50KGNsb3NpbmdFbGVtZW50KSkge1xuICAgICAgICB0aGlzLnJhaXNlKEpzeEVycm9ycy5NaXNzaW5nQ2xvc2luZ1RhZ0VsZW1lbnQsIGNsb3NpbmdFbGVtZW50LCB7XG4gICAgICAgICAgb3BlbmluZ1RhZ05hbWU6IGdldFF1YWxpZmllZEpTWE5hbWUob3BlbmluZ0VsZW1lbnQubmFtZSlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0ZyYWdtZW50KG9wZW5pbmdFbGVtZW50KSAmJiAhaXNGcmFnbWVudChjbG9zaW5nRWxlbWVudCkpIHtcbiAgICAgICAgaWYgKGdldFF1YWxpZmllZEpTWE5hbWUoY2xvc2luZ0VsZW1lbnQubmFtZSkgIT09IGdldFF1YWxpZmllZEpTWE5hbWUob3BlbmluZ0VsZW1lbnQubmFtZSkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEpzeEVycm9ycy5NaXNzaW5nQ2xvc2luZ1RhZ0VsZW1lbnQsIGNsb3NpbmdFbGVtZW50LCB7XG4gICAgICAgICAgICBvcGVuaW5nVGFnTmFtZTogZ2V0UXVhbGlmaWVkSlNYTmFtZShvcGVuaW5nRWxlbWVudC5uYW1lKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0ZyYWdtZW50KG9wZW5pbmdFbGVtZW50KSkge1xuICAgICAgbm9kZS5vcGVuaW5nRnJhZ21lbnQgPSBvcGVuaW5nRWxlbWVudDtcbiAgICAgIG5vZGUuY2xvc2luZ0ZyYWdtZW50ID0gY2xvc2luZ0VsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUub3BlbmluZ0VsZW1lbnQgPSBvcGVuaW5nRWxlbWVudDtcbiAgICAgIG5vZGUuY2xvc2luZ0VsZW1lbnQgPSBjbG9zaW5nRWxlbWVudDtcbiAgICB9XG4gICAgbm9kZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShKc3hFcnJvcnMuVW53cmFwcGVkQWRqYWNlbnRKU1hFbGVtZW50cywgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgfVxuICAgIHJldHVybiBpc0ZyYWdtZW50KG9wZW5pbmdFbGVtZW50KSA/IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWEZyYWdtZW50XCIpIDogdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSlNYRWxlbWVudFwiKTtcbiAgfVxuICBqc3hQYXJzZUVsZW1lbnQoKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmpzeFBhcnNlRWxlbWVudEF0KHN0YXJ0TG9jKTtcbiAgfVxuICBzZXRDb250ZXh0KG5ld0NvbnRleHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0XG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29udGV4dFtjb250ZXh0Lmxlbmd0aCAtIDFdID0gbmV3Q29udGV4dDtcbiAgfVxuICBwYXJzZUV4cHJBdG9tKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxNDMpKSB7XG4gICAgICByZXR1cm4gdGhpcy5qc3hQYXJzZUVsZW1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goNDcpICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcykgIT09IDMzKSB7XG4gICAgICB0aGlzLnJlcGxhY2VUb2tlbigxNDMpO1xuICAgICAgcmV0dXJuIHRoaXMuanN4UGFyc2VFbGVtZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdXBlci5wYXJzZUV4cHJBdG9tKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIH1cbiAgfVxuICBza2lwU3BhY2UoKSB7XG4gICAgY29uc3QgY3VyQ29udGV4dCA9IHRoaXMuY3VyQ29udGV4dCgpO1xuICAgIGlmICghY3VyQ29udGV4dC5wcmVzZXJ2ZVNwYWNlKSBzdXBlci5za2lwU3BhY2UoKTtcbiAgfVxuICBnZXRUb2tlbkZyb21Db2RlKGNvZGUpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gICAgaWYgKGNvbnRleHQgPT09IHR5cGVzLmpfZXhwcikge1xuICAgICAgdGhpcy5qc3hSZWFkVG9rZW4oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQgPT09IHR5cGVzLmpfb1RhZyB8fCBjb250ZXh0ID09PSB0eXBlcy5qX2NUYWcpIHtcbiAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjb2RlKSkge1xuICAgICAgICB0aGlzLmpzeFJlYWRXb3JkKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSA2Mikge1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDE0NCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgoY29kZSA9PT0gMzQgfHwgY29kZSA9PT0gMzkpICYmIGNvbnRleHQgPT09IHR5cGVzLmpfb1RhZykge1xuICAgICAgICB0aGlzLmpzeFJlYWRTdHJpbmcoY29kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IDYwICYmIHRoaXMuc3RhdGUuY2FuU3RhcnRKU1hFbGVtZW50ICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpICE9PSAzMykge1xuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTQzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKTtcbiAgfVxuICB1cGRhdGVDb250ZXh0KHByZXZUeXBlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodHlwZSA9PT0gNTYgJiYgcHJldlR5cGUgPT09IDE0Mykge1xuICAgICAgY29udGV4dC5zcGxpY2UoLTIsIDIsIHR5cGVzLmpfY1RhZyk7XG4gICAgICB0aGlzLnN0YXRlLmNhblN0YXJ0SlNYRWxlbWVudCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMTQzKSB7XG4gICAgICBjb250ZXh0LnB1c2godHlwZXMual9vVGFnKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDE0NCkge1xuICAgICAgY29uc3Qgb3V0ID0gY29udGV4dFtjb250ZXh0Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKG91dCA9PT0gdHlwZXMual9vVGFnICYmIHByZXZUeXBlID09PSA1NiB8fCBvdXQgPT09IHR5cGVzLmpfY1RhZykge1xuICAgICAgICBjb250ZXh0LnBvcCgpO1xuICAgICAgICB0aGlzLnN0YXRlLmNhblN0YXJ0SlNYRWxlbWVudCA9IGNvbnRleHRbY29udGV4dC5sZW5ndGggLSAxXSA9PT0gdHlwZXMual9leHByO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRDb250ZXh0KHR5cGVzLmpfZXhwcik7XG4gICAgICAgIHRoaXMuc3RhdGUuY2FuU3RhcnRKU1hFbGVtZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZS5jYW5TdGFydEpTWEVsZW1lbnQgPSB0b2tlbkNvbWVzQmVmb3JlRXhwcmVzc2lvbih0eXBlKTtcbiAgICB9XG4gIH1cbn07XG5jbGFzcyBUeXBlU2NyaXB0U2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLnRzTmFtZXMgPSBuZXcgTWFwKCk7XG4gIH1cbn1cbmNsYXNzIFR5cGVTY3JpcHRTY29wZUhhbmRsZXIgZXh0ZW5kcyBTY29wZUhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgdGhpcy5pbXBvcnRzU3RhY2sgPSBbXTtcbiAgfVxuICBjcmVhdGVTY29wZShmbGFncykge1xuICAgIHRoaXMuaW1wb3J0c1N0YWNrLnB1c2gobmV3IFNldCgpKTtcbiAgICByZXR1cm4gbmV3IFR5cGVTY3JpcHRTY29wZShmbGFncyk7XG4gIH1cbiAgZW50ZXIoZmxhZ3MpIHtcbiAgICBpZiAoZmxhZ3MgPT09IDI1Nikge1xuICAgICAgdGhpcy5pbXBvcnRzU3RhY2sucHVzaChuZXcgU2V0KCkpO1xuICAgIH1cbiAgICBzdXBlci5lbnRlcihmbGFncyk7XG4gIH1cbiAgZXhpdCgpIHtcbiAgICBjb25zdCBmbGFncyA9IHN1cGVyLmV4aXQoKTtcbiAgICBpZiAoZmxhZ3MgPT09IDI1Nikge1xuICAgICAgdGhpcy5pbXBvcnRzU3RhY2sucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiBmbGFncztcbiAgfVxuICBoYXNJbXBvcnQobmFtZSwgYWxsb3dTaGFkb3cpIHtcbiAgICBjb25zdCBsZW4gPSB0aGlzLmltcG9ydHNTdGFjay5sZW5ndGg7XG4gICAgaWYgKHRoaXMuaW1wb3J0c1N0YWNrW2xlbiAtIDFdLmhhcyhuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghYWxsb3dTaGFkb3cgJiYgbGVuID4gMSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuaW1wb3J0c1N0YWNrW2ldLmhhcyhuYW1lKSkgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkZWNsYXJlTmFtZShuYW1lLCBiaW5kaW5nVHlwZSwgbG9jKSB7XG4gICAgaWYgKGJpbmRpbmdUeXBlICYgNDA5Nikge1xuICAgICAgaWYgKHRoaXMuaGFzSW1wb3J0KG5hbWUsIHRydWUpKSB7XG4gICAgICAgIHRoaXMucGFyc2VyLnJhaXNlKEVycm9ycy5WYXJSZWRlY2xhcmF0aW9uLCBsb2MsIHtcbiAgICAgICAgICBpZGVudGlmaWVyTmFtZTogbmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW1wb3J0c1N0YWNrW3RoaXMuaW1wb3J0c1N0YWNrLmxlbmd0aCAtIDFdLmFkZChuYW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgIGxldCB0eXBlID0gc2NvcGUudHNOYW1lcy5nZXQobmFtZSkgfHwgMDtcbiAgICBpZiAoYmluZGluZ1R5cGUgJiAxMDI0KSB7XG4gICAgICB0aGlzLm1heWJlRXhwb3J0RGVmaW5lZChzY29wZSwgbmFtZSk7XG4gICAgICBzY29wZS50c05hbWVzLnNldChuYW1lLCB0eXBlIHwgMTYpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5kZWNsYXJlTmFtZShuYW1lLCBiaW5kaW5nVHlwZSwgbG9jKTtcbiAgICBpZiAoYmluZGluZ1R5cGUgJiAyKSB7XG4gICAgICBpZiAoIShiaW5kaW5nVHlwZSAmIDEpKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZWRlY2xhcmF0aW9uSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUsIGxvYyk7XG4gICAgICAgIHRoaXMubWF5YmVFeHBvcnREZWZpbmVkKHNjb3BlLCBuYW1lKTtcbiAgICAgIH1cbiAgICAgIHR5cGUgPSB0eXBlIHwgMTtcbiAgICB9XG4gICAgaWYgKGJpbmRpbmdUeXBlICYgMjU2KSB7XG4gICAgICB0eXBlID0gdHlwZSB8IDI7XG4gICAgfVxuICAgIGlmIChiaW5kaW5nVHlwZSAmIDUxMikge1xuICAgICAgdHlwZSA9IHR5cGUgfCA0O1xuICAgIH1cbiAgICBpZiAoYmluZGluZ1R5cGUgJiAxMjgpIHtcbiAgICAgIHR5cGUgPSB0eXBlIHwgODtcbiAgICB9XG4gICAgaWYgKHR5cGUpIHNjb3BlLnRzTmFtZXMuc2V0KG5hbWUsIHR5cGUpO1xuICB9XG4gIGlzUmVkZWNsYXJlZEluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlKSB7XG4gICAgY29uc3QgdHlwZSA9IHNjb3BlLnRzTmFtZXMuZ2V0KG5hbWUpO1xuICAgIGlmICgodHlwZSAmIDIpID4gMCkge1xuICAgICAgaWYgKGJpbmRpbmdUeXBlICYgMjU2KSB7XG4gICAgICAgIGNvbnN0IGlzQ29uc3QgPSAhIShiaW5kaW5nVHlwZSAmIDUxMik7XG4gICAgICAgIGNvbnN0IHdhc0NvbnN0ID0gKHR5cGUgJiA0KSA+IDA7XG4gICAgICAgIHJldHVybiBpc0NvbnN0ICE9PSB3YXNDb25zdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoYmluZGluZ1R5cGUgJiAxMjggJiYgKHR5cGUgJiA4KSA+IDApIHtcbiAgICAgIGlmIChzY29wZS5uYW1lcy5nZXQobmFtZSkgJiAyKSB7XG4gICAgICAgIHJldHVybiAhIShiaW5kaW5nVHlwZSAmIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmluZGluZ1R5cGUgJiAyICYmICh0eXBlICYgMSkgPiAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzUmVkZWNsYXJlZEluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlKTtcbiAgfVxuICBjaGVja0xvY2FsRXhwb3J0KGlkKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZVxuICAgIH0gPSBpZDtcbiAgICBpZiAodGhpcy5oYXNJbXBvcnQobmFtZSkpIHJldHVybjtcbiAgICBjb25zdCBsZW4gPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICBjb25zdCB0eXBlID0gc2NvcGUudHNOYW1lcy5nZXQobmFtZSk7XG4gICAgICBpZiAoKHR5cGUgJiAxKSA+IDAgfHwgKHR5cGUgJiAxNikgPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIuY2hlY2tMb2NhbEV4cG9ydChpZCk7XG4gIH1cbn1cbmNvbnN0IHVud3JhcFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uID0gbm9kZSA9PiB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIiA/IHVud3JhcFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbikgOiBub2RlO1xufTtcbmNsYXNzIExWYWxQYXJzZXIgZXh0ZW5kcyBOb2RlVXRpbHMge1xuICB0b0Fzc2lnbmFibGUobm9kZSwgaXNMSFMgPSBmYWxzZSkge1xuICAgIHZhciBfbm9kZSRleHRyYSwgX25vZGUkZXh0cmEzO1xuICAgIGxldCBwYXJlbnRoZXNpemVkID0gdW5kZWZpbmVkO1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIiB8fCAoX25vZGUkZXh0cmEgPSBub2RlLmV4dHJhKSAhPSBudWxsICYmIF9ub2RlJGV4dHJhLnBhcmVudGhlc2l6ZWQpIHtcbiAgICAgIHBhcmVudGhlc2l6ZWQgPSB1bndyYXBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbihub2RlKTtcbiAgICAgIGlmIChpc0xIUykge1xuICAgICAgICBpZiAocGFyZW50aGVzaXplZC50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLnJlY29yZEFycm93UGFyYW1ldGVyQmluZGluZ0Vycm9yKEVycm9ycy5JbnZhbGlkUGFyZW50aGVzaXplZEFzc2lnbm1lbnQsIG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmVudGhlc2l6ZWQudHlwZSAhPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgIXRoaXMuaXNPcHRpb25hbE1lbWJlckV4cHJlc3Npb24ocGFyZW50aGVzaXplZCkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkUGFyZW50aGVzaXplZEFzc2lnbm1lbnQsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkUGFyZW50aGVzaXplZEFzc2lnbm1lbnQsIG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICAgIG5vZGUudHlwZSA9IFwiT2JqZWN0UGF0dGVyblwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gbm9kZS5wcm9wZXJ0aWVzLmxlbmd0aCwgbGFzdCA9IGxlbmd0aCAtIDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBfbm9kZSRleHRyYTI7XG4gICAgICAgICAgY29uc3QgcHJvcCA9IG5vZGUucHJvcGVydGllc1tpXTtcbiAgICAgICAgICBjb25zdCBpc0xhc3QgPSBpID09PSBsYXN0O1xuICAgICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlT2JqZWN0RXhwcmVzc2lvblByb3AocHJvcCwgaXNMYXN0LCBpc0xIUyk7XG4gICAgICAgICAgaWYgKGlzTGFzdCAmJiBwcm9wLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIiAmJiAoX25vZGUkZXh0cmEyID0gbm9kZS5leHRyYSkgIT0gbnVsbCAmJiBfbm9kZSRleHRyYTIudHJhaWxpbmdDb21tYUxvYykge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUmVzdFRyYWlsaW5nQ29tbWEsIG5vZGUuZXh0cmEudHJhaWxpbmdDb21tYUxvYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIk9iamVjdFByb3BlcnR5XCI6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSBub2RlO1xuICAgICAgICAgIGlmICh0aGlzLmlzUHJpdmF0ZU5hbWUoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5jbGFzc1Njb3BlLnVzZVByaXZhdGVOYW1lKHRoaXMuZ2V0UHJpdmF0ZU5hbWVTVihrZXkpLCBrZXkubG9jLnN0YXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUodmFsdWUsIGlzTEhTKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIlNwcmVhZEVsZW1lbnRcIjpcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIEBiYWJlbC9wYXJzZXIgZXJyb3IgKHRoaXMgaXMgYSBidWcsIHBsZWFzZSByZXBvcnQgaXQpLlwiICsgXCIgU3ByZWFkRWxlbWVudCBzaG91bGQgYmUgY29udmVydGVkIGJ5IC50b0Fzc2lnbmFibGUncyBjYWxsZXIuXCIpO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICAgIG5vZGUudHlwZSA9IFwiQXJyYXlQYXR0ZXJuXCI7XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlTGlzdChub2RlLmVsZW1lbnRzLCAoX25vZGUkZXh0cmEzID0gbm9kZS5leHRyYSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGV4dHJhMy50cmFpbGluZ0NvbW1hTG9jLCBpc0xIUyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmIChub2RlLm9wZXJhdG9yICE9PSBcIj1cIikge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk1pc3NpbmdFcUluQXNzaWdubWVudCwgbm9kZS5sZWZ0LmxvYy5lbmQpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUudHlwZSA9IFwiQXNzaWdubWVudFBhdHRlcm5cIjtcbiAgICAgICAgZGVsZXRlIG5vZGUub3BlcmF0b3I7XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUubGVmdCwgaXNMSFMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShwYXJlbnRoZXNpemVkLCBpc0xIUyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0b0Fzc2lnbmFibGVPYmplY3RFeHByZXNzaW9uUHJvcChwcm9wLCBpc0xhc3QsIGlzTEhTKSB7XG4gICAgaWYgKHByb3AudHlwZSA9PT0gXCJPYmplY3RNZXRob2RcIikge1xuICAgICAgdGhpcy5yYWlzZShwcm9wLmtpbmQgPT09IFwiZ2V0XCIgfHwgcHJvcC5raW5kID09PSBcInNldFwiID8gRXJyb3JzLlBhdHRlcm5IYXNBY2Nlc3NvciA6IEVycm9ycy5QYXR0ZXJuSGFzTWV0aG9kLCBwcm9wLmtleSk7XG4gICAgfSBlbHNlIGlmIChwcm9wLnR5cGUgPT09IFwiU3ByZWFkRWxlbWVudFwiKSB7XG4gICAgICBwcm9wLnR5cGUgPSBcIlJlc3RFbGVtZW50XCI7XG4gICAgICBjb25zdCBhcmcgPSBwcm9wLmFyZ3VtZW50O1xuICAgICAgdGhpcy5jaGVja1RvUmVzdENvbnZlcnNpb24oYXJnLCBmYWxzZSk7XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShhcmcsIGlzTEhTKTtcbiAgICAgIGlmICghaXNMYXN0KSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlJlc3RUcmFpbGluZ0NvbW1hLCBwcm9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50b0Fzc2lnbmFibGUocHJvcCwgaXNMSFMpO1xuICAgIH1cbiAgfVxuICB0b0Fzc2lnbmFibGVMaXN0KGV4cHJMaXN0LCB0cmFpbGluZ0NvbW1hTG9jLCBpc0xIUykge1xuICAgIGNvbnN0IGVuZCA9IGV4cHJMaXN0Lmxlbmd0aCAtIDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsdCA9IGV4cHJMaXN0W2ldO1xuICAgICAgaWYgKCFlbHQpIGNvbnRpbnVlO1xuICAgICAgdGhpcy50b0Fzc2lnbmFibGVMaXN0SXRlbShleHByTGlzdCwgaSwgaXNMSFMpO1xuICAgICAgaWYgKGVsdC50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpIHtcbiAgICAgICAgaWYgKGkgPCBlbmQpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5SZXN0VHJhaWxpbmdDb21tYSwgZWx0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0cmFpbGluZ0NvbW1hTG9jKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUmVzdFRyYWlsaW5nQ29tbWEsIHRyYWlsaW5nQ29tbWFMb2MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRvQXNzaWduYWJsZUxpc3RJdGVtKGV4cHJMaXN0LCBpbmRleCwgaXNMSFMpIHtcbiAgICBjb25zdCBub2RlID0gZXhwckxpc3RbaW5kZXhdO1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiU3ByZWFkRWxlbWVudFwiKSB7XG4gICAgICBub2RlLnR5cGUgPSBcIlJlc3RFbGVtZW50XCI7XG4gICAgICBjb25zdCBhcmcgPSBub2RlLmFyZ3VtZW50O1xuICAgICAgdGhpcy5jaGVja1RvUmVzdENvbnZlcnNpb24oYXJnLCB0cnVlKTtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKGFyZywgaXNMSFMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLCBpc0xIUyk7XG4gICAgfVxuICB9XG4gIGlzQXNzaWduYWJsZShub2RlLCBpc0JpbmRpbmcpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsYXN0ID0gbm9kZS5wcm9wZXJ0aWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgcmV0dXJuIG5vZGUucHJvcGVydGllcy5ldmVyeSgocHJvcCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHByb3AudHlwZSAhPT0gXCJPYmplY3RNZXRob2RcIiAmJiAoaSA9PT0gbGFzdCB8fCBwcm9wLnR5cGUgIT09IFwiU3ByZWFkRWxlbWVudFwiKSAmJiB0aGlzLmlzQXNzaWduYWJsZShwcm9wKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIk9iamVjdFByb3BlcnR5XCI6XG4gICAgICAgIHJldHVybiB0aGlzLmlzQXNzaWduYWJsZShub2RlLnZhbHVlKTtcbiAgICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgICAgIHJldHVybiB0aGlzLmlzQXNzaWduYWJsZShub2RlLmFyZ3VtZW50KTtcbiAgICAgIGNhc2UgXCJBcnJheUV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIG5vZGUuZWxlbWVudHMuZXZlcnkoZWxlbWVudCA9PiBlbGVtZW50ID09PSBudWxsIHx8IHRoaXMuaXNBc3NpZ25hYmxlKGVsZW1lbnQpKTtcbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gbm9kZS5vcGVyYXRvciA9PT0gXCI9XCI7XG4gICAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNBc3NpZ25hYmxlKG5vZGUuZXhwcmVzc2lvbik7XG4gICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gIWlzQmluZGluZztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgdG9SZWZlcmVuY2VkTGlzdChleHByTGlzdCwgaXNQYXJlbnRoZXNpemVkRXhwcikge1xuICAgIHJldHVybiBleHByTGlzdDtcbiAgfVxuICB0b1JlZmVyZW5jZWRMaXN0RGVlcChleHByTGlzdCwgaXNQYXJlbnRoZXNpemVkRXhwcikge1xuICAgIHRoaXMudG9SZWZlcmVuY2VkTGlzdChleHByTGlzdCwgaXNQYXJlbnRoZXNpemVkRXhwcik7XG4gICAgZm9yIChjb25zdCBleHByIG9mIGV4cHJMaXN0KSB7XG4gICAgICBpZiAoKGV4cHIgPT0gbnVsbCA/IHZvaWQgMCA6IGV4cHIudHlwZSkgPT09IFwiQXJyYXlFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgdGhpcy50b1JlZmVyZW5jZWRMaXN0RGVlcChleHByLmVsZW1lbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGFyc2VTcHJlYWQocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKHJlZkV4cHJlc3Npb25FcnJvcnMsIHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNwcmVhZEVsZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VSZXN0QmluZGluZygpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJlc3RFbGVtZW50XCIpO1xuICB9XG4gIHBhcnNlQmluZGluZ0F0b20oKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QoMywgOTMsIDEpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJheVBhdHRlcm5cIik7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmplY3RMaWtlKDgsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgfVxuICBwYXJzZUJpbmRpbmdMaXN0KGNsb3NlLCBjbG9zZUNoYXJDb2RlLCBmbGFncykge1xuICAgIGNvbnN0IGFsbG93RW1wdHkgPSBmbGFncyAmIDE7XG4gICAgY29uc3QgZWx0cyA9IFtdO1xuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgfVxuICAgICAgaWYgKGFsbG93RW1wdHkgJiYgdGhpcy5tYXRjaCgxMikpIHtcbiAgICAgICAgZWx0cy5wdXNoKG51bGwpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmVhdChjbG9zZSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goMjEpKSB7XG4gICAgICAgIGxldCByZXN0ID0gdGhpcy5wYXJzZVJlc3RCaW5kaW5nKCk7XG4gICAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImZsb3dcIikgfHwgZmxhZ3MgJiAyKSB7XG4gICAgICAgICAgcmVzdCA9IHRoaXMucGFyc2VGdW5jdGlvblBhcmFtVHlwZShyZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHRzLnB1c2gocmVzdCk7XG4gICAgICAgIGlmICghdGhpcy5jaGVja0NvbW1hQWZ0ZXJSZXN0KGNsb3NlQ2hhckNvZGUpKSB7XG4gICAgICAgICAgdGhpcy5leHBlY3QoY2xvc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBkZWNvcmF0b3JzID0gW107XG4gICAgICAgIGlmIChmbGFncyAmIDIpIHtcbiAgICAgICAgICBpZiAodGhpcy5tYXRjaCgyNikgJiYgdGhpcy5oYXNQbHVnaW4oXCJkZWNvcmF0b3JzXCIpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbnN1cHBvcnRlZFBhcmFtZXRlckRlY29yYXRvciwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlICh0aGlzLm1hdGNoKDI2KSkge1xuICAgICAgICAgICAgZGVjb3JhdG9ycy5wdXNoKHRoaXMucGFyc2VEZWNvcmF0b3IoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsdHMucHVzaCh0aGlzLnBhcnNlQmluZGluZ0VsZW1lbnQoZmxhZ3MsIGRlY29yYXRvcnMpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsdHM7XG4gIH1cbiAgcGFyc2VCaW5kaW5nUmVzdFByb3BlcnR5KHByb3ApIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBwcm9wLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICB0aGlzLmNoZWNrQ29tbWFBZnRlclJlc3QoMTI1KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiUmVzdEVsZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VCaW5kaW5nUHJvcGVydHkoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIHN0YXJ0TG9jXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHR5cGUgPT09IDIxKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUJpbmRpbmdSZXN0UHJvcGVydHkodGhpcy5zdGFydE5vZGUoKSk7XG4gICAgfVxuICAgIGNvbnN0IHByb3AgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGlmICh0eXBlID09PSAxMzkpIHtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiZGVzdHJ1Y3R1cmluZ1ByaXZhdGVcIiwgc3RhcnRMb2MpO1xuICAgICAgdGhpcy5jbGFzc1Njb3BlLnVzZVByaXZhdGVOYW1lKHRoaXMuc3RhdGUudmFsdWUsIHN0YXJ0TG9jKTtcbiAgICAgIHByb3Aua2V5ID0gdGhpcy5wYXJzZVByaXZhdGVOYW1lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgfVxuICAgIHByb3AubWV0aG9kID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VPYmpQcm9wVmFsdWUocHJvcCwgc3RhcnRMb2MsIGZhbHNlLCBmYWxzZSwgdHJ1ZSwgZmFsc2UpO1xuICB9XG4gIHBhcnNlQmluZGluZ0VsZW1lbnQoZmxhZ3MsIGRlY29yYXRvcnMpIHtcbiAgICBjb25zdCBsZWZ0ID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCgpO1xuICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImZsb3dcIikgfHwgZmxhZ3MgJiAyKSB7XG4gICAgICB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbVR5cGUobGVmdCk7XG4gICAgfVxuICAgIGNvbnN0IGVsdCA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQobGVmdC5sb2Muc3RhcnQsIGxlZnQpO1xuICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCkge1xuICAgICAgbGVmdC5kZWNvcmF0b3JzID0gZGVjb3JhdG9ycztcbiAgICB9XG4gICAgcmV0dXJuIGVsdDtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uUGFyYW1UeXBlKHBhcmFtKSB7XG4gICAgcmV0dXJuIHBhcmFtO1xuICB9XG4gIHBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0TG9jLCBsZWZ0KSB7XG4gICAgc3RhcnRMb2MgIT0gbnVsbCA/IHN0YXJ0TG9jIDogc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGxlZnQgPSBsZWZ0ICE9IG51bGwgPyBsZWZ0IDogdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgaWYgKCF0aGlzLmVhdCgyOSkpIHJldHVybiBsZWZ0O1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICBub2RlLmxlZnQgPSBsZWZ0O1xuICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpO1xuICB9XG4gIGlzVmFsaWRMVmFsKHR5cGUsIGlzVW5wYXJlbnRoZXNpemVkSW5Bc3NpZ24sIGJpbmRpbmcpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgICByZXR1cm4gXCJsZWZ0XCI7XG4gICAgICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIFwiYXJndW1lbnRcIjtcbiAgICAgIGNhc2UgXCJPYmplY3RQcm9wZXJ0eVwiOlxuICAgICAgICByZXR1cm4gXCJ2YWx1ZVwiO1xuICAgICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBcImV4cHJlc3Npb25cIjtcbiAgICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgICAgcmV0dXJuIFwiZWxlbWVudHNcIjtcbiAgICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgICAgIHJldHVybiBcInByb3BlcnRpZXNcIjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlzT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcbiAgICByZXR1cm4gZXhwcmVzc2lvbi50eXBlID09PSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiO1xuICB9XG4gIGNoZWNrTFZhbChleHByZXNzaW9uLCBhbmNlc3RvciwgYmluZGluZyA9IDY0LCBjaGVja0NsYXNoZXMgPSBmYWxzZSwgc3RyaWN0TW9kZUNoYW5nZWQgPSBmYWxzZSwgaGFzUGFyZW50aGVzaXplZEFuY2VzdG9yID0gZmFsc2UpIHtcbiAgICB2YXIgX2V4cHJlc3Npb24kZXh0cmE7XG4gICAgY29uc3QgdHlwZSA9IGV4cHJlc3Npb24udHlwZTtcbiAgICBpZiAodGhpcy5pc09iamVjdE1ldGhvZChleHByZXNzaW9uKSkgcmV0dXJuO1xuICAgIGNvbnN0IGlzT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uID0gdGhpcy5pc09wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbihleHByZXNzaW9uKTtcbiAgICBpZiAoaXNPcHRpb25hbE1lbWJlckV4cHJlc3Npb24gfHwgdHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICAgIGlmIChpc09wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbikge1xuICAgICAgICB0aGlzLmV4cGVjdFBsdWdpbihcIm9wdGlvbmFsQ2hhaW5pbmdBc3NpZ25cIiwgZXhwcmVzc2lvbi5sb2Muc3RhcnQpO1xuICAgICAgICBpZiAoYW5jZXN0b3IudHlwZSAhPT0gXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZExoc09wdGlvbmFsQ2hhaW5pbmcsIGV4cHJlc3Npb24sIHtcbiAgICAgICAgICAgIGFuY2VzdG9yXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChiaW5kaW5nICE9PSA2NCkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkUHJvcGVydHlCaW5kaW5nUGF0dGVybiwgZXhwcmVzc2lvbik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgdGhpcy5jaGVja0lkZW50aWZpZXIoZXhwcmVzc2lvbiwgYmluZGluZywgc3RyaWN0TW9kZUNoYW5nZWQpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lXG4gICAgICB9ID0gZXhwcmVzc2lvbjtcbiAgICAgIGlmIChjaGVja0NsYXNoZXMpIHtcbiAgICAgICAgaWYgKGNoZWNrQ2xhc2hlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5QYXJhbUR1cGUsIGV4cHJlc3Npb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoZWNrQ2xhc2hlcy5hZGQobmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRpdHkgPSB0aGlzLmlzVmFsaWRMVmFsKHR5cGUsICEoaGFzUGFyZW50aGVzaXplZEFuY2VzdG9yIHx8IChfZXhwcmVzc2lvbiRleHRyYSA9IGV4cHJlc3Npb24uZXh0cmEpICE9IG51bGwgJiYgX2V4cHJlc3Npb24kZXh0cmEucGFyZW50aGVzaXplZCkgJiYgYW5jZXN0b3IudHlwZSA9PT0gXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLCBiaW5kaW5nKTtcbiAgICBpZiAodmFsaWRpdHkgPT09IHRydWUpIHJldHVybjtcbiAgICBpZiAodmFsaWRpdHkgPT09IGZhbHNlKSB7XG4gICAgICBjb25zdCBQYXJzZUVycm9yQ2xhc3MgPSBiaW5kaW5nID09PSA2NCA/IEVycm9ycy5JbnZhbGlkTGhzIDogRXJyb3JzLkludmFsaWRMaHNCaW5kaW5nO1xuICAgICAgdGhpcy5yYWlzZShQYXJzZUVycm9yQ2xhc3MsIGV4cHJlc3Npb24sIHtcbiAgICAgICAgYW5jZXN0b3JcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQga2V5LCBpc1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uO1xuICAgIGlmICh0eXBlb2YgdmFsaWRpdHkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGtleSA9IHZhbGlkaXR5O1xuICAgICAgaXNQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiA9IHR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgW2tleSwgaXNQYXJlbnRoZXNpemVkRXhwcmVzc2lvbl0gPSB2YWxpZGl0eTtcbiAgICB9XG4gICAgY29uc3QgbmV4dEFuY2VzdG9yID0gdHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIiB8fCB0eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIiA/IHtcbiAgICAgIHR5cGVcbiAgICB9IDogYW5jZXN0b3I7XG4gICAgY29uc3QgdmFsID0gZXhwcmVzc2lvbltrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdmFsKSB7XG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgIHRoaXMuY2hlY2tMVmFsKGNoaWxkLCBuZXh0QW5jZXN0b3IsIGJpbmRpbmcsIGNoZWNrQ2xhc2hlcywgc3RyaWN0TW9kZUNoYW5nZWQsIGlzUGFyZW50aGVzaXplZEV4cHJlc3Npb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWwpIHtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKHZhbCwgbmV4dEFuY2VzdG9yLCBiaW5kaW5nLCBjaGVja0NsYXNoZXMsIHN0cmljdE1vZGVDaGFuZ2VkLCBpc1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uKTtcbiAgICB9XG4gIH1cbiAgY2hlY2tJZGVudGlmaWVyKGF0LCBiaW5kaW5nVHlwZSwgc3RyaWN0TW9kZUNoYW5nZWQgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLnN0YXRlLnN0cmljdCAmJiAoc3RyaWN0TW9kZUNoYW5nZWQgPyBpc1N0cmljdEJpbmRSZXNlcnZlZFdvcmQoYXQubmFtZSwgdGhpcy5pbk1vZHVsZSkgOiBpc1N0cmljdEJpbmRPbmx5UmVzZXJ2ZWRXb3JkKGF0Lm5hbWUpKSkge1xuICAgICAgaWYgKGJpbmRpbmdUeXBlID09PSA2NCkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5TdHJpY3RFdmFsQXJndW1lbnRzLCBhdCwge1xuICAgICAgICAgIHJlZmVyZW5jZU5hbWU6IGF0Lm5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5TdHJpY3RFdmFsQXJndW1lbnRzQmluZGluZywgYXQsIHtcbiAgICAgICAgICBiaW5kaW5nTmFtZTogYXQubmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJpbmRpbmdUeXBlICYgODE5MiAmJiBhdC5uYW1lID09PSBcImxldFwiKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5MZXRJbkxleGljYWxCaW5kaW5nLCBhdCk7XG4gICAgfVxuICAgIGlmICghKGJpbmRpbmdUeXBlICYgNjQpKSB7XG4gICAgICB0aGlzLmRlY2xhcmVOYW1lRnJvbUlkZW50aWZpZXIoYXQsIGJpbmRpbmdUeXBlKTtcbiAgICB9XG4gIH1cbiAgZGVjbGFyZU5hbWVGcm9tSWRlbnRpZmllcihpZGVudGlmaWVyLCBiaW5kaW5nKSB7XG4gICAgdGhpcy5zY29wZS5kZWNsYXJlTmFtZShpZGVudGlmaWVyLm5hbWUsIGJpbmRpbmcsIGlkZW50aWZpZXIubG9jLnN0YXJ0KTtcbiAgfVxuICBjaGVja1RvUmVzdENvbnZlcnNpb24obm9kZSwgYWxsb3dQYXR0ZXJuKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgICB0aGlzLmNoZWNrVG9SZXN0Q29udmVyc2lvbihub2RlLmV4cHJlc3Npb24sIGFsbG93UGF0dGVybik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKGFsbG93UGF0dGVybikgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkUmVzdEFzc2lnbm1lbnRQYXR0ZXJuLCBub2RlKTtcbiAgICB9XG4gIH1cbiAgY2hlY2tDb21tYUFmdGVyUmVzdChjbG9zZSkge1xuICAgIGlmICghdGhpcy5tYXRjaCgxMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5yYWlzZSh0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IGNsb3NlID8gRXJyb3JzLlJlc3RUcmFpbGluZ0NvbW1hIDogRXJyb3JzLkVsZW1lbnRBZnRlclJlc3QsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBub25OdWxsKHgpIHtcbiAgaWYgKHggPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCAke3h9IHZhbHVlLmApO1xuICB9XG4gIHJldHVybiB4O1xufVxuZnVuY3Rpb24gYXNzZXJ0KHgpIHtcbiAgaWYgKCF4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQXNzZXJ0IGZhaWxcIik7XG4gIH1cbn1cbmNvbnN0IFRTRXJyb3JzID0gUGFyc2VFcnJvckVudW1gdHlwZXNjcmlwdGAoe1xuICBBYnN0cmFjdE1ldGhvZEhhc0ltcGxlbWVudGF0aW9uOiAoe1xuICAgIG1ldGhvZE5hbWVcbiAgfSkgPT4gYE1ldGhvZCAnJHttZXRob2ROYW1lfScgY2Fubm90IGhhdmUgYW4gaW1wbGVtZW50YXRpb24gYmVjYXVzZSBpdCBpcyBtYXJrZWQgYWJzdHJhY3QuYCxcbiAgQWJzdHJhY3RQcm9wZXJ0eUhhc0luaXRpYWxpemVyOiAoe1xuICAgIHByb3BlcnR5TmFtZVxuICB9KSA9PiBgUHJvcGVydHkgJyR7cHJvcGVydHlOYW1lfScgY2Fubm90IGhhdmUgYW4gaW5pdGlhbGl6ZXIgYmVjYXVzZSBpdCBpcyBtYXJrZWQgYWJzdHJhY3QuYCxcbiAgQWNjZXNzb3JDYW5ub3RCZU9wdGlvbmFsOiBcIkFuICdhY2Nlc3NvcicgcHJvcGVydHkgY2Fubm90IGJlIGRlY2xhcmVkIG9wdGlvbmFsLlwiLFxuICBBY2Nlc3NvckNhbm5vdERlY2xhcmVUaGlzUGFyYW1ldGVyOiBcIidnZXQnIGFuZCAnc2V0JyBhY2Nlc3NvcnMgY2Fubm90IGRlY2xhcmUgJ3RoaXMnIHBhcmFtZXRlcnMuXCIsXG4gIEFjY2Vzc29yQ2Fubm90SGF2ZVR5cGVQYXJhbWV0ZXJzOiBcIkFuIGFjY2Vzc29yIGNhbm5vdCBoYXZlIHR5cGUgcGFyYW1ldGVycy5cIixcbiAgQ2xhc3NNZXRob2RIYXNEZWNsYXJlOiBcIkNsYXNzIG1ldGhvZHMgY2Fubm90IGhhdmUgdGhlICdkZWNsYXJlJyBtb2RpZmllci5cIixcbiAgQ2xhc3NNZXRob2RIYXNSZWFkb25seTogXCJDbGFzcyBtZXRob2RzIGNhbm5vdCBoYXZlIHRoZSAncmVhZG9ubHknIG1vZGlmaWVyLlwiLFxuICBDb25zdEluaXRpYWxpemVyTXVzdEJlU3RyaW5nT3JOdW1lcmljTGl0ZXJhbE9yTGl0ZXJhbEVudW1SZWZlcmVuY2U6IFwiQSAnY29uc3QnIGluaXRpYWxpemVyIGluIGFuIGFtYmllbnQgY29udGV4dCBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWVyaWMgbGl0ZXJhbCBvciBsaXRlcmFsIGVudW0gcmVmZXJlbmNlLlwiLFxuICBDb25zdHJ1Y3Rvckhhc1R5cGVQYXJhbWV0ZXJzOiBcIlR5cGUgcGFyYW1ldGVycyBjYW5ub3QgYXBwZWFyIG9uIGEgY29uc3RydWN0b3IgZGVjbGFyYXRpb24uXCIsXG4gIERlY2xhcmVBY2Nlc3NvcjogKHtcbiAgICBraW5kXG4gIH0pID0+IGAnZGVjbGFyZScgaXMgbm90IGFsbG93ZWQgaW4gJHtraW5kfXRlcnMuYCxcbiAgRGVjbGFyZUNsYXNzRmllbGRIYXNJbml0aWFsaXplcjogXCJJbml0aWFsaXplcnMgYXJlIG5vdCBhbGxvd2VkIGluIGFtYmllbnQgY29udGV4dHMuXCIsXG4gIERlY2xhcmVGdW5jdGlvbkhhc0ltcGxlbWVudGF0aW9uOiBcIkFuIGltcGxlbWVudGF0aW9uIGNhbm5vdCBiZSBkZWNsYXJlZCBpbiBhbWJpZW50IGNvbnRleHRzLlwiLFxuICBEdXBsaWNhdGVBY2Nlc3NpYmlsaXR5TW9kaWZpZXI6ICh7XG4gICAgbW9kaWZpZXJcbiAgfSkgPT4gYEFjY2Vzc2liaWxpdHkgbW9kaWZpZXIgYWxyZWFkeSBzZWVuLmAsXG4gIER1cGxpY2F0ZU1vZGlmaWVyOiAoe1xuICAgIG1vZGlmaWVyXG4gIH0pID0+IGBEdXBsaWNhdGUgbW9kaWZpZXI6ICcke21vZGlmaWVyfScuYCxcbiAgRW1wdHlIZXJpdGFnZUNsYXVzZVR5cGU6ICh7XG4gICAgdG9rZW5cbiAgfSkgPT4gYCcke3Rva2VufScgbGlzdCBjYW5ub3QgYmUgZW1wdHkuYCxcbiAgRW1wdHlUeXBlQXJndW1lbnRzOiBcIlR5cGUgYXJndW1lbnQgbGlzdCBjYW5ub3QgYmUgZW1wdHkuXCIsXG4gIEVtcHR5VHlwZVBhcmFtZXRlcnM6IFwiVHlwZSBwYXJhbWV0ZXIgbGlzdCBjYW5ub3QgYmUgZW1wdHkuXCIsXG4gIEV4cGVjdGVkQW1iaWVudEFmdGVyRXhwb3J0RGVjbGFyZTogXCInZXhwb3J0IGRlY2xhcmUnIG11c3QgYmUgZm9sbG93ZWQgYnkgYW4gYW1iaWVudCBkZWNsYXJhdGlvbi5cIixcbiAgSW1wb3J0QWxpYXNIYXNJbXBvcnRUeXBlOiBcIkFuIGltcG9ydCBhbGlhcyBjYW4gbm90IHVzZSAnaW1wb3J0IHR5cGUnLlwiLFxuICBJbXBvcnRSZWZsZWN0aW9uSGFzSW1wb3J0VHlwZTogXCJBbiBgaW1wb3J0IG1vZHVsZWAgZGVjbGFyYXRpb24gY2FuIG5vdCB1c2UgYHR5cGVgIG1vZGlmaWVyXCIsXG4gIEluY29tcGF0aWJsZU1vZGlmaWVyczogKHtcbiAgICBtb2RpZmllcnNcbiAgfSkgPT4gYCcke21vZGlmaWVyc1swXX0nIG1vZGlmaWVyIGNhbm5vdCBiZSB1c2VkIHdpdGggJyR7bW9kaWZpZXJzWzFdfScgbW9kaWZpZXIuYCxcbiAgSW5kZXhTaWduYXR1cmVIYXNBYnN0cmFjdDogXCJJbmRleCBzaWduYXR1cmVzIGNhbm5vdCBoYXZlIHRoZSAnYWJzdHJhY3QnIG1vZGlmaWVyLlwiLFxuICBJbmRleFNpZ25hdHVyZUhhc0FjY2Vzc2liaWxpdHk6ICh7XG4gICAgbW9kaWZpZXJcbiAgfSkgPT4gYEluZGV4IHNpZ25hdHVyZXMgY2Fubm90IGhhdmUgYW4gYWNjZXNzaWJpbGl0eSBtb2RpZmllciAoJyR7bW9kaWZpZXJ9JykuYCxcbiAgSW5kZXhTaWduYXR1cmVIYXNEZWNsYXJlOiBcIkluZGV4IHNpZ25hdHVyZXMgY2Fubm90IGhhdmUgdGhlICdkZWNsYXJlJyBtb2RpZmllci5cIixcbiAgSW5kZXhTaWduYXR1cmVIYXNPdmVycmlkZTogXCInb3ZlcnJpZGUnIG1vZGlmaWVyIGNhbm5vdCBhcHBlYXIgb24gYW4gaW5kZXggc2lnbmF0dXJlLlwiLFxuICBJbmRleFNpZ25hdHVyZUhhc1N0YXRpYzogXCJJbmRleCBzaWduYXR1cmVzIGNhbm5vdCBoYXZlIHRoZSAnc3RhdGljJyBtb2RpZmllci5cIixcbiAgSW5pdGlhbGl6ZXJOb3RBbGxvd2VkSW5BbWJpZW50Q29udGV4dDogXCJJbml0aWFsaXplcnMgYXJlIG5vdCBhbGxvd2VkIGluIGFtYmllbnQgY29udGV4dHMuXCIsXG4gIEludmFsaWRIZXJpdGFnZUNsYXVzZVR5cGU6ICh7XG4gICAgdG9rZW5cbiAgfSkgPT4gYCcke3Rva2VufScgbGlzdCBjYW4gb25seSBpbmNsdWRlIGlkZW50aWZpZXJzIG9yIHF1YWxpZmllZC1uYW1lcyB3aXRoIG9wdGlvbmFsIHR5cGUgYXJndW1lbnRzLmAsXG4gIEludmFsaWRNb2RpZmllck9uVHlwZU1lbWJlcjogKHtcbiAgICBtb2RpZmllclxuICB9KSA9PiBgJyR7bW9kaWZpZXJ9JyBtb2RpZmllciBjYW5ub3QgYXBwZWFyIG9uIGEgdHlwZSBtZW1iZXIuYCxcbiAgSW52YWxpZE1vZGlmaWVyT25UeXBlUGFyYW1ldGVyOiAoe1xuICAgIG1vZGlmaWVyXG4gIH0pID0+IGAnJHttb2RpZmllcn0nIG1vZGlmaWVyIGNhbm5vdCBhcHBlYXIgb24gYSB0eXBlIHBhcmFtZXRlci5gLFxuICBJbnZhbGlkTW9kaWZpZXJPblR5cGVQYXJhbWV0ZXJQb3NpdGlvbnM6ICh7XG4gICAgbW9kaWZpZXJcbiAgfSkgPT4gYCcke21vZGlmaWVyfScgbW9kaWZpZXIgY2FuIG9ubHkgYXBwZWFyIG9uIGEgdHlwZSBwYXJhbWV0ZXIgb2YgYSBjbGFzcywgaW50ZXJmYWNlIG9yIHR5cGUgYWxpYXMuYCxcbiAgSW52YWxpZE1vZGlmaWVyc09yZGVyOiAoe1xuICAgIG9yZGVyZWRNb2RpZmllcnNcbiAgfSkgPT4gYCcke29yZGVyZWRNb2RpZmllcnNbMF19JyBtb2RpZmllciBtdXN0IHByZWNlZGUgJyR7b3JkZXJlZE1vZGlmaWVyc1sxXX0nIG1vZGlmaWVyLmAsXG4gIEludmFsaWRQcm9wZXJ0eUFjY2Vzc0FmdGVySW5zdGFudGlhdGlvbkV4cHJlc3Npb246IFwiSW52YWxpZCBwcm9wZXJ0eSBhY2Nlc3MgYWZ0ZXIgYW4gaW5zdGFudGlhdGlvbiBleHByZXNzaW9uLiBcIiArIFwiWW91IGNhbiBlaXRoZXIgd3JhcCB0aGUgaW5zdGFudGlhdGlvbiBleHByZXNzaW9uIGluIHBhcmVudGhlc2VzLCBvciBkZWxldGUgdGhlIHR5cGUgYXJndW1lbnRzLlwiLFxuICBJbnZhbGlkVHVwbGVNZW1iZXJMYWJlbDogXCJUdXBsZSBtZW1iZXJzIG11c3QgYmUgbGFiZWxlZCB3aXRoIGEgc2ltcGxlIGlkZW50aWZpZXIuXCIsXG4gIE1pc3NpbmdJbnRlcmZhY2VOYW1lOiBcIidpbnRlcmZhY2UnIGRlY2xhcmF0aW9ucyBtdXN0IGJlIGZvbGxvd2VkIGJ5IGFuIGlkZW50aWZpZXIuXCIsXG4gIE5vbkFic3RyYWN0Q2xhc3NIYXNBYnN0cmFjdE1ldGhvZDogXCJBYnN0cmFjdCBtZXRob2RzIGNhbiBvbmx5IGFwcGVhciB3aXRoaW4gYW4gYWJzdHJhY3QgY2xhc3MuXCIsXG4gIE5vbkNsYXNzTWV0aG9kUHJvcGVydHlIYXNBYnN0cmFjdE1vZGlmZXI6IFwiJ2Fic3RyYWN0JyBtb2RpZmllciBjYW4gb25seSBhcHBlYXIgb24gYSBjbGFzcywgbWV0aG9kLCBvciBwcm9wZXJ0eSBkZWNsYXJhdGlvbi5cIixcbiAgT3B0aW9uYWxUeXBlQmVmb3JlUmVxdWlyZWQ6IFwiQSByZXF1aXJlZCBlbGVtZW50IGNhbm5vdCBmb2xsb3cgYW4gb3B0aW9uYWwgZWxlbWVudC5cIixcbiAgT3ZlcnJpZGVOb3RJblN1YkNsYXNzOiBcIlRoaXMgbWVtYmVyIGNhbm5vdCBoYXZlIGFuICdvdmVycmlkZScgbW9kaWZpZXIgYmVjYXVzZSBpdHMgY29udGFpbmluZyBjbGFzcyBkb2VzIG5vdCBleHRlbmQgYW5vdGhlciBjbGFzcy5cIixcbiAgUGF0dGVybklzT3B0aW9uYWw6IFwiQSBiaW5kaW5nIHBhdHRlcm4gcGFyYW1ldGVyIGNhbm5vdCBiZSBvcHRpb25hbCBpbiBhbiBpbXBsZW1lbnRhdGlvbiBzaWduYXR1cmUuXCIsXG4gIFByaXZhdGVFbGVtZW50SGFzQWJzdHJhY3Q6IFwiUHJpdmF0ZSBlbGVtZW50cyBjYW5ub3QgaGF2ZSB0aGUgJ2Fic3RyYWN0JyBtb2RpZmllci5cIixcbiAgUHJpdmF0ZUVsZW1lbnRIYXNBY2Nlc3NpYmlsaXR5OiAoe1xuICAgIG1vZGlmaWVyXG4gIH0pID0+IGBQcml2YXRlIGVsZW1lbnRzIGNhbm5vdCBoYXZlIGFuIGFjY2Vzc2liaWxpdHkgbW9kaWZpZXIgKCcke21vZGlmaWVyfScpLmAsXG4gIFJlYWRvbmx5Rm9yTWV0aG9kU2lnbmF0dXJlOiBcIidyZWFkb25seScgbW9kaWZpZXIgY2FuIG9ubHkgYXBwZWFyIG9uIGEgcHJvcGVydHkgZGVjbGFyYXRpb24gb3IgaW5kZXggc2lnbmF0dXJlLlwiLFxuICBSZXNlcnZlZEFycm93VHlwZVBhcmFtOiBcIlRoaXMgc3ludGF4IGlzIHJlc2VydmVkIGluIGZpbGVzIHdpdGggdGhlIC5tdHMgb3IgLmN0cyBleHRlbnNpb24uIEFkZCBhIHRyYWlsaW5nIGNvbW1hLCBhcyBpbiBgPFQsPigpID0+IC4uLmAuXCIsXG4gIFJlc2VydmVkVHlwZUFzc2VydGlvbjogXCJUaGlzIHN5bnRheCBpcyByZXNlcnZlZCBpbiBmaWxlcyB3aXRoIHRoZSAubXRzIG9yIC5jdHMgZXh0ZW5zaW9uLiBVc2UgYW4gYGFzYCBleHByZXNzaW9uIGluc3RlYWQuXCIsXG4gIFNldEFjY2Vzc29yQ2Fubm90SGF2ZU9wdGlvbmFsUGFyYW1ldGVyOiBcIkEgJ3NldCcgYWNjZXNzb3IgY2Fubm90IGhhdmUgYW4gb3B0aW9uYWwgcGFyYW1ldGVyLlwiLFxuICBTZXRBY2Nlc3NvckNhbm5vdEhhdmVSZXN0UGFyYW1ldGVyOiBcIkEgJ3NldCcgYWNjZXNzb3IgY2Fubm90IGhhdmUgcmVzdCBwYXJhbWV0ZXIuXCIsXG4gIFNldEFjY2Vzc29yQ2Fubm90SGF2ZVJldHVyblR5cGU6IFwiQSAnc2V0JyBhY2Nlc3NvciBjYW5ub3QgaGF2ZSBhIHJldHVybiB0eXBlIGFubm90YXRpb24uXCIsXG4gIFNpbmdsZVR5cGVQYXJhbWV0ZXJXaXRob3V0VHJhaWxpbmdDb21tYTogKHtcbiAgICB0eXBlUGFyYW1ldGVyTmFtZVxuICB9KSA9PiBgU2luZ2xlIHR5cGUgcGFyYW1ldGVyICR7dHlwZVBhcmFtZXRlck5hbWV9IHNob3VsZCBoYXZlIGEgdHJhaWxpbmcgY29tbWEuIEV4YW1wbGUgdXNhZ2U6IDwke3R5cGVQYXJhbWV0ZXJOYW1lfSw+LmAsXG4gIFN0YXRpY0Jsb2NrQ2Fubm90SGF2ZU1vZGlmaWVyOiBcIlN0YXRpYyBjbGFzcyBibG9ja3MgY2Fubm90IGhhdmUgYW55IG1vZGlmaWVyLlwiLFxuICBUdXBsZU9wdGlvbmFsQWZ0ZXJUeXBlOiBcIkEgbGFiZWxlZCB0dXBsZSBvcHRpb25hbCBlbGVtZW50IG11c3QgYmUgZGVjbGFyZWQgdXNpbmcgYSBxdWVzdGlvbiBtYXJrIGFmdGVyIHRoZSBuYW1lIGFuZCBiZWZvcmUgdGhlIGNvbG9uIChgbmFtZT86IHR5cGVgKSwgcmF0aGVyIHRoYW4gYWZ0ZXIgdGhlIHR5cGUgKGBuYW1lOiB0eXBlP2ApLlwiLFxuICBUeXBlQW5ub3RhdGlvbkFmdGVyQXNzaWduOiBcIlR5cGUgYW5ub3RhdGlvbnMgbXVzdCBjb21lIGJlZm9yZSBkZWZhdWx0IGFzc2lnbm1lbnRzLCBlLmcuIGluc3RlYWQgb2YgYGFnZSA9IDI1OiBudW1iZXJgIHVzZSBgYWdlOiBudW1iZXIgPSAyNWAuXCIsXG4gIFR5cGVJbXBvcnRDYW5ub3RTcGVjaWZ5RGVmYXVsdEFuZE5hbWVkOiBcIkEgdHlwZS1vbmx5IGltcG9ydCBjYW4gc3BlY2lmeSBhIGRlZmF1bHQgaW1wb3J0IG9yIG5hbWVkIGJpbmRpbmdzLCBidXQgbm90IGJvdGguXCIsXG4gIFR5cGVNb2RpZmllcklzVXNlZEluVHlwZUV4cG9ydHM6IFwiVGhlICd0eXBlJyBtb2RpZmllciBjYW5ub3QgYmUgdXNlZCBvbiBhIG5hbWVkIGV4cG9ydCB3aGVuICdleHBvcnQgdHlwZScgaXMgdXNlZCBvbiBpdHMgZXhwb3J0IHN0YXRlbWVudC5cIixcbiAgVHlwZU1vZGlmaWVySXNVc2VkSW5UeXBlSW1wb3J0czogXCJUaGUgJ3R5cGUnIG1vZGlmaWVyIGNhbm5vdCBiZSB1c2VkIG9uIGEgbmFtZWQgaW1wb3J0IHdoZW4gJ2ltcG9ydCB0eXBlJyBpcyB1c2VkIG9uIGl0cyBpbXBvcnQgc3RhdGVtZW50LlwiLFxuICBVbmV4cGVjdGVkUGFyYW1ldGVyTW9kaWZpZXI6IFwiQSBwYXJhbWV0ZXIgcHJvcGVydHkgaXMgb25seSBhbGxvd2VkIGluIGEgY29uc3RydWN0b3IgaW1wbGVtZW50YXRpb24uXCIsXG4gIFVuZXhwZWN0ZWRSZWFkb25seTogXCIncmVhZG9ubHknIHR5cGUgbW9kaWZpZXIgaXMgb25seSBwZXJtaXR0ZWQgb24gYXJyYXkgYW5kIHR1cGxlIGxpdGVyYWwgdHlwZXMuXCIsXG4gIFVuZXhwZWN0ZWRUeXBlQW5ub3RhdGlvbjogXCJEaWQgbm90IGV4cGVjdCBhIHR5cGUgYW5ub3RhdGlvbiBoZXJlLlwiLFxuICBVbmV4cGVjdGVkVHlwZUNhc3RJblBhcmFtZXRlcjogXCJVbmV4cGVjdGVkIHR5cGUgY2FzdCBpbiBwYXJhbWV0ZXIgcG9zaXRpb24uXCIsXG4gIFVuc3VwcG9ydGVkSW1wb3J0VHlwZUFyZ3VtZW50OiBcIkFyZ3VtZW50IGluIGEgdHlwZSBpbXBvcnQgbXVzdCBiZSBhIHN0cmluZyBsaXRlcmFsLlwiLFxuICBVbnN1cHBvcnRlZFBhcmFtZXRlclByb3BlcnR5S2luZDogXCJBIHBhcmFtZXRlciBwcm9wZXJ0eSBtYXkgbm90IGJlIGRlY2xhcmVkIHVzaW5nIGEgYmluZGluZyBwYXR0ZXJuLlwiLFxuICBVbnN1cHBvcnRlZFNpZ25hdHVyZVBhcmFtZXRlcktpbmQ6ICh7XG4gICAgdHlwZVxuICB9KSA9PiBgTmFtZSBpbiBhIHNpZ25hdHVyZSBtdXN0IGJlIGFuIElkZW50aWZpZXIsIE9iamVjdFBhdHRlcm4gb3IgQXJyYXlQYXR0ZXJuLCBpbnN0ZWFkIGdvdCAke3R5cGV9LmBcbn0pO1xuZnVuY3Rpb24ga2V5d29yZFR5cGVGcm9tTmFtZSh2YWx1ZSkge1xuICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgY2FzZSBcImFueVwiOlxuICAgICAgcmV0dXJuIFwiVFNBbnlLZXl3b3JkXCI7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiBcIlRTQm9vbGVhbktleXdvcmRcIjtcbiAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICByZXR1cm4gXCJUU0JpZ0ludEtleXdvcmRcIjtcbiAgICBjYXNlIFwibmV2ZXJcIjpcbiAgICAgIHJldHVybiBcIlRTTmV2ZXJLZXl3b3JkXCI7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgcmV0dXJuIFwiVFNOdW1iZXJLZXl3b3JkXCI7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgcmV0dXJuIFwiVFNPYmplY3RLZXl3b3JkXCI7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIFwiVFNTdHJpbmdLZXl3b3JkXCI7XG4gICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgcmV0dXJuIFwiVFNTeW1ib2xLZXl3b3JkXCI7XG4gICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgcmV0dXJuIFwiVFNVbmRlZmluZWRLZXl3b3JkXCI7XG4gICAgY2FzZSBcInVua25vd25cIjpcbiAgICAgIHJldHVybiBcIlRTVW5rbm93bktleXdvcmRcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuZnVuY3Rpb24gdHNJc0FjY2Vzc01vZGlmaWVyKG1vZGlmaWVyKSB7XG4gIHJldHVybiBtb2RpZmllciA9PT0gXCJwcml2YXRlXCIgfHwgbW9kaWZpZXIgPT09IFwicHVibGljXCIgfHwgbW9kaWZpZXIgPT09IFwicHJvdGVjdGVkXCI7XG59XG5mdW5jdGlvbiB0c0lzVmFyaWFuY2VBbm5vdGF0aW9ucyhtb2RpZmllcikge1xuICByZXR1cm4gbW9kaWZpZXIgPT09IFwiaW5cIiB8fCBtb2RpZmllciA9PT0gXCJvdXRcIjtcbn1cbnZhciB0eXBlc2NyaXB0ID0gc3VwZXJDbGFzcyA9PiBjbGFzcyBUeXBlU2NyaXB0UGFyc2VyTWl4aW4gZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMudHNQYXJzZUluT3V0TW9kaWZpZXJzID0gdGhpcy50c1BhcnNlTW9kaWZpZXJzLmJpbmQodGhpcywge1xuICAgICAgYWxsb3dlZE1vZGlmaWVyczogW1wiaW5cIiwgXCJvdXRcIl0sXG4gICAgICBkaXNhbGxvd2VkTW9kaWZpZXJzOiBbXCJjb25zdFwiLCBcInB1YmxpY1wiLCBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIiwgXCJyZWFkb25seVwiLCBcImRlY2xhcmVcIiwgXCJhYnN0cmFjdFwiLCBcIm92ZXJyaWRlXCJdLFxuICAgICAgZXJyb3JUZW1wbGF0ZTogVFNFcnJvcnMuSW52YWxpZE1vZGlmaWVyT25UeXBlUGFyYW1ldGVyXG4gICAgfSk7XG4gICAgdGhpcy50c1BhcnNlQ29uc3RNb2RpZmllciA9IHRoaXMudHNQYXJzZU1vZGlmaWVycy5iaW5kKHRoaXMsIHtcbiAgICAgIGFsbG93ZWRNb2RpZmllcnM6IFtcImNvbnN0XCJdLFxuICAgICAgZGlzYWxsb3dlZE1vZGlmaWVyczogW1wiaW5cIiwgXCJvdXRcIl0sXG4gICAgICBlcnJvclRlbXBsYXRlOiBUU0Vycm9ycy5JbnZhbGlkTW9kaWZpZXJPblR5cGVQYXJhbWV0ZXJQb3NpdGlvbnNcbiAgICB9KTtcbiAgICB0aGlzLnRzUGFyc2VJbk91dENvbnN0TW9kaWZpZXJzID0gdGhpcy50c1BhcnNlTW9kaWZpZXJzLmJpbmQodGhpcywge1xuICAgICAgYWxsb3dlZE1vZGlmaWVyczogW1wiaW5cIiwgXCJvdXRcIiwgXCJjb25zdFwiXSxcbiAgICAgIGRpc2FsbG93ZWRNb2RpZmllcnM6IFtcInB1YmxpY1wiLCBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIiwgXCJyZWFkb25seVwiLCBcImRlY2xhcmVcIiwgXCJhYnN0cmFjdFwiLCBcIm92ZXJyaWRlXCJdLFxuICAgICAgZXJyb3JUZW1wbGF0ZTogVFNFcnJvcnMuSW52YWxpZE1vZGlmaWVyT25UeXBlUGFyYW1ldGVyXG4gICAgfSk7XG4gIH1cbiAgZ2V0U2NvcGVIYW5kbGVyKCkge1xuICAgIHJldHVybiBUeXBlU2NyaXB0U2NvcGVIYW5kbGVyO1xuICB9XG4gIHRzSXNJZGVudGlmaWVyKCkge1xuICAgIHJldHVybiB0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpO1xuICB9XG4gIHRzVG9rZW5DYW5Gb2xsb3dNb2RpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgwKSB8fCB0aGlzLm1hdGNoKDUpIHx8IHRoaXMubWF0Y2goNTUpIHx8IHRoaXMubWF0Y2goMjEpIHx8IHRoaXMubWF0Y2goMTM5KSB8fCB0aGlzLmlzTGl0ZXJhbFByb3BlcnR5TmFtZSgpO1xuICB9XG4gIHRzTmV4dFRva2VuT25TYW1lTGluZUFuZENhbkZvbGxvd01vZGlmaWVyKCkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRzVG9rZW5DYW5Gb2xsb3dNb2RpZmllcigpO1xuICB9XG4gIHRzTmV4dFRva2VuQ2FuRm9sbG93TW9kaWZpZXIoKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTA2KSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy50c1Rva2VuQ2FuRm9sbG93TW9kaWZpZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHNOZXh0VG9rZW5PblNhbWVMaW5lQW5kQ2FuRm9sbG93TW9kaWZpZXIoKTtcbiAgfVxuICB0c1BhcnNlTW9kaWZpZXIoYWxsb3dlZE1vZGlmaWVycywgc3RvcE9uU3RhcnRPZkNsYXNzU3RhdGljQmxvY2spIHtcbiAgICBpZiAoIXRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkgJiYgdGhpcy5zdGF0ZS50eXBlICE9PSA1OCAmJiB0aGlzLnN0YXRlLnR5cGUgIT09IDc1KSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBtb2RpZmllciA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgaWYgKGFsbG93ZWRNb2RpZmllcnMuaW5jbHVkZXMobW9kaWZpZXIpKSB7XG4gICAgICBpZiAoc3RvcE9uU3RhcnRPZkNsYXNzU3RhdGljQmxvY2sgJiYgdGhpcy50c0lzU3RhcnRPZlN0YXRpY0Jsb2NrcygpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50c1RyeVBhcnNlKHRoaXMudHNOZXh0VG9rZW5DYW5Gb2xsb3dNb2RpZmllci5iaW5kKHRoaXMpKSkge1xuICAgICAgICByZXR1cm4gbW9kaWZpZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgdHNQYXJzZU1vZGlmaWVycyh7XG4gICAgYWxsb3dlZE1vZGlmaWVycyxcbiAgICBkaXNhbGxvd2VkTW9kaWZpZXJzLFxuICAgIHN0b3BPblN0YXJ0T2ZDbGFzc1N0YXRpY0Jsb2NrLFxuICAgIGVycm9yVGVtcGxhdGUgPSBUU0Vycm9ycy5JbnZhbGlkTW9kaWZpZXJPblR5cGVNZW1iZXJcbiAgfSwgbW9kaWZpZWQpIHtcbiAgICBjb25zdCBlbmZvcmNlT3JkZXIgPSAobG9jLCBtb2RpZmllciwgYmVmb3JlLCBhZnRlcikgPT4ge1xuICAgICAgaWYgKG1vZGlmaWVyID09PSBiZWZvcmUgJiYgbW9kaWZpZWRbYWZ0ZXJdKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW52YWxpZE1vZGlmaWVyc09yZGVyLCBsb2MsIHtcbiAgICAgICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbYmVmb3JlLCBhZnRlcl1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbmNvbXBhdGlibGUgPSAobG9jLCBtb2RpZmllciwgbW9kMSwgbW9kMikgPT4ge1xuICAgICAgaWYgKG1vZGlmaWVkW21vZDFdICYmIG1vZGlmaWVyID09PSBtb2QyIHx8IG1vZGlmaWVkW21vZDJdICYmIG1vZGlmaWVyID09PSBtb2QxKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW5jb21wYXRpYmxlTW9kaWZpZXJzLCBsb2MsIHtcbiAgICAgICAgICBtb2RpZmllcnM6IFttb2QxLCBtb2QyXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoOzspIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RhcnRMb2NcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgbW9kaWZpZXIgPSB0aGlzLnRzUGFyc2VNb2RpZmllcihhbGxvd2VkTW9kaWZpZXJzLmNvbmNhdChkaXNhbGxvd2VkTW9kaWZpZXJzICE9IG51bGwgPyBkaXNhbGxvd2VkTW9kaWZpZXJzIDogW10pLCBzdG9wT25TdGFydE9mQ2xhc3NTdGF0aWNCbG9jayk7XG4gICAgICBpZiAoIW1vZGlmaWVyKSBicmVhaztcbiAgICAgIGlmICh0c0lzQWNjZXNzTW9kaWZpZXIobW9kaWZpZXIpKSB7XG4gICAgICAgIGlmIChtb2RpZmllZC5hY2Nlc3NpYmlsaXR5KSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5EdXBsaWNhdGVBY2Nlc3NpYmlsaXR5TW9kaWZpZXIsIHN0YXJ0TG9jLCB7XG4gICAgICAgICAgICBtb2RpZmllclxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVuZm9yY2VPcmRlcihzdGFydExvYywgbW9kaWZpZXIsIG1vZGlmaWVyLCBcIm92ZXJyaWRlXCIpO1xuICAgICAgICAgIGVuZm9yY2VPcmRlcihzdGFydExvYywgbW9kaWZpZXIsIG1vZGlmaWVyLCBcInN0YXRpY1wiKTtcbiAgICAgICAgICBlbmZvcmNlT3JkZXIoc3RhcnRMb2MsIG1vZGlmaWVyLCBtb2RpZmllciwgXCJyZWFkb25seVwiKTtcbiAgICAgICAgICBtb2RpZmllZC5hY2Nlc3NpYmlsaXR5ID0gbW9kaWZpZXI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHNJc1ZhcmlhbmNlQW5ub3RhdGlvbnMobW9kaWZpZXIpKSB7XG4gICAgICAgIGlmIChtb2RpZmllZFttb2RpZmllcl0pIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkR1cGxpY2F0ZU1vZGlmaWVyLCBzdGFydExvYywge1xuICAgICAgICAgICAgbW9kaWZpZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBtb2RpZmllZFttb2RpZmllcl0gPSB0cnVlO1xuICAgICAgICBlbmZvcmNlT3JkZXIoc3RhcnRMb2MsIG1vZGlmaWVyLCBcImluXCIsIFwib3V0XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwobW9kaWZpZWQsIG1vZGlmaWVyKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuRHVwbGljYXRlTW9kaWZpZXIsIHN0YXJ0TG9jLCB7XG4gICAgICAgICAgICBtb2RpZmllclxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVuZm9yY2VPcmRlcihzdGFydExvYywgbW9kaWZpZXIsIFwic3RhdGljXCIsIFwicmVhZG9ubHlcIik7XG4gICAgICAgICAgZW5mb3JjZU9yZGVyKHN0YXJ0TG9jLCBtb2RpZmllciwgXCJzdGF0aWNcIiwgXCJvdmVycmlkZVwiKTtcbiAgICAgICAgICBlbmZvcmNlT3JkZXIoc3RhcnRMb2MsIG1vZGlmaWVyLCBcIm92ZXJyaWRlXCIsIFwicmVhZG9ubHlcIik7XG4gICAgICAgICAgZW5mb3JjZU9yZGVyKHN0YXJ0TG9jLCBtb2RpZmllciwgXCJhYnN0cmFjdFwiLCBcIm92ZXJyaWRlXCIpO1xuICAgICAgICAgIGluY29tcGF0aWJsZShzdGFydExvYywgbW9kaWZpZXIsIFwiZGVjbGFyZVwiLCBcIm92ZXJyaWRlXCIpO1xuICAgICAgICAgIGluY29tcGF0aWJsZShzdGFydExvYywgbW9kaWZpZXIsIFwic3RhdGljXCIsIFwiYWJzdHJhY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgbW9kaWZpZWRbbW9kaWZpZXJdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXNhbGxvd2VkTW9kaWZpZXJzICE9IG51bGwgJiYgZGlzYWxsb3dlZE1vZGlmaWVycy5pbmNsdWRlcyhtb2RpZmllcikpIHtcbiAgICAgICAgdGhpcy5yYWlzZShlcnJvclRlbXBsYXRlLCBzdGFydExvYywge1xuICAgICAgICAgIG1vZGlmaWVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0c0lzTGlzdFRlcm1pbmF0b3Ioa2luZCkge1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBcIkVudW1NZW1iZXJzXCI6XG4gICAgICBjYXNlIFwiVHlwZU1lbWJlcnNcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2goOCk7XG4gICAgICBjYXNlIFwiSGVyaXRhZ2VDbGF1c2VFbGVtZW50XCI6XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoKDUpO1xuICAgICAgY2FzZSBcIlR1cGxlRWxlbWVudFR5cGVzXCI6XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoKDMpO1xuICAgICAgY2FzZSBcIlR5cGVQYXJhbWV0ZXJzT3JBcmd1bWVudHNcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2goNDgpO1xuICAgIH1cbiAgfVxuICB0c1BhcnNlTGlzdChraW5kLCBwYXJzZUVsZW1lbnQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAoIXRoaXMudHNJc0xpc3RUZXJtaW5hdG9yKGtpbmQpKSB7XG4gICAgICByZXN1bHQucHVzaChwYXJzZUVsZW1lbnQoKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdHNQYXJzZURlbGltaXRlZExpc3Qoa2luZCwgcGFyc2VFbGVtZW50LCByZWZUcmFpbGluZ0NvbW1hUG9zKSB7XG4gICAgcmV0dXJuIG5vbk51bGwodGhpcy50c1BhcnNlRGVsaW1pdGVkTGlzdFdvcmtlcihraW5kLCBwYXJzZUVsZW1lbnQsIHRydWUsIHJlZlRyYWlsaW5nQ29tbWFQb3MpKTtcbiAgfVxuICB0c1BhcnNlRGVsaW1pdGVkTGlzdFdvcmtlcihraW5kLCBwYXJzZUVsZW1lbnQsIGV4cGVjdFN1Y2Nlc3MsIHJlZlRyYWlsaW5nQ29tbWFQb3MpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgdHJhaWxpbmdDb21tYVBvcyA9IC0xO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnRzSXNMaXN0VGVybWluYXRvcihraW5kKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRyYWlsaW5nQ29tbWFQb3MgPSAtMTtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBwYXJzZUVsZW1lbnQoKTtcbiAgICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKGVsZW1lbnQpO1xuICAgICAgaWYgKHRoaXMuZWF0KDEyKSkge1xuICAgICAgICB0cmFpbGluZ0NvbW1hUG9zID0gdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MuaW5kZXg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudHNJc0xpc3RUZXJtaW5hdG9yKGtpbmQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGV4cGVjdFN1Y2Nlc3MpIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHJlZlRyYWlsaW5nQ29tbWFQb3MpIHtcbiAgICAgIHJlZlRyYWlsaW5nQ29tbWFQb3MudmFsdWUgPSB0cmFpbGluZ0NvbW1hUG9zO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHRzUGFyc2VCcmFja2V0ZWRMaXN0KGtpbmQsIHBhcnNlRWxlbWVudCwgYnJhY2tldCwgc2tpcEZpcnN0VG9rZW4sIHJlZlRyYWlsaW5nQ29tbWFQb3MpIHtcbiAgICBpZiAoIXNraXBGaXJzdFRva2VuKSB7XG4gICAgICBpZiAoYnJhY2tldCkge1xuICAgICAgICB0aGlzLmV4cGVjdCgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KDQ3KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy50c1BhcnNlRGVsaW1pdGVkTGlzdChraW5kLCBwYXJzZUVsZW1lbnQsIHJlZlRyYWlsaW5nQ29tbWFQb3MpO1xuICAgIGlmIChicmFja2V0KSB7XG4gICAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5leHBlY3QoNDgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHRzUGFyc2VJbXBvcnRUeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMuZXhwZWN0KDgzKTtcbiAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDEzNCkpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuVW5zdXBwb3J0ZWRJbXBvcnRUeXBlQXJndW1lbnQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAge1xuICAgICAgICBub2RlLmFyZ3VtZW50ID0gc3VwZXIucGFyc2VFeHByQXRvbSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuZWF0KDEyKSAmJiAhdGhpcy5tYXRjaCgxMSkpIHtcbiAgICAgIG5vZGUub3B0aW9ucyA9IHN1cGVyLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgICB0aGlzLmVhdCgxMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUub3B0aW9ucyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICBpZiAodGhpcy5lYXQoMTYpKSB7XG4gICAgICBub2RlLnF1YWxpZmllciA9IHRoaXMudHNQYXJzZUVudGl0eU5hbWUoMSB8IDIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIHtcbiAgICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMudHNQYXJzZVR5cGVBcmd1bWVudHMoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTSW1wb3J0VHlwZVwiKTtcbiAgfVxuICB0c1BhcnNlRW50aXR5TmFtZShmbGFncykge1xuICAgIGxldCBlbnRpdHk7XG4gICAgaWYgKGZsYWdzICYgMSAmJiB0aGlzLm1hdGNoKDc4KSkge1xuICAgICAgaWYgKGZsYWdzICYgMikge1xuICAgICAgICBlbnRpdHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgZW50aXR5ID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhpc0V4cHJlc3Npb25cIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudGl0eSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCEhKGZsYWdzICYgMSkpO1xuICAgIH1cbiAgICB3aGlsZSAodGhpcy5lYXQoMTYpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdE5vZGUoZW50aXR5KTtcbiAgICAgIG5vZGUubGVmdCA9IGVudGl0eTtcbiAgICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcighIShmbGFncyAmIDEpKTtcbiAgICAgIGVudGl0eSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTUXVhbGlmaWVkTmFtZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudGl0eTtcbiAgfVxuICB0c1BhcnNlVHlwZVJlZmVyZW5jZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnR5cGVOYW1lID0gdGhpcy50c1BhcnNlRW50aXR5TmFtZSgxKTtcbiAgICBpZiAoIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkgJiYgdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIHtcbiAgICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMudHNQYXJzZVR5cGVBcmd1bWVudHMoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZVJlZmVyZW5jZVwiKTtcbiAgfVxuICB0c1BhcnNlVGhpc1R5cGVQcmVkaWNhdGUobGhzKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXROb2RlKGxocyk7XG4gICAgbm9kZS5wYXJhbWV0ZXJOYW1lID0gbGhzO1xuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLnRzUGFyc2VUeXBlQW5ub3RhdGlvbihmYWxzZSk7XG4gICAgbm9kZS5hc3NlcnRzID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZVByZWRpY2F0ZVwiKTtcbiAgfVxuICB0c1BhcnNlVGhpc1R5cGVOb2RlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1RoaXNUeXBlXCIpO1xuICB9XG4gIHRzUGFyc2VUeXBlUXVlcnkoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3QoODcpO1xuICAgIGlmICh0aGlzLm1hdGNoKDgzKSkge1xuICAgICAgbm9kZS5leHByTmFtZSA9IHRoaXMudHNQYXJzZUltcG9ydFR5cGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICBub2RlLmV4cHJOYW1lID0gdGhpcy50c1BhcnNlRW50aXR5TmFtZSgxIHwgMik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSAmJiB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAge1xuICAgICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1BhcnNlVHlwZUFyZ3VtZW50cygpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUXVlcnlcIik7XG4gIH1cbiAgdHNQYXJzZVR5cGVQYXJhbWV0ZXIocGFyc2VNb2RpZmllcnMpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBwYXJzZU1vZGlmaWVycyhub2RlKTtcbiAgICBub2RlLm5hbWUgPSB0aGlzLnRzUGFyc2VUeXBlUGFyYW1ldGVyTmFtZSgpO1xuICAgIG5vZGUuY29uc3RyYWludCA9IHRoaXMudHNFYXRUaGVuUGFyc2VUeXBlKDgxKTtcbiAgICBub2RlLmRlZmF1bHQgPSB0aGlzLnRzRWF0VGhlblBhcnNlVHlwZSgyOSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZVBhcmFtZXRlclwiKTtcbiAgfVxuICB0c1RyeVBhcnNlVHlwZVBhcmFtZXRlcnMocGFyc2VNb2RpZmllcnMpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlUGFyYW1ldGVycyhwYXJzZU1vZGlmaWVycyk7XG4gICAgfVxuICB9XG4gIHRzUGFyc2VUeXBlUGFyYW1ldGVycyhwYXJzZU1vZGlmaWVycykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSB8fCB0aGlzLm1hdGNoKDE0MykpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgY29uc3QgcmVmVHJhaWxpbmdDb21tYVBvcyA9IHtcbiAgICAgIHZhbHVlOiAtMVxuICAgIH07XG4gICAgbm9kZS5wYXJhbXMgPSB0aGlzLnRzUGFyc2VCcmFja2V0ZWRMaXN0KFwiVHlwZVBhcmFtZXRlcnNPckFyZ3VtZW50c1wiLCB0aGlzLnRzUGFyc2VUeXBlUGFyYW1ldGVyLmJpbmQodGhpcywgcGFyc2VNb2RpZmllcnMpLCBmYWxzZSwgdHJ1ZSwgcmVmVHJhaWxpbmdDb21tYVBvcyk7XG4gICAgaWYgKG5vZGUucGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5FbXB0eVR5cGVQYXJhbWV0ZXJzLCBub2RlKTtcbiAgICB9XG4gICAgaWYgKHJlZlRyYWlsaW5nQ29tbWFQb3MudmFsdWUgIT09IC0xKSB7XG4gICAgICB0aGlzLmFkZEV4dHJhKG5vZGUsIFwidHJhaWxpbmdDb21tYVwiLCByZWZUcmFpbGluZ0NvbW1hUG9zLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIpO1xuICB9XG4gIHRzRmlsbFNpZ25hdHVyZShyZXR1cm5Ub2tlbiwgc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgcmV0dXJuVG9rZW5SZXF1aXJlZCA9IHJldHVyblRva2VuID09PSAxOTtcbiAgICBjb25zdCBwYXJhbXNLZXkgPSBcInBhcmFtZXRlcnNcIjtcbiAgICBjb25zdCByZXR1cm5UeXBlS2V5ID0gXCJ0eXBlQW5ub3RhdGlvblwiO1xuICAgIHNpZ25hdHVyZS50eXBlUGFyYW1ldGVycyA9IHRoaXMudHNUcnlQYXJzZVR5cGVQYXJhbWV0ZXJzKHRoaXMudHNQYXJzZUNvbnN0TW9kaWZpZXIpO1xuICAgIHRoaXMuZXhwZWN0KDEwKTtcbiAgICBzaWduYXR1cmVbcGFyYW1zS2V5XSA9IHRoaXMudHNQYXJzZUJpbmRpbmdMaXN0Rm9yU2lnbmF0dXJlKCk7XG4gICAgaWYgKHJldHVyblRva2VuUmVxdWlyZWQpIHtcbiAgICAgIHNpZ25hdHVyZVtyZXR1cm5UeXBlS2V5XSA9IHRoaXMudHNQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKHJldHVyblRva2VuKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2gocmV0dXJuVG9rZW4pKSB7XG4gICAgICBzaWduYXR1cmVbcmV0dXJuVHlwZUtleV0gPSB0aGlzLnRzUGFyc2VUeXBlT3JUeXBlUHJlZGljYXRlQW5ub3RhdGlvbihyZXR1cm5Ub2tlbik7XG4gICAgfVxuICB9XG4gIHRzUGFyc2VCaW5kaW5nTGlzdEZvclNpZ25hdHVyZSgpIHtcbiAgICBjb25zdCBsaXN0ID0gc3VwZXIucGFyc2VCaW5kaW5nTGlzdCgxMSwgNDEsIDIpO1xuICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBsaXN0KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGVcbiAgICAgIH0gPSBwYXR0ZXJuO1xuICAgICAgaWYgKHR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIiB8fCB0eXBlID09PSBcIlRTUGFyYW1ldGVyUHJvcGVydHlcIikge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlVuc3VwcG9ydGVkU2lnbmF0dXJlUGFyYW1ldGVyS2luZCwgcGF0dGVybiwge1xuICAgICAgICAgIHR5cGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xuICB9XG4gIHRzUGFyc2VUeXBlTWVtYmVyU2VtaWNvbG9uKCkge1xuICAgIGlmICghdGhpcy5lYXQoMTIpICYmICF0aGlzLmlzTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgdGhpcy5leHBlY3QoMTMpO1xuICAgIH1cbiAgfVxuICB0c1BhcnNlU2lnbmF0dXJlTWVtYmVyKGtpbmQsIG5vZGUpIHtcbiAgICB0aGlzLnRzRmlsbFNpZ25hdHVyZSgxNCwgbm9kZSk7XG4gICAgdGhpcy50c1BhcnNlVHlwZU1lbWJlclNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwga2luZCk7XG4gIH1cbiAgdHNJc1VuYW1iaWd1b3VzbHlJbmRleFNpZ25hdHVyZSgpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5tYXRjaCgxNCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0c1RyeVBhcnNlSW5kZXhTaWduYXR1cmUobm9kZSkge1xuICAgIGlmICghKHRoaXMubWF0Y2goMCkgJiYgdGhpcy50c0xvb2tBaGVhZCh0aGlzLnRzSXNVbmFtYmlndW91c2x5SW5kZXhTaWduYXR1cmUuYmluZCh0aGlzKSkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDApO1xuICAgIGNvbnN0IGlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICBpZC50eXBlQW5ub3RhdGlvbiA9IHRoaXMudHNQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKGlkKTtcbiAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICBub2RlLnBhcmFtZXRlcnMgPSBbaWRdO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgIGlmICh0eXBlKSBub2RlLnR5cGVBbm5vdGF0aW9uID0gdHlwZTtcbiAgICB0aGlzLnRzUGFyc2VUeXBlTWVtYmVyU2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTSW5kZXhTaWduYXR1cmVcIik7XG4gIH1cbiAgdHNQYXJzZVByb3BlcnR5T3JNZXRob2RTaWduYXR1cmUobm9kZSwgcmVhZG9ubHkpIHtcbiAgICBpZiAodGhpcy5lYXQoMTcpKSBub2RlLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICBjb25zdCBub2RlQW55ID0gbm9kZTtcbiAgICBpZiAodGhpcy5tYXRjaCgxMCkgfHwgdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIGlmIChyZWFkb25seSkge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlJlYWRvbmx5Rm9yTWV0aG9kU2lnbmF0dXJlLCBub2RlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1ldGhvZCA9IG5vZGVBbnk7XG4gICAgICBpZiAobWV0aG9kLmtpbmQgJiYgdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5BY2Nlc3NvckNhbm5vdEhhdmVUeXBlUGFyYW1ldGVycywgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHNGaWxsU2lnbmF0dXJlKDE0LCBtZXRob2QpO1xuICAgICAgdGhpcy50c1BhcnNlVHlwZU1lbWJlclNlbWljb2xvbigpO1xuICAgICAgY29uc3QgcGFyYW1zS2V5ID0gXCJwYXJhbWV0ZXJzXCI7XG4gICAgICBjb25zdCByZXR1cm5UeXBlS2V5ID0gXCJ0eXBlQW5ub3RhdGlvblwiO1xuICAgICAgaWYgKG1ldGhvZC5raW5kID09PSBcImdldFwiKSB7XG4gICAgICAgIGlmIChtZXRob2RbcGFyYW1zS2V5XS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQmFkR2V0dGVyQXJpdHksIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgICAgaWYgKHRoaXMuaXNUaGlzUGFyYW0obWV0aG9kW3BhcmFtc0tleV1bMF0pKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkFjY2Vzc29yQ2Fubm90RGVjbGFyZVRoaXNQYXJhbWV0ZXIsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiKSB7XG4gICAgICAgIGlmIChtZXRob2RbcGFyYW1zS2V5XS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5CYWRTZXR0ZXJBcml0eSwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBmaXJzdFBhcmFtZXRlciA9IG1ldGhvZFtwYXJhbXNLZXldWzBdO1xuICAgICAgICAgIGlmICh0aGlzLmlzVGhpc1BhcmFtKGZpcnN0UGFyYW1ldGVyKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5BY2Nlc3NvckNhbm5vdERlY2xhcmVUaGlzUGFyYW1ldGVyLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmlyc3RQYXJhbWV0ZXIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgZmlyc3RQYXJhbWV0ZXIub3B0aW9uYWwpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuU2V0QWNjZXNzb3JDYW5ub3RIYXZlT3B0aW9uYWxQYXJhbWV0ZXIsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmaXJzdFBhcmFtZXRlci50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuU2V0QWNjZXNzb3JDYW5ub3RIYXZlUmVzdFBhcmFtZXRlciwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZFtyZXR1cm5UeXBlS2V5XSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuU2V0QWNjZXNzb3JDYW5ub3RIYXZlUmV0dXJuVHlwZSwgbWV0aG9kW3JldHVyblR5cGVLZXldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWV0aG9kLmtpbmQgPSBcIm1ldGhvZFwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShtZXRob2QsIFwiVFNNZXRob2RTaWduYXR1cmVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gbm9kZUFueTtcbiAgICAgIGlmIChyZWFkb25seSkgcHJvcGVydHkucmVhZG9ubHkgPSB0cnVlO1xuICAgICAgY29uc3QgdHlwZSA9IHRoaXMudHNUcnlQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgICBpZiAodHlwZSkgcHJvcGVydHkudHlwZUFubm90YXRpb24gPSB0eXBlO1xuICAgICAgdGhpcy50c1BhcnNlVHlwZU1lbWJlclNlbWljb2xvbigpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wZXJ0eSwgXCJUU1Byb3BlcnR5U2lnbmF0dXJlXCIpO1xuICAgIH1cbiAgfVxuICB0c1BhcnNlVHlwZU1lbWJlcigpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAodGhpcy5tYXRjaCgxMCkgfHwgdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VTaWduYXR1cmVNZW1iZXIoXCJUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvblwiLCBub2RlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goNzcpKSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDEwKSB8fCB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlU2lnbmF0dXJlTWVtYmVyKFwiVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvblwiLCBub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUua2V5ID0gdGhpcy5jcmVhdGVJZGVudGlmaWVyKGlkLCBcIm5ld1wiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVByb3BlcnR5T3JNZXRob2RTaWduYXR1cmUobm9kZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRzUGFyc2VNb2RpZmllcnMoe1xuICAgICAgYWxsb3dlZE1vZGlmaWVyczogW1wicmVhZG9ubHlcIl0sXG4gICAgICBkaXNhbGxvd2VkTW9kaWZpZXJzOiBbXCJkZWNsYXJlXCIsIFwiYWJzdHJhY3RcIiwgXCJwcml2YXRlXCIsIFwicHJvdGVjdGVkXCIsIFwicHVibGljXCIsIFwic3RhdGljXCIsIFwib3ZlcnJpZGVcIl1cbiAgICB9LCBub2RlKTtcbiAgICBjb25zdCBpZHggPSB0aGlzLnRzVHJ5UGFyc2VJbmRleFNpZ25hdHVyZShub2RlKTtcbiAgICBpZiAoaWR4KSB7XG4gICAgICByZXR1cm4gaWR4O1xuICAgIH1cbiAgICBzdXBlci5wYXJzZVByb3BlcnR5TmFtZShub2RlKTtcbiAgICBpZiAoIW5vZGUuY29tcHV0ZWQgJiYgbm9kZS5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgKG5vZGUua2V5Lm5hbWUgPT09IFwiZ2V0XCIgfHwgbm9kZS5rZXkubmFtZSA9PT0gXCJzZXRcIikgJiYgdGhpcy50c1Rva2VuQ2FuRm9sbG93TW9kaWZpZXIoKSkge1xuICAgICAgbm9kZS5raW5kID0gbm9kZS5rZXkubmFtZTtcbiAgICAgIHN1cGVyLnBhcnNlUHJvcGVydHlOYW1lKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50c1BhcnNlUHJvcGVydHlPck1ldGhvZFNpZ25hdHVyZShub2RlLCAhIW5vZGUucmVhZG9ubHkpO1xuICB9XG4gIHRzUGFyc2VUeXBlTGl0ZXJhbCgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLm1lbWJlcnMgPSB0aGlzLnRzUGFyc2VPYmplY3RUeXBlTWVtYmVycygpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1R5cGVMaXRlcmFsXCIpO1xuICB9XG4gIHRzUGFyc2VPYmplY3RUeXBlTWVtYmVycygpIHtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICBjb25zdCBtZW1iZXJzID0gdGhpcy50c1BhcnNlTGlzdChcIlR5cGVNZW1iZXJzXCIsIHRoaXMudHNQYXJzZVR5cGVNZW1iZXIuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5leHBlY3QoOCk7XG4gICAgcmV0dXJuIG1lbWJlcnM7XG4gIH1cbiAgdHNJc1N0YXJ0T2ZNYXBwZWRUeXBlKCkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLmVhdCg1MykpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzQ29udGV4dHVhbCgxMjIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTIyKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5tYXRjaCgwKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAoIXRoaXMudHNJc0lkZW50aWZpZXIoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCg1OCk7XG4gIH1cbiAgdHNQYXJzZU1hcHBlZFR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgaWYgKHRoaXMubWF0Y2goNTMpKSB7XG4gICAgICBub2RlLnJlYWRvbmx5ID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKDEyMik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVhdENvbnRleHR1YWwoMTIyKSkge1xuICAgICAgbm9kZS5yZWFkb25seSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDApO1xuICAgIHtcbiAgICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdHlwZVBhcmFtZXRlci5uYW1lID0gdGhpcy50c1BhcnNlVHlwZVBhcmFtZXRlck5hbWUoKTtcbiAgICAgIHR5cGVQYXJhbWV0ZXIuY29uc3RyYWludCA9IHRoaXMudHNFeHBlY3RUaGVuUGFyc2VUeXBlKDU4KTtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlciA9IHRoaXMuZmluaXNoTm9kZSh0eXBlUGFyYW1ldGVyLCBcIlRTVHlwZVBhcmFtZXRlclwiKTtcbiAgICB9XG4gICAgbm9kZS5uYW1lVHlwZSA9IHRoaXMuZWF0Q29udGV4dHVhbCg5MykgPyB0aGlzLnRzUGFyc2VUeXBlKCkgOiBudWxsO1xuICAgIHRoaXMuZXhwZWN0KDMpO1xuICAgIGlmICh0aGlzLm1hdGNoKDUzKSkge1xuICAgICAgbm9kZS5vcHRpb25hbCA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHRoaXMuZXhwZWN0KDE3KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgbm9kZS5vcHRpb25hbCA9IHRydWU7XG4gICAgfVxuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLnRzVHJ5UGFyc2VUeXBlKCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNNYXBwZWRUeXBlXCIpO1xuICB9XG4gIHRzUGFyc2VUdXBsZVR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5lbGVtZW50VHlwZXMgPSB0aGlzLnRzUGFyc2VCcmFja2V0ZWRMaXN0KFwiVHVwbGVFbGVtZW50VHlwZXNcIiwgdGhpcy50c1BhcnNlVHVwbGVFbGVtZW50VHlwZS5iaW5kKHRoaXMpLCB0cnVlLCBmYWxzZSk7XG4gICAgbGV0IHNlZW5PcHRpb25hbEVsZW1lbnQgPSBmYWxzZTtcbiAgICBub2RlLmVsZW1lbnRUeXBlcy5mb3JFYWNoKGVsZW1lbnROb2RlID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHlwZVxuICAgICAgfSA9IGVsZW1lbnROb2RlO1xuICAgICAgaWYgKHNlZW5PcHRpb25hbEVsZW1lbnQgJiYgdHlwZSAhPT0gXCJUU1Jlc3RUeXBlXCIgJiYgdHlwZSAhPT0gXCJUU09wdGlvbmFsVHlwZVwiICYmICEodHlwZSA9PT0gXCJUU05hbWVkVHVwbGVNZW1iZXJcIiAmJiBlbGVtZW50Tm9kZS5vcHRpb25hbCkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5PcHRpb25hbFR5cGVCZWZvcmVSZXF1aXJlZCwgZWxlbWVudE5vZGUpO1xuICAgICAgfVxuICAgICAgc2Vlbk9wdGlvbmFsRWxlbWVudCB8fCAoc2Vlbk9wdGlvbmFsRWxlbWVudCA9IHR5cGUgPT09IFwiVFNOYW1lZFR1cGxlTWVtYmVyXCIgJiYgZWxlbWVudE5vZGUub3B0aW9uYWwgfHwgdHlwZSA9PT0gXCJUU09wdGlvbmFsVHlwZVwiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUdXBsZVR5cGVcIik7XG4gIH1cbiAgdHNQYXJzZVR1cGxlRWxlbWVudFR5cGUoKSB7XG4gICAgY29uc3QgcmVzdFN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCByZXN0ID0gdGhpcy5lYXQoMjEpO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0TG9jXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgbGV0IGxhYmVsZWQ7XG4gICAgbGV0IGxhYmVsO1xuICAgIGxldCBvcHRpb25hbDtcbiAgICBsZXQgdHlwZTtcbiAgICBjb25zdCBpc1dvcmQgPSB0b2tlbklzS2V5d29yZE9ySWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpO1xuICAgIGNvbnN0IGNoQWZ0ZXJXb3JkID0gaXNXb3JkID8gdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpIDogbnVsbDtcbiAgICBpZiAoY2hBZnRlcldvcmQgPT09IDU4KSB7XG4gICAgICBsYWJlbGVkID0gdHJ1ZTtcbiAgICAgIG9wdGlvbmFsID0gZmFsc2U7XG4gICAgICBsYWJlbCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgdGhpcy5leHBlY3QoMTQpO1xuICAgICAgdHlwZSA9IHRoaXMudHNQYXJzZVR5cGUoKTtcbiAgICB9IGVsc2UgaWYgKGNoQWZ0ZXJXb3JkID09PSA2Mykge1xuICAgICAgb3B0aW9uYWwgPSB0cnVlO1xuICAgICAgY29uc3Qgd29yZE5hbWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgY29uc3QgdHlwZU9yTGFiZWwgPSB0aGlzLnRzUGFyc2VOb25BcnJheVR5cGUoKTtcbiAgICAgIGlmICh0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDU4KSB7XG4gICAgICAgIGxhYmVsZWQgPSB0cnVlO1xuICAgICAgICBsYWJlbCA9IHRoaXMuY3JlYXRlSWRlbnRpZmllcih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKSwgd29yZE5hbWUpO1xuICAgICAgICB0aGlzLmV4cGVjdCgxNyk7XG4gICAgICAgIHRoaXMuZXhwZWN0KDE0KTtcbiAgICAgICAgdHlwZSA9IHRoaXMudHNQYXJzZVR5cGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhYmVsZWQgPSBmYWxzZTtcbiAgICAgICAgdHlwZSA9IHR5cGVPckxhYmVsO1xuICAgICAgICB0aGlzLmV4cGVjdCgxNyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGUgPSB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgICBvcHRpb25hbCA9IHRoaXMuZWF0KDE3KTtcbiAgICAgIGxhYmVsZWQgPSB0aGlzLmVhdCgxNCk7XG4gICAgfVxuICAgIGlmIChsYWJlbGVkKSB7XG4gICAgICBsZXQgbGFiZWxlZE5vZGU7XG4gICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgbGFiZWxlZE5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgICAgbGFiZWxlZE5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgICAgbGFiZWxlZE5vZGUubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgbGFiZWxlZE5vZGUuZWxlbWVudFR5cGUgPSB0eXBlO1xuICAgICAgICBpZiAodGhpcy5lYXQoMTcpKSB7XG4gICAgICAgICAgbGFiZWxlZE5vZGUub3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuVHVwbGVPcHRpb25hbEFmdGVyVHlwZSwgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYWJlbGVkTm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgICBsYWJlbGVkTm9kZS5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkludmFsaWRUdXBsZU1lbWJlckxhYmVsLCB0eXBlKTtcbiAgICAgICAgbGFiZWxlZE5vZGUubGFiZWwgPSB0eXBlO1xuICAgICAgICBsYWJlbGVkTm9kZS5lbGVtZW50VHlwZSA9IHRoaXMudHNQYXJzZVR5cGUoKTtcbiAgICAgIH1cbiAgICAgIHR5cGUgPSB0aGlzLmZpbmlzaE5vZGUobGFiZWxlZE5vZGUsIFwiVFNOYW1lZFR1cGxlTWVtYmVyXCIpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9uYWwpIHtcbiAgICAgIGNvbnN0IG9wdGlvbmFsVHlwZU5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIG9wdGlvbmFsVHlwZU5vZGUudHlwZUFubm90YXRpb24gPSB0eXBlO1xuICAgICAgdHlwZSA9IHRoaXMuZmluaXNoTm9kZShvcHRpb25hbFR5cGVOb2RlLCBcIlRTT3B0aW9uYWxUeXBlXCIpO1xuICAgIH1cbiAgICBpZiAocmVzdCkge1xuICAgICAgY29uc3QgcmVzdE5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHJlc3RTdGFydExvYyk7XG4gICAgICByZXN0Tm9kZS50eXBlQW5ub3RhdGlvbiA9IHR5cGU7XG4gICAgICB0eXBlID0gdGhpcy5maW5pc2hOb2RlKHJlc3ROb2RlLCBcIlRTUmVzdFR5cGVcIik7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHRzUGFyc2VQYXJlbnRoZXNpemVkVHlwZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMudHNQYXJzZVR5cGUoKTtcbiAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTUGFyZW50aGVzaXplZFR5cGVcIik7XG4gIH1cbiAgdHNQYXJzZUZ1bmN0aW9uT3JDb25zdHJ1Y3RvclR5cGUodHlwZSwgYWJzdHJhY3QpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAodHlwZSA9PT0gXCJUU0NvbnN0cnVjdG9yVHlwZVwiKSB7XG4gICAgICBub2RlLmFic3RyYWN0ID0gISFhYnN0cmFjdDtcbiAgICAgIGlmIChhYnN0cmFjdCkgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgdGhpcy50c0luQWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCgoKSA9PiB0aGlzLnRzRmlsbFNpZ25hdHVyZSgxOSwgbm9kZSkpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdHlwZSk7XG4gIH1cbiAgdHNQYXJzZUxpdGVyYWxUeXBlTm9kZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgY2FzZSAxMzU6XG4gICAgICBjYXNlIDEzNjpcbiAgICAgIGNhc2UgMTM0OlxuICAgICAgY2FzZSA4NTpcbiAgICAgIGNhc2UgODY6XG4gICAgICAgIG5vZGUubGl0ZXJhbCA9IHN1cGVyLnBhcnNlRXhwckF0b20oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTTGl0ZXJhbFR5cGVcIik7XG4gIH1cbiAgdHNQYXJzZVRlbXBsYXRlTGl0ZXJhbFR5cGUoKSB7XG4gICAge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBub2RlLmxpdGVyYWwgPSBzdXBlci5wYXJzZVRlbXBsYXRlKGZhbHNlKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0xpdGVyYWxUeXBlXCIpO1xuICAgIH1cbiAgfVxuICBwYXJzZVRlbXBsYXRlU3Vic3RpdHV0aW9uKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLmluVHlwZSkgcmV0dXJuIHRoaXMudHNQYXJzZVR5cGUoKTtcbiAgICByZXR1cm4gc3VwZXIucGFyc2VUZW1wbGF0ZVN1YnN0aXR1dGlvbigpO1xuICB9XG4gIHRzUGFyc2VUaGlzVHlwZU9yVGhpc1R5cGVQcmVkaWNhdGUoKSB7XG4gICAgY29uc3QgdGhpc0tleXdvcmQgPSB0aGlzLnRzUGFyc2VUaGlzVHlwZU5vZGUoKTtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTE2KSAmJiAhdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSkge1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVRoaXNUeXBlUHJlZGljYXRlKHRoaXNLZXl3b3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXNLZXl3b3JkO1xuICAgIH1cbiAgfVxuICB0c1BhcnNlTm9uQXJyYXlUeXBlKCkge1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIDEzNDpcbiAgICAgIGNhc2UgMTM1OlxuICAgICAgY2FzZSAxMzY6XG4gICAgICBjYXNlIDg1OlxuICAgICAgY2FzZSA4NjpcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUxpdGVyYWxUeXBlTm9kZSgpO1xuICAgICAgY2FzZSA1MzpcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUudmFsdWUgPT09IFwiLVwiKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgICAgY29uc3QgbmV4dFRva2VuID0gdGhpcy5sb29rYWhlYWQoKTtcbiAgICAgICAgICBpZiAobmV4dFRva2VuLnR5cGUgIT09IDEzNSAmJiBuZXh0VG9rZW4udHlwZSAhPT0gMTM2KSB7XG4gICAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5saXRlcmFsID0gdGhpcy5wYXJzZU1heWJlVW5hcnkoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNMaXRlcmFsVHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNzg6XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUaGlzVHlwZU9yVGhpc1R5cGVQcmVkaWNhdGUoKTtcbiAgICAgIGNhc2UgODc6XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlUXVlcnkoKTtcbiAgICAgIGNhc2UgODM6XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VJbXBvcnRUeXBlKCk7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHJldHVybiB0aGlzLnRzTG9va0FoZWFkKHRoaXMudHNJc1N0YXJ0T2ZNYXBwZWRUeXBlLmJpbmQodGhpcykpID8gdGhpcy50c1BhcnNlTWFwcGVkVHlwZSgpIDogdGhpcy50c1BhcnNlVHlwZUxpdGVyYWwoKTtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVR1cGxlVHlwZSgpO1xuICAgICAgY2FzZSAxMDpcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVBhcmVudGhlc2l6ZWRUeXBlKCk7XG4gICAgICBjYXNlIDI1OlxuICAgICAgY2FzZSAyNDpcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVRlbXBsYXRlTGl0ZXJhbFR5cGUoKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgaWYgKHRva2VuSXNJZGVudGlmaWVyKHR5cGUpIHx8IHR5cGUgPT09IDg4IHx8IHR5cGUgPT09IDg0KSB7XG4gICAgICAgICAgICBjb25zdCBub2RlVHlwZSA9IHR5cGUgPT09IDg4ID8gXCJUU1ZvaWRLZXl3b3JkXCIgOiB0eXBlID09PSA4NCA/IFwiVFNOdWxsS2V5d29yZFwiIDoga2V5d29yZFR5cGVGcm9tTmFtZSh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChub2RlVHlwZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSAhPT0gNDYpIHtcbiAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIG5vZGVUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlUmVmZXJlbmNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG4gIHRzUGFyc2VBcnJheVR5cGVPckhpZ2hlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydExvY1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCB0eXBlID0gdGhpcy50c1BhcnNlTm9uQXJyYXlUeXBlKCk7XG4gICAgd2hpbGUgKCF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpICYmIHRoaXMuZWF0KDApKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCgzKSkge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICAgIG5vZGUuZWxlbWVudFR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICAgICAgdHlwZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTQXJyYXlUeXBlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgICBub2RlLm9iamVjdFR5cGUgPSB0eXBlO1xuICAgICAgICBub2RlLmluZGV4VHlwZSA9IHRoaXMudHNQYXJzZVR5cGUoKTtcbiAgICAgICAgdGhpcy5leHBlY3QoMyk7XG4gICAgICAgIHR5cGUgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0luZGV4ZWRBY2Nlc3NUeXBlXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICB0c1BhcnNlVHlwZU9wZXJhdG9yKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNvbnN0IG9wZXJhdG9yID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMudHNQYXJzZVR5cGVPcGVyYXRvck9ySGlnaGVyKCk7XG4gICAgaWYgKG9wZXJhdG9yID09PSBcInJlYWRvbmx5XCIpIHtcbiAgICAgIHRoaXMudHNDaGVja1R5cGVBbm5vdGF0aW9uRm9yUmVhZE9ubHkobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1R5cGVPcGVyYXRvclwiKTtcbiAgfVxuICB0c0NoZWNrVHlwZUFubm90YXRpb25Gb3JSZWFkT25seShub2RlKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGVBbm5vdGF0aW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJUU1R1cGxlVHlwZVwiOlxuICAgICAgY2FzZSBcIlRTQXJyYXlUeXBlXCI6XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuVW5leHBlY3RlZFJlYWRvbmx5LCBub2RlKTtcbiAgICB9XG4gIH1cbiAgdHNQYXJzZUluZmVyVHlwZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoMTE1KTtcbiAgICBjb25zdCB0eXBlUGFyYW1ldGVyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0eXBlUGFyYW1ldGVyLm5hbWUgPSB0aGlzLnRzUGFyc2VUeXBlUGFyYW1ldGVyTmFtZSgpO1xuICAgIHR5cGVQYXJhbWV0ZXIuY29uc3RyYWludCA9IHRoaXMudHNUcnlQYXJzZSgoKSA9PiB0aGlzLnRzUGFyc2VDb25zdHJhaW50Rm9ySW5mZXJUeXBlKCkpO1xuICAgIG5vZGUudHlwZVBhcmFtZXRlciA9IHRoaXMuZmluaXNoTm9kZSh0eXBlUGFyYW1ldGVyLCBcIlRTVHlwZVBhcmFtZXRlclwiKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNJbmZlclR5cGVcIik7XG4gIH1cbiAgdHNQYXJzZUNvbnN0cmFpbnRGb3JJbmZlclR5cGUoKSB7XG4gICAgaWYgKHRoaXMuZWF0KDgxKSkge1xuICAgICAgY29uc3QgY29uc3RyYWludCA9IHRoaXMudHNJbkRpc2FsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQoKCkgPT4gdGhpcy50c1BhcnNlVHlwZSgpKTtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCB8fCAhdGhpcy5tYXRjaCgxNykpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0cmFpbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRzUGFyc2VUeXBlT3BlcmF0b3JPckhpZ2hlcigpIHtcbiAgICBjb25zdCBpc1R5cGVPcGVyYXRvciA9IHRva2VuSXNUU1R5cGVPcGVyYXRvcih0aGlzLnN0YXRlLnR5cGUpICYmICF0aGlzLnN0YXRlLmNvbnRhaW5zRXNjO1xuICAgIHJldHVybiBpc1R5cGVPcGVyYXRvciA/IHRoaXMudHNQYXJzZVR5cGVPcGVyYXRvcigpIDogdGhpcy5pc0NvbnRleHR1YWwoMTE1KSA/IHRoaXMudHNQYXJzZUluZmVyVHlwZSgpIDogdGhpcy50c0luQWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCgoKSA9PiB0aGlzLnRzUGFyc2VBcnJheVR5cGVPckhpZ2hlcigpKTtcbiAgfVxuICB0c1BhcnNlVW5pb25PckludGVyc2VjdGlvblR5cGUoa2luZCwgcGFyc2VDb25zdGl0dWVudFR5cGUsIG9wZXJhdG9yKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgaGFzTGVhZGluZ09wZXJhdG9yID0gdGhpcy5lYXQob3BlcmF0b3IpO1xuICAgIGNvbnN0IHR5cGVzID0gW107XG4gICAgZG8ge1xuICAgICAgdHlwZXMucHVzaChwYXJzZUNvbnN0aXR1ZW50VHlwZSgpKTtcbiAgICB9IHdoaWxlICh0aGlzLmVhdChvcGVyYXRvcikpO1xuICAgIGlmICh0eXBlcy5sZW5ndGggPT09IDEgJiYgIWhhc0xlYWRpbmdPcGVyYXRvcikge1xuICAgICAgcmV0dXJuIHR5cGVzWzBdO1xuICAgIH1cbiAgICBub2RlLnR5cGVzID0gdHlwZXM7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBraW5kKTtcbiAgfVxuICB0c1BhcnNlSW50ZXJzZWN0aW9uVHlwZU9ySGlnaGVyKCkge1xuICAgIHJldHVybiB0aGlzLnRzUGFyc2VVbmlvbk9ySW50ZXJzZWN0aW9uVHlwZShcIlRTSW50ZXJzZWN0aW9uVHlwZVwiLCB0aGlzLnRzUGFyc2VUeXBlT3BlcmF0b3JPckhpZ2hlci5iaW5kKHRoaXMpLCA0NSk7XG4gIH1cbiAgdHNQYXJzZVVuaW9uVHlwZU9ySGlnaGVyKCkge1xuICAgIHJldHVybiB0aGlzLnRzUGFyc2VVbmlvbk9ySW50ZXJzZWN0aW9uVHlwZShcIlRTVW5pb25UeXBlXCIsIHRoaXMudHNQYXJzZUludGVyc2VjdGlvblR5cGVPckhpZ2hlci5iaW5kKHRoaXMpLCA0Myk7XG4gIH1cbiAgdHNJc1N0YXJ0T2ZGdW5jdGlvblR5cGUoKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMTApICYmIHRoaXMudHNMb29rQWhlYWQodGhpcy50c0lzVW5hbWJpZ3VvdXNseVN0YXJ0T2ZGdW5jdGlvblR5cGUuYmluZCh0aGlzKSk7XG4gIH1cbiAgdHNTa2lwUGFyYW1ldGVyU3RhcnQoKSB7XG4gICAgaWYgKHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkgfHwgdGhpcy5tYXRjaCg3OCkpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDUpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVycm9yc1xuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBwcmV2aW91c0Vycm9yQ291bnQgPSBlcnJvcnMubGVuZ3RoO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5wYXJzZU9iamVjdExpa2UoOCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBlcnJvcnMubGVuZ3RoID09PSBwcmV2aW91c0Vycm9yQ291bnQ7XG4gICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goMCkpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBlcnJvcnNcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgcHJldmlvdXNFcnJvckNvdW50ID0gZXJyb3JzLmxlbmd0aDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN1cGVyLnBhcnNlQmluZGluZ0xpc3QoMywgOTMsIDEpO1xuICAgICAgICByZXR1cm4gZXJyb3JzLmxlbmd0aCA9PT0gcHJldmlvdXNFcnJvckNvdW50O1xuICAgICAgfSBjYXRjaCAoX3VudXNlZDIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHNJc1VuYW1iaWd1b3VzbHlTdGFydE9mRnVuY3Rpb25UeXBlKCkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLm1hdGNoKDExKSB8fCB0aGlzLm1hdGNoKDIxKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLnRzU2tpcFBhcmFtZXRlclN0YXJ0KCkpIHtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDE0KSB8fCB0aGlzLm1hdGNoKDEyKSB8fCB0aGlzLm1hdGNoKDE3KSB8fCB0aGlzLm1hdGNoKDI5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1hdGNoKDExKSkge1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2goMTkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRzUGFyc2VUeXBlT3JUeXBlUHJlZGljYXRlQW5ub3RhdGlvbihyZXR1cm5Ub2tlbikge1xuICAgIHJldHVybiB0aGlzLnRzSW5UeXBlKCgpID0+IHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5leHBlY3QocmV0dXJuVG9rZW4pO1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBjb25zdCBhc3NlcnRzID0gISF0aGlzLnRzVHJ5UGFyc2UodGhpcy50c1BhcnNlVHlwZVByZWRpY2F0ZUFzc2VydHMuYmluZCh0aGlzKSk7XG4gICAgICBpZiAoYXNzZXJ0cyAmJiB0aGlzLm1hdGNoKDc4KSkge1xuICAgICAgICBsZXQgdGhpc1R5cGVQcmVkaWNhdGUgPSB0aGlzLnRzUGFyc2VUaGlzVHlwZU9yVGhpc1R5cGVQcmVkaWNhdGUoKTtcbiAgICAgICAgaWYgKHRoaXNUeXBlUHJlZGljYXRlLnR5cGUgPT09IFwiVFNUaGlzVHlwZVwiKSB7XG4gICAgICAgICAgbm9kZS5wYXJhbWV0ZXJOYW1lID0gdGhpc1R5cGVQcmVkaWNhdGU7XG4gICAgICAgICAgbm9kZS5hc3NlcnRzID0gdHJ1ZTtcbiAgICAgICAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gbnVsbDtcbiAgICAgICAgICB0aGlzVHlwZVByZWRpY2F0ZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZVByZWRpY2F0ZVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbkZyb21Ob2RlKHRoaXNUeXBlUHJlZGljYXRlLCBub2RlKTtcbiAgICAgICAgICB0aGlzVHlwZVByZWRpY2F0ZS5hc3NlcnRzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0LnR5cGVBbm5vdGF0aW9uID0gdGhpc1R5cGVQcmVkaWNhdGU7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUodCwgXCJUU1R5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgdHlwZVByZWRpY2F0ZVZhcmlhYmxlID0gdGhpcy50c0lzSWRlbnRpZmllcigpICYmIHRoaXMudHNUcnlQYXJzZSh0aGlzLnRzUGFyc2VUeXBlUHJlZGljYXRlUHJlZml4LmJpbmQodGhpcykpO1xuICAgICAgaWYgKCF0eXBlUHJlZGljYXRlVmFyaWFibGUpIHtcbiAgICAgICAgaWYgKCFhc3NlcnRzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVR5cGVBbm5vdGF0aW9uKGZhbHNlLCB0KTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnBhcmFtZXRlck5hbWUgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgICBub2RlLmFzc2VydHMgPSBhc3NlcnRzO1xuICAgICAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gbnVsbDtcbiAgICAgICAgdC50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZVByZWRpY2F0ZVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZSh0LCBcIlRTVHlwZUFubm90YXRpb25cIik7XG4gICAgICB9XG4gICAgICBjb25zdCB0eXBlID0gdGhpcy50c1BhcnNlVHlwZUFubm90YXRpb24oZmFsc2UpO1xuICAgICAgbm9kZS5wYXJhbWV0ZXJOYW1lID0gdHlwZVByZWRpY2F0ZVZhcmlhYmxlO1xuICAgICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHR5cGU7XG4gICAgICBub2RlLmFzc2VydHMgPSBhc3NlcnRzO1xuICAgICAgdC50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZVByZWRpY2F0ZVwiKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUodCwgXCJUU1R5cGVBbm5vdGF0aW9uXCIpO1xuICAgIH0pO1xuICB9XG4gIHRzVHJ5UGFyc2VUeXBlT3JUeXBlUHJlZGljYXRlQW5ub3RhdGlvbigpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlT3JUeXBlUHJlZGljYXRlQW5ub3RhdGlvbigxNCk7XG4gICAgfVxuICB9XG4gIHRzVHJ5UGFyc2VUeXBlQW5ub3RhdGlvbigpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgIH1cbiAgfVxuICB0c1RyeVBhcnNlVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy50c0VhdFRoZW5QYXJzZVR5cGUoMTQpO1xuICB9XG4gIHRzUGFyc2VUeXBlUHJlZGljYXRlUHJlZml4KCkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTE2KSAmJiAhdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICB9XG4gIHRzUGFyc2VUeXBlUHJlZGljYXRlQXNzZXJ0cygpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS50eXBlICE9PSAxMDkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgY29udGFpbnNFc2MgPSB0aGlzLnN0YXRlLmNvbnRhaW5zRXNjO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICghdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSAmJiAhdGhpcy5tYXRjaCg3OCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGNvbnRhaW5zRXNjKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkRXNjYXBlZFJlc2VydmVkV29yZCwgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MsIHtcbiAgICAgICAgcmVzZXJ2ZWRXb3JkOiBcImFzc2VydHNcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRzUGFyc2VUeXBlQW5ub3RhdGlvbihlYXRDb2xvbiA9IHRydWUsIHQgPSB0aGlzLnN0YXJ0Tm9kZSgpKSB7XG4gICAgdGhpcy50c0luVHlwZSgoKSA9PiB7XG4gICAgICBpZiAoZWF0Q29sb24pIHRoaXMuZXhwZWN0KDE0KTtcbiAgICAgIHQudHlwZUFubm90YXRpb24gPSB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZSh0LCBcIlRTVHlwZUFubm90YXRpb25cIik7XG4gIH1cbiAgdHNQYXJzZVR5cGUoKSB7XG4gICAgYXNzZXJ0KHRoaXMuc3RhdGUuaW5UeXBlKTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50c1BhcnNlTm9uQ29uZGl0aW9uYWxUeXBlKCk7XG4gICAgaWYgKHRoaXMuc3RhdGUuaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0IHx8IHRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkgfHwgIXRoaXMuZWF0KDgxKSkge1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0Tm9kZSh0eXBlKTtcbiAgICBub2RlLmNoZWNrVHlwZSA9IHR5cGU7XG4gICAgbm9kZS5leHRlbmRzVHlwZSA9IHRoaXMudHNJbkRpc2FsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQoKCkgPT4gdGhpcy50c1BhcnNlTm9uQ29uZGl0aW9uYWxUeXBlKCkpO1xuICAgIHRoaXMuZXhwZWN0KDE3KTtcbiAgICBub2RlLnRydWVUeXBlID0gdGhpcy50c0luQWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCgoKSA9PiB0aGlzLnRzUGFyc2VUeXBlKCkpO1xuICAgIHRoaXMuZXhwZWN0KDE0KTtcbiAgICBub2RlLmZhbHNlVHlwZSA9IHRoaXMudHNJbkFsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQoKCkgPT4gdGhpcy50c1BhcnNlVHlwZSgpKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNDb25kaXRpb25hbFR5cGVcIik7XG4gIH1cbiAgaXNBYnN0cmFjdENvbnN0cnVjdG9yU2lnbmF0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLmlzQ29udGV4dHVhbCgxMjQpICYmIHRoaXMubG9va2FoZWFkKCkudHlwZSA9PT0gNzc7XG4gIH1cbiAgdHNQYXJzZU5vbkNvbmRpdGlvbmFsVHlwZSgpIHtcbiAgICBpZiAodGhpcy50c0lzU3RhcnRPZkZ1bmN0aW9uVHlwZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlRnVuY3Rpb25PckNvbnN0cnVjdG9yVHlwZShcIlRTRnVuY3Rpb25UeXBlXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCg3NykpIHtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VGdW5jdGlvbk9yQ29uc3RydWN0b3JUeXBlKFwiVFNDb25zdHJ1Y3RvclR5cGVcIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQWJzdHJhY3RDb25zdHJ1Y3RvclNpZ25hdHVyZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlRnVuY3Rpb25PckNvbnN0cnVjdG9yVHlwZShcIlRTQ29uc3RydWN0b3JUeXBlXCIsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50c1BhcnNlVW5pb25UeXBlT3JIaWdoZXIoKTtcbiAgfVxuICB0c1BhcnNlVHlwZUFzc2VydGlvbigpIHtcbiAgICBpZiAodGhpcy5nZXRQbHVnaW5PcHRpb24oXCJ0eXBlc2NyaXB0XCIsIFwiZGlzYWxsb3dBbWJpZ3VvdXNKU1hMaWtlXCIpKSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlJlc2VydmVkVHlwZUFzc2VydGlvbiwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLnRzSW5UeXBlKCgpID0+IHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMubWF0Y2goNzUpID8gdGhpcy50c1BhcnNlVHlwZVJlZmVyZW5jZSgpIDogdGhpcy50c1BhcnNlVHlwZSgpO1xuICAgIH0pO1xuICAgIHRoaXMuZXhwZWN0KDQ4KTtcbiAgICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLnBhcnNlTWF5YmVVbmFyeSgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1R5cGVBc3NlcnRpb25cIik7XG4gIH1cbiAgdHNQYXJzZUhlcml0YWdlQ2xhdXNlKHRva2VuKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgZGVsaW1pdGVkTGlzdCA9IHRoaXMudHNQYXJzZURlbGltaXRlZExpc3QoXCJIZXJpdGFnZUNsYXVzZUVsZW1lbnRcIiwgKCkgPT4ge1xuICAgICAge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgbm9kZS5leHByZXNzaW9uID0gdGhpcy50c1BhcnNlRW50aXR5TmFtZSgxIHwgMik7XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghZGVsaW1pdGVkTGlzdC5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuRW1wdHlIZXJpdGFnZUNsYXVzZVR5cGUsIG9yaWdpbmFsU3RhcnRMb2MsIHtcbiAgICAgICAgdG9rZW5cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVsaW1pdGVkTGlzdDtcbiAgfVxuICB0c1BhcnNlSW50ZXJmYWNlRGVjbGFyYXRpb24obm9kZSwgcHJvcGVydGllcyA9IHt9KSB7XG4gICAgaWYgKHRoaXMuaGFzRm9sbG93aW5nTGluZUJyZWFrKCkpIHJldHVybiBudWxsO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCgxMjkpO1xuICAgIGlmIChwcm9wZXJ0aWVzLmRlY2xhcmUpIG5vZGUuZGVjbGFyZSA9IHRydWU7XG4gICAgaWYgKHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgdGhpcy5jaGVja0lkZW50aWZpZXIobm9kZS5pZCwgMTMwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5pZCA9IG51bGw7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLk1pc3NpbmdJbnRlcmZhY2VOYW1lLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMudHNUcnlQYXJzZVR5cGVQYXJhbWV0ZXJzKHRoaXMudHNQYXJzZUluT3V0Q29uc3RNb2RpZmllcnMpO1xuICAgIGlmICh0aGlzLmVhdCg4MSkpIHtcbiAgICAgIG5vZGUuZXh0ZW5kcyA9IHRoaXMudHNQYXJzZUhlcml0YWdlQ2xhdXNlKFwiZXh0ZW5kc1wiKTtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgYm9keS5ib2R5ID0gdGhpcy50c0luVHlwZSh0aGlzLnRzUGFyc2VPYmplY3RUeXBlTWVtYmVycy5iaW5kKHRoaXMpKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLmZpbmlzaE5vZGUoYm9keSwgXCJUU0ludGVyZmFjZUJvZHlcIik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTSW50ZXJmYWNlRGVjbGFyYXRpb25cIik7XG4gIH1cbiAgdHNQYXJzZVR5cGVBbGlhc0RlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICB0aGlzLmNoZWNrSWRlbnRpZmllcihub2RlLmlkLCAyKTtcbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c0luVHlwZSgoKSA9PiB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1RyeVBhcnNlVHlwZVBhcmFtZXRlcnModGhpcy50c1BhcnNlSW5PdXRNb2RpZmllcnMpO1xuICAgICAgdGhpcy5leHBlY3QoMjkpO1xuICAgICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDExNCkgJiYgdGhpcy5sb29rYWhlYWQoKS50eXBlICE9PSAxNikge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0ludHJpbnNpY0tleXdvcmRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZSgpO1xuICAgIH0pO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIik7XG4gIH1cbiAgdHNJblRvcExldmVsQ29udGV4dChjYikge1xuICAgIGlmICh0aGlzLmN1ckNvbnRleHQoKSAhPT0gdHlwZXMuYnJhY2UpIHtcbiAgICAgIGNvbnN0IG9sZENvbnRleHQgPSB0aGlzLnN0YXRlLmNvbnRleHQ7XG4gICAgICB0aGlzLnN0YXRlLmNvbnRleHQgPSBbb2xkQ29udGV4dFswXV07XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gY2IoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuc3RhdGUuY29udGV4dCA9IG9sZENvbnRleHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjYigpO1xuICAgIH1cbiAgfVxuICB0c0luVHlwZShjYikge1xuICAgIGNvbnN0IG9sZEluVHlwZSA9IHRoaXMuc3RhdGUuaW5UeXBlO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNiKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gb2xkSW5UeXBlO1xuICAgIH1cbiAgfVxuICB0c0luRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dChjYikge1xuICAgIGNvbnN0IG9sZEluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCA9IHRoaXMuc3RhdGUuaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0O1xuICAgIHRoaXMuc3RhdGUuaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0ID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNiKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc3RhdGUuaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0ID0gb2xkSW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0O1xuICAgIH1cbiAgfVxuICB0c0luQWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dChjYikge1xuICAgIGNvbnN0IG9sZEluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCA9IHRoaXMuc3RhdGUuaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0O1xuICAgIHRoaXMuc3RhdGUuaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0ID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnN0YXRlLmluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCA9IG9sZEluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dDtcbiAgICB9XG4gIH1cbiAgdHNFYXRUaGVuUGFyc2VUeXBlKHRva2VuKSB7XG4gICAgaWYgKHRoaXMubWF0Y2godG9rZW4pKSB7XG4gICAgICByZXR1cm4gdGhpcy50c05leHRUaGVuUGFyc2VUeXBlKCk7XG4gICAgfVxuICB9XG4gIHRzRXhwZWN0VGhlblBhcnNlVHlwZSh0b2tlbikge1xuICAgIHJldHVybiB0aGlzLnRzSW5UeXBlKCgpID0+IHtcbiAgICAgIHRoaXMuZXhwZWN0KHRva2VuKTtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgfSk7XG4gIH1cbiAgdHNOZXh0VGhlblBhcnNlVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy50c0luVHlwZSgoKSA9PiB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgfSk7XG4gIH1cbiAgdHNQYXJzZUVudW1NZW1iZXIoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5pZCA9IHRoaXMubWF0Y2goMTM0KSA/IHN1cGVyLnBhcnNlU3RyaW5nTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKSA6IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgIGlmICh0aGlzLmVhdCgyOSkpIHtcbiAgICAgIG5vZGUuaW5pdGlhbGl6ZXIgPSBzdXBlci5wYXJzZU1heWJlQXNzaWduQWxsb3dJbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNFbnVtTWVtYmVyXCIpO1xuICB9XG4gIHRzUGFyc2VFbnVtRGVjbGFyYXRpb24obm9kZSwgcHJvcGVydGllcyA9IHt9KSB7XG4gICAgaWYgKHByb3BlcnRpZXMuY29uc3QpIG5vZGUuY29uc3QgPSB0cnVlO1xuICAgIGlmIChwcm9wZXJ0aWVzLmRlY2xhcmUpIG5vZGUuZGVjbGFyZSA9IHRydWU7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKDEyNik7XG4gICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgdGhpcy5jaGVja0lkZW50aWZpZXIobm9kZS5pZCwgbm9kZS5jb25zdCA/IDg5NzEgOiA4NDU5KTtcbiAgICB7XG4gICAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICAgIG5vZGUubWVtYmVycyA9IHRoaXMudHNQYXJzZURlbGltaXRlZExpc3QoXCJFbnVtTWVtYmVyc1wiLCB0aGlzLnRzUGFyc2VFbnVtTWVtYmVyLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5leHBlY3QoOCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0VudW1EZWNsYXJhdGlvblwiKTtcbiAgfVxuICB0c1BhcnNlRW51bUJvZHkoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgbm9kZS5tZW1iZXJzID0gdGhpcy50c1BhcnNlRGVsaW1pdGVkTGlzdChcIkVudW1NZW1iZXJzXCIsIHRoaXMudHNQYXJzZUVudW1NZW1iZXIuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5leHBlY3QoOCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTRW51bUJvZHlcIik7XG4gIH1cbiAgdHNQYXJzZU1vZHVsZUJsb2NrKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMuc2NvcGUuZW50ZXIoMCk7XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgc3VwZXIucGFyc2VCbG9ja09yTW9kdWxlQmxvY2tCb2R5KG5vZGUuYm9keSA9IFtdLCB1bmRlZmluZWQsIHRydWUsIDgpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU01vZHVsZUJsb2NrXCIpO1xuICB9XG4gIHRzUGFyc2VNb2R1bGVPck5hbWVzcGFjZURlY2xhcmF0aW9uKG5vZGUsIG5lc3RlZCA9IGZhbHNlKSB7XG4gICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgaWYgKCFuZXN0ZWQpIHtcbiAgICAgIHRoaXMuY2hlY2tJZGVudGlmaWVyKG5vZGUuaWQsIDEwMjQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lYXQoMTYpKSB7XG4gICAgICBjb25zdCBpbm5lciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLnRzUGFyc2VNb2R1bGVPck5hbWVzcGFjZURlY2xhcmF0aW9uKGlubmVyLCB0cnVlKTtcbiAgICAgIG5vZGUuYm9keSA9IGlubmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNjb3BlLmVudGVyKDI1Nik7XG4gICAgICB0aGlzLnByb2RQYXJhbS5lbnRlcigwKTtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMudHNQYXJzZU1vZHVsZUJsb2NrKCk7XG4gICAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIik7XG4gIH1cbiAgdHNQYXJzZUFtYmllbnRFeHRlcm5hbE1vZHVsZURlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTEyKSkge1xuICAgICAgbm9kZS5raW5kID0gXCJnbG9iYWxcIjtcbiAgICAgIHtcbiAgICAgICAgbm9kZS5nbG9iYWwgPSB0cnVlO1xuICAgICAgfVxuICAgICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKDEzNCkpIHtcbiAgICAgIG5vZGUua2luZCA9IFwibW9kdWxlXCI7XG4gICAgICBub2RlLmlkID0gc3VwZXIucGFyc2VTdHJpbmdMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goNSkpIHtcbiAgICAgIHRoaXMuc2NvcGUuZW50ZXIoMjU2KTtcbiAgICAgIHRoaXMucHJvZFBhcmFtLmVudGVyKDApO1xuICAgICAgbm9kZS5ib2R5ID0gdGhpcy50c1BhcnNlTW9kdWxlQmxvY2soKTtcbiAgICAgIHRoaXMucHJvZFBhcmFtLmV4aXQoKTtcbiAgICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiKTtcbiAgfVxuICB0c1BhcnNlSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24obm9kZSwgbWF5YmVEZWZhdWx0SWRlbnRpZmllciwgaXNFeHBvcnQpIHtcbiAgICB7XG4gICAgICBub2RlLmlzRXhwb3J0ID0gaXNFeHBvcnQgfHwgZmFsc2U7XG4gICAgfVxuICAgIG5vZGUuaWQgPSBtYXliZURlZmF1bHRJZGVudGlmaWVyIHx8IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgdGhpcy5jaGVja0lkZW50aWZpZXIobm9kZS5pZCwgNDA5Nik7XG4gICAgdGhpcy5leHBlY3QoMjkpO1xuICAgIGNvbnN0IG1vZHVsZVJlZmVyZW5jZSA9IHRoaXMudHNQYXJzZU1vZHVsZVJlZmVyZW5jZSgpO1xuICAgIGlmIChub2RlLmltcG9ydEtpbmQgPT09IFwidHlwZVwiICYmIG1vZHVsZVJlZmVyZW5jZS50eXBlICE9PSBcIlRTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2VcIikge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5JbXBvcnRBbGlhc0hhc0ltcG9ydFR5cGUsIG1vZHVsZVJlZmVyZW5jZSk7XG4gICAgfVxuICAgIG5vZGUubW9kdWxlUmVmZXJlbmNlID0gbW9kdWxlUmVmZXJlbmNlO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb25cIik7XG4gIH1cbiAgdHNJc0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlKCkge1xuICAgIHJldHVybiB0aGlzLmlzQ29udGV4dHVhbCgxMTkpICYmIHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gNDA7XG4gIH1cbiAgdHNQYXJzZU1vZHVsZVJlZmVyZW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy50c0lzRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2UoKSA/IHRoaXMudHNQYXJzZUV4dGVybmFsTW9kdWxlUmVmZXJlbmNlKCkgOiB0aGlzLnRzUGFyc2VFbnRpdHlOYW1lKDApO1xuICB9XG4gIHRzUGFyc2VFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoMTE5KTtcbiAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDEzNCkpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICBub2RlLmV4cHJlc3Npb24gPSBzdXBlci5wYXJzZUV4cHJBdG9tKCk7XG4gICAgdGhpcy5leHBlY3QoMTEpO1xuICAgIHRoaXMuc2F3VW5hbWJpZ3VvdXNFU00gPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlXCIpO1xuICB9XG4gIHRzTG9va0FoZWFkKGYpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUuY2xvbmUoKTtcbiAgICBjb25zdCByZXMgPSBmKCk7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgdHNUcnlQYXJzZUFuZENhdGNoKGYpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRyeVBhcnNlKGFib3J0ID0+IGYoKSB8fCBhYm9ydCgpKTtcbiAgICBpZiAocmVzdWx0LmFib3J0ZWQgfHwgIXJlc3VsdC5ub2RlKSByZXR1cm47XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgdGhpcy5zdGF0ZSA9IHJlc3VsdC5mYWlsU3RhdGU7XG4gICAgcmV0dXJuIHJlc3VsdC5ub2RlO1xuICB9XG4gIHRzVHJ5UGFyc2UoZikge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5jbG9uZSgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGYoKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgcmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICB9XG4gIHRzVHJ5UGFyc2VEZWNsYXJlKG5hbnkpIHtcbiAgICBpZiAodGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHN0YXJ0VHlwZSA9IHRoaXMuc3RhdGUudHlwZTtcbiAgICBsZXQga2luZDtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTAwKSkge1xuICAgICAgc3RhcnRUeXBlID0gNzQ7XG4gICAgICBraW5kID0gXCJsZXRcIjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHNJbkFtYmllbnRDb250ZXh0KCgpID0+IHtcbiAgICAgIHN3aXRjaCAoc3RhcnRUeXBlKSB7XG4gICAgICAgIGNhc2UgNjg6XG4gICAgICAgICAgbmFueS5kZWNsYXJlID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gc3VwZXIucGFyc2VGdW5jdGlvblN0YXRlbWVudChuYW55LCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICBjYXNlIDgwOlxuICAgICAgICAgIG5hbnkuZGVjbGFyZSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyhuYW55LCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIGNhc2UgMTI2OlxuICAgICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VFbnVtRGVjbGFyYXRpb24obmFueSwge1xuICAgICAgICAgICAgZGVjbGFyZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlIDExMjpcbiAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlQW1iaWVudEV4dGVybmFsTW9kdWxlRGVjbGFyYXRpb24obmFueSk7XG4gICAgICAgIGNhc2UgNzU6XG4gICAgICAgIGNhc2UgNzQ6XG4gICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKDc1KSB8fCAhdGhpcy5pc0xvb2thaGVhZENvbnRleHR1YWwoXCJlbnVtXCIpKSB7XG4gICAgICAgICAgICBuYW55LmRlY2xhcmUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYXJTdGF0ZW1lbnQobmFueSwga2luZCB8fCB0aGlzLnN0YXRlLnZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5leHBlY3QoNzUpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VFbnVtRGVjbGFyYXRpb24obmFueSwge1xuICAgICAgICAgICAgY29uc3Q6IHRydWUsXG4gICAgICAgICAgICBkZWNsYXJlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgMTI5OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudHNQYXJzZUludGVyZmFjZURlY2xhcmF0aW9uKG5hbnksIHtcbiAgICAgICAgICAgICAgZGVjbGFyZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIoc3RhcnRUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZURlY2xhcmF0aW9uKG5hbnksIHRoaXMuc3RhdGUudmFsdWUsIHRydWUsIG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB0c1RyeVBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHNQYXJzZURlY2xhcmF0aW9uKHRoaXMuc3RhcnROb2RlKCksIHRoaXMuc3RhdGUudmFsdWUsIHRydWUsIG51bGwpO1xuICB9XG4gIHRzUGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIsIGRlY29yYXRvcnMpIHtcbiAgICBzd2l0Y2ggKGV4cHIubmFtZSkge1xuICAgICAgY2FzZSBcImRlY2xhcmVcIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gdGhpcy50c1RyeVBhcnNlRGVjbGFyZShub2RlKTtcbiAgICAgICAgICBpZiAoZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uLmRlY2xhcmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGVjbGFyYXRpb247XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJnbG9iYWxcIjpcbiAgICAgICAgaWYgKHRoaXMubWF0Y2goNSkpIHtcbiAgICAgICAgICB0aGlzLnNjb3BlLmVudGVyKDI1Nik7XG4gICAgICAgICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoMCk7XG4gICAgICAgICAgY29uc3QgbW9kID0gbm9kZTtcbiAgICAgICAgICBtb2Qua2luZCA9IFwiZ2xvYmFsXCI7XG4gICAgICAgICAge1xuICAgICAgICAgICAgbm9kZS5nbG9iYWwgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb2QuaWQgPSBleHByO1xuICAgICAgICAgIG1vZC5ib2R5ID0gdGhpcy50c1BhcnNlTW9kdWxlQmxvY2soKTtcbiAgICAgICAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICAgICAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShtb2QsIFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VEZWNsYXJhdGlvbihub2RlLCBleHByLm5hbWUsIGZhbHNlLCBkZWNvcmF0b3JzKTtcbiAgICB9XG4gIH1cbiAgdHNQYXJzZURlY2xhcmF0aW9uKG5vZGUsIHZhbHVlLCBuZXh0LCBkZWNvcmF0b3JzKSB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgY2FzZSBcImFic3RyYWN0XCI6XG4gICAgICAgIGlmICh0aGlzLnRzQ2hlY2tMaW5lVGVybWluYXRvcihuZXh0KSAmJiAodGhpcy5tYXRjaCg4MCkgfHwgdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlQWJzdHJhY3REZWNsYXJhdGlvbihub2RlLCBkZWNvcmF0b3JzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtb2R1bGVcIjpcbiAgICAgICAgaWYgKHRoaXMudHNDaGVja0xpbmVUZXJtaW5hdG9yKG5leHQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMubWF0Y2goMTM0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUFtYmllbnRFeHRlcm5hbE1vZHVsZURlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICAgICAgbm9kZS5raW5kID0gXCJtb2R1bGVcIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VNb2R1bGVPck5hbWVzcGFjZURlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJuYW1lc3BhY2VcIjpcbiAgICAgICAgaWYgKHRoaXMudHNDaGVja0xpbmVUZXJtaW5hdG9yKG5leHQpICYmIHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgICAgICBub2RlLmtpbmQgPSBcIm5hbWVzcGFjZVwiO1xuICAgICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VNb2R1bGVPck5hbWVzcGFjZURlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInR5cGVcIjpcbiAgICAgICAgaWYgKHRoaXMudHNDaGVja0xpbmVUZXJtaW5hdG9yKG5leHQpICYmIHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZUFsaWFzRGVjbGFyYXRpb24obm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRzQ2hlY2tMaW5lVGVybWluYXRvcihuZXh0KSB7XG4gICAgaWYgKG5leHQpIHtcbiAgICAgIGlmICh0aGlzLmhhc0ZvbGxvd2luZ0xpbmVCcmVhaygpKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gIXRoaXMuaXNMaW5lVGVybWluYXRvcigpO1xuICB9XG4gIHRzVHJ5UGFyc2VHZW5lcmljQXN5bmNBcnJvd0Z1bmN0aW9uKHN0YXJ0TG9jKSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDQ3KSkgcmV0dXJuO1xuICAgIGNvbnN0IG9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnM7XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gdHJ1ZTtcbiAgICBjb25zdCByZXMgPSB0aGlzLnRzVHJ5UGFyc2VBbmRDYXRjaCgoKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1BhcnNlVHlwZVBhcmFtZXRlcnModGhpcy50c1BhcnNlQ29uc3RNb2RpZmllcik7XG4gICAgICBzdXBlci5wYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUpO1xuICAgICAgbm9kZS5yZXR1cm5UeXBlID0gdGhpcy50c1RyeVBhcnNlVHlwZU9yVHlwZVByZWRpY2F0ZUFubm90YXRpb24oKTtcbiAgICAgIHRoaXMuZXhwZWN0KDE5KTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICAgIHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycyA9IG9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnM7XG4gICAgaWYgKCFyZXMpIHJldHVybjtcbiAgICByZXR1cm4gc3VwZXIucGFyc2VBcnJvd0V4cHJlc3Npb24ocmVzLCBudWxsLCB0cnVlKTtcbiAgfVxuICB0c1BhcnNlVHlwZUFyZ3VtZW50c0luRXhwcmVzc2lvbigpIHtcbiAgICBpZiAodGhpcy5yZVNjYW5fbHQoKSAhPT0gNDcpIHJldHVybjtcbiAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZUFyZ3VtZW50cygpO1xuICB9XG4gIHRzUGFyc2VUeXBlQXJndW1lbnRzKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUucGFyYW1zID0gdGhpcy50c0luVHlwZSgoKSA9PiB0aGlzLnRzSW5Ub3BMZXZlbENvbnRleHQoKCkgPT4ge1xuICAgICAgdGhpcy5leHBlY3QoNDcpO1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZURlbGltaXRlZExpc3QoXCJUeXBlUGFyYW1ldGVyc09yQXJndW1lbnRzXCIsIHRoaXMudHNQYXJzZVR5cGUuYmluZCh0aGlzKSk7XG4gICAgfSkpO1xuICAgIGlmIChub2RlLnBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuRW1wdHlUeXBlQXJndW1lbnRzLCBub2RlKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnN0YXRlLmluVHlwZSAmJiB0aGlzLmN1ckNvbnRleHQoKSA9PT0gdHlwZXMuYnJhY2UpIHtcbiAgICAgIHRoaXMucmVTY2FuX2x0X2d0KCk7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDQ4KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKTtcbiAgfVxuICB0c0lzRGVjbGFyYXRpb25TdGFydCgpIHtcbiAgICByZXR1cm4gdG9rZW5Jc1RTRGVjbGFyYXRpb25TdGFydCh0aGlzLnN0YXRlLnR5cGUpO1xuICB9XG4gIGlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcigpIHtcbiAgICBpZiAodGhpcy50c0lzRGVjbGFyYXRpb25TdGFydCgpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHN1cGVyLmlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcigpO1xuICB9XG4gIHBhcnNlQmluZGluZ0VsZW1lbnQoZmxhZ3MsIGRlY29yYXRvcnMpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgbW9kaWZpZWQgPSB7fTtcbiAgICB0aGlzLnRzUGFyc2VNb2RpZmllcnMoe1xuICAgICAgYWxsb3dlZE1vZGlmaWVyczogW1wicHVibGljXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCBcIm92ZXJyaWRlXCIsIFwicmVhZG9ubHlcIl1cbiAgICB9LCBtb2RpZmllZCk7XG4gICAgY29uc3QgYWNjZXNzaWJpbGl0eSA9IG1vZGlmaWVkLmFjY2Vzc2liaWxpdHk7XG4gICAgY29uc3Qgb3ZlcnJpZGUgPSBtb2RpZmllZC5vdmVycmlkZTtcbiAgICBjb25zdCByZWFkb25seSA9IG1vZGlmaWVkLnJlYWRvbmx5O1xuICAgIGlmICghKGZsYWdzICYgNCkgJiYgKGFjY2Vzc2liaWxpdHkgfHwgcmVhZG9ubHkgfHwgb3ZlcnJpZGUpKSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlVuZXhwZWN0ZWRQYXJhbWV0ZXJNb2RpZmllciwgc3RhcnRMb2MpO1xuICAgIH1cbiAgICBjb25zdCBsZWZ0ID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCgpO1xuICAgIGlmIChmbGFncyAmIDIpIHtcbiAgICAgIHRoaXMucGFyc2VGdW5jdGlvblBhcmFtVHlwZShsZWZ0KTtcbiAgICB9XG4gICAgY29uc3QgZWx0ID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChsZWZ0LmxvYy5zdGFydCwgbGVmdCk7XG4gICAgaWYgKGFjY2Vzc2liaWxpdHkgfHwgcmVhZG9ubHkgfHwgb3ZlcnJpZGUpIHtcbiAgICAgIGNvbnN0IHBwID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBpZiAoZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgcHAuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnM7XG4gICAgICB9XG4gICAgICBpZiAoYWNjZXNzaWJpbGl0eSkgcHAuYWNjZXNzaWJpbGl0eSA9IGFjY2Vzc2liaWxpdHk7XG4gICAgICBpZiAocmVhZG9ubHkpIHBwLnJlYWRvbmx5ID0gcmVhZG9ubHk7XG4gICAgICBpZiAob3ZlcnJpZGUpIHBwLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgICBpZiAoZWx0LnR5cGUgIT09IFwiSWRlbnRpZmllclwiICYmIGVsdC50eXBlICE9PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5VbnN1cHBvcnRlZFBhcmFtZXRlclByb3BlcnR5S2luZCwgcHApO1xuICAgICAgfVxuICAgICAgcHAucGFyYW1ldGVyID0gZWx0O1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcCwgXCJUU1BhcmFtZXRlclByb3BlcnR5XCIpO1xuICAgIH1cbiAgICBpZiAoZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgIGxlZnQuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnM7XG4gICAgfVxuICAgIHJldHVybiBlbHQ7XG4gIH1cbiAgaXNTaW1wbGVQYXJhbWV0ZXIobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiICYmIHN1cGVyLmlzU2ltcGxlUGFyYW1ldGVyKG5vZGUucGFyYW1ldGVyKSB8fCBzdXBlci5pc1NpbXBsZVBhcmFtZXRlcihub2RlKTtcbiAgfVxuICB0c0Rpc2FsbG93T3B0aW9uYWxQYXR0ZXJuKG5vZGUpIHtcbiAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIG5vZGUucGFyYW1zKSB7XG4gICAgICBpZiAocGFyYW0udHlwZSAhPT0gXCJJZGVudGlmaWVyXCIgJiYgcGFyYW0ub3B0aW9uYWwgJiYgIXRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCkge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlBhdHRlcm5Jc09wdGlvbmFsLCBwYXJhbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNldEFycm93RnVuY3Rpb25QYXJhbWV0ZXJzKG5vZGUsIHBhcmFtcywgdHJhaWxpbmdDb21tYUxvYykge1xuICAgIHN1cGVyLnNldEFycm93RnVuY3Rpb25QYXJhbWV0ZXJzKG5vZGUsIHBhcmFtcywgdHJhaWxpbmdDb21tYUxvYyk7XG4gICAgdGhpcy50c0Rpc2FsbG93T3B0aW9uYWxQYXR0ZXJuKG5vZGUpO1xuICB9XG4gIHBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIHR5cGUsIGlzTWV0aG9kID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHRoaXMudHNQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKDE0KTtcbiAgICB9XG4gICAgY29uc3QgYm9kaWxlc3NUeXBlID0gdHlwZSA9PT0gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgPyBcIlRTRGVjbGFyZUZ1bmN0aW9uXCIgOiB0eXBlID09PSBcIkNsYXNzTWV0aG9kXCIgfHwgdHlwZSA9PT0gXCJDbGFzc1ByaXZhdGVNZXRob2RcIiA/IFwiVFNEZWNsYXJlTWV0aG9kXCIgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGJvZGlsZXNzVHlwZSAmJiAhdGhpcy5tYXRjaCg1KSAmJiB0aGlzLmlzTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBib2RpbGVzc1R5cGUpO1xuICAgIH1cbiAgICBpZiAoYm9kaWxlc3NUeXBlID09PSBcIlRTRGVjbGFyZUZ1bmN0aW9uXCIgJiYgdGhpcy5zdGF0ZS5pc0FtYmllbnRDb250ZXh0KSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkRlY2xhcmVGdW5jdGlvbkhhc0ltcGxlbWVudGF0aW9uLCBub2RlKTtcbiAgICAgIGlmIChub2RlLmRlY2xhcmUpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIGJvZGlsZXNzVHlwZSwgaXNNZXRob2QpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRzRGlzYWxsb3dPcHRpb25hbFBhdHRlcm4obm9kZSk7XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIHR5cGUsIGlzTWV0aG9kKTtcbiAgfVxuICByZWdpc3RlckZ1bmN0aW9uU3RhdGVtZW50SWQobm9kZSkge1xuICAgIGlmICghbm9kZS5ib2R5ICYmIG5vZGUuaWQpIHtcbiAgICAgIHRoaXMuY2hlY2tJZGVudGlmaWVyKG5vZGUuaWQsIDEwMjQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5yZWdpc3RlckZ1bmN0aW9uU3RhdGVtZW50SWQobm9kZSk7XG4gICAgfVxuICB9XG4gIHRzQ2hlY2tGb3JJbnZhbGlkVHlwZUNhc3RzKGl0ZW1zKSB7XG4gICAgaXRlbXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIGlmICgobm9kZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZS50eXBlKSA9PT0gXCJUU1R5cGVDYXN0RXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuVW5leHBlY3RlZFR5cGVBbm5vdGF0aW9uLCBub2RlLnR5cGVBbm5vdGF0aW9uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB0b1JlZmVyZW5jZWRMaXN0KGV4cHJMaXN0LCBpc0luUGFyZW5zKSB7XG4gICAgdGhpcy50c0NoZWNrRm9ySW52YWxpZFR5cGVDYXN0cyhleHByTGlzdCk7XG4gICAgcmV0dXJuIGV4cHJMaXN0O1xuICB9XG4gIHBhcnNlQXJyYXlMaWtlKGNsb3NlLCBjYW5CZVBhdHRlcm4sIGlzVHVwbGUsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VBcnJheUxpa2UoY2xvc2UsIGNhbkJlUGF0dGVybiwgaXNUdXBsZSwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJBcnJheUV4cHJlc3Npb25cIikge1xuICAgICAgdGhpcy50c0NoZWNrRm9ySW52YWxpZFR5cGVDYXN0cyhub2RlLmVsZW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMsIHN0YXRlKSB7XG4gICAgaWYgKCF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpICYmIHRoaXMubWF0Y2goMzUpKSB7XG4gICAgICB0aGlzLnN0YXRlLmNhblN0YXJ0SlNYRWxlbWVudCA9IGZhbHNlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBjb25zdCBub25OdWxsRXhwcmVzc2lvbiA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgbm9uTnVsbEV4cHJlc3Npb24uZXhwcmVzc2lvbiA9IGJhc2U7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vbk51bGxFeHByZXNzaW9uLCBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIik7XG4gICAgfVxuICAgIGxldCBpc09wdGlvbmFsQ2FsbCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLm1hdGNoKDE4KSAmJiB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDYwKSB7XG4gICAgICBpZiAobm9DYWxscykge1xuICAgICAgICBzdGF0ZS5zdG9wID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICB9XG4gICAgICBzdGF0ZS5vcHRpb25hbENoYWluTWVtYmVyID0gaXNPcHRpb25hbENhbGwgPSB0cnVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSB8fCB0aGlzLm1hdGNoKDUxKSkge1xuICAgICAgbGV0IG1pc3NpbmdQYXJlbkVycm9yTG9jO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy50c1RyeVBhcnNlQW5kQ2F0Y2goKCkgPT4ge1xuICAgICAgICBpZiAoIW5vQ2FsbHMgJiYgdGhpcy5hdFBvc3NpYmxlQXN5bmNBcnJvdyhiYXNlKSkge1xuICAgICAgICAgIGNvbnN0IGFzeW5jQXJyb3dGbiA9IHRoaXMudHNUcnlQYXJzZUdlbmVyaWNBc3luY0Fycm93RnVuY3Rpb24oc3RhcnRMb2MpO1xuICAgICAgICAgIGlmIChhc3luY0Fycm93Rm4pIHtcbiAgICAgICAgICAgIHJldHVybiBhc3luY0Fycm93Rm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGVBcmd1bWVudHMgPSB0aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzSW5FeHByZXNzaW9uKCk7XG4gICAgICAgIGlmICghdHlwZUFyZ3VtZW50cykgcmV0dXJuO1xuICAgICAgICBpZiAoaXNPcHRpb25hbENhbGwgJiYgIXRoaXMubWF0Y2goMTApKSB7XG4gICAgICAgICAgbWlzc2luZ1BhcmVuRXJyb3JMb2MgPSB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbklzVGVtcGxhdGUodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLnBhcnNlVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKGJhc2UsIHN0YXJ0TG9jLCBzdGF0ZSk7XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmVzdWx0LnR5cGVQYXJhbWV0ZXJzID0gdHlwZUFyZ3VtZW50cztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vQ2FsbHMgJiYgdGhpcy5lYXQoMTApKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgICAgIG5vZGUuY2FsbGVlID0gYmFzZTtcbiAgICAgICAgICBub2RlLmFyZ3VtZW50cyA9IHRoaXMucGFyc2VDYWxsRXhwcmVzc2lvbkFyZ3VtZW50cygxMSk7XG4gICAgICAgICAgdGhpcy50c0NoZWNrRm9ySW52YWxpZFR5cGVDYXN0cyhub2RlLmFyZ3VtZW50cyk7XG4gICAgICAgICAge1xuICAgICAgICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHR5cGVBcmd1bWVudHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5vcHRpb25hbENoYWluTWVtYmVyKSB7XG4gICAgICAgICAgICBub2RlLm9wdGlvbmFsID0gaXNPcHRpb25hbENhbGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaENhbGxFeHByZXNzaW9uKG5vZGUsIHN0YXRlLm9wdGlvbmFsQ2hhaW5NZW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRva2VuVHlwZSA9IHRoaXMuc3RhdGUudHlwZTtcbiAgICAgICAgaWYgKHRva2VuVHlwZSA9PT0gNDggfHwgdG9rZW5UeXBlID09PSA1MiB8fCB0b2tlblR5cGUgIT09IDEwICYmIHRva2VuQ2FuU3RhcnRFeHByZXNzaW9uKHRva2VuVHlwZSkgJiYgIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgICBub2RlLmV4cHJlc3Npb24gPSBiYXNlO1xuICAgICAgICB7XG4gICAgICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHR5cGVBcmd1bWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTSW5zdGFudGlhdGlvbkV4cHJlc3Npb25cIik7XG4gICAgICB9KTtcbiAgICAgIGlmIChtaXNzaW5nUGFyZW5FcnJvckxvYykge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQobWlzc2luZ1BhcmVuRXJyb3JMb2MsIDEwKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcIlRTSW5zdGFudGlhdGlvbkV4cHJlc3Npb25cIiAmJiAodGhpcy5tYXRjaCgxNikgfHwgdGhpcy5tYXRjaCgxOCkgJiYgdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpICE9PSA0MCkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkludmFsaWRQcm9wZXJ0eUFjY2Vzc0FmdGVySW5zdGFudGlhdGlvbkV4cHJlc3Npb24sIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZVN1YnNjcmlwdChiYXNlLCBzdGFydExvYywgbm9DYWxscywgc3RhdGUpO1xuICB9XG4gIHBhcnNlTmV3Q2FsbGVlKG5vZGUpIHtcbiAgICB2YXIgX2NhbGxlZSRleHRyYTtcbiAgICBzdXBlci5wYXJzZU5ld0NhbGxlZShub2RlKTtcbiAgICBjb25zdCB7XG4gICAgICBjYWxsZWVcbiAgICB9ID0gbm9kZTtcbiAgICBpZiAoY2FsbGVlLnR5cGUgPT09IFwiVFNJbnN0YW50aWF0aW9uRXhwcmVzc2lvblwiICYmICEoKF9jYWxsZWUkZXh0cmEgPSBjYWxsZWUuZXh0cmEpICE9IG51bGwgJiYgX2NhbGxlZSRleHRyYS5wYXJlbnRoZXNpemVkKSkge1xuICAgICAge1xuICAgICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gY2FsbGVlLnR5cGVQYXJhbWV0ZXJzO1xuICAgICAgfVxuICAgICAgbm9kZS5jYWxsZWUgPSBjYWxsZWUuZXhwcmVzc2lvbjtcbiAgICB9XG4gIH1cbiAgcGFyc2VFeHByT3AobGVmdCwgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjKSB7XG4gICAgbGV0IGlzU2F0aXNmaWVzO1xuICAgIGlmICh0b2tlbk9wZXJhdG9yUHJlY2VkZW5jZSg1OCkgPiBtaW5QcmVjICYmICF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpICYmICh0aGlzLmlzQ29udGV4dHVhbCg5MykgfHwgKGlzU2F0aXNmaWVzID0gdGhpcy5pc0NvbnRleHR1YWwoMTIwKSkpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChsZWZ0U3RhcnRMb2MpO1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gbGVmdDtcbiAgICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLnRzSW5UeXBlKCgpID0+IHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKDc1KSkge1xuICAgICAgICAgIGlmIChpc1NhdGlzZmllcykge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZEtleXdvcmQsIHRoaXMuc3RhdGUuc3RhcnRMb2MsIHtcbiAgICAgICAgICAgICAga2V5d29yZDogXCJjb25zdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVR5cGVSZWZlcmVuY2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNTYXRpc2ZpZXMgPyBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiIDogXCJUU0FzRXhwcmVzc2lvblwiKTtcbiAgICAgIHRoaXMucmVTY2FuX2x0X2d0KCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJPcChub2RlLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VFeHByT3AobGVmdCwgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjKTtcbiAgfVxuICBjaGVja1Jlc2VydmVkV29yZCh3b3JkLCBzdGFydExvYywgY2hlY2tLZXl3b3JkcywgaXNCaW5kaW5nKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLmlzQW1iaWVudENvbnRleHQpIHtcbiAgICAgIHN1cGVyLmNoZWNrUmVzZXJ2ZWRXb3JkKHdvcmQsIHN0YXJ0TG9jLCBjaGVja0tleXdvcmRzLCBpc0JpbmRpbmcpO1xuICAgIH1cbiAgfVxuICBjaGVja0ltcG9ydFJlZmxlY3Rpb24obm9kZSkge1xuICAgIHN1cGVyLmNoZWNrSW1wb3J0UmVmbGVjdGlvbihub2RlKTtcbiAgICBpZiAobm9kZS5tb2R1bGUgJiYgbm9kZS5pbXBvcnRLaW5kICE9PSBcInZhbHVlXCIpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW1wb3J0UmVmbGVjdGlvbkhhc0ltcG9ydFR5cGUsIG5vZGUuc3BlY2lmaWVyc1swXS5sb2Muc3RhcnQpO1xuICAgIH1cbiAgfVxuICBjaGVja0R1cGxpY2F0ZUV4cG9ydHMoKSB7fVxuICBpc1BvdGVudGlhbEltcG9ydFBoYXNlKGlzRXhwb3J0KSB7XG4gICAgaWYgKHN1cGVyLmlzUG90ZW50aWFsSW1wb3J0UGhhc2UoaXNFeHBvcnQpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTMwKSkge1xuICAgICAgY29uc3QgY2ggPSB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCk7XG4gICAgICByZXR1cm4gaXNFeHBvcnQgPyBjaCA9PT0gMTIzIHx8IGNoID09PSA0MiA6IGNoICE9PSA2MTtcbiAgICB9XG4gICAgcmV0dXJuICFpc0V4cG9ydCAmJiB0aGlzLmlzQ29udGV4dHVhbCg4Nyk7XG4gIH1cbiAgYXBwbHlJbXBvcnRQaGFzZShub2RlLCBpc0V4cG9ydCwgcGhhc2UsIGxvYykge1xuICAgIHN1cGVyLmFwcGx5SW1wb3J0UGhhc2Uobm9kZSwgaXNFeHBvcnQsIHBoYXNlLCBsb2MpO1xuICAgIGlmIChpc0V4cG9ydCkge1xuICAgICAgbm9kZS5leHBvcnRLaW5kID0gcGhhc2UgPT09IFwidHlwZVwiID8gXCJ0eXBlXCIgOiBcInZhbHVlXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuaW1wb3J0S2luZCA9IHBoYXNlID09PSBcInR5cGVcIiB8fCBwaGFzZSA9PT0gXCJ0eXBlb2ZcIiA/IHBoYXNlIDogXCJ2YWx1ZVwiO1xuICAgIH1cbiAgfVxuICBwYXJzZUltcG9ydChub2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTM0KSkge1xuICAgICAgbm9kZS5pbXBvcnRLaW5kID0gXCJ2YWx1ZVwiO1xuICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlSW1wb3J0KG5vZGUpO1xuICAgIH1cbiAgICBsZXQgaW1wb3J0Tm9kZTtcbiAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSAmJiB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDYxKSB7XG4gICAgICBub2RlLmltcG9ydEtpbmQgPSBcInZhbHVlXCI7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24obm9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMzApKSB7XG4gICAgICBjb25zdCBtYXliZURlZmF1bHRJZGVudGlmaWVyID0gdGhpcy5wYXJzZU1heWJlSW1wb3J0UGhhc2Uobm9kZSwgZmFsc2UpO1xuICAgICAgaWYgKHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gNjEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUltcG9ydEVxdWFsc0RlY2xhcmF0aW9uKG5vZGUsIG1heWJlRGVmYXVsdElkZW50aWZpZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW1wb3J0Tm9kZSA9IHN1cGVyLnBhcnNlSW1wb3J0U3BlY2lmaWVyc0FuZEFmdGVyKG5vZGUsIG1heWJlRGVmYXVsdElkZW50aWZpZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbXBvcnROb2RlID0gc3VwZXIucGFyc2VJbXBvcnQobm9kZSk7XG4gICAgfVxuICAgIGlmIChpbXBvcnROb2RlLmltcG9ydEtpbmQgPT09IFwidHlwZVwiICYmIGltcG9ydE5vZGUuc3BlY2lmaWVycy5sZW5ndGggPiAxICYmIGltcG9ydE5vZGUuc3BlY2lmaWVyc1swXS50eXBlID09PSBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIikge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5UeXBlSW1wb3J0Q2Fubm90U3BlY2lmeURlZmF1bHRBbmROYW1lZCwgaW1wb3J0Tm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBpbXBvcnROb2RlO1xuICB9XG4gIHBhcnNlRXhwb3J0KG5vZGUsIGRlY29yYXRvcnMpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg4MykpIHtcbiAgICAgIGNvbnN0IG5vZGVJbXBvcnRFcXVhbHMgPSBub2RlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBsZXQgbWF5YmVEZWZhdWx0SWRlbnRpZmllciA9IG51bGw7XG4gICAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTMwKSAmJiB0aGlzLmlzUG90ZW50aWFsSW1wb3J0UGhhc2UoZmFsc2UpKSB7XG4gICAgICAgIG1heWJlRGVmYXVsdElkZW50aWZpZXIgPSB0aGlzLnBhcnNlTWF5YmVJbXBvcnRQaGFzZShub2RlSW1wb3J0RXF1YWxzLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlSW1wb3J0RXF1YWxzLmltcG9ydEtpbmQgPSBcInZhbHVlXCI7XG4gICAgICB9XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbiA9IHRoaXMudHNQYXJzZUltcG9ydEVxdWFsc0RlY2xhcmF0aW9uKG5vZGVJbXBvcnRFcXVhbHMsIG1heWJlRGVmYXVsdElkZW50aWZpZXIsIHRydWUpO1xuICAgICAge1xuICAgICAgICByZXR1cm4gZGVjbGFyYXRpb247XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmVhdCgyOSkpIHtcbiAgICAgIGNvbnN0IGFzc2lnbiA9IG5vZGU7XG4gICAgICBhc3NpZ24uZXhwcmVzc2lvbiA9IHN1cGVyLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIHRoaXMuc2F3VW5hbWJpZ3VvdXNFU00gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShhc3NpZ24sIFwiVFNFeHBvcnRBc3NpZ25tZW50XCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5lYXRDb250ZXh0dWFsKDkzKSkge1xuICAgICAgY29uc3QgZGVjbCA9IG5vZGU7XG4gICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoMTI4KTtcbiAgICAgIGRlY2wuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoZGVjbCwgXCJUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIucGFyc2VFeHBvcnQobm9kZSwgZGVjb3JhdG9ycyk7XG4gICAgfVxuICB9XG4gIGlzQWJzdHJhY3RDbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc0NvbnRleHR1YWwoMTI0KSAmJiB0aGlzLmxvb2thaGVhZCgpLnR5cGUgPT09IDgwO1xuICB9XG4gIHBhcnNlRXhwb3J0RGVmYXVsdEV4cHJlc3Npb24oKSB7XG4gICAgaWYgKHRoaXMuaXNBYnN0cmFjdENsYXNzKCkpIHtcbiAgICAgIGNvbnN0IGNscyA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGNscy5hYnN0cmFjdCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKGNscywgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDEyOSkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudHNQYXJzZUludGVyZmFjZURlY2xhcmF0aW9uKHRoaXMuc3RhcnROb2RlKCkpO1xuICAgICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlRXhwb3J0RGVmYXVsdEV4cHJlc3Npb24oKTtcbiAgfVxuICBwYXJzZVZhclN0YXRlbWVudChub2RlLCBraW5kLCBhbGxvd01pc3NpbmdJbml0aWFsaXplciA9IGZhbHNlKSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNBbWJpZW50Q29udGV4dFxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gc3VwZXIucGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwga2luZCwgYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIgfHwgaXNBbWJpZW50Q29udGV4dCk7XG4gICAgaWYgKCFpc0FtYmllbnRDb250ZXh0KSByZXR1cm4gZGVjbGFyYXRpb247XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGluaXRcbiAgICB9IG9mIGRlY2xhcmF0aW9uLmRlY2xhcmF0aW9ucykge1xuICAgICAgaWYgKCFpbml0KSBjb250aW51ZTtcbiAgICAgIGlmIChraW5kICE9PSBcImNvbnN0XCIgfHwgISFpZC50eXBlQW5ub3RhdGlvbikge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkluaXRpYWxpemVyTm90QWxsb3dlZEluQW1iaWVudENvbnRleHQsIGluaXQpO1xuICAgICAgfSBlbHNlIGlmICghaXNWYWxpZEFtYmllbnRDb25zdEluaXRpYWxpemVyKGluaXQsIHRoaXMuaGFzUGx1Z2luKFwiZXN0cmVlXCIpKSkge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkNvbnN0SW5pdGlhbGl6ZXJNdXN0QmVTdHJpbmdPck51bWVyaWNMaXRlcmFsT3JMaXRlcmFsRW51bVJlZmVyZW5jZSwgaW5pdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWNsYXJhdGlvbjtcbiAgfVxuICBwYXJzZVN0YXRlbWVudENvbnRlbnQoZmxhZ3MsIGRlY29yYXRvcnMpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg3NSkgJiYgdGhpcy5pc0xvb2thaGVhZENvbnRleHR1YWwoXCJlbnVtXCIpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMuZXhwZWN0KDc1KTtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VFbnVtRGVjbGFyYXRpb24obm9kZSwge1xuICAgICAgICBjb25zdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMjYpKSB7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlRW51bURlY2xhcmF0aW9uKHRoaXMuc3RhcnROb2RlKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTI5KSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy50c1BhcnNlSW50ZXJmYWNlRGVjbGFyYXRpb24odGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICBpZiAocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VTdGF0ZW1lbnRDb250ZW50KGZsYWdzLCBkZWNvcmF0b3JzKTtcbiAgfVxuICBwYXJzZUFjY2Vzc01vZGlmaWVyKCkge1xuICAgIHJldHVybiB0aGlzLnRzUGFyc2VNb2RpZmllcihbXCJwdWJsaWNcIiwgXCJwcm90ZWN0ZWRcIiwgXCJwcml2YXRlXCJdKTtcbiAgfVxuICB0c0hhc1NvbWVNb2RpZmllcnMobWVtYmVyLCBtb2RpZmllcnMpIHtcbiAgICByZXR1cm4gbW9kaWZpZXJzLnNvbWUobW9kaWZpZXIgPT4ge1xuICAgICAgaWYgKHRzSXNBY2Nlc3NNb2RpZmllcihtb2RpZmllcikpIHtcbiAgICAgICAgcmV0dXJuIG1lbWJlci5hY2Nlc3NpYmlsaXR5ID09PSBtb2RpZmllcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhIW1lbWJlclttb2RpZmllcl07XG4gICAgfSk7XG4gIH1cbiAgdHNJc1N0YXJ0T2ZTdGF0aWNCbG9ja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNDb250ZXh0dWFsKDEwNikgJiYgdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpID09PSAxMjM7XG4gIH1cbiAgcGFyc2VDbGFzc01lbWJlcihjbGFzc0JvZHksIG1lbWJlciwgc3RhdGUpIHtcbiAgICBjb25zdCBtb2RpZmllcnMgPSBbXCJkZWNsYXJlXCIsIFwicHJpdmF0ZVwiLCBcInB1YmxpY1wiLCBcInByb3RlY3RlZFwiLCBcIm92ZXJyaWRlXCIsIFwiYWJzdHJhY3RcIiwgXCJyZWFkb25seVwiLCBcInN0YXRpY1wiXTtcbiAgICB0aGlzLnRzUGFyc2VNb2RpZmllcnMoe1xuICAgICAgYWxsb3dlZE1vZGlmaWVyczogbW9kaWZpZXJzLFxuICAgICAgZGlzYWxsb3dlZE1vZGlmaWVyczogW1wiaW5cIiwgXCJvdXRcIl0sXG4gICAgICBzdG9wT25TdGFydE9mQ2xhc3NTdGF0aWNCbG9jazogdHJ1ZSxcbiAgICAgIGVycm9yVGVtcGxhdGU6IFRTRXJyb3JzLkludmFsaWRNb2RpZmllck9uVHlwZVBhcmFtZXRlclBvc2l0aW9uc1xuICAgIH0sIG1lbWJlcik7XG4gICAgY29uc3QgY2FsbFBhcnNlQ2xhc3NNZW1iZXJXaXRoSXNTdGF0aWMgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy50c0lzU3RhcnRPZlN0YXRpY0Jsb2NrcygpKSB7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKHRoaXMudHNIYXNTb21lTW9kaWZpZXJzKG1lbWJlciwgbW9kaWZpZXJzKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuU3RhdGljQmxvY2tDYW5ub3RIYXZlTW9kaWZpZXIsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIucGFyc2VDbGFzc1N0YXRpY0Jsb2NrKGNsYXNzQm9keSwgbWVtYmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyc2VDbGFzc01lbWJlcldpdGhJc1N0YXRpYyhjbGFzc0JvZHksIG1lbWJlciwgc3RhdGUsICEhbWVtYmVyLnN0YXRpYyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAobWVtYmVyLmRlY2xhcmUpIHtcbiAgICAgIHRoaXMudHNJbkFtYmllbnRDb250ZXh0KGNhbGxQYXJzZUNsYXNzTWVtYmVyV2l0aElzU3RhdGljKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbFBhcnNlQ2xhc3NNZW1iZXJXaXRoSXNTdGF0aWMoKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VDbGFzc01lbWJlcldpdGhJc1N0YXRpYyhjbGFzc0JvZHksIG1lbWJlciwgc3RhdGUsIGlzU3RhdGljKSB7XG4gICAgY29uc3QgaWR4ID0gdGhpcy50c1RyeVBhcnNlSW5kZXhTaWduYXR1cmUobWVtYmVyKTtcbiAgICBpZiAoaWR4KSB7XG4gICAgICBjbGFzc0JvZHkuYm9keS5wdXNoKGlkeCk7XG4gICAgICBpZiAobWVtYmVyLmFic3RyYWN0KSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW5kZXhTaWduYXR1cmVIYXNBYnN0cmFjdCwgbWVtYmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZW1iZXIuYWNjZXNzaWJpbGl0eSkge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkluZGV4U2lnbmF0dXJlSGFzQWNjZXNzaWJpbGl0eSwgbWVtYmVyLCB7XG4gICAgICAgICAgbW9kaWZpZXI6IG1lbWJlci5hY2Nlc3NpYmlsaXR5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG1lbWJlci5kZWNsYXJlKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW5kZXhTaWduYXR1cmVIYXNEZWNsYXJlLCBtZW1iZXIpO1xuICAgICAgfVxuICAgICAgaWYgKG1lbWJlci5vdmVycmlkZSkge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkluZGV4U2lnbmF0dXJlSGFzT3ZlcnJpZGUsIG1lbWJlcik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5zdGF0ZS5pbkFic3RyYWN0Q2xhc3MgJiYgbWVtYmVyLmFic3RyYWN0KSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLk5vbkFic3RyYWN0Q2xhc3NIYXNBYnN0cmFjdE1ldGhvZCwgbWVtYmVyKTtcbiAgICB9XG4gICAgaWYgKG1lbWJlci5vdmVycmlkZSkge1xuICAgICAgaWYgKCFzdGF0ZS5oYWRTdXBlckNsYXNzKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuT3ZlcnJpZGVOb3RJblN1YkNsYXNzLCBtZW1iZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlci5wYXJzZUNsYXNzTWVtYmVyV2l0aElzU3RhdGljKGNsYXNzQm9keSwgbWVtYmVyLCBzdGF0ZSwgaXNTdGF0aWMpO1xuICB9XG4gIHBhcnNlUG9zdE1lbWJlck5hbWVNb2RpZmllcnMobWV0aG9kT3JQcm9wKSB7XG4gICAgY29uc3Qgb3B0aW9uYWwgPSB0aGlzLmVhdCgxNyk7XG4gICAgaWYgKG9wdGlvbmFsKSBtZXRob2RPclByb3Aub3B0aW9uYWwgPSB0cnVlO1xuICAgIGlmIChtZXRob2RPclByb3AucmVhZG9ubHkgJiYgdGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuQ2xhc3NNZXRob2RIYXNSZWFkb25seSwgbWV0aG9kT3JQcm9wKTtcbiAgICB9XG4gICAgaWYgKG1ldGhvZE9yUHJvcC5kZWNsYXJlICYmIHRoaXMubWF0Y2goMTApKSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkNsYXNzTWV0aG9kSGFzRGVjbGFyZSwgbWV0aG9kT3JQcm9wKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIsIGRlY29yYXRvcnMpIHtcbiAgICBjb25zdCBkZWNsID0gZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiA/IHRoaXMudHNQYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwciwgZGVjb3JhdG9ycykgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGRlY2wgfHwgc3VwZXIucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIsIGRlY29yYXRvcnMpO1xuICB9XG4gIHNob3VsZFBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKSB7XG4gICAgaWYgKHRoaXMudHNJc0RlY2xhcmF0aW9uU3RhcnQoKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHN1cGVyLnNob3VsZFBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKTtcbiAgfVxuICBwYXJzZUNvbmRpdGlvbmFsKGV4cHIsIHN0YXJ0TG9jLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDE3KSkgcmV0dXJuIGV4cHI7XG4gICAgaWYgKHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycykge1xuICAgICAgY29uc3QgbmV4dENoID0gdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpO1xuICAgICAgaWYgKG5leHRDaCA9PT0gNDQgfHwgbmV4dENoID09PSA2MSB8fCBuZXh0Q2ggPT09IDU4IHx8IG5leHRDaCA9PT0gNDEpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25hbFBhcmFtZXRlcnNFcnJvcihyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZUNvbmRpdGlvbmFsKGV4cHIsIHN0YXJ0TG9jLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgfVxuICBwYXJzZVBhcmVuSXRlbShub2RlLCBzdGFydExvYykge1xuICAgIGNvbnN0IG5ld05vZGUgPSBzdXBlci5wYXJzZVBhcmVuSXRlbShub2RlLCBzdGFydExvYyk7XG4gICAgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgbmV3Tm9kZS5vcHRpb25hbCA9IHRydWU7XG4gICAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24obm9kZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgY29uc3QgdHlwZUNhc3ROb2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICB0eXBlQ2FzdE5vZGUuZXhwcmVzc2lvbiA9IG5vZGU7XG4gICAgICB0eXBlQ2FzdE5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLnRzUGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZSh0eXBlQ2FzdE5vZGUsIFwiVFNUeXBlQ2FzdEV4cHJlc3Npb25cIik7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHBhcnNlRXhwb3J0RGVjbGFyYXRpb24obm9kZSkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5pc0FtYmllbnRDb250ZXh0ICYmIHRoaXMuaXNDb250ZXh0dWFsKDEyNSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRzSW5BbWJpZW50Q29udGV4dCgoKSA9PiB0aGlzLnBhcnNlRXhwb3J0RGVjbGFyYXRpb24obm9kZSkpO1xuICAgIH1cbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgaXNEZWNsYXJlID0gdGhpcy5lYXRDb250ZXh0dWFsKDEyNSk7XG4gICAgaWYgKGlzRGVjbGFyZSAmJiAodGhpcy5pc0NvbnRleHR1YWwoMTI1KSB8fCAhdGhpcy5zaG91bGRQYXJzZUV4cG9ydERlY2xhcmF0aW9uKCkpKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKFRTRXJyb3JzLkV4cGVjdGVkQW1iaWVudEFmdGVyRXhwb3J0RGVjbGFyZSwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgfVxuICAgIGNvbnN0IGlzSWRlbnRpZmllciA9IHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSk7XG4gICAgY29uc3QgZGVjbGFyYXRpb24gPSBpc0lkZW50aWZpZXIgJiYgdGhpcy50c1RyeVBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKSB8fCBzdXBlci5wYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpO1xuICAgIGlmICghZGVjbGFyYXRpb24pIHJldHVybiBudWxsO1xuICAgIGlmIChkZWNsYXJhdGlvbi50eXBlID09PSBcIlRTSW50ZXJmYWNlRGVjbGFyYXRpb25cIiB8fCBkZWNsYXJhdGlvbi50eXBlID09PSBcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIiB8fCBpc0RlY2xhcmUpIHtcbiAgICAgIG5vZGUuZXhwb3J0S2luZCA9IFwidHlwZVwiO1xuICAgIH1cbiAgICBpZiAoaXNEZWNsYXJlICYmIGRlY2xhcmF0aW9uLnR5cGUgIT09IFwiVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvblwiKSB7XG4gICAgICB0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbihkZWNsYXJhdGlvbiwgc3RhcnRMb2MpO1xuICAgICAgZGVjbGFyYXRpb24uZGVjbGFyZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBkZWNsYXJhdGlvbjtcbiAgfVxuICBwYXJzZUNsYXNzSWQobm9kZSwgaXNTdGF0ZW1lbnQsIG9wdGlvbmFsSWQsIGJpbmRpbmdUeXBlKSB7XG4gICAgaWYgKCghaXNTdGF0ZW1lbnQgfHwgb3B0aW9uYWxJZCkgJiYgdGhpcy5pc0NvbnRleHR1YWwoMTEzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5wYXJzZUNsYXNzSWQobm9kZSwgaXNTdGF0ZW1lbnQsIG9wdGlvbmFsSWQsIG5vZGUuZGVjbGFyZSA/IDEwMjQgOiA4MzMxKTtcbiAgICBjb25zdCB0eXBlUGFyYW1ldGVycyA9IHRoaXMudHNUcnlQYXJzZVR5cGVQYXJhbWV0ZXJzKHRoaXMudHNQYXJzZUluT3V0Q29uc3RNb2RpZmllcnMpO1xuICAgIGlmICh0eXBlUGFyYW1ldGVycykgbm9kZS50eXBlUGFyYW1ldGVycyA9IHR5cGVQYXJhbWV0ZXJzO1xuICB9XG4gIHBhcnNlQ2xhc3NQcm9wZXJ0eUFubm90YXRpb24obm9kZSkge1xuICAgIGlmICghbm9kZS5vcHRpb25hbCkge1xuICAgICAgaWYgKHRoaXMuZWF0KDM1KSkge1xuICAgICAgICBub2RlLmRlZmluaXRlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5lYXQoMTcpKSB7XG4gICAgICAgIG5vZGUub3B0aW9uYWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0eXBlID0gdGhpcy50c1RyeVBhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICBpZiAodHlwZSkgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHR5cGU7XG4gIH1cbiAgcGFyc2VDbGFzc1Byb3BlcnR5KG5vZGUpIHtcbiAgICB0aGlzLnBhcnNlQ2xhc3NQcm9wZXJ0eUFubm90YXRpb24obm9kZSk7XG4gICAgaWYgKHRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCAmJiAhKG5vZGUucmVhZG9ubHkgJiYgIW5vZGUudHlwZUFubm90YXRpb24pICYmIHRoaXMubWF0Y2goMjkpKSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkRlY2xhcmVDbGFzc0ZpZWxkSGFzSW5pdGlhbGl6ZXIsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgIH1cbiAgICBpZiAobm9kZS5hYnN0cmFjdCAmJiB0aGlzLm1hdGNoKDI5KSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBrZXlcbiAgICAgIH0gPSBub2RlO1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5BYnN0cmFjdFByb3BlcnR5SGFzSW5pdGlhbGl6ZXIsIHRoaXMuc3RhdGUuc3RhcnRMb2MsIHtcbiAgICAgICAgcHJvcGVydHlOYW1lOiBrZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgIW5vZGUuY29tcHV0ZWQgPyBrZXkubmFtZSA6IGBbJHt0aGlzLmlucHV0LnNsaWNlKHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3Moa2V5LnN0YXJ0KSwgdGhpcy5vZmZzZXRUb1NvdXJjZVBvcyhrZXkuZW5kKSl9XWBcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VDbGFzc1Byb3BlcnR5KG5vZGUpO1xuICB9XG4gIHBhcnNlQ2xhc3NQcml2YXRlUHJvcGVydHkobm9kZSkge1xuICAgIGlmIChub2RlLmFic3RyYWN0KSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlByaXZhdGVFbGVtZW50SGFzQWJzdHJhY3QsIG5vZGUpO1xuICAgIH1cbiAgICBpZiAobm9kZS5hY2Nlc3NpYmlsaXR5KSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlByaXZhdGVFbGVtZW50SGFzQWNjZXNzaWJpbGl0eSwgbm9kZSwge1xuICAgICAgICBtb2RpZmllcjogbm9kZS5hY2Nlc3NpYmlsaXR5XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5wYXJzZUNsYXNzUHJvcGVydHlBbm5vdGF0aW9uKG5vZGUpO1xuICAgIHJldHVybiBzdXBlci5wYXJzZUNsYXNzUHJpdmF0ZVByb3BlcnR5KG5vZGUpO1xuICB9XG4gIHBhcnNlQ2xhc3NBY2Nlc3NvclByb3BlcnR5KG5vZGUpIHtcbiAgICB0aGlzLnBhcnNlQ2xhc3NQcm9wZXJ0eUFubm90YXRpb24obm9kZSk7XG4gICAgaWYgKG5vZGUub3B0aW9uYWwpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuQWNjZXNzb3JDYW5ub3RCZU9wdGlvbmFsLCBub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQ2xhc3NBY2Nlc3NvclByb3BlcnR5KG5vZGUpO1xuICB9XG4gIHB1c2hDbGFzc01ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93c0RpcmVjdFN1cGVyKSB7XG4gICAgY29uc3QgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlUGFyYW1ldGVycyh0aGlzLnRzUGFyc2VDb25zdE1vZGlmaWVyKTtcbiAgICBpZiAodHlwZVBhcmFtZXRlcnMgJiYgaXNDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5Db25zdHJ1Y3Rvckhhc1R5cGVQYXJhbWV0ZXJzLCB0eXBlUGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGRlY2xhcmUgPSBmYWxzZSxcbiAgICAgIGtpbmRcbiAgICB9ID0gbWV0aG9kO1xuICAgIGlmIChkZWNsYXJlICYmIChraW5kID09PSBcImdldFwiIHx8IGtpbmQgPT09IFwic2V0XCIpKSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkRlY2xhcmVBY2Nlc3NvciwgbWV0aG9kLCB7XG4gICAgICAgIGtpbmRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZVBhcmFtZXRlcnMpIG1ldGhvZC50eXBlUGFyYW1ldGVycyA9IHR5cGVQYXJhbWV0ZXJzO1xuICAgIHN1cGVyLnB1c2hDbGFzc01ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93c0RpcmVjdFN1cGVyKTtcbiAgfVxuICBwdXNoQ2xhc3NQcml2YXRlTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYykge1xuICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1RyeVBhcnNlVHlwZVBhcmFtZXRlcnModGhpcy50c1BhcnNlQ29uc3RNb2RpZmllcik7XG4gICAgaWYgKHR5cGVQYXJhbWV0ZXJzKSBtZXRob2QudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICBzdXBlci5wdXNoQ2xhc3NQcml2YXRlTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYyk7XG4gIH1cbiAgZGVjbGFyZUNsYXNzUHJpdmF0ZU1ldGhvZEluU2NvcGUobm9kZSwga2luZCkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiVFNEZWNsYXJlTWV0aG9kXCIpIHJldHVybjtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIk1ldGhvZERlZmluaXRpb25cIiAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChub2RlLnZhbHVlLCBcImJvZHlcIikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuZGVjbGFyZUNsYXNzUHJpdmF0ZU1ldGhvZEluU2NvcGUobm9kZSwga2luZCk7XG4gIH1cbiAgcGFyc2VDbGFzc1N1cGVyKG5vZGUpIHtcbiAgICBzdXBlci5wYXJzZUNsYXNzU3VwZXIobm9kZSk7XG4gICAgaWYgKG5vZGUuc3VwZXJDbGFzcyAmJiAodGhpcy5tYXRjaCg0NykgfHwgdGhpcy5tYXRjaCg1MSkpKSB7XG4gICAgICB7XG4gICAgICAgIG5vZGUuc3VwZXJUeXBlUGFyYW1ldGVycyA9IHRoaXMudHNQYXJzZVR5cGVBcmd1bWVudHNJbkV4cHJlc3Npb24oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbCgxMTMpKSB7XG4gICAgICBub2RlLmltcGxlbWVudHMgPSB0aGlzLnRzUGFyc2VIZXJpdGFnZUNsYXVzZShcImltcGxlbWVudHNcIik7XG4gICAgfVxuICB9XG4gIHBhcnNlT2JqUHJvcFZhbHVlKHByb3AsIHN0YXJ0TG9jLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNQYXR0ZXJuLCBpc0FjY2Vzc29yLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgY29uc3QgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlUGFyYW1ldGVycyh0aGlzLnRzUGFyc2VDb25zdE1vZGlmaWVyKTtcbiAgICBpZiAodHlwZVBhcmFtZXRlcnMpIHByb3AudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICByZXR1cm4gc3VwZXIucGFyc2VPYmpQcm9wVmFsdWUocHJvcCwgc3RhcnRMb2MsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc1BhdHRlcm4sIGlzQWNjZXNzb3IsIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICB9XG4gIHBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSwgaXNDb25zdHJ1Y3Rvcikge1xuICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1RyeVBhcnNlVHlwZVBhcmFtZXRlcnModGhpcy50c1BhcnNlQ29uc3RNb2RpZmllcik7XG4gICAgaWYgKHR5cGVQYXJhbWV0ZXJzKSBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdHlwZVBhcmFtZXRlcnM7XG4gICAgc3VwZXIucGFyc2VGdW5jdGlvblBhcmFtcyhub2RlLCBpc0NvbnN0cnVjdG9yKTtcbiAgfVxuICBwYXJzZVZhcklkKGRlY2wsIGtpbmQpIHtcbiAgICBzdXBlci5wYXJzZVZhcklkKGRlY2wsIGtpbmQpO1xuICAgIGlmIChkZWNsLmlkLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmICF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpICYmIHRoaXMuZWF0KDM1KSkge1xuICAgICAgZGVjbC5kZWZpbml0ZSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICBkZWNsLmlkLnR5cGVBbm5vdGF0aW9uID0gdHlwZTtcbiAgICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbihkZWNsLmlkKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VBc3luY0Fycm93RnJvbUNhbGxFeHByZXNzaW9uKG5vZGUsIGNhbGwpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHRoaXMudHNQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZUFzeW5jQXJyb3dGcm9tQ2FsbEV4cHJlc3Npb24obm9kZSwgY2FsbCk7XG4gIH1cbiAgcGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSkge1xuICAgIHZhciBfanN4LCBfanN4MiwgX3R5cGVDYXN0LCBfanN4MywgX3R5cGVDYXN0MjtcbiAgICBsZXQgc3RhdGU7XG4gICAgbGV0IGpzeDtcbiAgICBsZXQgdHlwZUNhc3Q7XG4gICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwianN4XCIpICYmICh0aGlzLm1hdGNoKDE0MykgfHwgdGhpcy5tYXRjaCg0NykpKSB7XG4gICAgICBzdGF0ZSA9IHRoaXMuc3RhdGUuY2xvbmUoKTtcbiAgICAgIGpzeCA9IHRoaXMudHJ5UGFyc2UoKCkgPT4gc3VwZXIucGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSksIHN0YXRlKTtcbiAgICAgIGlmICghanN4LmVycm9yKSByZXR1cm4ganN4Lm5vZGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgY3VycmVudENvbnRleHQgPSBjb250ZXh0W2NvbnRleHQubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoY3VycmVudENvbnRleHQgPT09IHR5cGVzLmpfb1RhZyB8fCBjdXJyZW50Q29udGV4dCA9PT0gdHlwZXMual9leHByKSB7XG4gICAgICAgIGNvbnRleHQucG9wKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghKChfanN4ID0ganN4KSAhPSBudWxsICYmIF9qc3guZXJyb3IpICYmICF0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpO1xuICAgIH1cbiAgICBpZiAoIXN0YXRlIHx8IHN0YXRlID09PSB0aGlzLnN0YXRlKSBzdGF0ZSA9IHRoaXMuc3RhdGUuY2xvbmUoKTtcbiAgICBsZXQgdHlwZVBhcmFtZXRlcnM7XG4gICAgY29uc3QgYXJyb3cgPSB0aGlzLnRyeVBhcnNlKGFib3J0ID0+IHtcbiAgICAgIHZhciBfZXhwciRleHRyYSwgX3R5cGVQYXJhbWV0ZXJzO1xuICAgICAgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzUGFyc2VUeXBlUGFyYW1ldGVycyh0aGlzLnRzUGFyc2VDb25zdE1vZGlmaWVyKTtcbiAgICAgIGNvbnN0IGV4cHIgPSBzdXBlci5wYXJzZU1heWJlQXNzaWduKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKTtcbiAgICAgIGlmIChleHByLnR5cGUgIT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiB8fCAoX2V4cHIkZXh0cmEgPSBleHByLmV4dHJhKSAhPSBudWxsICYmIF9leHByJGV4dHJhLnBhcmVudGhlc2l6ZWQpIHtcbiAgICAgICAgYWJvcnQoKTtcbiAgICAgIH1cbiAgICAgIGlmICgoKF90eXBlUGFyYW1ldGVycyA9IHR5cGVQYXJhbWV0ZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX3R5cGVQYXJhbWV0ZXJzLnBhcmFtcy5sZW5ndGgpICE9PSAwKSB7XG4gICAgICAgIHRoaXMucmVzZXRTdGFydExvY2F0aW9uRnJvbU5vZGUoZXhwciwgdHlwZVBhcmFtZXRlcnMpO1xuICAgICAgfVxuICAgICAgZXhwci50eXBlUGFyYW1ldGVycyA9IHR5cGVQYXJhbWV0ZXJzO1xuICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfSwgc3RhdGUpO1xuICAgIGlmICghYXJyb3cuZXJyb3IgJiYgIWFycm93LmFib3J0ZWQpIHtcbiAgICAgIGlmICh0eXBlUGFyYW1ldGVycykgdGhpcy5yZXBvcnRSZXNlcnZlZEFycm93VHlwZVBhcmFtKHR5cGVQYXJhbWV0ZXJzKTtcbiAgICAgIHJldHVybiBhcnJvdy5ub2RlO1xuICAgIH1cbiAgICBpZiAoIWpzeCkge1xuICAgICAgYXNzZXJ0KCF0aGlzLmhhc1BsdWdpbihcImpzeFwiKSk7XG4gICAgICB0eXBlQ2FzdCA9IHRoaXMudHJ5UGFyc2UoKCkgPT4gc3VwZXIucGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSksIHN0YXRlKTtcbiAgICAgIGlmICghdHlwZUNhc3QuZXJyb3IpIHJldHVybiB0eXBlQ2FzdC5ub2RlO1xuICAgIH1cbiAgICBpZiAoKF9qc3gyID0ganN4KSAhPSBudWxsICYmIF9qc3gyLm5vZGUpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBqc3guZmFpbFN0YXRlO1xuICAgICAgcmV0dXJuIGpzeC5ub2RlO1xuICAgIH1cbiAgICBpZiAoYXJyb3cubm9kZSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IGFycm93LmZhaWxTdGF0ZTtcbiAgICAgIGlmICh0eXBlUGFyYW1ldGVycykgdGhpcy5yZXBvcnRSZXNlcnZlZEFycm93VHlwZVBhcmFtKHR5cGVQYXJhbWV0ZXJzKTtcbiAgICAgIHJldHVybiBhcnJvdy5ub2RlO1xuICAgIH1cbiAgICBpZiAoKF90eXBlQ2FzdCA9IHR5cGVDYXN0KSAhPSBudWxsICYmIF90eXBlQ2FzdC5ub2RlKSB7XG4gICAgICB0aGlzLnN0YXRlID0gdHlwZUNhc3QuZmFpbFN0YXRlO1xuICAgICAgcmV0dXJuIHR5cGVDYXN0Lm5vZGU7XG4gICAgfVxuICAgIHRocm93ICgoX2pzeDMgPSBqc3gpID09IG51bGwgPyB2b2lkIDAgOiBfanN4My5lcnJvcikgfHwgYXJyb3cuZXJyb3IgfHwgKChfdHlwZUNhc3QyID0gdHlwZUNhc3QpID09IG51bGwgPyB2b2lkIDAgOiBfdHlwZUNhc3QyLmVycm9yKTtcbiAgfVxuICByZXBvcnRSZXNlcnZlZEFycm93VHlwZVBhcmFtKG5vZGUpIHtcbiAgICB2YXIgX25vZGUkZXh0cmEyO1xuICAgIGlmIChub2RlLnBhcmFtcy5sZW5ndGggPT09IDEgJiYgIW5vZGUucGFyYW1zWzBdLmNvbnN0cmFpbnQgJiYgISgoX25vZGUkZXh0cmEyID0gbm9kZS5leHRyYSkgIT0gbnVsbCAmJiBfbm9kZSRleHRyYTIudHJhaWxpbmdDb21tYSkgJiYgdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJ0eXBlc2NyaXB0XCIsIFwiZGlzYWxsb3dBbWJpZ3VvdXNKU1hMaWtlXCIpKSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlJlc2VydmVkQXJyb3dUeXBlUGFyYW0sIG5vZGUpO1xuICAgIH1cbiAgfVxuICBwYXJzZU1heWJlVW5hcnkocmVmRXhwcmVzc2lvbkVycm9ycywgc2F3VW5hcnkpIHtcbiAgICBpZiAoIXRoaXMuaGFzUGx1Z2luKFwianN4XCIpICYmIHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZUFzc2VydGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VNYXliZVVuYXJ5KHJlZkV4cHJlc3Npb25FcnJvcnMsIHNhd1VuYXJ5KTtcbiAgfVxuICBwYXJzZUFycm93KG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudHJ5UGFyc2UoYWJvcnQgPT4ge1xuICAgICAgICBjb25zdCByZXR1cm5UeXBlID0gdGhpcy50c1BhcnNlVHlwZU9yVHlwZVByZWRpY2F0ZUFubm90YXRpb24oMTQpO1xuICAgICAgICBpZiAodGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSB8fCAhdGhpcy5tYXRjaCgxOSkpIGFib3J0KCk7XG4gICAgICAgIHJldHVybiByZXR1cm5UeXBlO1xuICAgICAgfSk7XG4gICAgICBpZiAocmVzdWx0LmFib3J0ZWQpIHJldHVybjtcbiAgICAgIGlmICghcmVzdWx0LnRocm93bikge1xuICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB0aGlzLnN0YXRlID0gcmVzdWx0LmZhaWxTdGF0ZTtcbiAgICAgICAgbm9kZS5yZXR1cm5UeXBlID0gcmVzdWx0Lm5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZUFycm93KG5vZGUpO1xuICB9XG4gIHBhcnNlRnVuY3Rpb25QYXJhbVR5cGUocGFyYW0pIHtcbiAgICBpZiAodGhpcy5lYXQoMTcpKSB7XG4gICAgICBwYXJhbS5vcHRpb25hbCA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgIGlmICh0eXBlKSBwYXJhbS50eXBlQW5ub3RhdGlvbiA9IHR5cGU7XG4gICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKHBhcmFtKTtcbiAgICByZXR1cm4gcGFyYW07XG4gIH1cbiAgaXNBc3NpZ25hYmxlKG5vZGUsIGlzQmluZGluZykge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiVFNUeXBlQ2FzdEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNBc3NpZ25hYmxlKG5vZGUuZXhwcmVzc2lvbiwgaXNCaW5kaW5nKTtcbiAgICAgIGNhc2UgXCJUU1BhcmFtZXRlclByb3BlcnR5XCI6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN1cGVyLmlzQXNzaWduYWJsZShub2RlLCBpc0JpbmRpbmcpO1xuICAgIH1cbiAgfVxuICB0b0Fzc2lnbmFibGUobm9kZSwgaXNMSFMgPSBmYWxzZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGVQYXJlbnRoZXNpemVkRXhwcmVzc2lvbihub2RlLCBpc0xIUyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlRTQXNFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiVFNTYXRpc2ZpZXNFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiVFNOb25OdWxsRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlRTVHlwZUFzc2VydGlvblwiOlxuICAgICAgICBpZiAoaXNMSFMpIHtcbiAgICAgICAgICB0aGlzLmV4cHJlc3Npb25TY29wZS5yZWNvcmRBcnJvd1BhcmFtZXRlckJpbmRpbmdFcnJvcihUU0Vycm9ycy5VbmV4cGVjdGVkVHlwZUNhc3RJblBhcmFtZXRlciwgbm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5VbmV4cGVjdGVkVHlwZUNhc3RJblBhcmFtZXRlciwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5leHByZXNzaW9uLCBpc0xIUyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmICghaXNMSFMgJiYgbm9kZS5sZWZ0LnR5cGUgPT09IFwiVFNUeXBlQ2FzdEV4cHJlc3Npb25cIikge1xuICAgICAgICAgIG5vZGUubGVmdCA9IHRoaXMudHlwZUNhc3RUb1BhcmFtZXRlcihub2RlLmxlZnQpO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzdXBlci50b0Fzc2lnbmFibGUobm9kZSwgaXNMSFMpO1xuICAgIH1cbiAgfVxuICB0b0Fzc2lnbmFibGVQYXJlbnRoZXNpemVkRXhwcmVzc2lvbihub2RlLCBpc0xIUykge1xuICAgIHN3aXRjaCAobm9kZS5leHByZXNzaW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJUU0FzRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJUU1R5cGVBc3NlcnRpb25cIjpcbiAgICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmV4cHJlc3Npb24sIGlzTEhTKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzdXBlci50b0Fzc2lnbmFibGUobm9kZSwgaXNMSFMpO1xuICAgIH1cbiAgfVxuICBjaGVja1RvUmVzdENvbnZlcnNpb24obm9kZSwgYWxsb3dQYXR0ZXJuKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJUU0FzRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlRTVHlwZUFzc2VydGlvblwiOlxuICAgICAgY2FzZSBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgdGhpcy5jaGVja1RvUmVzdENvbnZlcnNpb24obm9kZS5leHByZXNzaW9uLCBmYWxzZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3VwZXIuY2hlY2tUb1Jlc3RDb252ZXJzaW9uKG5vZGUsIGFsbG93UGF0dGVybik7XG4gICAgfVxuICB9XG4gIGlzVmFsaWRMVmFsKHR5cGUsIGlzVW5wYXJlbnRoZXNpemVkSW5Bc3NpZ24sIGJpbmRpbmcpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJUU1R5cGVDYXN0RXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgXCJUU1BhcmFtZXRlclByb3BlcnR5XCI6XG4gICAgICAgIHJldHVybiBcInBhcmFtZXRlclwiO1xuICAgICAgY2FzZSBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIFwiZXhwcmVzc2lvblwiO1xuICAgICAgY2FzZSBcIlRTQXNFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiVFNTYXRpc2ZpZXNFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiVFNUeXBlQXNzZXJ0aW9uXCI6XG4gICAgICAgIHJldHVybiAoYmluZGluZyAhPT0gNjQgfHwgIWlzVW5wYXJlbnRoZXNpemVkSW5Bc3NpZ24pICYmIFtcImV4cHJlc3Npb25cIiwgdHJ1ZV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3VwZXIuaXNWYWxpZExWYWwodHlwZSwgaXNVbnBhcmVudGhlc2l6ZWRJbkFzc2lnbiwgYmluZGluZyk7XG4gICAgfVxuICB9XG4gIHBhcnNlQmluZGluZ0F0b20oKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUudHlwZSA9PT0gNzgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgfVxuICBwYXJzZU1heWJlRGVjb3JhdG9yQXJndW1lbnRzKGV4cHIsIHN0YXJ0TG9jKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpIHx8IHRoaXMubWF0Y2goNTEpKSB7XG4gICAgICBjb25zdCB0eXBlQXJndW1lbnRzID0gdGhpcy50c1BhcnNlVHlwZUFyZ3VtZW50c0luRXhwcmVzc2lvbigpO1xuICAgICAgaWYgKHRoaXMubWF0Y2goMTApKSB7XG4gICAgICAgIGNvbnN0IGNhbGwgPSBzdXBlci5wYXJzZU1heWJlRGVjb3JhdG9yQXJndW1lbnRzKGV4cHIsIHN0YXJ0TG9jKTtcbiAgICAgICAge1xuICAgICAgICAgIGNhbGwudHlwZVBhcmFtZXRlcnMgPSB0eXBlQXJndW1lbnRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgICAgfVxuICAgICAgdGhpcy51bmV4cGVjdGVkKG51bGwsIDEwKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlTWF5YmVEZWNvcmF0b3JBcmd1bWVudHMoZXhwciwgc3RhcnRMb2MpO1xuICB9XG4gIGNoZWNrQ29tbWFBZnRlclJlc3QoY2xvc2UpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5pc0FtYmllbnRDb250ZXh0ICYmIHRoaXMubWF0Y2goMTIpICYmIHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gY2xvc2UpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuY2hlY2tDb21tYUFmdGVyUmVzdChjbG9zZSk7XG4gIH1cbiAgaXNDbGFzc01ldGhvZCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCg0NykgfHwgc3VwZXIuaXNDbGFzc01ldGhvZCgpO1xuICB9XG4gIGlzQ2xhc3NQcm9wZXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgzNSkgfHwgdGhpcy5tYXRjaCgxNCkgfHwgc3VwZXIuaXNDbGFzc1Byb3BlcnR5KCk7XG4gIH1cbiAgcGFyc2VNYXliZURlZmF1bHQoc3RhcnRMb2MsIGxlZnQpIHtcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VNYXliZURlZmF1bHQoc3RhcnRMb2MsIGxlZnQpO1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIiAmJiBub2RlLnR5cGVBbm5vdGF0aW9uICYmIG5vZGUucmlnaHQuc3RhcnQgPCBub2RlLnR5cGVBbm5vdGF0aW9uLnN0YXJ0KSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlR5cGVBbm5vdGF0aW9uQWZ0ZXJBc3NpZ24sIG5vZGUudHlwZUFubm90YXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBnZXRUb2tlbkZyb21Db2RlKGNvZGUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5pblR5cGUpIHtcbiAgICAgIGlmIChjb2RlID09PSA2Mikge1xuICAgICAgICB0aGlzLmZpbmlzaE9wKDQ4LCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGUgPT09IDYwKSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AoNDcsIDEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyLmdldFRva2VuRnJvbUNvZGUoY29kZSk7XG4gIH1cbiAgcmVTY2FuX2x0X2d0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodHlwZSA9PT0gNDcpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zIC09IDE7XG4gICAgICB0aGlzLnJlYWRUb2tlbl9sdCgpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gNDgpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zIC09IDE7XG4gICAgICB0aGlzLnJlYWRUb2tlbl9ndCgpO1xuICAgIH1cbiAgfVxuICByZVNjYW5fbHQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0eXBlID09PSA1MSkge1xuICAgICAgdGhpcy5zdGF0ZS5wb3MgLT0gMjtcbiAgICAgIHRoaXMuZmluaXNoT3AoNDcsIDEpO1xuICAgICAgcmV0dXJuIDQ3O1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICB0b0Fzc2lnbmFibGVMaXN0SXRlbShleHByTGlzdCwgaW5kZXgsIGlzTEhTKSB7XG4gICAgY29uc3Qgbm9kZSA9IGV4cHJMaXN0W2luZGV4XTtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIlRTVHlwZUNhc3RFeHByZXNzaW9uXCIpIHtcbiAgICAgIGV4cHJMaXN0W2luZGV4XSA9IHRoaXMudHlwZUNhc3RUb1BhcmFtZXRlcihub2RlKTtcbiAgICB9XG4gICAgc3VwZXIudG9Bc3NpZ25hYmxlTGlzdEl0ZW0oZXhwckxpc3QsIGluZGV4LCBpc0xIUyk7XG4gIH1cbiAgdHlwZUNhc3RUb1BhcmFtZXRlcihub2RlKSB7XG4gICAgbm9kZS5leHByZXNzaW9uLnR5cGVBbm5vdGF0aW9uID0gbm9kZS50eXBlQW5ub3RhdGlvbjtcbiAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24obm9kZS5leHByZXNzaW9uLCBub2RlLnR5cGVBbm5vdGF0aW9uLmxvYy5lbmQpO1xuICAgIHJldHVybiBub2RlLmV4cHJlc3Npb247XG4gIH1cbiAgc2hvdWxkUGFyc2VBcnJvdyhwYXJhbXMpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIHJldHVybiBwYXJhbXMuZXZlcnkoZXhwciA9PiB0aGlzLmlzQXNzaWduYWJsZShleHByLCB0cnVlKSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5zaG91bGRQYXJzZUFycm93KHBhcmFtcyk7XG4gIH1cbiAgc2hvdWxkUGFyc2VBc3luY0Fycm93KCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKDE0KSB8fCBzdXBlci5zaG91bGRQYXJzZUFzeW5jQXJyb3coKTtcbiAgfVxuICBjYW5IYXZlTGVhZGluZ0RlY29yYXRvcigpIHtcbiAgICByZXR1cm4gc3VwZXIuY2FuSGF2ZUxlYWRpbmdEZWNvcmF0b3IoKSB8fCB0aGlzLmlzQWJzdHJhY3RDbGFzcygpO1xuICB9XG4gIGpzeFBhcnNlT3BlbmluZ0VsZW1lbnRBZnRlck5hbWUobm9kZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSB8fCB0aGlzLm1hdGNoKDUxKSkge1xuICAgICAgY29uc3QgdHlwZUFyZ3VtZW50cyA9IHRoaXMudHNUcnlQYXJzZUFuZENhdGNoKCgpID0+IHRoaXMudHNQYXJzZVR5cGVBcmd1bWVudHNJbkV4cHJlc3Npb24oKSk7XG4gICAgICBpZiAodHlwZUFyZ3VtZW50cykge1xuICAgICAgICB7XG4gICAgICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHR5cGVBcmd1bWVudHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmpzeFBhcnNlT3BlbmluZ0VsZW1lbnRBZnRlck5hbWUobm9kZSk7XG4gIH1cbiAgZ2V0R2V0dGVyU2V0dGVyRXhwZWN0ZWRQYXJhbUNvdW50KG1ldGhvZCkge1xuICAgIGNvbnN0IGJhc2VDb3VudCA9IHN1cGVyLmdldEdldHRlclNldHRlckV4cGVjdGVkUGFyYW1Db3VudChtZXRob2QpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuZ2V0T2JqZWN0T3JDbGFzc01ldGhvZFBhcmFtcyhtZXRob2QpO1xuICAgIGNvbnN0IGZpcnN0UGFyYW0gPSBwYXJhbXNbMF07XG4gICAgY29uc3QgaGFzQ29udGV4dFBhcmFtID0gZmlyc3RQYXJhbSAmJiB0aGlzLmlzVGhpc1BhcmFtKGZpcnN0UGFyYW0pO1xuICAgIHJldHVybiBoYXNDb250ZXh0UGFyYW0gPyBiYXNlQ291bnQgKyAxIDogYmFzZUNvdW50O1xuICB9XG4gIHBhcnNlQ2F0Y2hDbGF1c2VQYXJhbSgpIHtcbiAgICBjb25zdCBwYXJhbSA9IHN1cGVyLnBhcnNlQ2F0Y2hDbGF1c2VQYXJhbSgpO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICBwYXJhbS50eXBlQW5ub3RhdGlvbiA9IHR5cGU7XG4gICAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24ocGFyYW0pO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW07XG4gIH1cbiAgdHNJbkFtYmllbnRDb250ZXh0KGNiKSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNBbWJpZW50Q29udGV4dDogb2xkSXNBbWJpZW50Q29udGV4dCxcbiAgICAgIHN0cmljdDogb2xkU3RyaWN0XG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5zdGF0ZS5pc0FtYmllbnRDb250ZXh0ID0gdHJ1ZTtcbiAgICB0aGlzLnN0YXRlLnN0cmljdCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2IoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5zdGF0ZS5pc0FtYmllbnRDb250ZXh0ID0gb2xkSXNBbWJpZW50Q29udGV4dDtcbiAgICAgIHRoaXMuc3RhdGUuc3RyaWN0ID0gb2xkU3RyaWN0O1xuICAgIH1cbiAgfVxuICBwYXJzZUNsYXNzKG5vZGUsIGlzU3RhdGVtZW50LCBvcHRpb25hbElkKSB7XG4gICAgY29uc3Qgb2xkSW5BYnN0cmFjdENsYXNzID0gdGhpcy5zdGF0ZS5pbkFic3RyYWN0Q2xhc3M7XG4gICAgdGhpcy5zdGF0ZS5pbkFic3RyYWN0Q2xhc3MgPSAhIW5vZGUuYWJzdHJhY3Q7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBzdXBlci5wYXJzZUNsYXNzKG5vZGUsIGlzU3RhdGVtZW50LCBvcHRpb25hbElkKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5zdGF0ZS5pbkFic3RyYWN0Q2xhc3MgPSBvbGRJbkFic3RyYWN0Q2xhc3M7XG4gICAgfVxuICB9XG4gIHRzUGFyc2VBYnN0cmFjdERlY2xhcmF0aW9uKG5vZGUsIGRlY29yYXRvcnMpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg4MCkpIHtcbiAgICAgIG5vZGUuYWJzdHJhY3QgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMubWF5YmVUYWtlRGVjb3JhdG9ycyhkZWNvcmF0b3JzLCB0aGlzLnBhcnNlQ2xhc3Mobm9kZSwgdHJ1ZSwgZmFsc2UpKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEyOSkpIHtcbiAgICAgIGlmICghdGhpcy5oYXNGb2xsb3dpbmdMaW5lQnJlYWsoKSkge1xuICAgICAgICBub2RlLmFic3RyYWN0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5Ob25DbGFzc01ldGhvZFByb3BlcnR5SGFzQWJzdHJhY3RNb2RpZmVyLCBub2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUludGVyZmFjZURlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQobnVsbCwgODApO1xuICAgIH1cbiAgfVxuICBwYXJzZU1ldGhvZChub2RlLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNDb25zdHJ1Y3RvciwgYWxsb3dEaXJlY3RTdXBlciwgdHlwZSwgaW5DbGFzc1Njb3BlKSB7XG4gICAgY29uc3QgbWV0aG9kID0gc3VwZXIucGFyc2VNZXRob2Qobm9kZSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93RGlyZWN0U3VwZXIsIHR5cGUsIGluQ2xhc3NTY29wZSk7XG4gICAgaWYgKG1ldGhvZC5hYnN0cmFjdCkge1xuICAgICAgY29uc3QgaGFzRXN0cmVlUGx1Z2luID0gdGhpcy5oYXNQbHVnaW4oXCJlc3RyZWVcIik7XG4gICAgICBjb25zdCBtZXRob2RGbiA9IGhhc0VzdHJlZVBsdWdpbiA/IG1ldGhvZC52YWx1ZSA6IG1ldGhvZDtcbiAgICAgIGlmIChtZXRob2RGbi5ib2R5KSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBrZXlcbiAgICAgICAgfSA9IG1ldGhvZDtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5BYnN0cmFjdE1ldGhvZEhhc0ltcGxlbWVudGF0aW9uLCBtZXRob2QsIHtcbiAgICAgICAgICBtZXRob2ROYW1lOiBrZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgIW1ldGhvZC5jb21wdXRlZCA/IGtleS5uYW1lIDogYFske3RoaXMuaW5wdXQuc2xpY2UodGhpcy5vZmZzZXRUb1NvdXJjZVBvcyhrZXkuc3RhcnQpLCB0aGlzLm9mZnNldFRvU291cmNlUG9zKGtleS5lbmQpKX1dYFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1ldGhvZDtcbiAgfVxuICB0c1BhcnNlVHlwZVBhcmFtZXRlck5hbWUoKSB7XG4gICAgY29uc3QgdHlwZU5hbWUgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIHJldHVybiB0eXBlTmFtZS5uYW1lO1xuICB9XG4gIHNob3VsZFBhcnNlQXNBbWJpZW50Q29udGV4dCgpIHtcbiAgICByZXR1cm4gISF0aGlzLmdldFBsdWdpbk9wdGlvbihcInR5cGVzY3JpcHRcIiwgXCJkdHNcIik7XG4gIH1cbiAgcGFyc2UoKSB7XG4gICAgaWYgKHRoaXMuc2hvdWxkUGFyc2VBc0FtYmllbnRDb250ZXh0KCkpIHtcbiAgICAgIHRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZSgpO1xuICB9XG4gIGdldEV4cHJlc3Npb24oKSB7XG4gICAgaWYgKHRoaXMuc2hvdWxkUGFyc2VBc0FtYmllbnRDb250ZXh0KCkpIHtcbiAgICAgIHRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5nZXRFeHByZXNzaW9uKCk7XG4gIH1cbiAgcGFyc2VFeHBvcnRTcGVjaWZpZXIobm9kZSwgaXNTdHJpbmcsIGlzSW5UeXBlRXhwb3J0LCBpc01heWJlVHlwZU9ubHkpIHtcbiAgICBpZiAoIWlzU3RyaW5nICYmIGlzTWF5YmVUeXBlT25seSkge1xuICAgICAgdGhpcy5wYXJzZVR5cGVPbmx5SW1wb3J0RXhwb3J0U3BlY2lmaWVyKG5vZGUsIGZhbHNlLCBpc0luVHlwZUV4cG9ydCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0U3BlY2lmaWVyXCIpO1xuICAgIH1cbiAgICBub2RlLmV4cG9ydEtpbmQgPSBcInZhbHVlXCI7XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlRXhwb3J0U3BlY2lmaWVyKG5vZGUsIGlzU3RyaW5nLCBpc0luVHlwZUV4cG9ydCwgaXNNYXliZVR5cGVPbmx5KTtcbiAgfVxuICBwYXJzZUltcG9ydFNwZWNpZmllcihzcGVjaWZpZXIsIGltcG9ydGVkSXNTdHJpbmcsIGlzSW5UeXBlT25seUltcG9ydCwgaXNNYXliZVR5cGVPbmx5LCBiaW5kaW5nVHlwZSkge1xuICAgIGlmICghaW1wb3J0ZWRJc1N0cmluZyAmJiBpc01heWJlVHlwZU9ubHkpIHtcbiAgICAgIHRoaXMucGFyc2VUeXBlT25seUltcG9ydEV4cG9ydFNwZWNpZmllcihzcGVjaWZpZXIsIHRydWUsIGlzSW5UeXBlT25seUltcG9ydCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHNwZWNpZmllciwgXCJJbXBvcnRTcGVjaWZpZXJcIik7XG4gICAgfVxuICAgIHNwZWNpZmllci5pbXBvcnRLaW5kID0gXCJ2YWx1ZVwiO1xuICAgIHJldHVybiBzdXBlci5wYXJzZUltcG9ydFNwZWNpZmllcihzcGVjaWZpZXIsIGltcG9ydGVkSXNTdHJpbmcsIGlzSW5UeXBlT25seUltcG9ydCwgaXNNYXliZVR5cGVPbmx5LCBpc0luVHlwZU9ubHlJbXBvcnQgPyA0MDk4IDogNDA5Nik7XG4gIH1cbiAgcGFyc2VUeXBlT25seUltcG9ydEV4cG9ydFNwZWNpZmllcihub2RlLCBpc0ltcG9ydCwgaXNJblR5cGVPbmx5SW1wb3J0RXhwb3J0KSB7XG4gICAgY29uc3QgbGVmdE9mQXNLZXkgPSBpc0ltcG9ydCA/IFwiaW1wb3J0ZWRcIiA6IFwibG9jYWxcIjtcbiAgICBjb25zdCByaWdodE9mQXNLZXkgPSBpc0ltcG9ydCA/IFwibG9jYWxcIiA6IFwiZXhwb3J0ZWRcIjtcbiAgICBsZXQgbGVmdE9mQXMgPSBub2RlW2xlZnRPZkFzS2V5XTtcbiAgICBsZXQgcmlnaHRPZkFzO1xuICAgIGxldCBoYXNUeXBlU3BlY2lmaWVyID0gZmFsc2U7XG4gICAgbGV0IGNhblBhcnNlQXNLZXl3b3JkID0gdHJ1ZTtcbiAgICBjb25zdCBsb2MgPSBsZWZ0T2ZBcy5sb2Muc3RhcnQ7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDkzKSkge1xuICAgICAgY29uc3QgZmlyc3RBcyA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoOTMpKSB7XG4gICAgICAgIGNvbnN0IHNlY29uZEFzID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgICAgaWYgKHRva2VuSXNLZXl3b3JkT3JJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgICAgICBoYXNUeXBlU3BlY2lmaWVyID0gdHJ1ZTtcbiAgICAgICAgICBsZWZ0T2ZBcyA9IGZpcnN0QXM7XG4gICAgICAgICAgcmlnaHRPZkFzID0gaXNJbXBvcnQgPyB0aGlzLnBhcnNlSWRlbnRpZmllcigpIDogdGhpcy5wYXJzZU1vZHVsZUV4cG9ydE5hbWUoKTtcbiAgICAgICAgICBjYW5QYXJzZUFzS2V5d29yZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJpZ2h0T2ZBcyA9IHNlY29uZEFzO1xuICAgICAgICAgIGNhblBhcnNlQXNLZXl3b3JkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICBjYW5QYXJzZUFzS2V5d29yZCA9IGZhbHNlO1xuICAgICAgICByaWdodE9mQXMgPSBpc0ltcG9ydCA/IHRoaXMucGFyc2VJZGVudGlmaWVyKCkgOiB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFzVHlwZVNwZWNpZmllciA9IHRydWU7XG4gICAgICAgIGxlZnRPZkFzID0gZmlyc3RBcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRva2VuSXNLZXl3b3JkT3JJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgIGhhc1R5cGVTcGVjaWZpZXIgPSB0cnVlO1xuICAgICAgaWYgKGlzSW1wb3J0KSB7XG4gICAgICAgIGxlZnRPZkFzID0gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgICAgIGlmICghdGhpcy5pc0NvbnRleHR1YWwoOTMpKSB7XG4gICAgICAgICAgdGhpcy5jaGVja1Jlc2VydmVkV29yZChsZWZ0T2ZBcy5uYW1lLCBsZWZ0T2ZBcy5sb2Muc3RhcnQsIHRydWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWZ0T2ZBcyA9IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNUeXBlU3BlY2lmaWVyICYmIGlzSW5UeXBlT25seUltcG9ydEV4cG9ydCkge1xuICAgICAgdGhpcy5yYWlzZShpc0ltcG9ydCA/IFRTRXJyb3JzLlR5cGVNb2RpZmllcklzVXNlZEluVHlwZUltcG9ydHMgOiBUU0Vycm9ycy5UeXBlTW9kaWZpZXJJc1VzZWRJblR5cGVFeHBvcnRzLCBsb2MpO1xuICAgIH1cbiAgICBub2RlW2xlZnRPZkFzS2V5XSA9IGxlZnRPZkFzO1xuICAgIG5vZGVbcmlnaHRPZkFzS2V5XSA9IHJpZ2h0T2ZBcztcbiAgICBjb25zdCBraW5kS2V5ID0gaXNJbXBvcnQgPyBcImltcG9ydEtpbmRcIiA6IFwiZXhwb3J0S2luZFwiO1xuICAgIG5vZGVba2luZEtleV0gPSBoYXNUeXBlU3BlY2lmaWVyID8gXCJ0eXBlXCIgOiBcInZhbHVlXCI7XG4gICAgaWYgKGNhblBhcnNlQXNLZXl3b3JkICYmIHRoaXMuZWF0Q29udGV4dHVhbCg5MykpIHtcbiAgICAgIG5vZGVbcmlnaHRPZkFzS2V5XSA9IGlzSW1wb3J0ID8gdGhpcy5wYXJzZUlkZW50aWZpZXIoKSA6IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk7XG4gICAgfVxuICAgIGlmICghbm9kZVtyaWdodE9mQXNLZXldKSB7XG4gICAgICBub2RlW3JpZ2h0T2ZBc0tleV0gPSBjbG9uZUlkZW50aWZpZXIobm9kZVtsZWZ0T2ZBc0tleV0pO1xuICAgIH1cbiAgICBpZiAoaXNJbXBvcnQpIHtcbiAgICAgIHRoaXMuY2hlY2tJZGVudGlmaWVyKG5vZGVbcmlnaHRPZkFzS2V5XSwgaGFzVHlwZVNwZWNpZmllciA/IDQwOTggOiA0MDk2KTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBpc1Bvc3NpYmx5TGl0ZXJhbEVudW0oZXhwcmVzc2lvbikge1xuICBpZiAoZXhwcmVzc2lvbi50eXBlICE9PSBcIk1lbWJlckV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICBjb25zdCB7XG4gICAgY29tcHV0ZWQsXG4gICAgcHJvcGVydHlcbiAgfSA9IGV4cHJlc3Npb247XG4gIGlmIChjb21wdXRlZCAmJiBwcm9wZXJ0eS50eXBlICE9PSBcIlN0cmluZ0xpdGVyYWxcIiAmJiAocHJvcGVydHkudHlwZSAhPT0gXCJUZW1wbGF0ZUxpdGVyYWxcIiB8fCBwcm9wZXJ0eS5leHByZXNzaW9ucy5sZW5ndGggPiAwKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNVbmNvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbkNoYWluKGV4cHJlc3Npb24ub2JqZWN0KTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRBbWJpZW50Q29uc3RJbml0aWFsaXplcihleHByZXNzaW9uLCBlc3RyZWUpIHtcbiAgdmFyIF9leHByZXNzaW9uJGV4dHJhO1xuICBjb25zdCB7XG4gICAgdHlwZVxuICB9ID0gZXhwcmVzc2lvbjtcbiAgaWYgKChfZXhwcmVzc2lvbiRleHRyYSA9IGV4cHJlc3Npb24uZXh0cmEpICE9IG51bGwgJiYgX2V4cHJlc3Npb24kZXh0cmEucGFyZW50aGVzaXplZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZXN0cmVlKSB7XG4gICAgaWYgKHR5cGUgPT09IFwiTGl0ZXJhbFwiKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHZhbHVlXG4gICAgICB9ID0gZXhwcmVzc2lvbjtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGUgPT09IFwiU3RyaW5nTGl0ZXJhbFwiIHx8IHR5cGUgPT09IFwiQm9vbGVhbkxpdGVyYWxcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChpc051bWJlcihleHByZXNzaW9uLCBlc3RyZWUpIHx8IGlzTmVnYXRpdmVOdW1iZXIoZXhwcmVzc2lvbiwgZXN0cmVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0eXBlID09PSBcIlRlbXBsYXRlTGl0ZXJhbFwiICYmIGV4cHJlc3Npb24uZXhwcmVzc2lvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlzUG9zc2libHlMaXRlcmFsRW51bShleHByZXNzaW9uKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyKGV4cHJlc3Npb24sIGVzdHJlZSkge1xuICBpZiAoZXN0cmVlKSB7XG4gICAgcmV0dXJuIGV4cHJlc3Npb24udHlwZSA9PT0gXCJMaXRlcmFsXCIgJiYgKHR5cGVvZiBleHByZXNzaW9uLnZhbHVlID09PSBcIm51bWJlclwiIHx8IFwiYmlnaW50XCIgaW4gZXhwcmVzc2lvbik7XG4gIH1cbiAgcmV0dXJuIGV4cHJlc3Npb24udHlwZSA9PT0gXCJOdW1lcmljTGl0ZXJhbFwiIHx8IGV4cHJlc3Npb24udHlwZSA9PT0gXCJCaWdJbnRMaXRlcmFsXCI7XG59XG5mdW5jdGlvbiBpc05lZ2F0aXZlTnVtYmVyKGV4cHJlc3Npb24sIGVzdHJlZSkge1xuICBpZiAoZXhwcmVzc2lvbi50eXBlID09PSBcIlVuYXJ5RXhwcmVzc2lvblwiKSB7XG4gICAgY29uc3Qge1xuICAgICAgb3BlcmF0b3IsXG4gICAgICBhcmd1bWVudFxuICAgIH0gPSBleHByZXNzaW9uO1xuICAgIGlmIChvcGVyYXRvciA9PT0gXCItXCIgJiYgaXNOdW1iZXIoYXJndW1lbnQsIGVzdHJlZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1VuY29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uQ2hhaW4oZXhwcmVzc2lvbikge1xuICBpZiAoZXhwcmVzc2lvbi50eXBlID09PSBcIklkZW50aWZpZXJcIikgcmV0dXJuIHRydWU7XG4gIGlmIChleHByZXNzaW9uLnR5cGUgIT09IFwiTWVtYmVyRXhwcmVzc2lvblwiIHx8IGV4cHJlc3Npb24uY29tcHV0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzVW5jb21wdXRlZE1lbWJlckV4cHJlc3Npb25DaGFpbihleHByZXNzaW9uLm9iamVjdCk7XG59XG5jb25zdCBQbGFjZWhvbGRlckVycm9ycyA9IFBhcnNlRXJyb3JFbnVtYHBsYWNlaG9sZGVyc2Aoe1xuICBDbGFzc05hbWVJc1JlcXVpcmVkOiBcIkEgY2xhc3MgbmFtZSBpcyByZXF1aXJlZC5cIixcbiAgVW5leHBlY3RlZFNwYWNlOiBcIlVuZXhwZWN0ZWQgc3BhY2UgaW4gcGxhY2Vob2xkZXIuXCJcbn0pO1xudmFyIHBsYWNlaG9sZGVycyA9IHN1cGVyQ2xhc3MgPT4gY2xhc3MgUGxhY2Vob2xkZXJzUGFyc2VyTWl4aW4gZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgcGFyc2VQbGFjZWhvbGRlcihleHBlY3RlZE5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxMzMpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5hc3NlcnROb1NwYWNlKCk7XG4gICAgICBub2RlLm5hbWUgPSBzdXBlci5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgICB0aGlzLmFzc2VydE5vU3BhY2UoKTtcbiAgICAgIHRoaXMuZXhwZWN0KDEzMyk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hQbGFjZWhvbGRlcihub2RlLCBleHBlY3RlZE5vZGUpO1xuICAgIH1cbiAgfVxuICBmaW5pc2hQbGFjZWhvbGRlcihub2RlLCBleHBlY3RlZE5vZGUpIHtcbiAgICBsZXQgcGxhY2Vob2xkZXIgPSBub2RlO1xuICAgIGlmICghcGxhY2Vob2xkZXIuZXhwZWN0ZWROb2RlIHx8ICFwbGFjZWhvbGRlci50eXBlKSB7XG4gICAgICBwbGFjZWhvbGRlciA9IHRoaXMuZmluaXNoTm9kZShwbGFjZWhvbGRlciwgXCJQbGFjZWhvbGRlclwiKTtcbiAgICB9XG4gICAgcGxhY2Vob2xkZXIuZXhwZWN0ZWROb2RlID0gZXhwZWN0ZWROb2RlO1xuICAgIHJldHVybiBwbGFjZWhvbGRlcjtcbiAgfVxuICBnZXRUb2tlbkZyb21Db2RlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gMzcgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSkgPT09IDM3KSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDEzMywgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLmdldFRva2VuRnJvbUNvZGUoY29kZSk7XG4gICAgfVxuICB9XG4gIHBhcnNlRXhwckF0b20ocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJFeHByZXNzaW9uXCIpIHx8IHN1cGVyLnBhcnNlRXhwckF0b20ocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gIH1cbiAgcGFyc2VJZGVudGlmaWVyKGxpYmVyYWwpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVBsYWNlaG9sZGVyKFwiSWRlbnRpZmllclwiKSB8fCBzdXBlci5wYXJzZUlkZW50aWZpZXIobGliZXJhbCk7XG4gIH1cbiAgY2hlY2tSZXNlcnZlZFdvcmQod29yZCwgc3RhcnRMb2MsIGNoZWNrS2V5d29yZHMsIGlzQmluZGluZykge1xuICAgIGlmICh3b3JkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN1cGVyLmNoZWNrUmVzZXJ2ZWRXb3JkKHdvcmQsIHN0YXJ0TG9jLCBjaGVja0tleXdvcmRzLCBpc0JpbmRpbmcpO1xuICAgIH1cbiAgfVxuICBwYXJzZUJpbmRpbmdBdG9tKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJQYXR0ZXJuXCIpIHx8IHN1cGVyLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgfVxuICBpc1ZhbGlkTFZhbCh0eXBlLCBpc1BhcmVudGhlc2l6ZWQsIGJpbmRpbmcpIHtcbiAgICByZXR1cm4gdHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiIHx8IHN1cGVyLmlzVmFsaWRMVmFsKHR5cGUsIGlzUGFyZW50aGVzaXplZCwgYmluZGluZyk7XG4gIH1cbiAgdG9Bc3NpZ25hYmxlKG5vZGUsIGlzTEhTKSB7XG4gICAgaWYgKG5vZGUgJiYgbm9kZS50eXBlID09PSBcIlBsYWNlaG9sZGVyXCIgJiYgbm9kZS5leHBlY3RlZE5vZGUgPT09IFwiRXhwcmVzc2lvblwiKSB7XG4gICAgICBub2RlLmV4cGVjdGVkTm9kZSA9IFwiUGF0dGVyblwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci50b0Fzc2lnbmFibGUobm9kZSwgaXNMSFMpO1xuICAgIH1cbiAgfVxuICBjaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyKGNoLCBwb3MpIHtcbiAgICBpZiAoc3VwZXIuY2hTdGFydHNCaW5kaW5nSWRlbnRpZmllcihjaCwgcG9zKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IG5leHRUb2tlbiA9IHRoaXMubG9va2FoZWFkKCk7XG4gICAgaWYgKG5leHRUb2tlbi50eXBlID09PSAxMzMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmVyaWZ5QnJlYWtDb250aW51ZShub2RlLCBpc0JyZWFrKSB7XG4gICAgaWYgKG5vZGUubGFiZWwgJiYgbm9kZS5sYWJlbC50eXBlID09PSBcIlBsYWNlaG9sZGVyXCIpIHJldHVybjtcbiAgICBzdXBlci52ZXJpZnlCcmVha0NvbnRpbnVlKG5vZGUsIGlzQnJlYWspO1xuICB9XG4gIHBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByKSB7XG4gICAgdmFyIF9leHByJGV4dHJhO1xuICAgIGlmIChleHByLnR5cGUgIT09IFwiUGxhY2Vob2xkZXJcIiB8fCAoX2V4cHIkZXh0cmEgPSBleHByLmV4dHJhKSAhPSBudWxsICYmIF9leHByJGV4dHJhLnBhcmVudGhlc2l6ZWQpIHtcbiAgICAgIHJldHVybiBzdXBlci5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwcik7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgY29uc3Qgc3RtdCA9IG5vZGU7XG4gICAgICBzdG10LmxhYmVsID0gdGhpcy5maW5pc2hQbGFjZWhvbGRlcihleHByLCBcIklkZW50aWZpZXJcIik7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHN0bXQuYm9keSA9IHN1cGVyLnBhcnNlU3RhdGVtZW50T3JTbG9wcHlBbm5leEJGdW5jdGlvbkRlY2xhcmF0aW9uKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHN0bXQsIFwiTGFiZWxlZFN0YXRlbWVudFwiKTtcbiAgICB9XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICBjb25zdCBzdG10UGxhY2Vob2xkZXIgPSBub2RlO1xuICAgIHN0bXRQbGFjZWhvbGRlci5uYW1lID0gZXhwci5uYW1lO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFBsYWNlaG9sZGVyKHN0bXRQbGFjZWhvbGRlciwgXCJTdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VCbG9jayhhbGxvd0RpcmVjdGl2ZXMsIGNyZWF0ZU5ld0xleGljYWxTY29wZSwgYWZ0ZXJCbG9ja1BhcnNlKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIkJsb2NrU3RhdGVtZW50XCIpIHx8IHN1cGVyLnBhcnNlQmxvY2soYWxsb3dEaXJlY3RpdmVzLCBjcmVhdGVOZXdMZXhpY2FsU2NvcGUsIGFmdGVyQmxvY2tQYXJzZSk7XG4gIH1cbiAgcGFyc2VGdW5jdGlvbklkKHJlcXVpcmVJZCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJJZGVudGlmaWVyXCIpIHx8IHN1cGVyLnBhcnNlRnVuY3Rpb25JZChyZXF1aXJlSWQpO1xuICB9XG4gIHBhcnNlQ2xhc3Mobm9kZSwgaXNTdGF0ZW1lbnQsIG9wdGlvbmFsSWQpIHtcbiAgICBjb25zdCB0eXBlID0gaXNTdGF0ZW1lbnQgPyBcIkNsYXNzRGVjbGFyYXRpb25cIiA6IFwiQ2xhc3NFeHByZXNzaW9uXCI7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgY29uc3Qgb2xkU3RyaWN0ID0gdGhpcy5zdGF0ZS5zdHJpY3Q7XG4gICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJJZGVudGlmaWVyXCIpO1xuICAgIGlmIChwbGFjZWhvbGRlcikge1xuICAgICAgaWYgKHRoaXMubWF0Y2goODEpIHx8IHRoaXMubWF0Y2goMTMzKSB8fCB0aGlzLm1hdGNoKDUpKSB7XG4gICAgICAgIG5vZGUuaWQgPSBwbGFjZWhvbGRlcjtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9uYWxJZCB8fCAhaXNTdGF0ZW1lbnQpIHtcbiAgICAgICAgbm9kZS5pZCA9IG51bGw7XG4gICAgICAgIG5vZGUuYm9keSA9IHRoaXMuZmluaXNoUGxhY2Vob2xkZXIocGxhY2Vob2xkZXIsIFwiQ2xhc3NCb2R5XCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHR5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShQbGFjZWhvbGRlckVycm9ycy5DbGFzc05hbWVJc1JlcXVpcmVkLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJzZUNsYXNzSWQobm9kZSwgaXNTdGF0ZW1lbnQsIG9wdGlvbmFsSWQpO1xuICAgIH1cbiAgICBzdXBlci5wYXJzZUNsYXNzU3VwZXIobm9kZSk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVBsYWNlaG9sZGVyKFwiQ2xhc3NCb2R5XCIpIHx8IHN1cGVyLnBhcnNlQ2xhc3NCb2R5KCEhbm9kZS5zdXBlckNsYXNzLCBvbGRTdHJpY3QpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdHlwZSk7XG4gIH1cbiAgcGFyc2VFeHBvcnQobm9kZSwgZGVjb3JhdG9ycykge1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gdGhpcy5wYXJzZVBsYWNlaG9sZGVyKFwiSWRlbnRpZmllclwiKTtcbiAgICBpZiAoIXBsYWNlaG9sZGVyKSByZXR1cm4gc3VwZXIucGFyc2VFeHBvcnQobm9kZSwgZGVjb3JhdG9ycyk7XG4gICAgY29uc3Qgbm9kZTIgPSBub2RlO1xuICAgIGlmICghdGhpcy5pc0NvbnRleHR1YWwoOTgpICYmICF0aGlzLm1hdGNoKDEyKSkge1xuICAgICAgbm9kZTIuc3BlY2lmaWVycyA9IFtdO1xuICAgICAgbm9kZTIuc291cmNlID0gbnVsbDtcbiAgICAgIG5vZGUyLmRlY2xhcmF0aW9uID0gdGhpcy5maW5pc2hQbGFjZWhvbGRlcihwbGFjZWhvbGRlciwgXCJEZWNsYXJhdGlvblwiKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZTIsIFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiKTtcbiAgICB9XG4gICAgdGhpcy5leHBlY3RQbHVnaW4oXCJleHBvcnREZWZhdWx0RnJvbVwiKTtcbiAgICBjb25zdCBzcGVjaWZpZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHNwZWNpZmllci5leHBvcnRlZCA9IHBsYWNlaG9sZGVyO1xuICAgIG5vZGUyLnNwZWNpZmllcnMgPSBbdGhpcy5maW5pc2hOb2RlKHNwZWNpZmllciwgXCJFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCIpXTtcbiAgICByZXR1cm4gc3VwZXIucGFyc2VFeHBvcnQobm9kZTIsIGRlY29yYXRvcnMpO1xuICB9XG4gIGlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcigpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg2NSkpIHtcbiAgICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlblN0YXJ0KCk7XG4gICAgICBpZiAodGhpcy5pc1VucGFyc2VkQ29udGV4dHVhbChuZXh0LCBcImZyb21cIikpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuc3RhcnRzV2l0aCh0b2tlbkxhYmVsTmFtZSgxMzMpLCB0aGlzLm5leHRUb2tlblN0YXJ0U2luY2UobmV4dCArIDQpKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5pc0V4cG9ydERlZmF1bHRTcGVjaWZpZXIoKTtcbiAgfVxuICBtYXliZVBhcnNlRXhwb3J0RGVmYXVsdFNwZWNpZmllcihub2RlLCBtYXliZURlZmF1bHRJZGVudGlmaWVyKSB7XG4gICAgdmFyIF9zcGVjaWZpZXJzO1xuICAgIGlmICgoX3NwZWNpZmllcnMgPSBub2RlLnNwZWNpZmllcnMpICE9IG51bGwgJiYgX3NwZWNpZmllcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLm1heWJlUGFyc2VFeHBvcnREZWZhdWx0U3BlY2lmaWVyKG5vZGUsIG1heWJlRGVmYXVsdElkZW50aWZpZXIpO1xuICB9XG4gIGNoZWNrRXhwb3J0KG5vZGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBzcGVjaWZpZXJzXG4gICAgfSA9IG5vZGU7XG4gICAgaWYgKHNwZWNpZmllcnMgIT0gbnVsbCAmJiBzcGVjaWZpZXJzLmxlbmd0aCkge1xuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gc3BlY2lmaWVycy5maWx0ZXIobm9kZSA9PiBub2RlLmV4cG9ydGVkLnR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIik7XG4gICAgfVxuICAgIHN1cGVyLmNoZWNrRXhwb3J0KG5vZGUpO1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IHNwZWNpZmllcnM7XG4gIH1cbiAgcGFyc2VJbXBvcnQobm9kZSkge1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gdGhpcy5wYXJzZVBsYWNlaG9sZGVyKFwiSWRlbnRpZmllclwiKTtcbiAgICBpZiAoIXBsYWNlaG9sZGVyKSByZXR1cm4gc3VwZXIucGFyc2VJbXBvcnQobm9kZSk7XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gW107XG4gICAgaWYgKCF0aGlzLmlzQ29udGV4dHVhbCg5OCkgJiYgIXRoaXMubWF0Y2goMTIpKSB7XG4gICAgICBub2RlLnNvdXJjZSA9IHRoaXMuZmluaXNoUGxhY2Vob2xkZXIocGxhY2Vob2xkZXIsIFwiU3RyaW5nTGl0ZXJhbFwiKTtcbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIik7XG4gICAgfVxuICAgIGNvbnN0IHNwZWNpZmllciA9IHRoaXMuc3RhcnROb2RlQXROb2RlKHBsYWNlaG9sZGVyKTtcbiAgICBzcGVjaWZpZXIubG9jYWwgPSBwbGFjZWhvbGRlcjtcbiAgICBub2RlLnNwZWNpZmllcnMucHVzaCh0aGlzLmZpbmlzaE5vZGUoc3BlY2lmaWVyLCBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIikpO1xuICAgIGlmICh0aGlzLmVhdCgxMikpIHtcbiAgICAgIGNvbnN0IGhhc1N0YXJJbXBvcnQgPSB0aGlzLm1heWJlUGFyc2VTdGFySW1wb3J0U3BlY2lmaWVyKG5vZGUpO1xuICAgICAgaWYgKCFoYXNTdGFySW1wb3J0KSB0aGlzLnBhcnNlTmFtZWRJbXBvcnRTcGVjaWZpZXJzKG5vZGUpO1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoOTgpO1xuICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUltcG9ydFNvdXJjZSgpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydERlY2xhcmF0aW9uXCIpO1xuICB9XG4gIHBhcnNlSW1wb3J0U291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJTdHJpbmdMaXRlcmFsXCIpIHx8IHN1cGVyLnBhcnNlSW1wb3J0U291cmNlKCk7XG4gIH1cbiAgYXNzZXJ0Tm9TcGFjZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5zdGFydCA+IHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3ModGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jLmluZGV4KSkge1xuICAgICAgdGhpcy5yYWlzZShQbGFjZWhvbGRlckVycm9ycy5VbmV4cGVjdGVkU3BhY2UsIHRoaXMuc3RhdGUubGFzdFRva0VuZExvYyk7XG4gICAgfVxuICB9XG59O1xudmFyIHY4aW50cmluc2ljID0gc3VwZXJDbGFzcyA9PiBjbGFzcyBWOEludHJpbnNpY01peGluIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG4gIHBhcnNlVjhJbnRyaW5zaWMoKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goNTQpKSB7XG4gICAgICBjb25zdCB2OEludHJpbnNpY1N0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSB0aGlzLmNyZWF0ZUlkZW50aWZpZXIobm9kZSwgbmFtZSk7XG4gICAgICAgIGlkZW50aWZpZXIudHlwZSA9IFwiVjhJbnRyaW5zaWNJZGVudGlmaWVyXCI7XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgICAgIHJldHVybiBpZGVudGlmaWVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQodjhJbnRyaW5zaWNTdGFydExvYyk7XG4gICAgfVxuICB9XG4gIHBhcnNlRXhwckF0b20ocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIHJldHVybiB0aGlzLnBhcnNlVjhJbnRyaW5zaWMoKSB8fCBzdXBlci5wYXJzZUV4cHJBdG9tKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICB9XG59O1xuY29uc3QgUElQRUxJTkVfUFJPUE9TQUxTID0gW1wibWluaW1hbFwiLCBcImZzaGFycFwiLCBcImhhY2tcIiwgXCJzbWFydFwiXTtcbmNvbnN0IFRPUElDX1RPS0VOUyA9IFtcIl5eXCIsIFwiQEBcIiwgXCJeXCIsIFwiJVwiLCBcIiNcIl07XG5mdW5jdGlvbiB2YWxpZGF0ZVBsdWdpbnMocGx1Z2luc01hcCkge1xuICBpZiAocGx1Z2luc01hcC5oYXMoXCJkZWNvcmF0b3JzXCIpKSB7XG4gICAgaWYgKHBsdWdpbnNNYXAuaGFzKFwiZGVjb3JhdG9ycy1sZWdhY3lcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgdGhlIGRlY29yYXRvcnMgYW5kIGRlY29yYXRvcnMtbGVnYWN5IHBsdWdpbiB0b2dldGhlclwiKTtcbiAgICB9XG4gICAgY29uc3QgZGVjb3JhdG9yc0JlZm9yZUV4cG9ydCA9IHBsdWdpbnNNYXAuZ2V0KFwiZGVjb3JhdG9yc1wiKS5kZWNvcmF0b3JzQmVmb3JlRXhwb3J0O1xuICAgIGlmIChkZWNvcmF0b3JzQmVmb3JlRXhwb3J0ICE9IG51bGwgJiYgdHlwZW9mIGRlY29yYXRvcnNCZWZvcmVFeHBvcnQgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCInZGVjb3JhdG9yc0JlZm9yZUV4cG9ydCcgbXVzdCBiZSBhIGJvb2xlYW4sIGlmIHNwZWNpZmllZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IGFsbG93Q2FsbFBhcmVudGhlc2l6ZWQgPSBwbHVnaW5zTWFwLmdldChcImRlY29yYXRvcnNcIikuYWxsb3dDYWxsUGFyZW50aGVzaXplZDtcbiAgICBpZiAoYWxsb3dDYWxsUGFyZW50aGVzaXplZCAhPSBudWxsICYmIHR5cGVvZiBhbGxvd0NhbGxQYXJlbnRoZXNpemVkICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ2FsbG93Q2FsbFBhcmVudGhlc2l6ZWQnIG11c3QgYmUgYSBib29sZWFuLlwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKHBsdWdpbnNNYXAuaGFzKFwiZmxvd1wiKSAmJiBwbHVnaW5zTWFwLmhhcyhcInR5cGVzY3JpcHRcIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tYmluZSBmbG93IGFuZCB0eXBlc2NyaXB0IHBsdWdpbnMuXCIpO1xuICB9XG4gIGlmIChwbHVnaW5zTWFwLmhhcyhcInBsYWNlaG9sZGVyc1wiKSAmJiBwbHVnaW5zTWFwLmhhcyhcInY4aW50cmluc2ljXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbWJpbmUgcGxhY2Vob2xkZXJzIGFuZCB2OGludHJpbnNpYyBwbHVnaW5zLlwiKTtcbiAgfVxuICBpZiAocGx1Z2luc01hcC5oYXMoXCJwaXBlbGluZU9wZXJhdG9yXCIpKSB7XG4gICAgdmFyIF9wbHVnaW5zTWFwJGdldDtcbiAgICBjb25zdCBwcm9wb3NhbCA9IHBsdWdpbnNNYXAuZ2V0KFwicGlwZWxpbmVPcGVyYXRvclwiKS5wcm9wb3NhbDtcbiAgICBpZiAoIVBJUEVMSU5FX1BST1BPU0FMUy5pbmNsdWRlcyhwcm9wb3NhbCkpIHtcbiAgICAgIGNvbnN0IHByb3Bvc2FsTGlzdCA9IFBJUEVMSU5FX1BST1BPU0FMUy5tYXAocCA9PiBgXCIke3B9XCJgKS5qb2luKFwiLCBcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFwicGlwZWxpbmVPcGVyYXRvclwiIHJlcXVpcmVzIFwicHJvcG9zYWxcIiBvcHRpb24gd2hvc2UgdmFsdWUgbXVzdCBiZSBvbmUgb2Y6ICR7cHJvcG9zYWxMaXN0fS5gKTtcbiAgICB9XG4gICAgY29uc3QgdHVwbGVTeW50YXhJc0hhc2ggPSAoKF9wbHVnaW5zTWFwJGdldCA9IHBsdWdpbnNNYXAuZ2V0KFwicmVjb3JkQW5kVHVwbGVcIikpID09IG51bGwgPyB2b2lkIDAgOiBfcGx1Z2luc01hcCRnZXQuc3ludGF4VHlwZSkgPT09IFwiaGFzaFwiO1xuICAgIGlmIChwcm9wb3NhbCA9PT0gXCJoYWNrXCIpIHtcbiAgICAgIGlmIChwbHVnaW5zTWFwLmhhcyhcInBsYWNlaG9sZGVyc1wiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tYmluZSBwbGFjZWhvbGRlcnMgcGx1Z2luIGFuZCBIYWNrLXN0eWxlIHBpcGVzLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChwbHVnaW5zTWFwLmhhcyhcInY4aW50cmluc2ljXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21iaW5lIHY4aW50cmluc2ljIHBsdWdpbiBhbmQgSGFjay1zdHlsZSBwaXBlcy5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCB0b3BpY1Rva2VuID0gcGx1Z2luc01hcC5nZXQoXCJwaXBlbGluZU9wZXJhdG9yXCIpLnRvcGljVG9rZW47XG4gICAgICBpZiAoIVRPUElDX1RPS0VOUy5pbmNsdWRlcyh0b3BpY1Rva2VuKSkge1xuICAgICAgICBjb25zdCB0b2tlbkxpc3QgPSBUT1BJQ19UT0tFTlMubWFwKHQgPT4gYFwiJHt0fVwiYCkuam9pbihcIiwgXCIpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwicGlwZWxpbmVPcGVyYXRvclwiIGluIFwicHJvcG9zYWxcIjogXCJoYWNrXCIgbW9kZSBhbHNvIHJlcXVpcmVzIGEgXCJ0b3BpY1Rva2VuXCIgb3B0aW9uIHdob3NlIHZhbHVlIG11c3QgYmUgb25lIG9mOiAke3Rva2VuTGlzdH0uYCk7XG4gICAgICB9XG4gICAgICBpZiAodG9waWNUb2tlbiA9PT0gXCIjXCIgJiYgdHVwbGVTeW50YXhJc0hhc2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQbHVnaW4gY29uZmxpY3QgYmV0d2VlbiBcXGBbXCJwaXBlbGluZU9wZXJhdG9yXCIsIHsgcHJvcG9zYWw6IFwiaGFja1wiLCB0b3BpY1Rva2VuOiBcIiNcIiB9XVxcYCBhbmQgXFxgJHtKU09OLnN0cmluZ2lmeShbXCJyZWNvcmRBbmRUdXBsZVwiLCBwbHVnaW5zTWFwLmdldChcInJlY29yZEFuZFR1cGxlXCIpXSl9XFxgLmApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcG9zYWwgPT09IFwic21hcnRcIiAmJiB0dXBsZVN5bnRheElzSGFzaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQbHVnaW4gY29uZmxpY3QgYmV0d2VlbiBcXGBbXCJwaXBlbGluZU9wZXJhdG9yXCIsIHsgcHJvcG9zYWw6IFwic21hcnRcIiB9XVxcYCBhbmQgXFxgJHtKU09OLnN0cmluZ2lmeShbXCJyZWNvcmRBbmRUdXBsZVwiLCBwbHVnaW5zTWFwLmdldChcInJlY29yZEFuZFR1cGxlXCIpXSl9XFxgLmApO1xuICAgIH1cbiAgfVxuICBpZiAocGx1Z2luc01hcC5oYXMoXCJtb2R1bGVBdHRyaWJ1dGVzXCIpKSB7XG4gICAge1xuICAgICAgaWYgKHBsdWdpbnNNYXAuaGFzKFwiZGVwcmVjYXRlZEltcG9ydEFzc2VydFwiKSB8fCBwbHVnaW5zTWFwLmhhcyhcImltcG9ydEFzc2VydGlvbnNcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbWJpbmUgaW1wb3J0QXNzZXJ0aW9ucywgZGVwcmVjYXRlZEltcG9ydEFzc2VydCBhbmQgbW9kdWxlQXR0cmlidXRlcyBwbHVnaW5zLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZHVsZUF0dHJpYnV0ZXNWZXJzaW9uUGx1Z2luT3B0aW9uID0gcGx1Z2luc01hcC5nZXQoXCJtb2R1bGVBdHRyaWJ1dGVzXCIpLnZlcnNpb247XG4gICAgICBpZiAobW9kdWxlQXR0cmlidXRlc1ZlcnNpb25QbHVnaW5PcHRpb24gIT09IFwibWF5LTIwMjBcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgJ21vZHVsZUF0dHJpYnV0ZXMnIHBsdWdpbiByZXF1aXJlcyBhICd2ZXJzaW9uJyBvcHRpb24sXCIgKyBcIiByZXByZXNlbnRpbmcgdGhlIGxhc3QgcHJvcG9zYWwgdXBkYXRlLiBDdXJyZW50bHksIHRoZVwiICsgXCIgb25seSBzdXBwb3J0ZWQgdmFsdWUgaXMgJ21heS0yMDIwJy5cIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChwbHVnaW5zTWFwLmhhcyhcImltcG9ydEFzc2VydGlvbnNcIikpIHtcbiAgICBpZiAocGx1Z2luc01hcC5oYXMoXCJkZXByZWNhdGVkSW1wb3J0QXNzZXJ0XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tYmluZSBpbXBvcnRBc3NlcnRpb25zIGFuZCBkZXByZWNhdGVkSW1wb3J0QXNzZXJ0IHBsdWdpbnMuXCIpO1xuICAgIH1cbiAgfVxuICBpZiAoIXBsdWdpbnNNYXAuaGFzKFwiZGVwcmVjYXRlZEltcG9ydEFzc2VydFwiKSAmJiBwbHVnaW5zTWFwLmhhcyhcImltcG9ydEF0dHJpYnV0ZXNcIikgJiYgcGx1Z2luc01hcC5nZXQoXCJpbXBvcnRBdHRyaWJ1dGVzXCIpLmRlcHJlY2F0ZWRBc3NlcnRTeW50YXgpIHtcbiAgICB7XG4gICAgICBwbHVnaW5zTWFwLnNldChcImRlcHJlY2F0ZWRJbXBvcnRBc3NlcnRcIiwge30pO1xuICAgIH1cbiAgfVxuICBpZiAocGx1Z2luc01hcC5oYXMoXCJyZWNvcmRBbmRUdXBsZVwiKSkge1xuICAgIGNvbnN0IHN5bnRheFR5cGUgPSBwbHVnaW5zTWFwLmdldChcInJlY29yZEFuZFR1cGxlXCIpLnN5bnRheFR5cGU7XG4gICAgaWYgKHN5bnRheFR5cGUgIT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBjb25zdCBSRUNPUkRfQU5EX1RVUExFX1NZTlRBWF9UWVBFUyA9IFtcImhhc2hcIiwgXCJiYXJcIl07XG4gICAgICAgIGlmICghUkVDT1JEX0FORF9UVVBMRV9TWU5UQVhfVFlQRVMuaW5jbHVkZXMoc3ludGF4VHlwZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgJ3N5bnRheFR5cGUnIG9wdGlvbiBvZiB0aGUgJ3JlY29yZEFuZFR1cGxlJyBwbHVnaW4gbXVzdCBiZSBvbmUgb2Y6IFwiICsgUkVDT1JEX0FORF9UVVBMRV9TWU5UQVhfVFlQRVMubWFwKHAgPT4gYCcke3B9J2ApLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHBsdWdpbnNNYXAuaGFzKFwiYXN5bmNEb0V4cHJlc3Npb25zXCIpICYmICFwbHVnaW5zTWFwLmhhcyhcImRvRXhwcmVzc2lvbnNcIikpIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcIidhc3luY0RvRXhwcmVzc2lvbnMnIHJlcXVpcmVzICdkb0V4cHJlc3Npb25zJywgcGxlYXNlIGFkZCAnZG9FeHByZXNzaW9ucycgdG8gcGFyc2VyIHBsdWdpbnMuXCIpO1xuICAgIGVycm9yLm1pc3NpbmdQbHVnaW5zID0gXCJkb0V4cHJlc3Npb25zXCI7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYgKHBsdWdpbnNNYXAuaGFzKFwib3B0aW9uYWxDaGFpbmluZ0Fzc2lnblwiKSAmJiBwbHVnaW5zTWFwLmdldChcIm9wdGlvbmFsQ2hhaW5pbmdBc3NpZ25cIikudmVyc2lvbiAhPT0gXCIyMDIzLTA3XCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgJ29wdGlvbmFsQ2hhaW5pbmdBc3NpZ24nIHBsdWdpbiByZXF1aXJlcyBhICd2ZXJzaW9uJyBvcHRpb24sXCIgKyBcIiByZXByZXNlbnRpbmcgdGhlIGxhc3QgcHJvcG9zYWwgdXBkYXRlLiBDdXJyZW50bHksIHRoZVwiICsgXCIgb25seSBzdXBwb3J0ZWQgdmFsdWUgaXMgJzIwMjMtMDcnLlwiKTtcbiAgfVxufVxuY29uc3QgbWl4aW5QbHVnaW5zID0ge1xuICBlc3RyZWUsXG4gIGpzeCxcbiAgZmxvdyxcbiAgdHlwZXNjcmlwdCxcbiAgdjhpbnRyaW5zaWMsXG4gIHBsYWNlaG9sZGVyc1xufTtcbmNvbnN0IG1peGluUGx1Z2luTmFtZXMgPSBPYmplY3Qua2V5cyhtaXhpblBsdWdpbnMpO1xuY2xhc3MgRXhwcmVzc2lvblBhcnNlciBleHRlbmRzIExWYWxQYXJzZXIge1xuICBjaGVja1Byb3RvKHByb3AsIGlzUmVjb3JkLCBzYXdQcm90bywgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGlmIChwcm9wLnR5cGUgPT09IFwiU3ByZWFkRWxlbWVudFwiIHx8IHRoaXMuaXNPYmplY3RNZXRob2QocHJvcCkgfHwgcHJvcC5jb21wdXRlZCB8fCBwcm9wLnNob3J0aGFuZCkge1xuICAgICAgcmV0dXJuIHNhd1Byb3RvO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBwcm9wLmtleTtcbiAgICBjb25zdCBuYW1lID0ga2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiID8ga2V5Lm5hbWUgOiBrZXkudmFsdWU7XG4gICAgaWYgKG5hbWUgPT09IFwiX19wcm90b19fXCIpIHtcbiAgICAgIGlmIChpc1JlY29yZCkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5SZWNvcmROb1Byb3RvLCBrZXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzYXdQcm90bykge1xuICAgICAgICBpZiAocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgICAgICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzLmRvdWJsZVByb3RvTG9jID09PSBudWxsKSB7XG4gICAgICAgICAgICByZWZFeHByZXNzaW9uRXJyb3JzLmRvdWJsZVByb3RvTG9jID0ga2V5LmxvYy5zdGFydDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRHVwbGljYXRlUHJvdG8sIGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc2F3UHJvdG87XG4gIH1cbiAgc2hvdWxkRXhpdERlc2NlbmRpbmcoZXhwciwgcG90ZW50aWFsQXJyb3dBdCkge1xuICAgIHJldHVybiBleHByLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiB0aGlzLm9mZnNldFRvU291cmNlUG9zKGV4cHIuc3RhcnQpID09PSBwb3RlbnRpYWxBcnJvd0F0O1xuICB9XG4gIGdldEV4cHJlc3Npb24oKSB7XG4gICAgdGhpcy5lbnRlckluaXRpYWxTY29wZXMoKTtcbiAgICB0aGlzLm5leHRUb2tlbigpO1xuICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIGlmICghdGhpcy5tYXRjaCgxNDApKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgdGhpcy5maW5hbGl6ZVJlbWFpbmluZ0NvbW1lbnRzKCk7XG4gICAgZXhwci5jb21tZW50cyA9IHRoaXMuY29tbWVudHM7XG4gICAgZXhwci5lcnJvcnMgPSB0aGlzLnN0YXRlLmVycm9ycztcbiAgICBpZiAodGhpcy5vcHRpb25GbGFncyAmIDI1Nikge1xuICAgICAgZXhwci50b2tlbnMgPSB0aGlzLnRva2VucztcbiAgICB9XG4gICAgcmV0dXJuIGV4cHI7XG4gIH1cbiAgcGFyc2VFeHByZXNzaW9uKGRpc2FsbG93SW4sIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBpZiAoZGlzYWxsb3dJbikge1xuICAgICAgcmV0dXJuIHRoaXMuZGlzYWxsb3dJbkFuZCgoKSA9PiB0aGlzLnBhcnNlRXhwcmVzc2lvbkJhc2UocmVmRXhwcmVzc2lvbkVycm9ycykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hbGxvd0luQW5kKCgpID0+IHRoaXMucGFyc2VFeHByZXNzaW9uQmFzZShyZWZFeHByZXNzaW9uRXJyb3JzKSk7XG4gIH1cbiAgcGFyc2VFeHByZXNzaW9uQmFzZShyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgaWYgKHRoaXMubWF0Y2goMTIpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBub2RlLmV4cHJlc3Npb25zID0gW2V4cHJdO1xuICAgICAgd2hpbGUgKHRoaXMuZWF0KDEyKSkge1xuICAgICAgICBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZU1heWJlQXNzaWduKHJlZkV4cHJlc3Npb25FcnJvcnMpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudG9SZWZlcmVuY2VkTGlzdChub2RlLmV4cHJlc3Npb25zKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIik7XG4gICAgfVxuICAgIHJldHVybiBleHByO1xuICB9XG4gIHBhcnNlTWF5YmVBc3NpZ25EaXNhbGxvd0luKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzYWxsb3dJbkFuZCgoKSA9PiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpKTtcbiAgfVxuICBwYXJzZU1heWJlQXNzaWduQWxsb3dJbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSkge1xuICAgIHJldHVybiB0aGlzLmFsbG93SW5BbmQoKCkgPT4gdGhpcy5wYXJzZU1heWJlQXNzaWduKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSk7XG4gIH1cbiAgc2V0T3B0aW9uYWxQYXJhbWV0ZXJzRXJyb3IocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIHJlZkV4cHJlc3Npb25FcnJvcnMub3B0aW9uYWxQYXJhbWV0ZXJzTG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgfVxuICBwYXJzZU1heWJlQXNzaWduKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IGlzWWllbGQgPSB0aGlzLmlzQ29udGV4dHVhbCgxMDgpO1xuICAgIGlmIChpc1lpZWxkKSB7XG4gICAgICBpZiAodGhpcy5wcm9kUGFyYW0uaGFzWWllbGQpIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGxldCBsZWZ0ID0gdGhpcy5wYXJzZVlpZWxkKHN0YXJ0TG9jKTtcbiAgICAgICAgaWYgKGFmdGVyTGVmdFBhcnNlKSB7XG4gICAgICAgICAgbGVmdCA9IGFmdGVyTGVmdFBhcnNlLmNhbGwodGhpcywgbGVmdCwgc3RhcnRMb2MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgb3duRXhwcmVzc2lvbkVycm9ycztcbiAgICBpZiAocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgICAgb3duRXhwcmVzc2lvbkVycm9ycyA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWZFeHByZXNzaW9uRXJyb3JzID0gbmV3IEV4cHJlc3Npb25FcnJvcnMoKTtcbiAgICAgIG93bkV4cHJlc3Npb25FcnJvcnMgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHR5cGUgPT09IDEwIHx8IHRva2VuSXNJZGVudGlmaWVyKHR5cGUpKSB7XG4gICAgICB0aGlzLnN0YXRlLnBvdGVudGlhbEFycm93QXQgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgIH1cbiAgICBsZXQgbGVmdCA9IHRoaXMucGFyc2VNYXliZUNvbmRpdGlvbmFsKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIGlmIChhZnRlckxlZnRQYXJzZSkge1xuICAgICAgbGVmdCA9IGFmdGVyTGVmdFBhcnNlLmNhbGwodGhpcywgbGVmdCwgc3RhcnRMb2MpO1xuICAgIH1cbiAgICBpZiAodG9rZW5Jc0Fzc2lnbm1lbnQodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgY29uc3Qgb3BlcmF0b3IgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgbm9kZS5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgaWYgKHRoaXMubWF0Y2goMjkpKSB7XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKGxlZnQsIHRydWUpO1xuICAgICAgICBub2RlLmxlZnQgPSBsZWZ0O1xuICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gc3RhcnRMb2MuaW5kZXg7XG4gICAgICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzLmRvdWJsZVByb3RvTG9jICE9IG51bGwgJiYgcmVmRXhwcmVzc2lvbkVycm9ycy5kb3VibGVQcm90b0xvYy5pbmRleCA+PSBzdGFydEluZGV4KSB7XG4gICAgICAgICAgcmVmRXhwcmVzc2lvbkVycm9ycy5kb3VibGVQcm90b0xvYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMuc2hvcnRoYW5kQXNzaWduTG9jICE9IG51bGwgJiYgcmVmRXhwcmVzc2lvbkVycm9ycy5zaG9ydGhhbmRBc3NpZ25Mb2MuaW5kZXggPj0gc3RhcnRJbmRleCkge1xuICAgICAgICAgIHJlZkV4cHJlc3Npb25FcnJvcnMuc2hvcnRoYW5kQXNzaWduTG9jID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmRXhwcmVzc2lvbkVycm9ycy5wcml2YXRlS2V5TG9jICE9IG51bGwgJiYgcmVmRXhwcmVzc2lvbkVycm9ycy5wcml2YXRlS2V5TG9jLmluZGV4ID49IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrRGVzdHJ1Y3R1cmluZ1ByaXZhdGUocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgICAgICAgcmVmRXhwcmVzc2lvbkVycm9ycy5wcml2YXRlS2V5TG9jID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgdGhpcy5jaGVja0xWYWwobGVmdCwgdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIikpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmIChvd25FeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZFeHByZXNzaW9uRXJyb3JzLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGlzWWllbGQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHlwZVxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBzdGFydHNFeHByID0gdGhpcy5oYXNQbHVnaW4oXCJ2OGludHJpbnNpY1wiKSA/IHRva2VuQ2FuU3RhcnRFeHByZXNzaW9uKHR5cGUpIDogdG9rZW5DYW5TdGFydEV4cHJlc3Npb24odHlwZSkgJiYgIXRoaXMubWF0Y2goNTQpO1xuICAgICAgaWYgKHN0YXJ0c0V4cHIgJiYgIXRoaXMuaXNBbWJpZ3VvdXNQcmVmaXhPcklkZW50aWZpZXIoKSkge1xuICAgICAgICB0aGlzLnJhaXNlT3ZlcndyaXRlKEVycm9ycy5ZaWVsZE5vdEluR2VuZXJhdG9yRnVuY3Rpb24sIHN0YXJ0TG9jKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VZaWVsZChzdGFydExvYyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZWZ0O1xuICB9XG4gIHBhcnNlTWF5YmVDb25kaXRpb25hbChyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IHBvdGVudGlhbEFycm93QXQgPSB0aGlzLnN0YXRlLnBvdGVudGlhbEFycm93QXQ7XG4gICAgY29uc3QgZXhwciA9IHRoaXMucGFyc2VFeHByT3BzKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIGlmICh0aGlzLnNob3VsZEV4aXREZXNjZW5kaW5nKGV4cHIsIHBvdGVudGlhbEFycm93QXQpKSB7XG4gICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VDb25kaXRpb25hbChleHByLCBzdGFydExvYywgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gIH1cbiAgcGFyc2VDb25kaXRpb25hbChleHByLCBzdGFydExvYywgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGlmICh0aGlzLmVhdCgxNykpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUudGVzdCA9IGV4cHI7XG4gICAgICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgICB0aGlzLmV4cGVjdCgxNCk7XG4gICAgICBub2RlLmFsdGVybmF0ZSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cHI7XG4gIH1cbiAgcGFyc2VNYXliZVVuYXJ5T3JQcml2YXRlKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgxMzkpID8gdGhpcy5wYXJzZVByaXZhdGVOYW1lKCkgOiB0aGlzLnBhcnNlTWF5YmVVbmFyeShyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgfVxuICBwYXJzZUV4cHJPcHMocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBwb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0O1xuICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeU9yUHJpdmF0ZShyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICBpZiAodGhpcy5zaG91bGRFeGl0RGVzY2VuZGluZyhleHByLCBwb3RlbnRpYWxBcnJvd0F0KSkge1xuICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlRXhwck9wKGV4cHIsIHN0YXJ0TG9jLCAtMSk7XG4gIH1cbiAgcGFyc2VFeHByT3AobGVmdCwgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjKSB7XG4gICAgaWYgKHRoaXMuaXNQcml2YXRlTmFtZShsZWZ0KSkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFByaXZhdGVOYW1lU1YobGVmdCk7XG4gICAgICBpZiAobWluUHJlYyA+PSB0b2tlbk9wZXJhdG9yUHJlY2VkZW5jZSg1OCkgfHwgIXRoaXMucHJvZFBhcmFtLmhhc0luIHx8ICF0aGlzLm1hdGNoKDU4KSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Qcml2YXRlSW5FeHBlY3RlZEluLCBsZWZ0LCB7XG4gICAgICAgICAgaWRlbnRpZmllck5hbWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGFzc1Njb3BlLnVzZVByaXZhdGVOYW1lKHZhbHVlLCBsZWZ0LmxvYy5zdGFydCk7XG4gICAgfVxuICAgIGNvbnN0IG9wID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgIGlmICh0b2tlbklzT3BlcmF0b3Iob3ApICYmICh0aGlzLnByb2RQYXJhbS5oYXNJbiB8fCAhdGhpcy5tYXRjaCg1OCkpKSB7XG4gICAgICBsZXQgcHJlYyA9IHRva2VuT3BlcmF0b3JQcmVjZWRlbmNlKG9wKTtcbiAgICAgIGlmIChwcmVjID4gbWluUHJlYykge1xuICAgICAgICBpZiAob3AgPT09IDM5KSB7XG4gICAgICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJwaXBlbGluZU9wZXJhdG9yXCIpO1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5KSB7XG4gICAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jaGVja1BpcGVsaW5lQXRJbmZpeE9wZXJhdG9yKGxlZnQsIGxlZnRTdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQobGVmdFN0YXJ0TG9jKTtcbiAgICAgICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICAgICAgbm9kZS5vcGVyYXRvciA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICAgIGNvbnN0IGxvZ2ljYWwgPSBvcCA9PT0gNDEgfHwgb3AgPT09IDQyO1xuICAgICAgICBjb25zdCBjb2FsZXNjZSA9IG9wID09PSA0MDtcbiAgICAgICAgaWYgKGNvYWxlc2NlKSB7XG4gICAgICAgICAgcHJlYyA9IHRva2VuT3BlcmF0b3JQcmVjZWRlbmNlKDQyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKG9wID09PSAzOSAmJiB0aGlzLmhhc1BsdWdpbihbXCJwaXBlbGluZU9wZXJhdG9yXCIsIHtcbiAgICAgICAgICBwcm9wb3NhbDogXCJtaW5pbWFsXCJcbiAgICAgICAgfV0pKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUudHlwZSA9PT0gOTYgJiYgdGhpcy5wcm9kUGFyYW0uaGFzQXdhaXQpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRBd2FpdEFmdGVyUGlwZWxpbmVCb2R5LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VFeHByT3BSaWdodEV4cHIob3AsIHByZWMpO1xuICAgICAgICBjb25zdCBmaW5pc2hlZE5vZGUgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgbG9naWNhbCB8fCBjb2FsZXNjZSA/IFwiTG9naWNhbEV4cHJlc3Npb25cIiA6IFwiQmluYXJ5RXhwcmVzc2lvblwiKTtcbiAgICAgICAgY29uc3QgbmV4dE9wID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgICAgICBpZiAoY29hbGVzY2UgJiYgKG5leHRPcCA9PT0gNDEgfHwgbmV4dE9wID09PSA0MikgfHwgbG9naWNhbCAmJiBuZXh0T3AgPT09IDQwKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuTWl4aW5nQ29hbGVzY2VXaXRoTG9naWNhbCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3AoZmluaXNoZWROb2RlLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVmdDtcbiAgfVxuICBwYXJzZUV4cHJPcFJpZ2h0RXhwcihvcCwgcHJlYykge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICBjYXNlIDM5OlxuICAgICAgICBzd2l0Y2ggKHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwicGlwZWxpbmVPcGVyYXRvclwiLCBcInByb3Bvc2FsXCIpKSB7XG4gICAgICAgICAgY2FzZSBcImhhY2tcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpdGhUb3BpY0JpbmRpbmdDb250ZXh0KCgpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VIYWNrUGlwZUJvZHkoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhc2UgXCJmc2hhcnBcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpdGhTb2xvQXdhaXRQZXJtaXR0aW5nQ29udGV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRlNoYXJwUGlwZWxpbmVCb2R5KHByZWMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwicGlwZWxpbmVPcGVyYXRvclwiLCBcInByb3Bvc2FsXCIpID09PSBcInNtYXJ0XCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy53aXRoVG9waWNCaW5kaW5nQ29udGV4dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9kUGFyYW0uaGFzWWllbGQgJiYgdGhpcy5pc0NvbnRleHR1YWwoMTA4KSkge1xuICAgICAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5QaXBlQm9keUlzVGlnaHRlciwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNtYXJ0UGlwZWxpbmVCb2R5SW5TdHlsZSh0aGlzLnBhcnNlRXhwck9wQmFzZVJpZ2h0RXhwcihvcCwgcHJlYyksIHN0YXJ0TG9jKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3BCYXNlUmlnaHRFeHByKG9wLCBwcmVjKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VFeHByT3BCYXNlUmlnaHRFeHByKG9wLCBwcmVjKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIHJldHVybiB0aGlzLnBhcnNlRXhwck9wKHRoaXMucGFyc2VNYXliZVVuYXJ5T3JQcml2YXRlKCksIHN0YXJ0TG9jLCB0b2tlbklzUmlnaHRBc3NvY2lhdGl2ZShvcCkgPyBwcmVjIC0gMSA6IHByZWMpO1xuICB9XG4gIHBhcnNlSGFja1BpcGVCb2R5KCkge1xuICAgIHZhciBfYm9keSRleHRyYTtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydExvY1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGJvZHkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICBjb25zdCByZXF1aXJlZFBhcmVudGhlc2VzID0gVW5wYXJlbnRoZXNpemVkUGlwZUJvZHlEZXNjcmlwdGlvbnMuaGFzKGJvZHkudHlwZSk7XG4gICAgaWYgKHJlcXVpcmVkUGFyZW50aGVzZXMgJiYgISgoX2JvZHkkZXh0cmEgPSBib2R5LmV4dHJhKSAhPSBudWxsICYmIF9ib2R5JGV4dHJhLnBhcmVudGhlc2l6ZWQpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5QaXBlVW5wYXJlbnRoZXNpemVkQm9keSwgc3RhcnRMb2MsIHtcbiAgICAgICAgdHlwZTogYm9keS50eXBlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnRvcGljUmVmZXJlbmNlV2FzVXNlZEluQ3VycmVudENvbnRleHQoKSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUGlwZVRvcGljVW51c2VkLCBzdGFydExvYyk7XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xuICB9XG4gIGNoZWNrRXhwb25lbnRpYWxBZnRlclVuYXJ5KG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg1NykpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRUb2tlblVuYXJ5RXhwb25lbnRpYXRpb24sIG5vZGUuYXJndW1lbnQpO1xuICAgIH1cbiAgfVxuICBwYXJzZU1heWJlVW5hcnkocmVmRXhwcmVzc2lvbkVycm9ycywgc2F3VW5hcnkpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgaXNBd2FpdCA9IHRoaXMuaXNDb250ZXh0dWFsKDk2KTtcbiAgICBpZiAoaXNBd2FpdCAmJiB0aGlzLnJlY29yZEF3YWl0SWZBbGxvd2VkKCkpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgY29uc3QgZXhwciA9IHRoaXMucGFyc2VBd2FpdChzdGFydExvYyk7XG4gICAgICBpZiAoIXNhd1VuYXJ5KSB0aGlzLmNoZWNrRXhwb25lbnRpYWxBZnRlclVuYXJ5KGV4cHIpO1xuICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZSA9IHRoaXMubWF0Y2goMzQpO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGlmICh0b2tlbklzUHJlZml4KHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgbm9kZS5wcmVmaXggPSB0cnVlO1xuICAgICAgaWYgKHRoaXMubWF0Y2goNzIpKSB7XG4gICAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwidGhyb3dFeHByZXNzaW9uc1wiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzRGVsZXRlID0gdGhpcy5tYXRjaCg4OSk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCB0cnVlKTtcbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkV4cHJlc3Npb25FcnJvcnMsIHRydWUpO1xuICAgICAgaWYgKHRoaXMuc3RhdGUuc3RyaWN0ICYmIGlzRGVsZXRlKSB7XG4gICAgICAgIGNvbnN0IGFyZyA9IG5vZGUuYXJndW1lbnQ7XG4gICAgICAgIGlmIChhcmcudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5TdHJpY3REZWxldGUsIG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzUHJvcGVydHlBc1ByaXZhdGVOYW1lKGFyZykpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EZWxldGVQcml2YXRlRmllbGQsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXVwZGF0ZSkge1xuICAgICAgICBpZiAoIXNhd1VuYXJ5KSB7XG4gICAgICAgICAgdGhpcy5jaGVja0V4cG9uZW50aWFsQWZ0ZXJVbmFyeShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVW5hcnlFeHByZXNzaW9uXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBleHByID0gdGhpcy5wYXJzZVVwZGF0ZShub2RlLCB1cGRhdGUsIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIGlmIChpc0F3YWl0KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGVcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3Qgc3RhcnRzRXhwciA9IHRoaXMuaGFzUGx1Z2luKFwidjhpbnRyaW5zaWNcIikgPyB0b2tlbkNhblN0YXJ0RXhwcmVzc2lvbih0eXBlKSA6IHRva2VuQ2FuU3RhcnRFeHByZXNzaW9uKHR5cGUpICYmICF0aGlzLm1hdGNoKDU0KTtcbiAgICAgIGlmIChzdGFydHNFeHByICYmICF0aGlzLmlzQW1iaWd1b3VzUHJlZml4T3JJZGVudGlmaWVyKCkpIHtcbiAgICAgICAgdGhpcy5yYWlzZU92ZXJ3cml0ZShFcnJvcnMuQXdhaXROb3RJbkFzeW5jQ29udGV4dCwgc3RhcnRMb2MpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUF3YWl0KHN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4cHI7XG4gIH1cbiAgcGFyc2VVcGRhdGUobm9kZSwgdXBkYXRlLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKHVwZGF0ZSkge1xuICAgICAgY29uc3QgdXBkYXRlRXhwcmVzc2lvbk5vZGUgPSBub2RlO1xuICAgICAgdGhpcy5jaGVja0xWYWwodXBkYXRlRXhwcmVzc2lvbk5vZGUuYXJndW1lbnQsIHRoaXMuZmluaXNoTm9kZSh1cGRhdGVFeHByZXNzaW9uTm9kZSwgXCJVcGRhdGVFeHByZXNzaW9uXCIpKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgbGV0IGV4cHIgPSB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkV4cHJlc3Npb25FcnJvcnMsIGZhbHNlKSkgcmV0dXJuIGV4cHI7XG4gICAgd2hpbGUgKHRva2VuSXNQb3N0Zml4KHRoaXMuc3RhdGUudHlwZSkgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgbm9kZS5wcmVmaXggPSBmYWxzZTtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSBleHByO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLmNoZWNrTFZhbChleHByLCBleHByID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVXBkYXRlRXhwcmVzc2lvblwiKSk7XG4gICAgfVxuICAgIHJldHVybiBleHByO1xuICB9XG4gIHBhcnNlRXhwclN1YnNjcmlwdHMocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBwb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0O1xuICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlRXhwckF0b20ocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgaWYgKHRoaXMuc2hvdWxkRXhpdERlc2NlbmRpbmcoZXhwciwgcG90ZW50aWFsQXJyb3dBdCkpIHtcbiAgICAgIHJldHVybiBleHByO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZVN1YnNjcmlwdHMoZXhwciwgc3RhcnRMb2MpO1xuICB9XG4gIHBhcnNlU3Vic2NyaXB0cyhiYXNlLCBzdGFydExvYywgbm9DYWxscykge1xuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgb3B0aW9uYWxDaGFpbk1lbWJlcjogZmFsc2UsXG4gICAgICBtYXliZUFzeW5jQXJyb3c6IHRoaXMuYXRQb3NzaWJsZUFzeW5jQXJyb3coYmFzZSksXG4gICAgICBzdG9wOiBmYWxzZVxuICAgIH07XG4gICAgZG8ge1xuICAgICAgYmFzZSA9IHRoaXMucGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMsIHN0YXRlKTtcbiAgICAgIHN0YXRlLm1heWJlQXN5bmNBcnJvdyA9IGZhbHNlO1xuICAgIH0gd2hpbGUgKCFzdGF0ZS5zdG9wKTtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuICBwYXJzZVN1YnNjcmlwdChiYXNlLCBzdGFydExvYywgbm9DYWxscywgc3RhdGUpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKCFub0NhbGxzICYmIHR5cGUgPT09IDE1KSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUJpbmQoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMsIHN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHRva2VuSXNUZW1wbGF0ZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oYmFzZSwgc3RhcnRMb2MsIHN0YXRlKTtcbiAgICB9XG4gICAgbGV0IG9wdGlvbmFsID0gZmFsc2U7XG4gICAgaWYgKHR5cGUgPT09IDE4KSB7XG4gICAgICBpZiAobm9DYWxscykge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5PcHRpb25hbENoYWluaW5nTm9OZXcsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICBpZiAodGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpID09PSA0MCkge1xuICAgICAgICAgIHN0YXRlLnN0b3AgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGF0ZS5vcHRpb25hbENoYWluTWVtYmVyID0gb3B0aW9uYWwgPSB0cnVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIGlmICghbm9DYWxscyAmJiB0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VDb3ZlckNhbGxBbmRBc3luY0Fycm93SGVhZChiYXNlLCBzdGFydExvYywgc3RhdGUsIG9wdGlvbmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29tcHV0ZWQgPSB0aGlzLmVhdCgwKTtcbiAgICAgIGlmIChjb21wdXRlZCB8fCBvcHRpb25hbCB8fCB0aGlzLmVhdCgxNikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VNZW1iZXIoYmFzZSwgc3RhcnRMb2MsIHN0YXRlLCBjb21wdXRlZCwgb3B0aW9uYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuc3RvcCA9IHRydWU7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXJzZU1lbWJlcihiYXNlLCBzdGFydExvYywgc3RhdGUsIGNvbXB1dGVkLCBvcHRpb25hbCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICBub2RlLm9iamVjdCA9IGJhc2U7XG4gICAgbm9kZS5jb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goMTM5KSkge1xuICAgICAgaWYgKGJhc2UudHlwZSA9PT0gXCJTdXBlclwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlN1cGVyUHJpdmF0ZUZpZWxkLCBzdGFydExvYyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNsYXNzU2NvcGUudXNlUHJpdmF0ZU5hbWUodGhpcy5zdGF0ZS52YWx1ZSwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZVByaXZhdGVOYW1lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLm9wdGlvbmFsQ2hhaW5NZW1iZXIpIHtcbiAgICAgIG5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgfVxuICBwYXJzZUJpbmQoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMsIHN0YXRlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgIG5vZGUub2JqZWN0ID0gYmFzZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmNhbGxlZSA9IHRoaXMucGFyc2VOb0NhbGxFeHByKCk7XG4gICAgc3RhdGUuc3RvcCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdWJzY3JpcHRzKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkJpbmRFeHByZXNzaW9uXCIpLCBzdGFydExvYywgbm9DYWxscyk7XG4gIH1cbiAgcGFyc2VDb3ZlckNhbGxBbmRBc3luY0Fycm93SGVhZChiYXNlLCBzdGFydExvYywgc3RhdGUsIG9wdGlvbmFsKSB7XG4gICAgY29uc3Qgb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycyA9IHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICBsZXQgcmVmRXhwcmVzc2lvbkVycm9ycyA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gdHJ1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgbm9kZS5jYWxsZWUgPSBiYXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIG1heWJlQXN5bmNBcnJvdyxcbiAgICAgIG9wdGlvbmFsQ2hhaW5NZW1iZXJcbiAgICB9ID0gc3RhdGU7XG4gICAgaWYgKG1heWJlQXN5bmNBcnJvdykge1xuICAgICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZW50ZXIobmV3QXN5bmNBcnJvd1Njb3BlKCkpO1xuICAgICAgcmVmRXhwcmVzc2lvbkVycm9ycyA9IG5ldyBFeHByZXNzaW9uRXJyb3JzKCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25hbENoYWluTWVtYmVyKSB7XG4gICAgICBub2RlLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgfVxuICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgbm9kZS5hcmd1bWVudHMgPSB0aGlzLnBhcnNlQ2FsbEV4cHJlc3Npb25Bcmd1bWVudHMoMTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmFyZ3VtZW50cyA9IHRoaXMucGFyc2VDYWxsRXhwcmVzc2lvbkFyZ3VtZW50cygxMSwgYmFzZS50eXBlICE9PSBcIlN1cGVyXCIsIG5vZGUsIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIH1cbiAgICBsZXQgZmluaXNoZWROb2RlID0gdGhpcy5maW5pc2hDYWxsRXhwcmVzc2lvbihub2RlLCBvcHRpb25hbENoYWluTWVtYmVyKTtcbiAgICBpZiAobWF5YmVBc3luY0Fycm93ICYmIHRoaXMuc2hvdWxkUGFyc2VBc3luY0Fycm93KCkgJiYgIW9wdGlvbmFsKSB7XG4gICAgICBzdGF0ZS5zdG9wID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2hlY2tEZXN0cnVjdHVyaW5nUHJpdmF0ZShyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLnZhbGlkYXRlQXNQYXR0ZXJuKCk7XG4gICAgICB0aGlzLmV4cHJlc3Npb25TY29wZS5leGl0KCk7XG4gICAgICBmaW5pc2hlZE5vZGUgPSB0aGlzLnBhcnNlQXN5bmNBcnJvd0Zyb21DYWxsRXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKSwgZmluaXNoZWROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG1heWJlQXN5bmNBcnJvdykge1xuICAgICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZFeHByZXNzaW9uRXJyb3JzLCB0cnVlKTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZXhpdCgpO1xuICAgICAgfVxuICAgICAgdGhpcy50b1JlZmVyZW5jZWRBcmd1bWVudHMoZmluaXNoZWROb2RlKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICByZXR1cm4gZmluaXNoZWROb2RlO1xuICB9XG4gIHRvUmVmZXJlbmNlZEFyZ3VtZW50cyhub2RlLCBpc1BhcmVudGhlc2l6ZWRFeHByKSB7XG4gICAgdGhpcy50b1JlZmVyZW5jZWRMaXN0RGVlcChub2RlLmFyZ3VtZW50cywgaXNQYXJlbnRoZXNpemVkRXhwcik7XG4gIH1cbiAgcGFyc2VUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oYmFzZSwgc3RhcnRMb2MsIHN0YXRlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgIG5vZGUudGFnID0gYmFzZTtcbiAgICBub2RlLnF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlKHRydWUpO1xuICAgIGlmIChzdGF0ZS5vcHRpb25hbENoYWluTWVtYmVyKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5PcHRpb25hbENoYWluaW5nTm9UZW1wbGF0ZSwgc3RhcnRMb2MpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIpO1xuICB9XG4gIGF0UG9zc2libGVBc3luY0Fycm93KGJhc2UpIHtcbiAgICByZXR1cm4gYmFzZS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBiYXNlLm5hbWUgPT09IFwiYXN5bmNcIiAmJiB0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MuaW5kZXggPT09IGJhc2UuZW5kICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIGJhc2UuZW5kIC0gYmFzZS5zdGFydCA9PT0gNSAmJiB0aGlzLm9mZnNldFRvU291cmNlUG9zKGJhc2Uuc3RhcnQpID09PSB0aGlzLnN0YXRlLnBvdGVudGlhbEFycm93QXQ7XG4gIH1cbiAgZmluaXNoQ2FsbEV4cHJlc3Npb24obm9kZSwgb3B0aW9uYWwpIHtcbiAgICBpZiAobm9kZS5jYWxsZWUudHlwZSA9PT0gXCJJbXBvcnRcIikge1xuICAgICAgaWYgKG5vZGUuYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCBub2RlLmFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydENhbGxBcml0eSwgbm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGFyZyBvZiBub2RlLmFyZ3VtZW50cykge1xuICAgICAgICAgIGlmIChhcmcudHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydENhbGxTcHJlYWRBcmd1bWVudCwgYXJnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBvcHRpb25hbCA/IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiIDogXCJDYWxsRXhwcmVzc2lvblwiKTtcbiAgfVxuICBwYXJzZUNhbGxFeHByZXNzaW9uQXJndW1lbnRzKGNsb3NlLCBhbGxvd1BsYWNlaG9sZGVyLCBub2RlRm9yRXh0cmEsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBjb25zdCBlbHRzID0gW107XG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICBjb25zdCBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IGZhbHNlO1xuICAgIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KDEyKTtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2goY2xvc2UpKSB7XG4gICAgICAgICAgaWYgKG5vZGVGb3JFeHRyYSkge1xuICAgICAgICAgICAgdGhpcy5hZGRUcmFpbGluZ0NvbW1hRXh0cmFUb05vZGUobm9kZUZvckV4dHJhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsdHMucHVzaCh0aGlzLnBhcnNlRXhwckxpc3RJdGVtKGZhbHNlLCByZWZFeHByZXNzaW9uRXJyb3JzLCBhbGxvd1BsYWNlaG9sZGVyKSk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keTtcbiAgICByZXR1cm4gZWx0cztcbiAgfVxuICBzaG91bGRQYXJzZUFzeW5jQXJyb3coKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMTkpICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpO1xuICB9XG4gIHBhcnNlQXN5bmNBcnJvd0Zyb21DYWxsRXhwcmVzc2lvbihub2RlLCBjYWxsKSB7XG4gICAgdmFyIF9jYWxsJGV4dHJhO1xuICAgIHRoaXMucmVzZXRQcmV2aW91c05vZGVUcmFpbGluZ0NvbW1lbnRzKGNhbGwpO1xuICAgIHRoaXMuZXhwZWN0KDE5KTtcbiAgICB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKG5vZGUsIGNhbGwuYXJndW1lbnRzLCB0cnVlLCAoX2NhbGwkZXh0cmEgPSBjYWxsLmV4dHJhKSA9PSBudWxsID8gdm9pZCAwIDogX2NhbGwkZXh0cmEudHJhaWxpbmdDb21tYUxvYyk7XG4gICAgaWYgKGNhbGwuaW5uZXJDb21tZW50cykge1xuICAgICAgc2V0SW5uZXJDb21tZW50cyhub2RlLCBjYWxsLmlubmVyQ29tbWVudHMpO1xuICAgIH1cbiAgICBpZiAoY2FsbC5jYWxsZWUudHJhaWxpbmdDb21tZW50cykge1xuICAgICAgc2V0SW5uZXJDb21tZW50cyhub2RlLCBjYWxsLmNhbGxlZS50cmFpbGluZ0NvbW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcGFyc2VOb0NhbGxFeHByKCkge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICByZXR1cm4gdGhpcy5wYXJzZVN1YnNjcmlwdHModGhpcy5wYXJzZUV4cHJBdG9tKCksIHN0YXJ0TG9jLCB0cnVlKTtcbiAgfVxuICBwYXJzZUV4cHJBdG9tKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBsZXQgbm9kZTtcbiAgICBsZXQgZGVjb3JhdG9ycyA9IG51bGw7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSA3OTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTdXBlcigpO1xuICAgICAgY2FzZSA4MzpcbiAgICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAodGhpcy5tYXRjaCgxNikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUltcG9ydE1ldGFQcm9wZXJ0eShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25GbGFncyAmIDUxMikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJbXBvcnRDYWxsKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbnN1cHBvcnRlZEltcG9ydCwgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRcIik7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgNzg6XG4gICAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRoaXNFeHByZXNzaW9uXCIpO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRG8odGhpcy5zdGFydE5vZGUoKSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDU2OlxuICAgICAgY2FzZSAzMTpcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMucmVhZFJlZ2V4cCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlUmVnRXhwTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAxMzU6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTnVtZXJpY0xpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSk7XG4gICAgICBjYXNlIDEzNjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCaWdJbnRMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgY2FzZSAxMzQ6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICAgIGNhc2UgODQ6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTnVsbExpdGVyYWwoKTtcbiAgICAgIGNhc2UgODU6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQm9vbGVhbkxpdGVyYWwodHJ1ZSk7XG4gICAgICBjYXNlIDg2OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJvb2xlYW5MaXRlcmFsKGZhbHNlKTtcbiAgICAgIGNhc2UgMTA6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBjYW5CZUFycm93ID0gdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0ID09PSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24oY2FuQmVBcnJvdyk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMjpcbiAgICAgIGNhc2UgMTpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyYXlMaWtlKHRoaXMuc3RhdGUudHlwZSA9PT0gMiA/IDQgOiAzLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyYXlMaWtlKDMsIHRydWUsIGZhbHNlLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSA2OlxuICAgICAgY2FzZSA3OlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmplY3RMaWtlKHRoaXMuc3RhdGUudHlwZSA9PT0gNiA/IDkgOiA4LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgNTpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqZWN0TGlrZSg4LCBmYWxzZSwgZmFsc2UsIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDY4OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uT3JGdW5jdGlvblNlbnQoKTtcbiAgICAgIGNhc2UgMjY6XG4gICAgICAgIGRlY29yYXRvcnMgPSB0aGlzLnBhcnNlRGVjb3JhdG9ycygpO1xuICAgICAgY2FzZSA4MDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyh0aGlzLm1heWJlVGFrZURlY29yYXRvcnMoZGVjb3JhdG9ycywgdGhpcy5zdGFydE5vZGUoKSksIGZhbHNlKTtcbiAgICAgIGNhc2UgNzc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTmV3T3JOZXdUYXJnZXQoKTtcbiAgICAgIGNhc2UgMjU6XG4gICAgICBjYXNlIDI0OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRlbXBsYXRlKGZhbHNlKTtcbiAgICAgIGNhc2UgMTU6XG4gICAgICAgIHtcbiAgICAgICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBub2RlLm9iamVjdCA9IG51bGw7XG4gICAgICAgICAgY29uc3QgY2FsbGVlID0gbm9kZS5jYWxsZWUgPSB0aGlzLnBhcnNlTm9DYWxsRXhwcigpO1xuICAgICAgICAgIGlmIChjYWxsZWUudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCaW5kRXhwcmVzc2lvblwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW5zdXBwb3J0ZWRCaW5kLCBjYWxsZWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgY2FzZSAxMzk6XG4gICAgICAgIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Qcml2YXRlSW5FeHBlY3RlZEluLCB0aGlzLnN0YXRlLnN0YXJ0TG9jLCB7XG4gICAgICAgICAgICBpZGVudGlmaWVyTmFtZTogdGhpcy5zdGF0ZS52YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlUHJpdmF0ZU5hbWUoKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAzMzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVG9waWNSZWZlcmVuY2VUaGVuRXF1YWxzU2lnbig1NCwgXCIlXCIpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDMyOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUb3BpY1JlZmVyZW5jZVRoZW5FcXVhbHNTaWduKDQ0LCBcIl5cIik7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMzc6XG4gICAgICBjYXNlIDM4OlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUb3BpY1JlZmVyZW5jZShcImhhY2tcIik7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgNDQ6XG4gICAgICBjYXNlIDU0OlxuICAgICAgY2FzZSAyNzpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHBpcGVQcm9wb3NhbCA9IHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwicGlwZWxpbmVPcGVyYXRvclwiLCBcInByb3Bvc2FsXCIpO1xuICAgICAgICAgIGlmIChwaXBlUHJvcG9zYWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVG9waWNSZWZlcmVuY2UocGlwZVByb3Bvc2FsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgNDc6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsb29rYWhlYWRDaCA9IHRoaXMuaW5wdXQuY29kZVBvaW50QXQodGhpcy5uZXh0VG9rZW5TdGFydCgpKTtcbiAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQobG9va2FoZWFkQ2gpIHx8IGxvb2thaGVhZENoID09PSA2Mikge1xuICAgICAgICAgICAgdGhpcy5leHBlY3RPbmVQbHVnaW4oW1wianN4XCIsIFwiZmxvd1wiLCBcInR5cGVzY3JpcHRcIl0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0eXBlID09PSAxMzcpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZURlY2ltYWxMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbklzSWRlbnRpZmllcih0eXBlKSkge1xuICAgICAgICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMjcpICYmIHRoaXMubG9va2FoZWFkSW5MaW5lQ2hhckNvZGUoKSA9PT0gMTIzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU1vZHVsZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY2FuQmVBcnJvdyA9IHRoaXMuc3RhdGUucG90ZW50aWFsQXJyb3dBdCA9PT0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICAgICAgICBjb25zdCBjb250YWluc0VzYyA9IHRoaXMuc3RhdGUuY29udGFpbnNFc2M7XG4gICAgICAgICAgY29uc3QgaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgICAgIGlmICghY29udGFpbnNFc2MgJiYgaWQubmFtZSA9PT0gXCJhc3luY1wiICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IDY4KSB7XG4gICAgICAgICAgICAgIHRoaXMucmVzZXRQcmV2aW91c05vZGVUcmFpbGluZ0NvbW1lbnRzKGlkKTtcbiAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXN5bmNGdW5jdGlvbkV4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdE5vZGUoaWQpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5Jc0lkZW50aWZpZXIodHlwZSkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gNjEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFzeW5jQXJyb3dVbmFyeUZ1bmN0aW9uKHRoaXMuc3RhcnROb2RlQXROb2RlKGlkKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDkwKSB7XG4gICAgICAgICAgICAgIHRoaXMucmVzZXRQcmV2aW91c05vZGVUcmFpbGluZ0NvbW1lbnRzKGlkKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VEbyh0aGlzLnN0YXJ0Tm9kZUF0Tm9kZShpZCksIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FuQmVBcnJvdyAmJiB0aGlzLm1hdGNoKDE5KSAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0Tm9kZShpZCksIFtpZF0sIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIHBhcnNlVG9waWNSZWZlcmVuY2VUaGVuRXF1YWxzU2lnbih0b3BpY1Rva2VuVHlwZSwgdG9waWNUb2tlblZhbHVlKSB7XG4gICAgY29uc3QgcGlwZVByb3Bvc2FsID0gdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJwaXBlbGluZU9wZXJhdG9yXCIsIFwicHJvcG9zYWxcIik7XG4gICAgaWYgKHBpcGVQcm9wb3NhbCkge1xuICAgICAgdGhpcy5zdGF0ZS50eXBlID0gdG9waWNUb2tlblR5cGU7XG4gICAgICB0aGlzLnN0YXRlLnZhbHVlID0gdG9waWNUb2tlblZhbHVlO1xuICAgICAgdGhpcy5zdGF0ZS5wb3MtLTtcbiAgICAgIHRoaXMuc3RhdGUuZW5kLS07XG4gICAgICB0aGlzLnN0YXRlLmVuZExvYyA9IGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldCh0aGlzLnN0YXRlLmVuZExvYywgLTEpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VUb3BpY1JlZmVyZW5jZShwaXBlUHJvcG9zYWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VUb3BpY1JlZmVyZW5jZShwaXBlUHJvcG9zYWwpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgdG9rZW5UeXBlID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRvcGljUmVmZXJlbmNlKG5vZGUsIHN0YXJ0TG9jLCBwaXBlUHJvcG9zYWwsIHRva2VuVHlwZSk7XG4gIH1cbiAgZmluaXNoVG9waWNSZWZlcmVuY2Uobm9kZSwgc3RhcnRMb2MsIHBpcGVQcm9wb3NhbCwgdG9rZW5UeXBlKSB7XG4gICAgaWYgKHRoaXMudGVzdFRvcGljUmVmZXJlbmNlQ29uZmlndXJhdGlvbihwaXBlUHJvcG9zYWwsIHN0YXJ0TG9jLCB0b2tlblR5cGUpKSB7XG4gICAgICBpZiAocGlwZVByb3Bvc2FsID09PSBcImhhY2tcIikge1xuICAgICAgICBpZiAoIXRoaXMudG9waWNSZWZlcmVuY2VJc0FsbG93ZWRJbkN1cnJlbnRDb250ZXh0KCkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5QaXBlVG9waWNVbmJvdW5kLCBzdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWdpc3RlclRvcGljUmVmZXJlbmNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUb3BpY1JlZmVyZW5jZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy50b3BpY1JlZmVyZW5jZUlzQWxsb3dlZEluQ3VycmVudENvbnRleHQoKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlByaW1hcnlUb3BpY05vdEFsbG93ZWQsIHN0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZ2lzdGVyVG9waWNSZWZlcmVuY2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5QaXBlVG9waWNVbmNvbmZpZ3VyZWRUb2tlbiwgc3RhcnRMb2MsIHtcbiAgICAgICAgdG9rZW46IHRva2VuTGFiZWxOYW1lKHRva2VuVHlwZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICB0ZXN0VG9waWNSZWZlcmVuY2VDb25maWd1cmF0aW9uKHBpcGVQcm9wb3NhbCwgc3RhcnRMb2MsIHRva2VuVHlwZSkge1xuICAgIHN3aXRjaCAocGlwZVByb3Bvc2FsKSB7XG4gICAgICBjYXNlIFwiaGFja1wiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFzUGx1Z2luKFtcInBpcGVsaW5lT3BlcmF0b3JcIiwge1xuICAgICAgICAgICAgdG9waWNUb2tlbjogdG9rZW5MYWJlbE5hbWUodG9rZW5UeXBlKVxuICAgICAgICAgIH1dKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcInNtYXJ0XCI6XG4gICAgICAgIHJldHVybiB0b2tlblR5cGUgPT09IDI3O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuUGlwZVRvcGljUmVxdWlyZXNIYWNrUGlwZXMsIHN0YXJ0TG9jKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VBc3luY0Fycm93VW5hcnlGdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoZnVuY3Rpb25GbGFncyh0cnVlLCB0aGlzLnByb2RQYXJhbS5oYXNZaWVsZCkpO1xuICAgIGNvbnN0IHBhcmFtcyA9IFt0aGlzLnBhcnNlSWRlbnRpZmllcigpXTtcbiAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgaWYgKHRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkxpbmVUZXJtaW5hdG9yQmVmb3JlQXJyb3csIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDE5KTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbihub2RlLCBwYXJhbXMsIHRydWUpO1xuICB9XG4gIHBhcnNlRG8obm9kZSwgaXNBc3luYykge1xuICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiZG9FeHByZXNzaW9uc1wiKTtcbiAgICBpZiAoaXNBc3luYykge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJhc3luY0RvRXhwcmVzc2lvbnNcIik7XG4gICAgfVxuICAgIG5vZGUuYXN5bmMgPSBpc0FzeW5jO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGNvbnN0IG9sZExhYmVscyA9IHRoaXMuc3RhdGUubGFiZWxzO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzID0gW107XG4gICAgaWYgKGlzQXN5bmMpIHtcbiAgICAgIHRoaXMucHJvZFBhcmFtLmVudGVyKDIpO1xuICAgICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VCbG9jaygpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLmxhYmVscyA9IG9sZExhYmVscztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRG9FeHByZXNzaW9uXCIpO1xuICB9XG4gIHBhcnNlU3VwZXIoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMubWF0Y2goMTApICYmICF0aGlzLnNjb3BlLmFsbG93RGlyZWN0U3VwZXIgJiYgISh0aGlzLm9wdGlvbkZsYWdzICYgMTYpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5TdXBlck5vdEFsbG93ZWQsIG5vZGUpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuc2NvcGUuYWxsb3dTdXBlciAmJiAhKHRoaXMub3B0aW9uRmxhZ3MgJiAxNikpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRTdXBlciwgbm9kZSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5tYXRjaCgxMCkgJiYgIXRoaXMubWF0Y2goMCkgJiYgIXRoaXMubWF0Y2goMTYpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbnN1cHBvcnRlZFN1cGVyLCBub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN1cGVyXCIpO1xuICB9XG4gIHBhcnNlUHJpdmF0ZU5hbWUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgaWQgPSB0aGlzLnN0YXJ0Tm9kZUF0KGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldCh0aGlzLnN0YXRlLnN0YXJ0TG9jLCAxKSk7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5pZCA9IHRoaXMuY3JlYXRlSWRlbnRpZmllcihpZCwgbmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlByaXZhdGVOYW1lXCIpO1xuICB9XG4gIHBhcnNlRnVuY3Rpb25PckZ1bmN0aW9uU2VudCgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5wcm9kUGFyYW0uaGFzWWllbGQgJiYgdGhpcy5tYXRjaCgxNikpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmNyZWF0ZUlkZW50aWZpZXIodGhpcy5zdGFydE5vZGVBdE5vZGUobm9kZSksIFwiZnVuY3Rpb25cIik7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDEwMykpIHtcbiAgICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJmdW5jdGlvblNlbnRcIik7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLmhhc1BsdWdpbihcImZ1bmN0aW9uU2VudFwiKSkge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlTWV0YVByb3BlcnR5KG5vZGUsIG1ldGEsIFwic2VudFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlKTtcbiAgfVxuICBwYXJzZU1ldGFQcm9wZXJ0eShub2RlLCBtZXRhLCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBub2RlLm1ldGEgPSBtZXRhO1xuICAgIGNvbnN0IGNvbnRhaW5zRXNjID0gdGhpcy5zdGF0ZS5jb250YWluc0VzYztcbiAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgaWYgKG5vZGUucHJvcGVydHkubmFtZSAhPT0gcHJvcGVydHlOYW1lIHx8IGNvbnRhaW5zRXNjKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbnN1cHBvcnRlZE1ldGFQcm9wZXJ0eSwgbm9kZS5wcm9wZXJ0eSwge1xuICAgICAgICB0YXJnZXQ6IG1ldGEubmFtZSxcbiAgICAgICAgb25seVZhbGlkUHJvcGVydHlOYW1lOiBwcm9wZXJ0eU5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWV0YVByb3BlcnR5XCIpO1xuICB9XG4gIHBhcnNlSW1wb3J0TWV0YVByb3BlcnR5KG5vZGUpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuY3JlYXRlSWRlbnRpZmllcih0aGlzLnN0YXJ0Tm9kZUF0Tm9kZShub2RlKSwgXCJpbXBvcnRcIik7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEwMSkpIHtcbiAgICAgIGlmICghdGhpcy5pbk1vZHVsZSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbXBvcnRNZXRhT3V0c2lkZU1vZHVsZSwgaWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5zYXdVbmFtYmlndW91c0VTTSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMDUpIHx8IHRoaXMuaXNDb250ZXh0dWFsKDk3KSkge1xuICAgICAgY29uc3QgaXNTb3VyY2UgPSB0aGlzLmlzQ29udGV4dHVhbCgxMDUpO1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oaXNTb3VyY2UgPyBcInNvdXJjZVBoYXNlSW1wb3J0c1wiIDogXCJkZWZlcnJlZEltcG9ydEV2YWx1YXRpb25cIik7XG4gICAgICBpZiAoISh0aGlzLm9wdGlvbkZsYWdzICYgNTEyKSkge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5EeW5hbWljSW1wb3J0UGhhc2VSZXF1aXJlc0ltcG9ydEV4cHJlc3Npb25zLCB0aGlzLnN0YXRlLnN0YXJ0TG9jLCB7XG4gICAgICAgICAgcGhhc2U6IHRoaXMuc3RhdGUudmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUucGhhc2UgPSBpc1NvdXJjZSA/IFwic291cmNlXCIgOiBcImRlZmVyXCI7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUltcG9ydENhbGwobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlTWV0YVByb3BlcnR5KG5vZGUsIGlkLCBcIm1ldGFcIik7XG4gIH1cbiAgcGFyc2VMaXRlcmFsQXROb2RlKHZhbHVlLCB0eXBlLCBub2RlKSB7XG4gICAgdGhpcy5hZGRFeHRyYShub2RlLCBcInJhd1ZhbHVlXCIsIHZhbHVlKTtcbiAgICB0aGlzLmFkZEV4dHJhKG5vZGUsIFwicmF3XCIsIHRoaXMuaW5wdXQuc2xpY2UodGhpcy5vZmZzZXRUb1NvdXJjZVBvcyhub2RlLnN0YXJ0KSwgdGhpcy5zdGF0ZS5lbmQpKTtcbiAgICBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCB0eXBlKTtcbiAgfVxuICBwYXJzZUxpdGVyYWwodmFsdWUsIHR5cGUpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWxBdE5vZGUodmFsdWUsIHR5cGUsIG5vZGUpO1xuICB9XG4gIHBhcnNlU3RyaW5nTGl0ZXJhbCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh2YWx1ZSwgXCJTdHJpbmdMaXRlcmFsXCIpO1xuICB9XG4gIHBhcnNlTnVtZXJpY0xpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUsIFwiTnVtZXJpY0xpdGVyYWxcIik7XG4gIH1cbiAgcGFyc2VCaWdJbnRMaXRlcmFsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHZhbHVlLCBcIkJpZ0ludExpdGVyYWxcIik7XG4gIH1cbiAgcGFyc2VEZWNpbWFsTGl0ZXJhbCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh2YWx1ZSwgXCJEZWNpbWFsTGl0ZXJhbFwiKTtcbiAgfVxuICBwYXJzZVJlZ0V4cExpdGVyYWwodmFsdWUpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmFkZEV4dHJhKG5vZGUsIFwicmF3XCIsIHRoaXMuaW5wdXQuc2xpY2UodGhpcy5vZmZzZXRUb1NvdXJjZVBvcyhub2RlLnN0YXJ0KSwgdGhpcy5zdGF0ZS5lbmQpKTtcbiAgICBub2RlLnBhdHRlcm4gPSB2YWx1ZS5wYXR0ZXJuO1xuICAgIG5vZGUuZmxhZ3MgPSB2YWx1ZS5mbGFncztcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmVnRXhwTGl0ZXJhbFwiKTtcbiAgfVxuICBwYXJzZUJvb2xlYW5MaXRlcmFsKHZhbHVlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCb29sZWFuTGl0ZXJhbFwiKTtcbiAgfVxuICBwYXJzZU51bGxMaXRlcmFsKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJOdWxsTGl0ZXJhbFwiKTtcbiAgfVxuICBwYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uKGNhbkJlQXJyb3cpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgbGV0IHZhbDtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmV4cHJlc3Npb25TY29wZS5lbnRlcihuZXdBcnJvd0hlYWRTY29wZSgpKTtcbiAgICBjb25zdCBvbGRNYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzO1xuICAgIGNvbnN0IG9sZEluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5ID0gdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keTtcbiAgICB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSB0cnVlO1xuICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSBmYWxzZTtcbiAgICBjb25zdCBpbm5lclN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBleHByTGlzdCA9IFtdO1xuICAgIGNvbnN0IHJlZkV4cHJlc3Npb25FcnJvcnMgPSBuZXcgRXhwcmVzc2lvbkVycm9ycygpO1xuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgbGV0IHNwcmVhZFN0YXJ0TG9jO1xuICAgIGxldCBvcHRpb25hbENvbW1hU3RhcnRMb2M7XG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKDExKSkge1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMiwgcmVmRXhwcmVzc2lvbkVycm9ycy5vcHRpb25hbFBhcmFtZXRlcnNMb2MgPT09IG51bGwgPyBudWxsIDogcmVmRXhwcmVzc2lvbkVycm9ycy5vcHRpb25hbFBhcmFtZXRlcnNMb2MpO1xuICAgICAgICBpZiAodGhpcy5tYXRjaCgxMSkpIHtcbiAgICAgICAgICBvcHRpb25hbENvbW1hU3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tYXRjaCgyMSkpIHtcbiAgICAgICAgY29uc3Qgc3ByZWFkTm9kZVN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgICAgc3ByZWFkU3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgICAgICBleHByTGlzdC5wdXNoKHRoaXMucGFyc2VQYXJlbkl0ZW0odGhpcy5wYXJzZVJlc3RCaW5kaW5nKCksIHNwcmVhZE5vZGVTdGFydExvYykpO1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tDb21tYUFmdGVyUmVzdCg0MSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKHJlZkV4cHJlc3Npb25FcnJvcnMsIHRoaXMucGFyc2VQYXJlbkl0ZW0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW5uZXJFbmRMb2MgPSB0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2M7XG4gICAgdGhpcy5leHBlY3QoMTEpO1xuICAgIHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycyA9IG9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnM7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IG9sZEluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgIGxldCBhcnJvd05vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICBpZiAoY2FuQmVBcnJvdyAmJiB0aGlzLnNob3VsZFBhcnNlQXJyb3coZXhwckxpc3QpICYmIChhcnJvd05vZGUgPSB0aGlzLnBhcnNlQXJyb3coYXJyb3dOb2RlKSkpIHtcbiAgICAgIHRoaXMuY2hlY2tEZXN0cnVjdHVyaW5nUHJpdmF0ZShyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLnZhbGlkYXRlQXNQYXR0ZXJuKCk7XG4gICAgICB0aGlzLmV4cHJlc3Npb25TY29wZS5leGl0KCk7XG4gICAgICB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKGFycm93Tm9kZSwgZXhwckxpc3QsIGZhbHNlKTtcbiAgICAgIHJldHVybiBhcnJvd05vZGU7XG4gICAgfVxuICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLmV4aXQoKTtcbiAgICBpZiAoIWV4cHJMaXN0Lmxlbmd0aCkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbmFsQ29tbWFTdGFydExvYykgdGhpcy51bmV4cGVjdGVkKG9wdGlvbmFsQ29tbWFTdGFydExvYyk7XG4gICAgaWYgKHNwcmVhZFN0YXJ0TG9jKSB0aGlzLnVuZXhwZWN0ZWQoc3ByZWFkU3RhcnRMb2MpO1xuICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkV4cHJlc3Npb25FcnJvcnMsIHRydWUpO1xuICAgIHRoaXMudG9SZWZlcmVuY2VkTGlzdERlZXAoZXhwckxpc3QsIHRydWUpO1xuICAgIGlmIChleHByTGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICB2YWwgPSB0aGlzLnN0YXJ0Tm9kZUF0KGlubmVyU3RhcnRMb2MpO1xuICAgICAgdmFsLmV4cHJlc3Npb25zID0gZXhwckxpc3Q7XG4gICAgICB0aGlzLmZpbmlzaE5vZGUodmFsLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKTtcbiAgICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbih2YWwsIGlubmVyRW5kTG9jKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gZXhwckxpc3RbMF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndyYXBQYXJlbnRoZXNpcyhzdGFydExvYywgdmFsKTtcbiAgfVxuICB3cmFwUGFyZW50aGVzaXMoc3RhcnRMb2MsIGV4cHJlc3Npb24pIHtcbiAgICBpZiAoISh0aGlzLm9wdGlvbkZsYWdzICYgMTAyNCkpIHtcbiAgICAgIHRoaXMuYWRkRXh0cmEoZXhwcmVzc2lvbiwgXCJwYXJlbnRoZXNpemVkXCIsIHRydWUpO1xuICAgICAgdGhpcy5hZGRFeHRyYShleHByZXNzaW9uLCBcInBhcmVuU3RhcnRcIiwgc3RhcnRMb2MuaW5kZXgpO1xuICAgICAgdGhpcy50YWtlU3Vycm91bmRpbmdDb21tZW50cyhleHByZXNzaW9uLCBzdGFydExvYy5pbmRleCwgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jLmluZGV4KTtcbiAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbkV4cHJlc3Npb24gPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICBwYXJlbkV4cHJlc3Npb24uZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwYXJlbkV4cHJlc3Npb24sIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIik7XG4gIH1cbiAgc2hvdWxkUGFyc2VBcnJvdyhwYXJhbXMpIHtcbiAgICByZXR1cm4gIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCk7XG4gIH1cbiAgcGFyc2VBcnJvdyhub2RlKSB7XG4gICAgaWYgKHRoaXMuZWF0KDE5KSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG4gIHBhcnNlUGFyZW5JdGVtKG5vZGUsIHN0YXJ0TG9jKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcGFyc2VOZXdPck5ld1RhcmdldCgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5tYXRjaCgxNikpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmNyZWF0ZUlkZW50aWZpZXIodGhpcy5zdGFydE5vZGVBdE5vZGUobm9kZSksIFwibmV3XCIpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBjb25zdCBtZXRhUHJvcCA9IHRoaXMucGFyc2VNZXRhUHJvcGVydHkobm9kZSwgbWV0YSwgXCJ0YXJnZXRcIik7XG4gICAgICBpZiAoIXRoaXMuc2NvcGUuaW5Ob25BcnJvd0Z1bmN0aW9uICYmICF0aGlzLnNjb3BlLmluQ2xhc3MgJiYgISh0aGlzLm9wdGlvbkZsYWdzICYgNCkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZE5ld1RhcmdldCwgbWV0YVByb3ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ldGFQcm9wO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZU5ldyhub2RlKTtcbiAgfVxuICBwYXJzZU5ldyhub2RlKSB7XG4gICAgdGhpcy5wYXJzZU5ld0NhbGxlZShub2RlKTtcbiAgICBpZiAodGhpcy5lYXQoMTApKSB7XG4gICAgICBjb25zdCBhcmdzID0gdGhpcy5wYXJzZUV4cHJMaXN0KDExKTtcbiAgICAgIHRoaXMudG9SZWZlcmVuY2VkTGlzdChhcmdzKTtcbiAgICAgIG5vZGUuYXJndW1lbnRzID0gYXJncztcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5hcmd1bWVudHMgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk5ld0V4cHJlc3Npb25cIik7XG4gIH1cbiAgcGFyc2VOZXdDYWxsZWUobm9kZSkge1xuICAgIGNvbnN0IGlzSW1wb3J0ID0gdGhpcy5tYXRjaCg4Myk7XG4gICAgY29uc3QgY2FsbGVlID0gdGhpcy5wYXJzZU5vQ2FsbEV4cHIoKTtcbiAgICBub2RlLmNhbGxlZSA9IGNhbGxlZTtcbiAgICBpZiAoaXNJbXBvcnQgJiYgKGNhbGxlZS50eXBlID09PSBcIkltcG9ydFwiIHx8IGNhbGxlZS50eXBlID09PSBcIkltcG9ydEV4cHJlc3Npb25cIikpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydENhbGxOb3ROZXdFeHByZXNzaW9uLCBjYWxsZWUpO1xuICAgIH1cbiAgfVxuICBwYXJzZVRlbXBsYXRlRWxlbWVudChpc1RhZ2dlZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0LFxuICAgICAgc3RhcnRMb2MsXG4gICAgICBlbmQsXG4gICAgICB2YWx1ZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGVsZW1TdGFydCA9IHN0YXJ0ICsgMTtcbiAgICBjb25zdCBlbGVtID0gdGhpcy5zdGFydE5vZGVBdChjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQoc3RhcnRMb2MsIDEpKTtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIGlmICghaXNUYWdnZWQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZEVzY2FwZVNlcXVlbmNlVGVtcGxhdGUsIGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldCh0aGlzLnN0YXRlLmZpcnN0SW52YWxpZFRlbXBsYXRlRXNjYXBlUG9zLCAxKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGlzVGFpbCA9IHRoaXMubWF0Y2goMjQpO1xuICAgIGNvbnN0IGVuZE9mZnNldCA9IGlzVGFpbCA/IC0xIDogLTI7XG4gICAgY29uc3QgZWxlbUVuZCA9IGVuZCArIGVuZE9mZnNldDtcbiAgICBlbGVtLnZhbHVlID0ge1xuICAgICAgcmF3OiB0aGlzLmlucHV0LnNsaWNlKGVsZW1TdGFydCwgZWxlbUVuZCkucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKSxcbiAgICAgIGNvb2tlZDogdmFsdWUgPT09IG51bGwgPyBudWxsIDogdmFsdWUuc2xpY2UoMSwgZW5kT2Zmc2V0KVxuICAgIH07XG4gICAgZWxlbS50YWlsID0gaXNUYWlsO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGNvbnN0IGZpbmlzaGVkTm9kZSA9IHRoaXMuZmluaXNoTm9kZShlbGVtLCBcIlRlbXBsYXRlRWxlbWVudFwiKTtcbiAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24oZmluaXNoZWROb2RlLCBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQodGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jLCBlbmRPZmZzZXQpKTtcbiAgICByZXR1cm4gZmluaXNoZWROb2RlO1xuICB9XG4gIHBhcnNlVGVtcGxhdGUoaXNUYWdnZWQpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBsZXQgY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudChpc1RhZ2dlZCk7XG4gICAgY29uc3QgcXVhc2lzID0gW2N1ckVsdF07XG4gICAgY29uc3Qgc3Vic3RpdHV0aW9ucyA9IFtdO1xuICAgIHdoaWxlICghY3VyRWx0LnRhaWwpIHtcbiAgICAgIHN1YnN0aXR1dGlvbnMucHVzaCh0aGlzLnBhcnNlVGVtcGxhdGVTdWJzdGl0dXRpb24oKSk7XG4gICAgICB0aGlzLnJlYWRUZW1wbGF0ZUNvbnRpbnVhdGlvbigpO1xuICAgICAgcXVhc2lzLnB1c2goY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudChpc1RhZ2dlZCkpO1xuICAgIH1cbiAgICBub2RlLmV4cHJlc3Npb25zID0gc3Vic3RpdHV0aW9ucztcbiAgICBub2RlLnF1YXNpcyA9IHF1YXNpcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGVtcGxhdGVMaXRlcmFsXCIpO1xuICB9XG4gIHBhcnNlVGVtcGxhdGVTdWJzdGl0dXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIH1cbiAgcGFyc2VPYmplY3RMaWtlKGNsb3NlLCBpc1BhdHRlcm4sIGlzUmVjb3JkLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKGlzUmVjb3JkKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpO1xuICAgIH1cbiAgICBjb25zdCBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IGZhbHNlO1xuICAgIGxldCBzYXdQcm90byA9IGZhbHNlO1xuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5wcm9wZXJ0aWVzID0gW107XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKGNsb3NlKSkge1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKGNsb3NlKSkge1xuICAgICAgICAgIHRoaXMuYWRkVHJhaWxpbmdDb21tYUV4dHJhVG9Ob2RlKG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgcHJvcDtcbiAgICAgIGlmIChpc1BhdHRlcm4pIHtcbiAgICAgICAgcHJvcCA9IHRoaXMucGFyc2VCaW5kaW5nUHJvcGVydHkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AgPSB0aGlzLnBhcnNlUHJvcGVydHlEZWZpbml0aW9uKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgICAgICBzYXdQcm90byA9IHRoaXMuY2hlY2tQcm90byhwcm9wLCBpc1JlY29yZCwgc2F3UHJvdG8sIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgICAgfVxuICAgICAgaWYgKGlzUmVjb3JkICYmICF0aGlzLmlzT2JqZWN0UHJvcGVydHkocHJvcCkgJiYgcHJvcC50eXBlICE9PSBcIlNwcmVhZEVsZW1lbnRcIikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkUmVjb3JkUHJvcGVydHksIHByb3ApO1xuICAgICAgfVxuICAgICAge1xuICAgICAgICBpZiAocHJvcC5zaG9ydGhhbmQpIHtcbiAgICAgICAgICB0aGlzLmFkZEV4dHJhKHByb3AsIFwic2hvcnRoYW5kXCIsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlLnByb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgICB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IG9sZEluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgIGxldCB0eXBlID0gXCJPYmplY3RFeHByZXNzaW9uXCI7XG4gICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgdHlwZSA9IFwiT2JqZWN0UGF0dGVyblwiO1xuICAgIH0gZWxzZSBpZiAoaXNSZWNvcmQpIHtcbiAgICAgIHR5cGUgPSBcIlJlY29yZEV4cHJlc3Npb25cIjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCB0eXBlKTtcbiAgfVxuICBhZGRUcmFpbGluZ0NvbW1hRXh0cmFUb05vZGUobm9kZSkge1xuICAgIHRoaXMuYWRkRXh0cmEobm9kZSwgXCJ0cmFpbGluZ0NvbW1hXCIsIHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jLmluZGV4KTtcbiAgICB0aGlzLmFkZEV4dHJhKG5vZGUsIFwidHJhaWxpbmdDb21tYUxvY1wiLCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYywgZmFsc2UpO1xuICB9XG4gIG1heWJlQXN5bmNPckFjY2Vzc29yUHJvcChwcm9wKSB7XG4gICAgcmV0dXJuICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmICh0aGlzLmlzTGl0ZXJhbFByb3BlcnR5TmFtZSgpIHx8IHRoaXMubWF0Y2goMCkgfHwgdGhpcy5tYXRjaCg1NSkpO1xuICB9XG4gIHBhcnNlUHJvcGVydHlEZWZpbml0aW9uKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBsZXQgZGVjb3JhdG9ycyA9IFtdO1xuICAgIGlmICh0aGlzLm1hdGNoKDI2KSkge1xuICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiZGVjb3JhdG9yc1wiKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbnN1cHBvcnRlZFByb3BlcnR5RGVjb3JhdG9yLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICh0aGlzLm1hdGNoKDI2KSkge1xuICAgICAgICBkZWNvcmF0b3JzLnB1c2godGhpcy5wYXJzZURlY29yYXRvcigpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHJvcCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbGV0IGlzQXN5bmMgPSBmYWxzZTtcbiAgICBsZXQgaXNBY2Nlc3NvciA9IGZhbHNlO1xuICAgIGxldCBzdGFydExvYztcbiAgICBpZiAodGhpcy5tYXRjaCgyMSkpIHtcbiAgICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCkgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVNwcmVhZCgpO1xuICAgIH1cbiAgICBpZiAoZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgIHByb3AuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnM7XG4gICAgICBkZWNvcmF0b3JzID0gW107XG4gICAgfVxuICAgIHByb3AubWV0aG9kID0gZmFsc2U7XG4gICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICB9XG4gICAgbGV0IGlzR2VuZXJhdG9yID0gdGhpcy5lYXQoNTUpO1xuICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWVQcmVmaXhPcGVyYXRvcihwcm9wKTtcbiAgICBjb25zdCBjb250YWluc0VzYyA9IHRoaXMuc3RhdGUuY29udGFpbnNFc2M7XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICBpZiAoIWlzR2VuZXJhdG9yICYmICFjb250YWluc0VzYyAmJiB0aGlzLm1heWJlQXN5bmNPckFjY2Vzc29yUHJvcChwcm9wKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBrZXlcbiAgICAgIH0gPSBwcm9wO1xuICAgICAgY29uc3Qga2V5TmFtZSA9IGtleS5uYW1lO1xuICAgICAgaWYgKGtleU5hbWUgPT09IFwiYXN5bmNcIiAmJiAhdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSkge1xuICAgICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXNldFByZXZpb3VzTm9kZVRyYWlsaW5nQ29tbWVudHMoa2V5KTtcbiAgICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCg1NSk7XG4gICAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgICB9XG4gICAgICBpZiAoa2V5TmFtZSA9PT0gXCJnZXRcIiB8fCBrZXlOYW1lID09PSBcInNldFwiKSB7XG4gICAgICAgIGlzQWNjZXNzb3IgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlc2V0UHJldmlvdXNOb2RlVHJhaWxpbmdDb21tZW50cyhrZXkpO1xuICAgICAgICBwcm9wLmtpbmQgPSBrZXlOYW1lO1xuICAgICAgICBpZiAodGhpcy5tYXRjaCg1NSkpIHtcbiAgICAgICAgICBpc0dlbmVyYXRvciA9IHRydWU7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQWNjZXNzb3JJc0dlbmVyYXRvciwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpLCB7XG4gICAgICAgICAgICBraW5kOiBrZXlOYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VPYmpQcm9wVmFsdWUocHJvcCwgc3RhcnRMb2MsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBmYWxzZSwgaXNBY2Nlc3NvciwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gIH1cbiAgZ2V0R2V0dGVyU2V0dGVyRXhwZWN0ZWRQYXJhbUNvdW50KG1ldGhvZCkge1xuICAgIHJldHVybiBtZXRob2Qua2luZCA9PT0gXCJnZXRcIiA/IDAgOiAxO1xuICB9XG4gIGdldE9iamVjdE9yQ2xhc3NNZXRob2RQYXJhbXMobWV0aG9kKSB7XG4gICAgcmV0dXJuIG1ldGhvZC5wYXJhbXM7XG4gIH1cbiAgY2hlY2tHZXR0ZXJTZXR0ZXJQYXJhbXMobWV0aG9kKSB7XG4gICAgdmFyIF9wYXJhbXM7XG4gICAgY29uc3QgcGFyYW1Db3VudCA9IHRoaXMuZ2V0R2V0dGVyU2V0dGVyRXhwZWN0ZWRQYXJhbUNvdW50KG1ldGhvZCk7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5nZXRPYmplY3RPckNsYXNzTWV0aG9kUGFyYW1zKG1ldGhvZCk7XG4gICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IHBhcmFtQ291bnQpIHtcbiAgICAgIHRoaXMucmFpc2UobWV0aG9kLmtpbmQgPT09IFwiZ2V0XCIgPyBFcnJvcnMuQmFkR2V0dGVyQXJpdHkgOiBFcnJvcnMuQmFkU2V0dGVyQXJpdHksIG1ldGhvZCk7XG4gICAgfVxuICAgIGlmIChtZXRob2Qua2luZCA9PT0gXCJzZXRcIiAmJiAoKF9wYXJhbXMgPSBwYXJhbXNbcGFyYW1zLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX3BhcmFtcy50eXBlKSA9PT0gXCJSZXN0RWxlbWVudFwiKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5CYWRTZXR0ZXJSZXN0UGFyYW1ldGVyLCBtZXRob2QpO1xuICAgIH1cbiAgfVxuICBwYXJzZU9iamVjdE1ldGhvZChwcm9wLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNQYXR0ZXJuLCBpc0FjY2Vzc29yKSB7XG4gICAgaWYgKGlzQWNjZXNzb3IpIHtcbiAgICAgIGNvbnN0IGZpbmlzaGVkUHJvcCA9IHRoaXMucGFyc2VNZXRob2QocHJvcCwgaXNHZW5lcmF0b3IsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIFwiT2JqZWN0TWV0aG9kXCIpO1xuICAgICAgdGhpcy5jaGVja0dldHRlclNldHRlclBhcmFtcyhmaW5pc2hlZFByb3ApO1xuICAgICAgcmV0dXJuIGZpbmlzaGVkUHJvcDtcbiAgICB9XG4gICAgaWYgKGlzQXN5bmMgfHwgaXNHZW5lcmF0b3IgfHwgdGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgIGlmIChpc1BhdHRlcm4pIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgcHJvcC5raW5kID0gXCJtZXRob2RcIjtcbiAgICAgIHByb3AubWV0aG9kID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlTWV0aG9kKHByb3AsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBmYWxzZSwgZmFsc2UsIFwiT2JqZWN0TWV0aG9kXCIpO1xuICAgIH1cbiAgfVxuICBwYXJzZU9iamVjdFByb3BlcnR5KHByb3AsIHN0YXJ0TG9jLCBpc1BhdHRlcm4sIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBwcm9wLnNob3J0aGFuZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmVhdCgxNCkpIHtcbiAgICAgIHByb3AudmFsdWUgPSBpc1BhdHRlcm4gPyB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMuc3RhdGUuc3RhcnRMb2MpIDogdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbihyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJPYmplY3RQcm9wZXJ0eVwiKTtcbiAgICB9XG4gICAgaWYgKCFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICB0aGlzLmNoZWNrUmVzZXJ2ZWRXb3JkKHByb3Aua2V5Lm5hbWUsIHByb3Aua2V5LmxvYy5zdGFydCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydExvYywgY2xvbmVJZGVudGlmaWVyKHByb3Aua2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goMjkpKSB7XG4gICAgICAgIGNvbnN0IHNob3J0aGFuZEFzc2lnbkxvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAocmVmRXhwcmVzc2lvbkVycm9ycy5zaG9ydGhhbmRBc3NpZ25Mb2MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlZkV4cHJlc3Npb25FcnJvcnMuc2hvcnRoYW5kQXNzaWduTG9jID0gc2hvcnRoYW5kQXNzaWduTG9jO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkQ292ZXJJbml0aWFsaXplZE5hbWUsIHNob3J0aGFuZEFzc2lnbkxvYyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQoc3RhcnRMb2MsIGNsb25lSWRlbnRpZmllcihwcm9wLmtleSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcC52YWx1ZSA9IGNsb25lSWRlbnRpZmllcihwcm9wLmtleSk7XG4gICAgICB9XG4gICAgICBwcm9wLnNob3J0aGFuZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiT2JqZWN0UHJvcGVydHlcIik7XG4gICAgfVxuICB9XG4gIHBhcnNlT2JqUHJvcFZhbHVlKHByb3AsIHN0YXJ0TG9jLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNQYXR0ZXJuLCBpc0FjY2Vzc29yLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMucGFyc2VPYmplY3RNZXRob2QocHJvcCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzUGF0dGVybiwgaXNBY2Nlc3NvcikgfHwgdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5KHByb3AsIHN0YXJ0TG9jLCBpc1BhdHRlcm4sIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIGlmICghbm9kZSkgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcGFyc2VQcm9wZXJ0eU5hbWUocHJvcCwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGlmICh0aGlzLmVhdCgwKSkge1xuICAgICAgcHJvcC5jb21wdXRlZCA9IHRydWU7XG4gICAgICBwcm9wLmtleSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4oKTtcbiAgICAgIHRoaXMuZXhwZWN0KDMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHZhbHVlXG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGxldCBrZXk7XG4gICAgICBpZiAodG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodHlwZSkpIHtcbiAgICAgICAga2V5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIDEzNTpcbiAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VOdW1lcmljTGl0ZXJhbCh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEzNDpcbiAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VTdHJpbmdMaXRlcmFsKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTM2OlxuICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZUJpZ0ludExpdGVyYWwodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMzk6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHByaXZhdGVLZXlMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgICAgICAgICAgICBpZiAocmVmRXhwcmVzc2lvbkVycm9ycyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMucHJpdmF0ZUtleUxvYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmVmRXhwcmVzc2lvbkVycm9ycy5wcml2YXRlS2V5TG9jID0gcHJpdmF0ZUtleUxvYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZFByaXZhdGVGaWVsZCwgcHJpdmF0ZUtleUxvYyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZVByaXZhdGVOYW1lKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gMTM3KSB7XG4gICAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VEZWNpbWFsTGl0ZXJhbCh2YWx1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByb3Aua2V5ID0ga2V5O1xuICAgICAgaWYgKHR5cGUgIT09IDEzOSkge1xuICAgICAgICBwcm9wLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGluaXRGdW5jdGlvbihub2RlLCBpc0FzeW5jKSB7XG4gICAgbm9kZS5pZCA9IG51bGw7XG4gICAgbm9kZS5nZW5lcmF0b3IgPSBmYWxzZTtcbiAgICBub2RlLmFzeW5jID0gaXNBc3luYztcbiAgfVxuICBwYXJzZU1ldGhvZChub2RlLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNDb25zdHJ1Y3RvciwgYWxsb3dEaXJlY3RTdXBlciwgdHlwZSwgaW5DbGFzc1Njb3BlID0gZmFsc2UpIHtcbiAgICB0aGlzLmluaXRGdW5jdGlvbihub2RlLCBpc0FzeW5jKTtcbiAgICBub2RlLmdlbmVyYXRvciA9IGlzR2VuZXJhdG9yO1xuICAgIHRoaXMuc2NvcGUuZW50ZXIoMiB8IDE2IHwgKGluQ2xhc3NTY29wZSA/IDY0IDogMCkgfCAoYWxsb3dEaXJlY3RTdXBlciA/IDMyIDogMCkpO1xuICAgIHRoaXMucHJvZFBhcmFtLmVudGVyKGZ1bmN0aW9uRmxhZ3MoaXNBc3luYywgbm9kZS5nZW5lcmF0b3IpKTtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSwgaXNDb25zdHJ1Y3Rvcik7XG4gICAgY29uc3QgZmluaXNoZWROb2RlID0gdGhpcy5wYXJzZUZ1bmN0aW9uQm9keUFuZEZpbmlzaChub2RlLCB0eXBlLCB0cnVlKTtcbiAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgcmV0dXJuIGZpbmlzaGVkTm9kZTtcbiAgfVxuICBwYXJzZUFycmF5TGlrZShjbG9zZSwgY2FuQmVQYXR0ZXJuLCBpc1R1cGxlLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKGlzVHVwbGUpIHtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwicmVjb3JkQW5kVHVwbGVcIik7XG4gICAgfVxuICAgIGNvbnN0IG9sZEluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5ID0gdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keTtcbiAgICB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5ID0gZmFsc2U7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5lbGVtZW50cyA9IHRoaXMucGFyc2VFeHByTGlzdChjbG9zZSwgIWlzVHVwbGUsIHJlZkV4cHJlc3Npb25FcnJvcnMsIG5vZGUpO1xuICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzVHVwbGUgPyBcIlR1cGxlRXhwcmVzc2lvblwiIDogXCJBcnJheUV4cHJlc3Npb25cIik7XG4gIH1cbiAgcGFyc2VBcnJvd0V4cHJlc3Npb24obm9kZSwgcGFyYW1zLCBpc0FzeW5jLCB0cmFpbGluZ0NvbW1hTG9jKSB7XG4gICAgdGhpcy5zY29wZS5lbnRlcigyIHwgNCk7XG4gICAgbGV0IGZsYWdzID0gZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBmYWxzZSk7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDUpICYmIHRoaXMucHJvZFBhcmFtLmhhc0luKSB7XG4gICAgICBmbGFncyB8PSA4O1xuICAgIH1cbiAgICB0aGlzLnByb2RQYXJhbS5lbnRlcihmbGFncyk7XG4gICAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSwgaXNBc3luYyk7XG4gICAgY29uc3Qgb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycyA9IHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICBpZiAocGFyYW1zKSB7XG4gICAgICB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSB0cnVlO1xuICAgICAgdGhpcy5zZXRBcnJvd0Z1bmN0aW9uUGFyYW1ldGVycyhub2RlLCBwYXJhbXMsIHRyYWlsaW5nQ29tbWFMb2MpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSBmYWxzZTtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIHRydWUpO1xuICAgIHRoaXMucHJvZFBhcmFtLmV4aXQoKTtcbiAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSBvbGRNYXliZUluQXJyb3dQYXJhbWV0ZXJzO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKTtcbiAgfVxuICBzZXRBcnJvd0Z1bmN0aW9uUGFyYW1ldGVycyhub2RlLCBwYXJhbXMsIHRyYWlsaW5nQ29tbWFMb2MpIHtcbiAgICB0aGlzLnRvQXNzaWduYWJsZUxpc3QocGFyYW1zLCB0cmFpbGluZ0NvbW1hTG9jLCBmYWxzZSk7XG4gICAgbm9kZS5wYXJhbXMgPSBwYXJhbXM7XG4gIH1cbiAgcGFyc2VGdW5jdGlvbkJvZHlBbmRGaW5pc2gobm9kZSwgdHlwZSwgaXNNZXRob2QgPSBmYWxzZSkge1xuICAgIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgZmFsc2UsIGlzTWV0aG9kKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHR5cGUpO1xuICB9XG4gIHBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGFsbG93RXhwcmVzc2lvbiwgaXNNZXRob2QgPSBmYWxzZSkge1xuICAgIGNvbnN0IGlzRXhwcmVzc2lvbiA9IGFsbG93RXhwcmVzc2lvbiAmJiAhdGhpcy5tYXRjaCg1KTtcbiAgICB0aGlzLmV4cHJlc3Npb25TY29wZS5lbnRlcihuZXdFeHByZXNzaW9uU2NvcGUoKSk7XG4gICAgaWYgKGlzRXhwcmVzc2lvbikge1xuICAgICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICB0aGlzLmNoZWNrUGFyYW1zKG5vZGUsIGZhbHNlLCBhbGxvd0V4cHJlc3Npb24sIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb2xkU3RyaWN0ID0gdGhpcy5zdGF0ZS5zdHJpY3Q7XG4gICAgICBjb25zdCBvbGRMYWJlbHMgPSB0aGlzLnN0YXRlLmxhYmVscztcbiAgICAgIHRoaXMuc3RhdGUubGFiZWxzID0gW107XG4gICAgICB0aGlzLnByb2RQYXJhbS5lbnRlcih0aGlzLnByb2RQYXJhbS5jdXJyZW50RmxhZ3MoKSB8IDQpO1xuICAgICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKHRydWUsIGZhbHNlLCBoYXNTdHJpY3RNb2RlRGlyZWN0aXZlID0+IHtcbiAgICAgICAgY29uc3Qgbm9uU2ltcGxlID0gIXRoaXMuaXNTaW1wbGVQYXJhbUxpc3Qobm9kZS5wYXJhbXMpO1xuICAgICAgICBpZiAoaGFzU3RyaWN0TW9kZURpcmVjdGl2ZSAmJiBub25TaW1wbGUpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbGxlZ2FsTGFuZ3VhZ2VNb2RlRGlyZWN0aXZlLCAobm9kZS5raW5kID09PSBcIm1ldGhvZFwiIHx8IG5vZGUua2luZCA9PT0gXCJjb25zdHJ1Y3RvclwiKSAmJiAhIW5vZGUua2V5ID8gbm9kZS5rZXkubG9jLmVuZCA6IG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmljdE1vZGVDaGFuZ2VkID0gIW9sZFN0cmljdCAmJiB0aGlzLnN0YXRlLnN0cmljdDtcbiAgICAgICAgdGhpcy5jaGVja1BhcmFtcyhub2RlLCAhdGhpcy5zdGF0ZS5zdHJpY3QgJiYgIWFsbG93RXhwcmVzc2lvbiAmJiAhaXNNZXRob2QgJiYgIW5vblNpbXBsZSwgYWxsb3dFeHByZXNzaW9uLCBzdHJpY3RNb2RlQ2hhbmdlZCk7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnN0cmljdCAmJiBub2RlLmlkKSB7XG4gICAgICAgICAgdGhpcy5jaGVja0lkZW50aWZpZXIobm9kZS5pZCwgNjUsIHN0cmljdE1vZGVDaGFuZ2VkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgICB0aGlzLnN0YXRlLmxhYmVscyA9IG9sZExhYmVscztcbiAgICB9XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZXhpdCgpO1xuICB9XG4gIGlzU2ltcGxlUGFyYW1ldGVyKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIklkZW50aWZpZXJcIjtcbiAgfVxuICBpc1NpbXBsZVBhcmFtTGlzdChwYXJhbXMpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcGFyYW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMuaXNTaW1wbGVQYXJhbWV0ZXIocGFyYW1zW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjaGVja1BhcmFtcyhub2RlLCBhbGxvd0R1cGxpY2F0ZXMsIGlzQXJyb3dGdW5jdGlvbiwgc3RyaWN0TW9kZUNoYW5nZWQgPSB0cnVlKSB7XG4gICAgY29uc3QgY2hlY2tDbGFzaGVzID0gIWFsbG93RHVwbGljYXRlcyAmJiBuZXcgU2V0KCk7XG4gICAgY29uc3QgZm9ybWFsUGFyYW1ldGVycyA9IHtcbiAgICAgIHR5cGU6IFwiRm9ybWFsUGFyYW1ldGVyc1wiXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIG5vZGUucGFyYW1zKSB7XG4gICAgICB0aGlzLmNoZWNrTFZhbChwYXJhbSwgZm9ybWFsUGFyYW1ldGVycywgNSwgY2hlY2tDbGFzaGVzLCBzdHJpY3RNb2RlQ2hhbmdlZCk7XG4gICAgfVxuICB9XG4gIHBhcnNlRXhwckxpc3QoY2xvc2UsIGFsbG93RW1wdHksIHJlZkV4cHJlc3Npb25FcnJvcnMsIG5vZGVGb3JFeHRyYSkge1xuICAgIGNvbnN0IGVsdHMgPSBbXTtcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KDEyKTtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2goY2xvc2UpKSB7XG4gICAgICAgICAgaWYgKG5vZGVGb3JFeHRyYSkge1xuICAgICAgICAgICAgdGhpcy5hZGRUcmFpbGluZ0NvbW1hRXh0cmFUb05vZGUobm9kZUZvckV4dHJhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsdHMucHVzaCh0aGlzLnBhcnNlRXhwckxpc3RJdGVtKGFsbG93RW1wdHksIHJlZkV4cHJlc3Npb25FcnJvcnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsdHM7XG4gIH1cbiAgcGFyc2VFeHByTGlzdEl0ZW0oYWxsb3dFbXB0eSwgcmVmRXhwcmVzc2lvbkVycm9ycywgYWxsb3dQbGFjZWhvbGRlcikge1xuICAgIGxldCBlbHQ7XG4gICAgaWYgKHRoaXMubWF0Y2goMTIpKSB7XG4gICAgICBpZiAoIWFsbG93RW1wdHkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZFRva2VuLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCksIHtcbiAgICAgICAgICB1bmV4cGVjdGVkOiBcIixcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVsdCA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKDIxKSkge1xuICAgICAgY29uc3Qgc3ByZWFkTm9kZVN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgIGVsdCA9IHRoaXMucGFyc2VQYXJlbkl0ZW0odGhpcy5wYXJzZVNwcmVhZChyZWZFeHByZXNzaW9uRXJyb3JzKSwgc3ByZWFkTm9kZVN0YXJ0TG9jKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goMTcpKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcInBhcnRpYWxBcHBsaWNhdGlvblwiKTtcbiAgICAgIGlmICghYWxsb3dQbGFjZWhvbGRlcikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkQXJndW1lbnRQbGFjZWhvbGRlciwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgZWx0ID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJndW1lbnRQbGFjZWhvbGRlclwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWx0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbihyZWZFeHByZXNzaW9uRXJyb3JzLCB0aGlzLnBhcnNlUGFyZW5JdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsdDtcbiAgfVxuICBwYXJzZUlkZW50aWZpZXIobGliZXJhbCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUobGliZXJhbCk7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlSWRlbnRpZmllcihub2RlLCBuYW1lKTtcbiAgfVxuICBjcmVhdGVJZGVudGlmaWVyKG5vZGUsIG5hbWUpIHtcbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICAgIG5vZGUubG9jLmlkZW50aWZpZXJOYW1lID0gbmFtZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSWRlbnRpZmllclwiKTtcbiAgfVxuICBwYXJzZUlkZW50aWZpZXJOYW1lKGxpYmVyYWwpIHtcbiAgICBsZXQgbmFtZTtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydExvYyxcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodHlwZSkpIHtcbiAgICAgIG5hbWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgY29uc3QgdG9rZW5Jc0tleXdvcmQgPSB0b2tlbktleXdvcmRPcklkZW50aWZpZXJJc0tleXdvcmQodHlwZSk7XG4gICAgaWYgKGxpYmVyYWwpIHtcbiAgICAgIGlmICh0b2tlbklzS2V5d29yZCkge1xuICAgICAgICB0aGlzLnJlcGxhY2VUb2tlbigxMzIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoZWNrUmVzZXJ2ZWRXb3JkKG5hbWUsIHN0YXJ0TG9jLCB0b2tlbklzS2V5d29yZCwgZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuICBjaGVja1Jlc2VydmVkV29yZCh3b3JkLCBzdGFydExvYywgY2hlY2tLZXl3b3JkcywgaXNCaW5kaW5nKSB7XG4gICAgaWYgKHdvcmQubGVuZ3RoID4gMTApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjYW5CZVJlc2VydmVkV29yZCh3b3JkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2hlY2tLZXl3b3JkcyAmJiBpc0tleXdvcmQod29yZCkpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRLZXl3b3JkLCBzdGFydExvYywge1xuICAgICAgICBrZXl3b3JkOiB3b3JkXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzZXJ2ZWRUZXN0ID0gIXRoaXMuc3RhdGUuc3RyaWN0ID8gaXNSZXNlcnZlZFdvcmQgOiBpc0JpbmRpbmcgPyBpc1N0cmljdEJpbmRSZXNlcnZlZFdvcmQgOiBpc1N0cmljdFJlc2VydmVkV29yZDtcbiAgICBpZiAocmVzZXJ2ZWRUZXN0KHdvcmQsIHRoaXMuaW5Nb2R1bGUpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkUmVzZXJ2ZWRXb3JkLCBzdGFydExvYywge1xuICAgICAgICByZXNlcnZlZFdvcmQ6IHdvcmRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAod29yZCA9PT0gXCJ5aWVsZFwiKSB7XG4gICAgICBpZiAodGhpcy5wcm9kUGFyYW0uaGFzWWllbGQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuWWllbGRCaW5kaW5nSWRlbnRpZmllciwgc3RhcnRMb2MpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh3b3JkID09PSBcImF3YWl0XCIpIHtcbiAgICAgIGlmICh0aGlzLnByb2RQYXJhbS5oYXNBd2FpdCkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Bd2FpdEJpbmRpbmdJZGVudGlmaWVyLCBzdGFydExvYyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNjb3BlLmluU3RhdGljQmxvY2spIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQXdhaXRCaW5kaW5nSWRlbnRpZmllckluU3RhdGljQmxvY2ssIHN0YXJ0TG9jKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5leHByZXNzaW9uU2NvcGUucmVjb3JkQXN5bmNBcnJvd1BhcmFtZXRlcnNFcnJvcihzdGFydExvYyk7XG4gICAgfSBlbHNlIGlmICh3b3JkID09PSBcImFyZ3VtZW50c1wiKSB7XG4gICAgICBpZiAodGhpcy5zY29wZS5pbkNsYXNzQW5kTm90SW5Ob25BcnJvd0Z1bmN0aW9uKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkFyZ3VtZW50c0luQ2xhc3MsIHN0YXJ0TG9jKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZWNvcmRBd2FpdElmQWxsb3dlZCgpIHtcbiAgICBjb25zdCBpc0F3YWl0QWxsb3dlZCA9IHRoaXMucHJvZFBhcmFtLmhhc0F3YWl0IHx8IHRoaXMub3B0aW9uRmxhZ3MgJiAxICYmICF0aGlzLnNjb3BlLmluRnVuY3Rpb247XG4gICAgaWYgKGlzQXdhaXRBbGxvd2VkICYmICF0aGlzLnNjb3BlLmluRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMuc3RhdGUuaGFzVG9wTGV2ZWxBd2FpdCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBpc0F3YWl0QWxsb3dlZDtcbiAgfVxuICBwYXJzZUF3YWl0KHN0YXJ0TG9jKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLnJlY29yZFBhcmFtZXRlckluaXRpYWxpemVyRXJyb3IoRXJyb3JzLkF3YWl0RXhwcmVzc2lvbkZvcm1hbFBhcmFtZXRlciwgbm9kZSk7XG4gICAgaWYgKHRoaXMuZWF0KDU1KSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuT2Jzb2xldGVBd2FpdFN0YXIsIG5vZGUpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc2NvcGUuaW5GdW5jdGlvbiAmJiAhKHRoaXMub3B0aW9uRmxhZ3MgJiAxKSkge1xuICAgICAgaWYgKHRoaXMuaXNBbWJpZ3VvdXNQcmVmaXhPcklkZW50aWZpZXIoKSkge1xuICAgICAgICB0aGlzLmFtYmlndW91c1NjcmlwdERpZmZlcmVudEFzdCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNhd1VuYW1iaWd1b3VzRVNNID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLnN0YXRlLnNvbG9Bd2FpdCkge1xuICAgICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXdhaXRFeHByZXNzaW9uXCIpO1xuICB9XG4gIGlzQW1iaWd1b3VzUHJlZml4T3JJZGVudGlmaWVyKCkge1xuICAgIGlmICh0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpKSByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIHR5cGUgPT09IDUzIHx8IHR5cGUgPT09IDEwIHx8IHR5cGUgPT09IDAgfHwgdG9rZW5Jc1RlbXBsYXRlKHR5cGUpIHx8IHR5cGUgPT09IDEwMiAmJiAhdGhpcy5zdGF0ZS5jb250YWluc0VzYyB8fCB0eXBlID09PSAxMzggfHwgdHlwZSA9PT0gNTYgfHwgdGhpcy5oYXNQbHVnaW4oXCJ2OGludHJpbnNpY1wiKSAmJiB0eXBlID09PSA1NDtcbiAgfVxuICBwYXJzZVlpZWxkKHN0YXJ0TG9jKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLnJlY29yZFBhcmFtZXRlckluaXRpYWxpemVyRXJyb3IoRXJyb3JzLllpZWxkSW5QYXJhbWV0ZXIsIG5vZGUpO1xuICAgIGxldCBkZWxlZ2F0aW5nID0gZmFsc2U7XG4gICAgbGV0IGFyZ3VtZW50ID0gbnVsbDtcbiAgICBpZiAoIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkpIHtcbiAgICAgIGRlbGVnYXRpbmcgPSB0aGlzLmVhdCg1NSk7XG4gICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICBjYXNlIDE0MDpcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDM6XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBpZiAoIWRlbGVnYXRpbmcpIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICB9XG4gICAgfVxuICAgIG5vZGUuZGVsZWdhdGUgPSBkZWxlZ2F0aW5nO1xuICAgIG5vZGUuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiWWllbGRFeHByZXNzaW9uXCIpO1xuICB9XG4gIHBhcnNlSW1wb3J0Q2FsbChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgbm9kZS5vcHRpb25zID0gbnVsbDtcbiAgICBpZiAodGhpcy5lYXQoMTIpKSB7XG4gICAgICBpZiAoIXRoaXMubWF0Y2goMTEpKSB7XG4gICAgICAgIG5vZGUub3B0aW9ucyA9IHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4oKTtcbiAgICAgICAgaWYgKHRoaXMuZWF0KDEyKSAmJiAhdGhpcy5tYXRjaCgxMSkpIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgICAgICAgfSB3aGlsZSAodGhpcy5lYXQoMTIpICYmICF0aGlzLm1hdGNoKDExKSk7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW1wb3J0Q2FsbEFyaXR5LCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydEV4cHJlc3Npb25cIik7XG4gIH1cbiAgY2hlY2tQaXBlbGluZUF0SW5maXhPcGVyYXRvcihsZWZ0LCBsZWZ0U3RhcnRMb2MpIHtcbiAgICBpZiAodGhpcy5oYXNQbHVnaW4oW1wicGlwZWxpbmVPcGVyYXRvclwiLCB7XG4gICAgICBwcm9wb3NhbDogXCJzbWFydFwiXG4gICAgfV0pKSB7XG4gICAgICBpZiAobGVmdC50eXBlID09PSBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlBpcGVsaW5lSGVhZFNlcXVlbmNlRXhwcmVzc2lvbiwgbGVmdFN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGFyc2VTbWFydFBpcGVsaW5lQm9keUluU3R5bGUoY2hpbGRFeHByLCBzdGFydExvYykge1xuICAgIGlmICh0aGlzLmlzU2ltcGxlUmVmZXJlbmNlKGNoaWxkRXhwcikpIHtcbiAgICAgIGNvbnN0IGJvZHlOb2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBib2R5Tm9kZS5jYWxsZWUgPSBjaGlsZEV4cHI7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKGJvZHlOb2RlLCBcIlBpcGVsaW5lQmFyZUZ1bmN0aW9uXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBib2R5Tm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgdGhpcy5jaGVja1NtYXJ0UGlwZVRvcGljQm9keUVhcmx5RXJyb3JzKHN0YXJ0TG9jKTtcbiAgICAgIGJvZHlOb2RlLmV4cHJlc3Npb24gPSBjaGlsZEV4cHI7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKGJvZHlOb2RlLCBcIlBpcGVsaW5lVG9waWNFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgfVxuICBpc1NpbXBsZVJlZmVyZW5jZShleHByZXNzaW9uKSB7XG4gICAgc3dpdGNoIChleHByZXNzaW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiAhZXhwcmVzc2lvbi5jb21wdXRlZCAmJiB0aGlzLmlzU2ltcGxlUmVmZXJlbmNlKGV4cHJlc3Npb24ub2JqZWN0KTtcbiAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBjaGVja1NtYXJ0UGlwZVRvcGljQm9keUVhcmx5RXJyb3JzKHN0YXJ0TG9jKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTkpKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5QaXBlbGluZUJvZHlOb0Fycm93LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnRvcGljUmVmZXJlbmNlV2FzVXNlZEluQ3VycmVudENvbnRleHQoKSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUGlwZWxpbmVUb3BpY1VudXNlZCwgc3RhcnRMb2MpO1xuICAgIH1cbiAgfVxuICB3aXRoVG9waWNCaW5kaW5nQ29udGV4dChjYWxsYmFjaykge1xuICAgIGNvbnN0IG91dGVyQ29udGV4dFRvcGljU3RhdGUgPSB0aGlzLnN0YXRlLnRvcGljQ29udGV4dDtcbiAgICB0aGlzLnN0YXRlLnRvcGljQ29udGV4dCA9IHtcbiAgICAgIG1heE51bU9mUmVzb2x2YWJsZVRvcGljczogMSxcbiAgICAgIG1heFRvcGljSW5kZXg6IG51bGxcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQgPSBvdXRlckNvbnRleHRUb3BpY1N0YXRlO1xuICAgIH1cbiAgfVxuICB3aXRoU21hcnRNaXhUb3BpY0ZvcmJpZGRpbmdDb250ZXh0KGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuaGFzUGx1Z2luKFtcInBpcGVsaW5lT3BlcmF0b3JcIiwge1xuICAgICAgcHJvcG9zYWw6IFwic21hcnRcIlxuICAgIH1dKSkge1xuICAgICAgY29uc3Qgb3V0ZXJDb250ZXh0VG9waWNTdGF0ZSA9IHRoaXMuc3RhdGUudG9waWNDb250ZXh0O1xuICAgICAgdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQgPSB7XG4gICAgICAgIG1heE51bU9mUmVzb2x2YWJsZVRvcGljczogMCxcbiAgICAgICAgbWF4VG9waWNJbmRleDogbnVsbFxuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQgPSBvdXRlckNvbnRleHRUb3BpY1N0YXRlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gIH1cbiAgd2l0aFNvbG9Bd2FpdFBlcm1pdHRpbmdDb250ZXh0KGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgb3V0ZXJDb250ZXh0U29sb0F3YWl0U3RhdGUgPSB0aGlzLnN0YXRlLnNvbG9Bd2FpdDtcbiAgICB0aGlzLnN0YXRlLnNvbG9Bd2FpdCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnN0YXRlLnNvbG9Bd2FpdCA9IG91dGVyQ29udGV4dFNvbG9Bd2FpdFN0YXRlO1xuICAgIH1cbiAgfVxuICBhbGxvd0luQW5kKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZmxhZ3MgPSB0aGlzLnByb2RQYXJhbS5jdXJyZW50RmxhZ3MoKTtcbiAgICBjb25zdCBwcm9kUGFyYW1Ub1NldCA9IDggJiB+ZmxhZ3M7XG4gICAgaWYgKHByb2RQYXJhbVRvU2V0KSB7XG4gICAgICB0aGlzLnByb2RQYXJhbS5lbnRlcihmbGFncyB8IDgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYWxsYmFjaygpO1xuICB9XG4gIGRpc2FsbG93SW5BbmQoY2FsbGJhY2spIHtcbiAgICBjb25zdCBmbGFncyA9IHRoaXMucHJvZFBhcmFtLmN1cnJlbnRGbGFncygpO1xuICAgIGNvbnN0IHByb2RQYXJhbVRvQ2xlYXIgPSA4ICYgZmxhZ3M7XG4gICAgaWYgKHByb2RQYXJhbVRvQ2xlYXIpIHtcbiAgICAgIHRoaXMucHJvZFBhcmFtLmVudGVyKGZsYWdzICYgfjgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYWxsYmFjaygpO1xuICB9XG4gIHJlZ2lzdGVyVG9waWNSZWZlcmVuY2UoKSB7XG4gICAgdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQubWF4VG9waWNJbmRleCA9IDA7XG4gIH1cbiAgdG9waWNSZWZlcmVuY2VJc0FsbG93ZWRJbkN1cnJlbnRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnRvcGljQ29udGV4dC5tYXhOdW1PZlJlc29sdmFibGVUb3BpY3MgPj0gMTtcbiAgfVxuICB0b3BpY1JlZmVyZW5jZVdhc1VzZWRJbkN1cnJlbnRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnRvcGljQ29udGV4dC5tYXhUb3BpY0luZGV4ICE9IG51bGwgJiYgdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQubWF4VG9waWNJbmRleCA+PSAwO1xuICB9XG4gIHBhcnNlRlNoYXJwUGlwZWxpbmVCb2R5KHByZWMpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICBjb25zdCBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IHRydWU7XG4gICAgY29uc3QgcmV0ID0gdGhpcy5wYXJzZUV4cHJPcCh0aGlzLnBhcnNlTWF5YmVVbmFyeU9yUHJpdmF0ZSgpLCBzdGFydExvYywgcHJlYyk7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IG9sZEluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgcGFyc2VNb2R1bGVFeHByZXNzaW9uKCkge1xuICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwibW9kdWxlQmxvY2tzXCIpO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICghdGhpcy5tYXRjaCg1KSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKG51bGwsIDUpO1xuICAgIH1cbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5zdGFydE5vZGVBdCh0aGlzLnN0YXRlLmVuZExvYyk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgY29uc3QgcmV2ZXJ0U2NvcGVzID0gdGhpcy5pbml0aWFsaXplU2NvcGVzKHRydWUpO1xuICAgIHRoaXMuZW50ZXJJbml0aWFsU2NvcGVzKCk7XG4gICAgdHJ5IHtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VQcm9ncmFtKHByb2dyYW0sIDgsIFwibW9kdWxlXCIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICByZXZlcnRTY29wZXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1vZHVsZUV4cHJlc3Npb25cIik7XG4gIH1cbiAgcGFyc2VQcm9wZXJ0eU5hbWVQcmVmaXhPcGVyYXRvcihwcm9wKSB7fVxufVxuY29uc3QgbG9vcExhYmVsID0ge1xuICAgIGtpbmQ6IDFcbiAgfSxcbiAgc3dpdGNoTGFiZWwgPSB7XG4gICAga2luZDogMlxuICB9O1xuY29uc3QgbG9uZVN1cnJvZ2F0ZSA9IC9bXFx1RDgwMC1cXHVERkZGXS91O1xuY29uc3Qga2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvciA9IC9pbig/OnN0YW5jZW9mKT8veTtcbmZ1bmN0aW9uIGJhYmVsN0NvbXBhdFRva2Vucyh0b2tlbnMsIGlucHV0LCBzdGFydEluZGV4KSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0b2tlbjtcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IDEzOSkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGxvYyxcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICB9ID0gdG9rZW47XG4gICAgICAgICAgY29uc3QgaGFzaEVuZFBvcyA9IHN0YXJ0ICsgMTtcbiAgICAgICAgICBjb25zdCBoYXNoRW5kTG9jID0gY3JlYXRlUG9zaXRpb25XaXRoQ29sdW1uT2Zmc2V0KGxvYy5zdGFydCwgMSk7XG4gICAgICAgICAgdG9rZW5zLnNwbGljZShpLCAxLCBuZXcgVG9rZW4oe1xuICAgICAgICAgICAgdHlwZTogZ2V0RXhwb3J0ZWRUb2tlbigyNyksXG4gICAgICAgICAgICB2YWx1ZTogXCIjXCIsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGhhc2hFbmRQb3MsXG4gICAgICAgICAgICBzdGFydExvYzogbG9jLnN0YXJ0LFxuICAgICAgICAgICAgZW5kTG9jOiBoYXNoRW5kTG9jXG4gICAgICAgICAgfSksIG5ldyBUb2tlbih7XG4gICAgICAgICAgICB0eXBlOiBnZXRFeHBvcnRlZFRva2VuKDEzMiksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBzdGFydDogaGFzaEVuZFBvcyxcbiAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgc3RhcnRMb2M6IGhhc2hFbmRMb2MsXG4gICAgICAgICAgICBlbmRMb2M6IGxvYy5lbmRcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbklzVGVtcGxhdGUodHlwZSkpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBsb2MsXG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfSA9IHRva2VuO1xuICAgICAgICAgIGNvbnN0IGJhY2txdW90ZUVuZCA9IHN0YXJ0ICsgMTtcbiAgICAgICAgICBjb25zdCBiYWNrcXVvdGVFbmRMb2MgPSBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQobG9jLnN0YXJ0LCAxKTtcbiAgICAgICAgICBsZXQgc3RhcnRUb2tlbjtcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChzdGFydCAtIHN0YXJ0SW5kZXgpID09PSA5Nikge1xuICAgICAgICAgICAgc3RhcnRUb2tlbiA9IG5ldyBUb2tlbih7XG4gICAgICAgICAgICAgIHR5cGU6IGdldEV4cG9ydGVkVG9rZW4oMjIpLFxuICAgICAgICAgICAgICB2YWx1ZTogXCJgXCIsXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBiYWNrcXVvdGVFbmQsXG4gICAgICAgICAgICAgIHN0YXJ0TG9jOiBsb2Muc3RhcnQsXG4gICAgICAgICAgICAgIGVuZExvYzogYmFja3F1b3RlRW5kTG9jXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRUb2tlbiA9IG5ldyBUb2tlbih7XG4gICAgICAgICAgICAgIHR5cGU6IGdldEV4cG9ydGVkVG9rZW4oOCksXG4gICAgICAgICAgICAgIHZhbHVlOiBcIn1cIixcbiAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGJhY2txdW90ZUVuZCxcbiAgICAgICAgICAgICAgc3RhcnRMb2M6IGxvYy5zdGFydCxcbiAgICAgICAgICAgICAgZW5kTG9jOiBiYWNrcXVvdGVFbmRMb2NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgdGVtcGxhdGVWYWx1ZSwgdGVtcGxhdGVFbGVtZW50RW5kLCB0ZW1wbGF0ZUVsZW1lbnRFbmRMb2MsIGVuZFRva2VuO1xuICAgICAgICAgIGlmICh0eXBlID09PSAyNCkge1xuICAgICAgICAgICAgdGVtcGxhdGVFbGVtZW50RW5kID0gZW5kIC0gMTtcbiAgICAgICAgICAgIHRlbXBsYXRlRWxlbWVudEVuZExvYyA9IGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldChsb2MuZW5kLCAtMSk7XG4gICAgICAgICAgICB0ZW1wbGF0ZVZhbHVlID0gdmFsdWUgPT09IG51bGwgPyBudWxsIDogdmFsdWUuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgZW5kVG9rZW4gPSBuZXcgVG9rZW4oe1xuICAgICAgICAgICAgICB0eXBlOiBnZXRFeHBvcnRlZFRva2VuKDIyKSxcbiAgICAgICAgICAgICAgdmFsdWU6IFwiYFwiLFxuICAgICAgICAgICAgICBzdGFydDogdGVtcGxhdGVFbGVtZW50RW5kLFxuICAgICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgICAgc3RhcnRMb2M6IHRlbXBsYXRlRWxlbWVudEVuZExvYyxcbiAgICAgICAgICAgICAgZW5kTG9jOiBsb2MuZW5kXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVtcGxhdGVFbGVtZW50RW5kID0gZW5kIC0gMjtcbiAgICAgICAgICAgIHRlbXBsYXRlRWxlbWVudEVuZExvYyA9IGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldChsb2MuZW5kLCAtMik7XG4gICAgICAgICAgICB0ZW1wbGF0ZVZhbHVlID0gdmFsdWUgPT09IG51bGwgPyBudWxsIDogdmFsdWUuc2xpY2UoMSwgLTIpO1xuICAgICAgICAgICAgZW5kVG9rZW4gPSBuZXcgVG9rZW4oe1xuICAgICAgICAgICAgICB0eXBlOiBnZXRFeHBvcnRlZFRva2VuKDIzKSxcbiAgICAgICAgICAgICAgdmFsdWU6IFwiJHtcIixcbiAgICAgICAgICAgICAgc3RhcnQ6IHRlbXBsYXRlRWxlbWVudEVuZCxcbiAgICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICAgIHN0YXJ0TG9jOiB0ZW1wbGF0ZUVsZW1lbnRFbmRMb2MsXG4gICAgICAgICAgICAgIGVuZExvYzogbG9jLmVuZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRva2Vucy5zcGxpY2UoaSwgMSwgc3RhcnRUb2tlbiwgbmV3IFRva2VuKHtcbiAgICAgICAgICAgIHR5cGU6IGdldEV4cG9ydGVkVG9rZW4oMjApLFxuICAgICAgICAgICAgdmFsdWU6IHRlbXBsYXRlVmFsdWUsXG4gICAgICAgICAgICBzdGFydDogYmFja3F1b3RlRW5kLFxuICAgICAgICAgICAgZW5kOiB0ZW1wbGF0ZUVsZW1lbnRFbmQsXG4gICAgICAgICAgICBzdGFydExvYzogYmFja3F1b3RlRW5kTG9jLFxuICAgICAgICAgICAgZW5kTG9jOiB0ZW1wbGF0ZUVsZW1lbnRFbmRMb2NcbiAgICAgICAgICB9KSwgZW5kVG9rZW4pO1xuICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdG9rZW4udHlwZSA9IGdldEV4cG9ydGVkVG9rZW4odHlwZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b2tlbnM7XG59XG5jbGFzcyBTdGF0ZW1lbnRQYXJzZXIgZXh0ZW5kcyBFeHByZXNzaW9uUGFyc2VyIHtcbiAgcGFyc2VUb3BMZXZlbChmaWxlLCBwcm9ncmFtKSB7XG4gICAgZmlsZS5wcm9ncmFtID0gdGhpcy5wYXJzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgZmlsZS5jb21tZW50cyA9IHRoaXMuY29tbWVudHM7XG4gICAgaWYgKHRoaXMub3B0aW9uRmxhZ3MgJiAyNTYpIHtcbiAgICAgIGZpbGUudG9rZW5zID0gYmFiZWw3Q29tcGF0VG9rZW5zKHRoaXMudG9rZW5zLCB0aGlzLmlucHV0LCB0aGlzLnN0YXJ0SW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKGZpbGUsIFwiRmlsZVwiKTtcbiAgfVxuICBwYXJzZVByb2dyYW0ocHJvZ3JhbSwgZW5kID0gMTQwLCBzb3VyY2VUeXBlID0gdGhpcy5vcHRpb25zLnNvdXJjZVR5cGUpIHtcbiAgICBwcm9ncmFtLnNvdXJjZVR5cGUgPSBzb3VyY2VUeXBlO1xuICAgIHByb2dyYW0uaW50ZXJwcmV0ZXIgPSB0aGlzLnBhcnNlSW50ZXJwcmV0ZXJEaXJlY3RpdmUoKTtcbiAgICB0aGlzLnBhcnNlQmxvY2tCb2R5KHByb2dyYW0sIHRydWUsIHRydWUsIGVuZCk7XG4gICAgaWYgKHRoaXMuaW5Nb2R1bGUpIHtcbiAgICAgIGlmICghKHRoaXMub3B0aW9uRmxhZ3MgJiA2NCkgJiYgdGhpcy5zY29wZS51bmRlZmluZWRFeHBvcnRzLnNpemUgPiAwKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2xvY2FsTmFtZSwgYXRdIG9mIEFycmF5LmZyb20odGhpcy5zY29wZS51bmRlZmluZWRFeHBvcnRzKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk1vZHVsZUV4cG9ydFVuZGVmaW5lZCwgYXQsIHtcbiAgICAgICAgICAgIGxvY2FsTmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmFkZEV4dHJhKHByb2dyYW0sIFwidG9wTGV2ZWxBd2FpdFwiLCB0aGlzLnN0YXRlLmhhc1RvcExldmVsQXdhaXQpO1xuICAgIH1cbiAgICBsZXQgZmluaXNoZWRQcm9ncmFtO1xuICAgIGlmIChlbmQgPT09IDE0MCkge1xuICAgICAgZmluaXNoZWRQcm9ncmFtID0gdGhpcy5maW5pc2hOb2RlKHByb2dyYW0sIFwiUHJvZ3JhbVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmluaXNoZWRQcm9ncmFtID0gdGhpcy5maW5pc2hOb2RlQXQocHJvZ3JhbSwgXCJQcm9ncmFtXCIsIGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldCh0aGlzLnN0YXRlLnN0YXJ0TG9jLCAtMSkpO1xuICAgIH1cbiAgICByZXR1cm4gZmluaXNoZWRQcm9ncmFtO1xuICB9XG4gIHN0bXRUb0RpcmVjdGl2ZShzdG10KSB7XG4gICAgY29uc3QgZGlyZWN0aXZlID0gc3RtdDtcbiAgICBkaXJlY3RpdmUudHlwZSA9IFwiRGlyZWN0aXZlXCI7XG4gICAgZGlyZWN0aXZlLnZhbHVlID0gZGlyZWN0aXZlLmV4cHJlc3Npb247XG4gICAgZGVsZXRlIGRpcmVjdGl2ZS5leHByZXNzaW9uO1xuICAgIGNvbnN0IGRpcmVjdGl2ZUxpdGVyYWwgPSBkaXJlY3RpdmUudmFsdWU7XG4gICAgY29uc3QgZXhwcmVzc2lvblZhbHVlID0gZGlyZWN0aXZlTGl0ZXJhbC52YWx1ZTtcbiAgICBjb25zdCByYXcgPSB0aGlzLmlucHV0LnNsaWNlKHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3MoZGlyZWN0aXZlTGl0ZXJhbC5zdGFydCksIHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3MoZGlyZWN0aXZlTGl0ZXJhbC5lbmQpKTtcbiAgICBjb25zdCB2YWwgPSBkaXJlY3RpdmVMaXRlcmFsLnZhbHVlID0gcmF3LnNsaWNlKDEsIC0xKTtcbiAgICB0aGlzLmFkZEV4dHJhKGRpcmVjdGl2ZUxpdGVyYWwsIFwicmF3XCIsIHJhdyk7XG4gICAgdGhpcy5hZGRFeHRyYShkaXJlY3RpdmVMaXRlcmFsLCBcInJhd1ZhbHVlXCIsIHZhbCk7XG4gICAgdGhpcy5hZGRFeHRyYShkaXJlY3RpdmVMaXRlcmFsLCBcImV4cHJlc3Npb25WYWx1ZVwiLCBleHByZXNzaW9uVmFsdWUpO1xuICAgIGRpcmVjdGl2ZUxpdGVyYWwudHlwZSA9IFwiRGlyZWN0aXZlTGl0ZXJhbFwiO1xuICAgIHJldHVybiBkaXJlY3RpdmU7XG4gIH1cbiAgcGFyc2VJbnRlcnByZXRlckRpcmVjdGl2ZSgpIHtcbiAgICBpZiAoIXRoaXMubWF0Y2goMjgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS52YWx1ZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkludGVycHJldGVyRGlyZWN0aXZlXCIpO1xuICB9XG4gIGlzTGV0KCkge1xuICAgIGlmICghdGhpcy5pc0NvbnRleHR1YWwoMTAwKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5oYXNGb2xsb3dpbmdCaW5kaW5nQXRvbSgpO1xuICB9XG4gIGNoU3RhcnRzQmluZGluZ0lkZW50aWZpZXIoY2gsIHBvcykge1xuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjaCkpIHtcbiAgICAgIGtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IubGFzdEluZGV4ID0gcG9zO1xuICAgICAgaWYgKGtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IudGVzdCh0aGlzLmlucHV0KSkge1xuICAgICAgICBjb25zdCBlbmRDaCA9IHRoaXMuY29kZVBvaW50QXRQb3Moa2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvci5sYXN0SW5kZXgpO1xuICAgICAgICBpZiAoIWlzSWRlbnRpZmllckNoYXIoZW5kQ2gpICYmIGVuZENoICE9PSA5Mikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gOTIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGNoU3RhcnRzQmluZGluZ1BhdHRlcm4oY2gpIHtcbiAgICByZXR1cm4gY2ggPT09IDkxIHx8IGNoID09PSAxMjM7XG4gIH1cbiAgaGFzRm9sbG93aW5nQmluZGluZ0F0b20oKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuU3RhcnQoKTtcbiAgICBjb25zdCBuZXh0Q2ggPSB0aGlzLmNvZGVQb2ludEF0UG9zKG5leHQpO1xuICAgIHJldHVybiB0aGlzLmNoU3RhcnRzQmluZGluZ1BhdHRlcm4obmV4dENoKSB8fCB0aGlzLmNoU3RhcnRzQmluZGluZ0lkZW50aWZpZXIobmV4dENoLCBuZXh0KTtcbiAgfVxuICBoYXNJbkxpbmVGb2xsb3dpbmdCaW5kaW5nSWRlbnRpZmllck9yQnJhY2UoKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuSW5MaW5lU3RhcnQoKTtcbiAgICBjb25zdCBuZXh0Q2ggPSB0aGlzLmNvZGVQb2ludEF0UG9zKG5leHQpO1xuICAgIHJldHVybiBuZXh0Q2ggPT09IDEyMyB8fCB0aGlzLmNoU3RhcnRzQmluZGluZ0lkZW50aWZpZXIobmV4dENoLCBuZXh0KTtcbiAgfVxuICBzdGFydHNVc2luZ0Zvck9mKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICBjb250YWluc0VzY1xuICAgIH0gPSB0aGlzLmxvb2thaGVhZCgpO1xuICAgIGlmICh0eXBlID09PSAxMDIgJiYgIWNvbnRhaW5zRXNjKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh0b2tlbklzSWRlbnRpZmllcih0eXBlKSAmJiAhdGhpcy5oYXNGb2xsb3dpbmdMaW5lQnJlYWsoKSkge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJleHBsaWNpdFJlc291cmNlTWFuYWdlbWVudFwiKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBzdGFydHNBd2FpdFVzaW5nKCkge1xuICAgIGxldCBuZXh0ID0gdGhpcy5uZXh0VG9rZW5JbkxpbmVTdGFydCgpO1xuICAgIGlmICh0aGlzLmlzVW5wYXJzZWRDb250ZXh0dWFsKG5leHQsIFwidXNpbmdcIikpIHtcbiAgICAgIG5leHQgPSB0aGlzLm5leHRUb2tlbkluTGluZVN0YXJ0U2luY2UobmV4dCArIDUpO1xuICAgICAgY29uc3QgbmV4dENoID0gdGhpcy5jb2RlUG9pbnRBdFBvcyhuZXh0KTtcbiAgICAgIGlmICh0aGlzLmNoU3RhcnRzQmluZGluZ0lkZW50aWZpZXIobmV4dENoLCBuZXh0KSkge1xuICAgICAgICB0aGlzLmV4cGVjdFBsdWdpbihcImV4cGxpY2l0UmVzb3VyY2VNYW5hZ2VtZW50XCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHBhcnNlTW9kdWxlSXRlbSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVN0YXRlbWVudExpa2UoMSB8IDIgfCA0IHwgOCk7XG4gIH1cbiAgcGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVN0YXRlbWVudExpa2UoMiB8IDQgfCAoIXRoaXMub3B0aW9ucy5hbm5leEIgfHwgdGhpcy5zdGF0ZS5zdHJpY3QgPyAwIDogOCkpO1xuICB9XG4gIHBhcnNlU3RhdGVtZW50T3JTbG9wcHlBbm5leEJGdW5jdGlvbkRlY2xhcmF0aW9uKGFsbG93TGFiZWxlZEZ1bmN0aW9uID0gZmFsc2UpIHtcbiAgICBsZXQgZmxhZ3MgPSAwO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYW5uZXhCICYmICF0aGlzLnN0YXRlLnN0cmljdCkge1xuICAgICAgZmxhZ3MgfD0gNDtcbiAgICAgIGlmIChhbGxvd0xhYmVsZWRGdW5jdGlvbikge1xuICAgICAgICBmbGFncyB8PSA4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZVN0YXRlbWVudExpa2UoZmxhZ3MpO1xuICB9XG4gIHBhcnNlU3RhdGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlU3RhdGVtZW50TGlrZSgwKTtcbiAgfVxuICBwYXJzZVN0YXRlbWVudExpa2UoZmxhZ3MpIHtcbiAgICBsZXQgZGVjb3JhdG9ycyA9IG51bGw7XG4gICAgaWYgKHRoaXMubWF0Y2goMjYpKSB7XG4gICAgICBkZWNvcmF0b3JzID0gdGhpcy5wYXJzZURlY29yYXRvcnModHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlU3RhdGVtZW50Q29udGVudChmbGFncywgZGVjb3JhdG9ycyk7XG4gIH1cbiAgcGFyc2VTdGF0ZW1lbnRDb250ZW50KGZsYWdzLCBkZWNvcmF0b3JzKSB7XG4gICAgY29uc3Qgc3RhcnRUeXBlID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNvbnN0IGFsbG93RGVjbGFyYXRpb24gPSAhIShmbGFncyAmIDIpO1xuICAgIGNvbnN0IGFsbG93RnVuY3Rpb25EZWNsYXJhdGlvbiA9ICEhKGZsYWdzICYgNCk7XG4gICAgY29uc3QgdG9wTGV2ZWwgPSBmbGFncyAmIDE7XG4gICAgc3dpdGNoIChzdGFydFR5cGUpIHtcbiAgICAgIGNhc2UgNjA6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudChub2RlLCB0cnVlKTtcbiAgICAgIGNhc2UgNjM6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudChub2RlLCBmYWxzZSk7XG4gICAgICBjYXNlIDY0OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZURlYnVnZ2VyU3RhdGVtZW50KG5vZGUpO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VEb1doaWxlU3RhdGVtZW50KG5vZGUpO1xuICAgICAgY2FzZSA5MTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3JTdGF0ZW1lbnQobm9kZSk7XG4gICAgICBjYXNlIDY4OlxuICAgICAgICBpZiAodGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpID09PSA0NikgYnJlYWs7XG4gICAgICAgIGlmICghYWxsb3dGdW5jdGlvbkRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0cmljdCA/IEVycm9ycy5TdHJpY3RGdW5jdGlvbiA6IHRoaXMub3B0aW9ucy5hbm5leEIgPyBFcnJvcnMuU2xvcHB5RnVuY3Rpb25Bbm5leEIgOiBFcnJvcnMuU2xvcHB5RnVuY3Rpb24sIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQobm9kZSwgZmFsc2UsICFhbGxvd0RlY2xhcmF0aW9uICYmIGFsbG93RnVuY3Rpb25EZWNsYXJhdGlvbik7XG4gICAgICBjYXNlIDgwOlxuICAgICAgICBpZiAoIWFsbG93RGVjbGFyYXRpb24pIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKHRoaXMubWF5YmVUYWtlRGVjb3JhdG9ycyhkZWNvcmF0b3JzLCBub2RlKSwgdHJ1ZSk7XG4gICAgICBjYXNlIDY5OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUlmU3RhdGVtZW50KG5vZGUpO1xuICAgICAgY2FzZSA3MDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VSZXR1cm5TdGF0ZW1lbnQobm9kZSk7XG4gICAgICBjYXNlIDcxOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVN3aXRjaFN0YXRlbWVudChub2RlKTtcbiAgICAgIGNhc2UgNzI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGhyb3dTdGF0ZW1lbnQobm9kZSk7XG4gICAgICBjYXNlIDczOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyeVN0YXRlbWVudChub2RlKTtcbiAgICAgIGNhc2UgOTY6XG4gICAgICAgIGlmICghdGhpcy5zdGF0ZS5jb250YWluc0VzYyAmJiB0aGlzLnN0YXJ0c0F3YWl0VXNpbmcoKSkge1xuICAgICAgICAgIGlmICghdGhpcy5yZWNvcmRBd2FpdElmQWxsb3dlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Bd2FpdFVzaW5nTm90SW5Bc3luY0NvbnRleHQsIG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWFsbG93RGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRMZXhpY2FsRGVjbGFyYXRpb24sIG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVZhclN0YXRlbWVudChub2RlLCBcImF3YWl0IHVzaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDc6XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmNvbnRhaW5zRXNjIHx8ICF0aGlzLmhhc0luTGluZUZvbGxvd2luZ0JpbmRpbmdJZGVudGlmaWVyT3JCcmFjZSgpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJleHBsaWNpdFJlc291cmNlTWFuYWdlbWVudFwiKTtcbiAgICAgICAgaWYgKCF0aGlzLnNjb3BlLmluTW9kdWxlICYmIHRoaXMuc2NvcGUuaW5Ub3BMZXZlbCkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRVc2luZ0RlY2xhcmF0aW9uLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgfSBlbHNlIGlmICghYWxsb3dEZWNsYXJhdGlvbikge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRMZXhpY2FsRGVjbGFyYXRpb24sIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVmFyU3RhdGVtZW50KG5vZGUsIFwidXNpbmdcIik7XG4gICAgICBjYXNlIDEwMDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmNvbnRhaW5zRXNjKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuU3RhcnQoKTtcbiAgICAgICAgICBjb25zdCBuZXh0Q2ggPSB0aGlzLmNvZGVQb2ludEF0UG9zKG5leHQpO1xuICAgICAgICAgIGlmIChuZXh0Q2ggIT09IDkxKSB7XG4gICAgICAgICAgICBpZiAoIWFsbG93RGVjbGFyYXRpb24gJiYgdGhpcy5oYXNGb2xsb3dpbmdMaW5lQnJlYWsoKSkgYnJlYWs7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hTdGFydHNCaW5kaW5nSWRlbnRpZmllcihuZXh0Q2gsIG5leHQpICYmIG5leHRDaCAhPT0gMTIzKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgY2FzZSA3NTpcbiAgICAgICAge1xuICAgICAgICAgIGlmICghYWxsb3dEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZExleGljYWxEZWNsYXJhdGlvbiwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBjYXNlIDc0OlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qga2luZCA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwga2luZCk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgOTI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlV2hpbGVTdGF0ZW1lbnQobm9kZSk7XG4gICAgICBjYXNlIDc2OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVdpdGhTdGF0ZW1lbnQobm9kZSk7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmxvY2soKTtcbiAgICAgIGNhc2UgMTM6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRW1wdHlTdGF0ZW1lbnQobm9kZSk7XG4gICAgICBjYXNlIDgzOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbmV4dFRva2VuQ2hhckNvZGUgPSB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCk7XG4gICAgICAgICAgaWYgKG5leHRUb2tlbkNoYXJDb2RlID09PSA0MCB8fCBuZXh0VG9rZW5DaGFyQ29kZSA9PT0gNDYpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgY2FzZSA4MjpcbiAgICAgICAge1xuICAgICAgICAgIGlmICghKHRoaXMub3B0aW9uRmxhZ3MgJiA4KSAmJiAhdG9wTGV2ZWwpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRJbXBvcnRFeHBvcnQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgIGlmIChzdGFydFR5cGUgPT09IDgzKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlSW1wb3J0KG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlRXhwb3J0KG5vZGUsIGRlY29yYXRvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFzc2VydE1vZHVsZU5vZGVBbGxvd2VkKHJlc3VsdCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0aGlzLmlzQXN5bmNGdW5jdGlvbigpKSB7XG4gICAgICAgICAgICBpZiAoIWFsbG93RGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQXN5bmNGdW5jdGlvbkluU2luZ2xlU3RhdGVtZW50Q29udGV4dCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQobm9kZSwgdHJ1ZSwgIWFsbG93RGVjbGFyYXRpb24gJiYgYWxsb3dGdW5jdGlvbkRlY2xhcmF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWF5YmVOYW1lID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICBjb25zdCBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIoc3RhcnRUeXBlKSAmJiBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHRoaXMuZWF0KDE0KSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG1heWJlTmFtZSwgZXhwciwgZmxhZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwciwgZGVjb3JhdG9ycyk7XG4gICAgfVxuICB9XG4gIGFzc2VydE1vZHVsZU5vZGVBbGxvd2VkKG5vZGUpIHtcbiAgICBpZiAoISh0aGlzLm9wdGlvbkZsYWdzICYgOCkgJiYgIXRoaXMuaW5Nb2R1bGUpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydE91dHNpZGVNb2R1bGUsIG5vZGUpO1xuICAgIH1cbiAgfVxuICBkZWNvcmF0b3JzRW5hYmxlZEJlZm9yZUV4cG9ydCgpIHtcbiAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJkZWNvcmF0b3JzLWxlZ2FjeVwiKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHRoaXMuaGFzUGx1Z2luKFwiZGVjb3JhdG9yc1wiKSAmJiB0aGlzLmdldFBsdWdpbk9wdGlvbihcImRlY29yYXRvcnNcIiwgXCJkZWNvcmF0b3JzQmVmb3JlRXhwb3J0XCIpICE9PSBmYWxzZTtcbiAgfVxuICBtYXliZVRha2VEZWNvcmF0b3JzKG1heWJlRGVjb3JhdG9ycywgY2xhc3NOb2RlLCBleHBvcnROb2RlKSB7XG4gICAgaWYgKG1heWJlRGVjb3JhdG9ycykge1xuICAgICAgdmFyIF9jbGFzc05vZGUkZGVjb3JhdG9ycztcbiAgICAgIGlmICgoX2NsYXNzTm9kZSRkZWNvcmF0b3JzID0gY2xhc3NOb2RlLmRlY29yYXRvcnMpICE9IG51bGwgJiYgX2NsYXNzTm9kZSRkZWNvcmF0b3JzLmxlbmd0aCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZGVjb3JhdG9yc1wiLCBcImRlY29yYXRvcnNCZWZvcmVFeHBvcnRcIikgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRGVjb3JhdG9yc0JlZm9yZUFmdGVyRXhwb3J0LCBjbGFzc05vZGUuZGVjb3JhdG9yc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2xhc3NOb2RlLmRlY29yYXRvcnMudW5zaGlmdCguLi5tYXliZURlY29yYXRvcnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xhc3NOb2RlLmRlY29yYXRvcnMgPSBtYXliZURlY29yYXRvcnM7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbkZyb21Ob2RlKGNsYXNzTm9kZSwgbWF5YmVEZWNvcmF0b3JzWzBdKTtcbiAgICAgIGlmIChleHBvcnROb2RlKSB0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbkZyb21Ob2RlKGV4cG9ydE5vZGUsIGNsYXNzTm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05vZGU7XG4gIH1cbiAgY2FuSGF2ZUxlYWRpbmdEZWNvcmF0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goODApO1xuICB9XG4gIHBhcnNlRGVjb3JhdG9ycyhhbGxvd0V4cG9ydCkge1xuICAgIGNvbnN0IGRlY29yYXRvcnMgPSBbXTtcbiAgICBkbyB7XG4gICAgICBkZWNvcmF0b3JzLnB1c2godGhpcy5wYXJzZURlY29yYXRvcigpKTtcbiAgICB9IHdoaWxlICh0aGlzLm1hdGNoKDI2KSk7XG4gICAgaWYgKHRoaXMubWF0Y2goODIpKSB7XG4gICAgICBpZiAoIWFsbG93RXhwb3J0KSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmRlY29yYXRvcnNFbmFibGVkQmVmb3JlRXhwb3J0KCkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRGVjb3JhdG9yRXhwb3J0Q2xhc3MsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXRoaXMuY2FuSGF2ZUxlYWRpbmdEZWNvcmF0b3IoKSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZExlYWRpbmdEZWNvcmF0b3IsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb3JhdG9ycztcbiAgfVxuICBwYXJzZURlY29yYXRvcigpIHtcbiAgICB0aGlzLmV4cGVjdE9uZVBsdWdpbihbXCJkZWNvcmF0b3JzXCIsIFwiZGVjb3JhdG9ycy1sZWdhY3lcIl0pO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImRlY29yYXRvcnNcIikpIHtcbiAgICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgIGxldCBleHByO1xuICAgICAgaWYgKHRoaXMubWF0Y2goMTApKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgICAgIGV4cHIgPSB0aGlzLndyYXBQYXJlbnRoZXNpcyhzdGFydExvYywgZXhwcik7XG4gICAgICAgIGNvbnN0IHBhcmFtc1N0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgICAgbm9kZS5leHByZXNzaW9uID0gdGhpcy5wYXJzZU1heWJlRGVjb3JhdG9yQXJndW1lbnRzKGV4cHIsIHN0YXJ0TG9jKTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZGVjb3JhdG9yc1wiLCBcImFsbG93Q2FsbFBhcmVudGhlc2l6ZWRcIikgPT09IGZhbHNlICYmIG5vZGUuZXhwcmVzc2lvbiAhPT0gZXhwcikge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkRlY29yYXRvckFyZ3VtZW50c091dHNpZGVQYXJlbnRoZXNlcywgcGFyYW1zU3RhcnRMb2MpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHByID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoZmFsc2UpO1xuICAgICAgICB3aGlsZSAodGhpcy5lYXQoMTYpKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgICAgIG5vZGUub2JqZWN0ID0gZXhwcjtcbiAgICAgICAgICBpZiAodGhpcy5tYXRjaCgxMzkpKSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzU2NvcGUudXNlUHJpdmF0ZU5hbWUodGhpcy5zdGF0ZS52YWx1ZSwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgICAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZVByaXZhdGVOYW1lKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5jb21wdXRlZCA9IGZhbHNlO1xuICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VNYXliZURlY29yYXRvckFyZ3VtZW50cyhleHByLCBzdGFydExvYyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByU3Vic2NyaXB0cygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjb3JhdG9yXCIpO1xuICB9XG4gIHBhcnNlTWF5YmVEZWNvcmF0b3JBcmd1bWVudHMoZXhwciwgc3RhcnRMb2MpIHtcbiAgICBpZiAodGhpcy5lYXQoMTApKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBub2RlLmNhbGxlZSA9IGV4cHI7XG4gICAgICBub2RlLmFyZ3VtZW50cyA9IHRoaXMucGFyc2VDYWxsRXhwcmVzc2lvbkFyZ3VtZW50cygxMSk7XG4gICAgICB0aGlzLnRvUmVmZXJlbmNlZExpc3Qobm9kZS5hcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNhbGxFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZXhwcjtcbiAgfVxuICBwYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQobm9kZSwgaXNCcmVhaykge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLmlzTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgbm9kZS5sYWJlbCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUubGFiZWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB9XG4gICAgdGhpcy52ZXJpZnlCcmVha0NvbnRpbnVlKG5vZGUsIGlzQnJlYWspO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNCcmVhayA/IFwiQnJlYWtTdGF0ZW1lbnRcIiA6IFwiQ29udGludWVTdGF0ZW1lbnRcIik7XG4gIH1cbiAgdmVyaWZ5QnJlYWtDb250aW51ZShub2RlLCBpc0JyZWFrKSB7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuc3RhdGUubGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBsYWIgPSB0aGlzLnN0YXRlLmxhYmVsc1tpXTtcbiAgICAgIGlmIChub2RlLmxhYmVsID09IG51bGwgfHwgbGFiLm5hbWUgPT09IG5vZGUubGFiZWwubmFtZSkge1xuICAgICAgICBpZiAobGFiLmtpbmQgIT0gbnVsbCAmJiAoaXNCcmVhayB8fCBsYWIua2luZCA9PT0gMSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5sYWJlbCAmJiBpc0JyZWFrKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPT09IHRoaXMuc3RhdGUubGFiZWxzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdHlwZSA9IGlzQnJlYWsgPyBcIkJyZWFrU3RhdGVtZW50XCIgOiBcIkNvbnRpbnVlU3RhdGVtZW50XCI7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbGxlZ2FsQnJlYWtDb250aW51ZSwgbm9kZSwge1xuICAgICAgICB0eXBlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcGFyc2VEZWJ1Z2dlclN0YXRlbWVudChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVidWdnZXJTdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VIZWFkZXJFeHByZXNzaW9uKCkge1xuICAgIHRoaXMuZXhwZWN0KDEwKTtcbiAgICBjb25zdCB2YWwgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHBhcnNlRG9XaGlsZVN0YXRlbWVudChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMud2l0aFNtYXJ0TWl4VG9waWNGb3JiaWRkaW5nQ29udGV4dCgoKSA9PiB0aGlzLnBhcnNlU3RhdGVtZW50KCkpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzLnBvcCgpO1xuICAgIHRoaXMuZXhwZWN0KDkyKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlSGVhZGVyRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuZWF0KDEzKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRG9XaGlsZVN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZUZvclN0YXRlbWVudChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgIGxldCBhd2FpdEF0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoOTYpICYmIHRoaXMucmVjb3JkQXdhaXRJZkFsbG93ZWQoKSkge1xuICAgICAgYXdhaXRBdCA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgdGhpcy5zY29wZS5lbnRlcigwKTtcbiAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgaWYgKHRoaXMubWF0Y2goMTMpKSB7XG4gICAgICBpZiAoYXdhaXRBdCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBudWxsKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRzV2l0aExldCA9IHRoaXMuaXNDb250ZXh0dWFsKDEwMCk7XG4gICAge1xuICAgICAgY29uc3Qgc3RhcnRzV2l0aEF3YWl0VXNpbmcgPSB0aGlzLmlzQ29udGV4dHVhbCg5NikgJiYgdGhpcy5zdGFydHNBd2FpdFVzaW5nKCk7XG4gICAgICBjb25zdCBzdGFyc1dpdGhVc2luZ0RlY2xhcmF0aW9uID0gc3RhcnRzV2l0aEF3YWl0VXNpbmcgfHwgdGhpcy5pc0NvbnRleHR1YWwoMTA3KSAmJiB0aGlzLnN0YXJ0c1VzaW5nRm9yT2YoKTtcbiAgICAgIGNvbnN0IGlzTGV0T3JVc2luZyA9IHN0YXJ0c1dpdGhMZXQgJiYgdGhpcy5oYXNGb2xsb3dpbmdCaW5kaW5nQXRvbSgpIHx8IHN0YXJzV2l0aFVzaW5nRGVjbGFyYXRpb247XG4gICAgICBpZiAodGhpcy5tYXRjaCg3NCkgfHwgdGhpcy5tYXRjaCg3NSkgfHwgaXNMZXRPclVzaW5nKSB7XG4gICAgICAgIGNvbnN0IGluaXROb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgbGV0IGtpbmQ7XG4gICAgICAgIGlmIChzdGFydHNXaXRoQXdhaXRVc2luZykge1xuICAgICAgICAgIGtpbmQgPSBcImF3YWl0IHVzaW5nXCI7XG4gICAgICAgICAgaWYgKCF0aGlzLnJlY29yZEF3YWl0SWZBbGxvd2VkKCkpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkF3YWl0VXNpbmdOb3RJbkFzeW5jQ29udGV4dCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtpbmQgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB0aGlzLnBhcnNlVmFyKGluaXROb2RlLCB0cnVlLCBraW5kKTtcbiAgICAgICAgY29uc3QgaW5pdCA9IHRoaXMuZmluaXNoTm9kZShpbml0Tm9kZSwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpO1xuICAgICAgICBjb25zdCBpc0ZvckluID0gdGhpcy5tYXRjaCg1OCk7XG4gICAgICAgIGlmIChpc0ZvckluICYmIHN0YXJzV2l0aFVzaW5nRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Gb3JJblVzaW5nLCBpbml0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGlzRm9ySW4gfHwgdGhpcy5pc0NvbnRleHR1YWwoMTAyKSkgJiYgaW5pdC5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3JJbihub2RlLCBpbml0LCBhd2FpdEF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXdhaXRBdCAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBpbml0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3RhcnRzV2l0aEFzeW5jID0gdGhpcy5pc0NvbnRleHR1YWwoOTUpO1xuICAgIGNvbnN0IHJlZkV4cHJlc3Npb25FcnJvcnMgPSBuZXcgRXhwcmVzc2lvbkVycm9ycygpO1xuICAgIGNvbnN0IGluaXQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbih0cnVlLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICBjb25zdCBpc0Zvck9mID0gdGhpcy5pc0NvbnRleHR1YWwoMTAyKTtcbiAgICBpZiAoaXNGb3JPZikge1xuICAgICAgaWYgKHN0YXJ0c1dpdGhMZXQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRm9yT2ZMZXQsIGluaXQpO1xuICAgICAgfVxuICAgICAgaWYgKGF3YWl0QXQgPT09IG51bGwgJiYgc3RhcnRzV2l0aEFzeW5jICYmIGluaXQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRm9yT2ZBc3luYywgaW5pdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0Zvck9mIHx8IHRoaXMubWF0Y2goNTgpKSB7XG4gICAgICB0aGlzLmNoZWNrRGVzdHJ1Y3R1cmluZ1ByaXZhdGUocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShpbml0LCB0cnVlKTtcbiAgICAgIGNvbnN0IHR5cGUgPSBpc0Zvck9mID8gXCJGb3JPZlN0YXRlbWVudFwiIDogXCJGb3JJblN0YXRlbWVudFwiO1xuICAgICAgdGhpcy5jaGVja0xWYWwoaW5pdCwge1xuICAgICAgICB0eXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9ySW4obm9kZSwgaW5pdCwgYXdhaXRBdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkV4cHJlc3Npb25FcnJvcnMsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoYXdhaXRBdCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBpbml0KTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5vZGUsIGlzQXN5bmMsIGlzSGFuZ2luZ0RlY2xhcmF0aW9uKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCAxIHwgKGlzSGFuZ2luZ0RlY2xhcmF0aW9uID8gMiA6IDApIHwgKGlzQXN5bmMgPyA4IDogMCkpO1xuICB9XG4gIHBhcnNlSWZTdGF0ZW1lbnQobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUudGVzdCA9IHRoaXMucGFyc2VIZWFkZXJFeHByZXNzaW9uKCk7XG4gICAgbm9kZS5jb25zZXF1ZW50ID0gdGhpcy5wYXJzZVN0YXRlbWVudE9yU2xvcHB5QW5uZXhCRnVuY3Rpb25EZWNsYXJhdGlvbigpO1xuICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5lYXQoNjYpID8gdGhpcy5wYXJzZVN0YXRlbWVudE9yU2xvcHB5QW5uZXhCRnVuY3Rpb25EZWNsYXJhdGlvbigpIDogbnVsbDtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSWZTdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VSZXR1cm5TdGF0ZW1lbnQobm9kZSkge1xuICAgIGlmICghdGhpcy5wcm9kUGFyYW0uaGFzUmV0dXJuICYmICEodGhpcy5vcHRpb25GbGFncyAmIDIpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbGxlZ2FsUmV0dXJuLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuaXNMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmV0dXJuU3RhdGVtZW50XCIpO1xuICB9XG4gIHBhcnNlU3dpdGNoU3RhdGVtZW50KG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmRpc2NyaW1pbmFudCA9IHRoaXMucGFyc2VIZWFkZXJFeHByZXNzaW9uKCk7XG4gICAgY29uc3QgY2FzZXMgPSBub2RlLmNhc2VzID0gW107XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucHVzaChzd2l0Y2hMYWJlbCk7XG4gICAgdGhpcy5zY29wZS5lbnRlcigwKTtcbiAgICBsZXQgY3VyO1xuICAgIGZvciAobGV0IHNhd0RlZmF1bHQ7ICF0aGlzLm1hdGNoKDgpOykge1xuICAgICAgaWYgKHRoaXMubWF0Y2goNjEpIHx8IHRoaXMubWF0Y2goNjUpKSB7XG4gICAgICAgIGNvbnN0IGlzQ2FzZSA9IHRoaXMubWF0Y2goNjEpO1xuICAgICAgICBpZiAoY3VyKSB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7XG4gICAgICAgIGNhc2VzLnB1c2goY3VyID0gdGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICAgIGN1ci5jb25zZXF1ZW50ID0gW107XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAoaXNDYXNlKSB7XG4gICAgICAgICAgY3VyLnRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzYXdEZWZhdWx0KSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5NdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2gsIHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2F3RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgY3VyLnRlc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhwZWN0KDE0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjdXIpIHtcbiAgICAgICAgICBjdXIuY29uc2VxdWVudC5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICBpZiAoY3VyKSB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN3aXRjaFN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZVRocm93U3RhdGVtZW50KG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTmV3bGluZUFmdGVyVGhyb3csIHRoaXMuc3RhdGUubGFzdFRva0VuZExvYyk7XG4gICAgfVxuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRocm93U3RhdGVtZW50XCIpO1xuICB9XG4gIHBhcnNlQ2F0Y2hDbGF1c2VQYXJhbSgpIHtcbiAgICBjb25zdCBwYXJhbSA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgIHRoaXMuc2NvcGUuZW50ZXIodGhpcy5vcHRpb25zLmFubmV4QiAmJiBwYXJhbS50eXBlID09PSBcIklkZW50aWZpZXJcIiA/IDggOiAwKTtcbiAgICB0aGlzLmNoZWNrTFZhbChwYXJhbSwge1xuICAgICAgdHlwZTogXCJDYXRjaENsYXVzZVwiXG4gICAgfSwgOSk7XG4gICAgcmV0dXJuIHBhcmFtO1xuICB9XG4gIHBhcnNlVHJ5U3RhdGVtZW50KG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmJsb2NrID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgbm9kZS5oYW5kbGVyID0gbnVsbDtcbiAgICBpZiAodGhpcy5tYXRjaCg2MikpIHtcbiAgICAgIGNvbnN0IGNsYXVzZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgICAgIGNsYXVzZS5wYXJhbSA9IHRoaXMucGFyc2VDYXRjaENsYXVzZVBhcmFtKCk7XG4gICAgICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsYXVzZS5wYXJhbSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2NvcGUuZW50ZXIoMCk7XG4gICAgICB9XG4gICAgICBjbGF1c2UuYm9keSA9IHRoaXMud2l0aFNtYXJ0TWl4VG9waWNGb3JiaWRkaW5nQ29udGV4dCgoKSA9PiB0aGlzLnBhcnNlQmxvY2soZmFsc2UsIGZhbHNlKSk7XG4gICAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICAgIG5vZGUuaGFuZGxlciA9IHRoaXMuZmluaXNoTm9kZShjbGF1c2UsIFwiQ2F0Y2hDbGF1c2VcIik7XG4gICAgfVxuICAgIG5vZGUuZmluYWxpemVyID0gdGhpcy5lYXQoNjcpID8gdGhpcy5wYXJzZUJsb2NrKCkgOiBudWxsO1xuICAgIGlmICghbm9kZS5oYW5kbGVyICYmICFub2RlLmZpbmFsaXplcikge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTm9DYXRjaE9yRmluYWxseSwgbm9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUcnlTdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwga2luZCwgYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIgPSBmYWxzZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMucGFyc2VWYXIobm9kZSwgZmFsc2UsIGtpbmQsIGFsbG93TWlzc2luZ0luaXRpYWxpemVyKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpO1xuICB9XG4gIHBhcnNlV2hpbGVTdGF0ZW1lbnQobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUudGVzdCA9IHRoaXMucGFyc2VIZWFkZXJFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMud2l0aFNtYXJ0TWl4VG9waWNGb3JiaWRkaW5nQ29udGV4dCgoKSA9PiB0aGlzLnBhcnNlU3RhdGVtZW50KCkpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJXaGlsZVN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZVdpdGhTdGF0ZW1lbnQobm9kZSkge1xuICAgIGlmICh0aGlzLnN0YXRlLnN0cmljdCkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuU3RyaWN0V2l0aCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUub2JqZWN0ID0gdGhpcy5wYXJzZUhlYWRlckV4cHJlc3Npb24oKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLndpdGhTbWFydE1peFRvcGljRm9yYmlkZGluZ0NvbnRleHQoKCkgPT4gdGhpcy5wYXJzZVN0YXRlbWVudCgpKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2l0aFN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZUVtcHR5U3RhdGVtZW50KG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlTdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG1heWJlTmFtZSwgZXhwciwgZmxhZ3MpIHtcbiAgICBmb3IgKGNvbnN0IGxhYmVsIG9mIHRoaXMuc3RhdGUubGFiZWxzKSB7XG4gICAgICBpZiAobGFiZWwubmFtZSA9PT0gbWF5YmVOYW1lKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkxhYmVsUmVkZWNsYXJhdGlvbiwgZXhwciwge1xuICAgICAgICAgIGxhYmVsTmFtZTogbWF5YmVOYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBraW5kID0gdG9rZW5Jc0xvb3AodGhpcy5zdGF0ZS50eXBlKSA/IDEgOiB0aGlzLm1hdGNoKDcxKSA/IDIgOiBudWxsO1xuICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlLmxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLnN0YXRlLmxhYmVsc1tpXTtcbiAgICAgIGlmIChsYWJlbC5zdGF0ZW1lbnRTdGFydCA9PT0gbm9kZS5zdGFydCkge1xuICAgICAgICBsYWJlbC5zdGF0ZW1lbnRTdGFydCA9IHRoaXMuc291cmNlVG9PZmZzZXRQb3ModGhpcy5zdGF0ZS5zdGFydCk7XG4gICAgICAgIGxhYmVsLmtpbmQgPSBraW5kO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc3RhdGUubGFiZWxzLnB1c2goe1xuICAgICAgbmFtZTogbWF5YmVOYW1lLFxuICAgICAga2luZDoga2luZCxcbiAgICAgIHN0YXRlbWVudFN0YXJ0OiB0aGlzLnNvdXJjZVRvT2Zmc2V0UG9zKHRoaXMuc3RhdGUuc3RhcnQpXG4gICAgfSk7XG4gICAgbm9kZS5ib2R5ID0gZmxhZ3MgJiA4ID8gdGhpcy5wYXJzZVN0YXRlbWVudE9yU2xvcHB5QW5uZXhCRnVuY3Rpb25EZWNsYXJhdGlvbih0cnVlKSA6IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcbiAgICB0aGlzLnN0YXRlLmxhYmVscy5wb3AoKTtcbiAgICBub2RlLmxhYmVsID0gZXhwcjtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGFiZWxlZFN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwciwgZGVjb3JhdG9ycykge1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IGV4cHI7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZUJsb2NrKGFsbG93RGlyZWN0aXZlcyA9IGZhbHNlLCBjcmVhdGVOZXdMZXhpY2FsU2NvcGUgPSB0cnVlLCBhZnRlckJsb2NrUGFyc2UpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAoYWxsb3dEaXJlY3RpdmVzKSB7XG4gICAgICB0aGlzLnN0YXRlLnN0cmljdEVycm9ycy5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICBpZiAoY3JlYXRlTmV3TGV4aWNhbFNjb3BlKSB7XG4gICAgICB0aGlzLnNjb3BlLmVudGVyKDApO1xuICAgIH1cbiAgICB0aGlzLnBhcnNlQmxvY2tCb2R5KG5vZGUsIGFsbG93RGlyZWN0aXZlcywgZmFsc2UsIDgsIGFmdGVyQmxvY2tQYXJzZSk7XG4gICAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkge1xuICAgICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKTtcbiAgfVxuICBpc1ZhbGlkRGlyZWN0aXZlKHN0bXQpIHtcbiAgICByZXR1cm4gc3RtdC50eXBlID09PSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiAmJiBzdG10LmV4cHJlc3Npb24udHlwZSA9PT0gXCJTdHJpbmdMaXRlcmFsXCIgJiYgIXN0bXQuZXhwcmVzc2lvbi5leHRyYS5wYXJlbnRoZXNpemVkO1xuICB9XG4gIHBhcnNlQmxvY2tCb2R5KG5vZGUsIGFsbG93RGlyZWN0aXZlcywgdG9wTGV2ZWwsIGVuZCwgYWZ0ZXJCbG9ja1BhcnNlKSB7XG4gICAgY29uc3QgYm9keSA9IG5vZGUuYm9keSA9IFtdO1xuICAgIGNvbnN0IGRpcmVjdGl2ZXMgPSBub2RlLmRpcmVjdGl2ZXMgPSBbXTtcbiAgICB0aGlzLnBhcnNlQmxvY2tPck1vZHVsZUJsb2NrQm9keShib2R5LCBhbGxvd0RpcmVjdGl2ZXMgPyBkaXJlY3RpdmVzIDogdW5kZWZpbmVkLCB0b3BMZXZlbCwgZW5kLCBhZnRlckJsb2NrUGFyc2UpO1xuICB9XG4gIHBhcnNlQmxvY2tPck1vZHVsZUJsb2NrQm9keShib2R5LCBkaXJlY3RpdmVzLCB0b3BMZXZlbCwgZW5kLCBhZnRlckJsb2NrUGFyc2UpIHtcbiAgICBjb25zdCBvbGRTdHJpY3QgPSB0aGlzLnN0YXRlLnN0cmljdDtcbiAgICBsZXQgaGFzU3RyaWN0TW9kZURpcmVjdGl2ZSA9IGZhbHNlO1xuICAgIGxldCBwYXJzZWROb25EaXJlY3RpdmUgPSBmYWxzZTtcbiAgICB3aGlsZSAoIXRoaXMubWF0Y2goZW5kKSkge1xuICAgICAgY29uc3Qgc3RtdCA9IHRvcExldmVsID8gdGhpcy5wYXJzZU1vZHVsZUl0ZW0oKSA6IHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpO1xuICAgICAgaWYgKGRpcmVjdGl2ZXMgJiYgIXBhcnNlZE5vbkRpcmVjdGl2ZSkge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkRGlyZWN0aXZlKHN0bXQpKSB7XG4gICAgICAgICAgY29uc3QgZGlyZWN0aXZlID0gdGhpcy5zdG10VG9EaXJlY3RpdmUoc3RtdCk7XG4gICAgICAgICAgZGlyZWN0aXZlcy5wdXNoKGRpcmVjdGl2ZSk7XG4gICAgICAgICAgaWYgKCFoYXNTdHJpY3RNb2RlRGlyZWN0aXZlICYmIGRpcmVjdGl2ZS52YWx1ZS52YWx1ZSA9PT0gXCJ1c2Ugc3RyaWN0XCIpIHtcbiAgICAgICAgICAgIGhhc1N0cmljdE1vZGVEaXJlY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zZXRTdHJpY3QodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlZE5vbkRpcmVjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGUuc3RyaWN0RXJyb3JzLmNsZWFyKCk7XG4gICAgICB9XG4gICAgICBib2R5LnB1c2goc3RtdCk7XG4gICAgfVxuICAgIGFmdGVyQmxvY2tQYXJzZSA9PSBudWxsIHx8IGFmdGVyQmxvY2tQYXJzZS5jYWxsKHRoaXMsIGhhc1N0cmljdE1vZGVEaXJlY3RpdmUpO1xuICAgIGlmICghb2xkU3RyaWN0KSB7XG4gICAgICB0aGlzLnNldFN0cmljdChmYWxzZSk7XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICB9XG4gIHBhcnNlRm9yKG5vZGUsIGluaXQpIHtcbiAgICBub2RlLmluaXQgPSBpbml0O1xuICAgIHRoaXMuc2VtaWNvbG9uKGZhbHNlKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLm1hdGNoKDEzKSA/IG51bGwgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuc2VtaWNvbG9uKGZhbHNlKTtcbiAgICBub2RlLnVwZGF0ZSA9IHRoaXMubWF0Y2goMTEpID8gbnVsbCA6IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5leHBlY3QoMTEpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMud2l0aFNtYXJ0TWl4VG9waWNGb3JiaWRkaW5nQ29udGV4dCgoKSA9PiB0aGlzLnBhcnNlU3RhdGVtZW50KCkpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGb3JTdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VGb3JJbihub2RlLCBpbml0LCBhd2FpdEF0KSB7XG4gICAgY29uc3QgaXNGb3JJbiA9IHRoaXMubWF0Y2goNTgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmIChpc0ZvckluKSB7XG4gICAgICBpZiAoYXdhaXRBdCAhPT0gbnVsbCkgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmF3YWl0ID0gYXdhaXRBdCAhPT0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGluaXQudHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIgJiYgaW5pdC5kZWNsYXJhdGlvbnNbMF0uaW5pdCAhPSBudWxsICYmICghaXNGb3JJbiB8fCAhdGhpcy5vcHRpb25zLmFubmV4QiB8fCB0aGlzLnN0YXRlLnN0cmljdCB8fCBpbml0LmtpbmQgIT09IFwidmFyXCIgfHwgaW5pdC5kZWNsYXJhdGlvbnNbMF0uaWQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5Gb3JJbk9mTG9vcEluaXRpYWxpemVyLCBpbml0LCB7XG4gICAgICAgIHR5cGU6IGlzRm9ySW4gPyBcIkZvckluU3RhdGVtZW50XCIgOiBcIkZvck9mU3RhdGVtZW50XCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaW5pdC50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRMaHMsIGluaXQsIHtcbiAgICAgICAgYW5jZXN0b3I6IHtcbiAgICAgICAgICB0eXBlOiBcIkZvclN0YXRlbWVudFwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBub2RlLmxlZnQgPSBpbml0O1xuICAgIG5vZGUucmlnaHQgPSBpc0ZvckluID8gdGhpcy5wYXJzZUV4cHJlc3Npb24oKSA6IHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4oKTtcbiAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy53aXRoU21hcnRNaXhUb3BpY0ZvcmJpZGRpbmdDb250ZXh0KCgpID0+IHRoaXMucGFyc2VTdGF0ZW1lbnQoKSk7XG4gICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc0ZvckluID8gXCJGb3JJblN0YXRlbWVudFwiIDogXCJGb3JPZlN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZVZhcihub2RlLCBpc0Zvciwga2luZCwgYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IGRlY2xhcmF0aW9ucyA9IG5vZGUuZGVjbGFyYXRpb25zID0gW107XG4gICAgbm9kZS5raW5kID0ga2luZDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICBjb25zdCBkZWNsID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMucGFyc2VWYXJJZChkZWNsLCBraW5kKTtcbiAgICAgIGRlY2wuaW5pdCA9ICF0aGlzLmVhdCgyOSkgPyBudWxsIDogaXNGb3IgPyB0aGlzLnBhcnNlTWF5YmVBc3NpZ25EaXNhbGxvd0luKCkgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgICBpZiAoZGVjbC5pbml0ID09PSBudWxsICYmICFhbGxvd01pc3NpbmdJbml0aWFsaXplcikge1xuICAgICAgICBpZiAoZGVjbC5pZC50eXBlICE9PSBcIklkZW50aWZpZXJcIiAmJiAhKGlzRm9yICYmICh0aGlzLm1hdGNoKDU4KSB8fCB0aGlzLmlzQ29udGV4dHVhbCgxMDIpKSkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EZWNsYXJhdGlvbk1pc3NpbmdJbml0aWFsaXplciwgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jLCB7XG4gICAgICAgICAgICBraW5kOiBcImRlc3RydWN0dXJpbmdcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKChraW5kID09PSBcImNvbnN0XCIgfHwga2luZCA9PT0gXCJ1c2luZ1wiIHx8IGtpbmQgPT09IFwiYXdhaXQgdXNpbmdcIikgJiYgISh0aGlzLm1hdGNoKDU4KSB8fCB0aGlzLmlzQ29udGV4dHVhbCgxMDIpKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkRlY2xhcmF0aW9uTWlzc2luZ0luaXRpYWxpemVyLCB0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MsIHtcbiAgICAgICAgICAgIGtpbmRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVjbGFyYXRpb25zLnB1c2godGhpcy5maW5pc2hOb2RlKGRlY2wsIFwiVmFyaWFibGVEZWNsYXJhdG9yXCIpKTtcbiAgICAgIGlmICghdGhpcy5lYXQoMTIpKSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcGFyc2VWYXJJZChkZWNsLCBraW5kKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICBpZiAoa2luZCA9PT0gXCJ1c2luZ1wiIHx8IGtpbmQgPT09IFwiYXdhaXQgdXNpbmdcIikge1xuICAgICAgaWYgKGlkLnR5cGUgPT09IFwiQXJyYXlQYXR0ZXJuXCIgfHwgaWQudHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVXNpbmdEZWNsYXJhdGlvbkhhc0JpbmRpbmdQYXR0ZXJuLCBpZC5sb2Muc3RhcnQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNoZWNrTFZhbChpZCwge1xuICAgICAgdHlwZTogXCJWYXJpYWJsZURlY2xhcmF0b3JcIlxuICAgIH0sIGtpbmQgPT09IFwidmFyXCIgPyA1IDogODIwMSk7XG4gICAgZGVjbC5pZCA9IGlkO1xuICB9XG4gIHBhcnNlQXN5bmNGdW5jdGlvbkV4cHJlc3Npb24obm9kZSkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24obm9kZSwgOCk7XG4gIH1cbiAgcGFyc2VGdW5jdGlvbihub2RlLCBmbGFncyA9IDApIHtcbiAgICBjb25zdCBoYW5naW5nRGVjbGFyYXRpb24gPSBmbGFncyAmIDI7XG4gICAgY29uc3QgaXNEZWNsYXJhdGlvbiA9ICEhKGZsYWdzICYgMSk7XG4gICAgY29uc3QgcmVxdWlyZUlkID0gaXNEZWNsYXJhdGlvbiAmJiAhKGZsYWdzICYgNCk7XG4gICAgY29uc3QgaXNBc3luYyA9ICEhKGZsYWdzICYgOCk7XG4gICAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSwgaXNBc3luYyk7XG4gICAgaWYgKHRoaXMubWF0Y2goNTUpKSB7XG4gICAgICBpZiAoaGFuZ2luZ0RlY2xhcmF0aW9uKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkdlbmVyYXRvckluU2luZ2xlU3RhdGVtZW50Q29udGV4dCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICB9XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUuZ2VuZXJhdG9yID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzRGVjbGFyYXRpb24pIHtcbiAgICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlRnVuY3Rpb25JZChyZXF1aXJlSWQpO1xuICAgIH1cbiAgICBjb25zdCBvbGRNYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzO1xuICAgIHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycyA9IGZhbHNlO1xuICAgIHRoaXMuc2NvcGUuZW50ZXIoMik7XG4gICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBub2RlLmdlbmVyYXRvcikpO1xuICAgIGlmICghaXNEZWNsYXJhdGlvbikge1xuICAgICAgbm9kZS5pZCA9IHRoaXMucGFyc2VGdW5jdGlvbklkKCk7XG4gICAgfVxuICAgIHRoaXMucGFyc2VGdW5jdGlvblBhcmFtcyhub2RlLCBmYWxzZSk7XG4gICAgdGhpcy53aXRoU21hcnRNaXhUb3BpY0ZvcmJpZGRpbmdDb250ZXh0KCgpID0+IHtcbiAgICAgIHRoaXMucGFyc2VGdW5jdGlvbkJvZHlBbmRGaW5pc2gobm9kZSwgaXNEZWNsYXJhdGlvbiA/IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIDogXCJGdW5jdGlvbkV4cHJlc3Npb25cIik7XG4gICAgfSk7XG4gICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIGlmIChpc0RlY2xhcmF0aW9uICYmICFoYW5naW5nRGVjbGFyYXRpb24pIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJGdW5jdGlvblN0YXRlbWVudElkKG5vZGUpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSBvbGRNYXliZUluQXJyb3dQYXJhbWV0ZXJzO1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHBhcnNlRnVuY3Rpb25JZChyZXF1aXJlSWQpIHtcbiAgICByZXR1cm4gcmVxdWlyZUlkIHx8IHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkgPyB0aGlzLnBhcnNlSWRlbnRpZmllcigpIDogbnVsbDtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUsIGlzQ29uc3RydWN0b3IpIHtcbiAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZW50ZXIobmV3UGFyYW1ldGVyRGVjbGFyYXRpb25TY29wZSgpKTtcbiAgICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCgxMSwgNDEsIDIgfCAoaXNDb25zdHJ1Y3RvciA/IDQgOiAwKSk7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZXhpdCgpO1xuICB9XG4gIHJlZ2lzdGVyRnVuY3Rpb25TdGF0ZW1lbnRJZChub2RlKSB7XG4gICAgaWYgKCFub2RlLmlkKSByZXR1cm47XG4gICAgdGhpcy5zY29wZS5kZWNsYXJlTmFtZShub2RlLmlkLm5hbWUsICF0aGlzLm9wdGlvbnMuYW5uZXhCIHx8IHRoaXMuc3RhdGUuc3RyaWN0IHx8IG5vZGUuZ2VuZXJhdG9yIHx8IG5vZGUuYXN5bmMgPyB0aGlzLnNjb3BlLnRyZWF0RnVuY3Rpb25zQXNWYXIgPyA1IDogODIwMSA6IDE3LCBub2RlLmlkLmxvYy5zdGFydCk7XG4gIH1cbiAgcGFyc2VDbGFzcyhub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGNvbnN0IG9sZFN0cmljdCA9IHRoaXMuc3RhdGUuc3RyaWN0O1xuICAgIHRoaXMuc3RhdGUuc3RyaWN0ID0gdHJ1ZTtcbiAgICB0aGlzLnBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCk7XG4gICAgdGhpcy5wYXJzZUNsYXNzU3VwZXIobm9kZSk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUNsYXNzQm9keSghIW5vZGUuc3VwZXJDbGFzcywgb2xkU3RyaWN0KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzU3RhdGVtZW50ID8gXCJDbGFzc0RlY2xhcmF0aW9uXCIgOiBcIkNsYXNzRXhwcmVzc2lvblwiKTtcbiAgfVxuICBpc0NsYXNzUHJvcGVydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMjkpIHx8IHRoaXMubWF0Y2goMTMpIHx8IHRoaXMubWF0Y2goOCk7XG4gIH1cbiAgaXNDbGFzc01ldGhvZCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgxMCk7XG4gIH1cbiAgbmFtZUlzQ29uc3RydWN0b3Ioa2V5KSB7XG4gICAgcmV0dXJuIGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBrZXkubmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8IGtleS50eXBlID09PSBcIlN0cmluZ0xpdGVyYWxcIiAmJiBrZXkudmFsdWUgPT09IFwiY29uc3RydWN0b3JcIjtcbiAgfVxuICBpc05vbnN0YXRpY0NvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgIHJldHVybiAhbWV0aG9kLmNvbXB1dGVkICYmICFtZXRob2Quc3RhdGljICYmIHRoaXMubmFtZUlzQ29uc3RydWN0b3IobWV0aG9kLmtleSk7XG4gIH1cbiAgcGFyc2VDbGFzc0JvZHkoaGFkU3VwZXJDbGFzcywgb2xkU3RyaWN0KSB7XG4gICAgdGhpcy5jbGFzc1Njb3BlLmVudGVyKCk7XG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICBoYWRDb25zdHJ1Y3RvcjogZmFsc2UsXG4gICAgICBoYWRTdXBlckNsYXNzXG4gICAgfTtcbiAgICBsZXQgZGVjb3JhdG9ycyA9IFtdO1xuICAgIGNvbnN0IGNsYXNzQm9keSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY2xhc3NCb2R5LmJvZHkgPSBbXTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICB0aGlzLndpdGhTbWFydE1peFRvcGljRm9yYmlkZGluZ0NvbnRleHQoKCkgPT4ge1xuICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKDgpKSB7XG4gICAgICAgIGlmICh0aGlzLmVhdCgxMykpIHtcbiAgICAgICAgICBpZiAoZGVjb3JhdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5EZWNvcmF0b3JTZW1pY29sb24sIHRoaXMuc3RhdGUubGFzdFRva0VuZExvYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKDI2KSkge1xuICAgICAgICAgIGRlY29yYXRvcnMucHVzaCh0aGlzLnBhcnNlRGVjb3JhdG9yKCkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lbWJlciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCkge1xuICAgICAgICAgIG1lbWJlci5kZWNvcmF0b3JzID0gZGVjb3JhdG9ycztcbiAgICAgICAgICB0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbkZyb21Ob2RlKG1lbWJlciwgZGVjb3JhdG9yc1swXSk7XG4gICAgICAgICAgZGVjb3JhdG9ycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyc2VDbGFzc01lbWJlcihjbGFzc0JvZHksIG1lbWJlciwgc3RhdGUpO1xuICAgICAgICBpZiAobWVtYmVyLmtpbmQgPT09IFwiY29uc3RydWN0b3JcIiAmJiBtZW1iZXIuZGVjb3JhdG9ycyAmJiBtZW1iZXIuZGVjb3JhdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRGVjb3JhdG9yQ29uc3RydWN0b3IsIG1lbWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnN0YXRlLnN0cmljdCA9IG9sZFN0cmljdDtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAoZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlRyYWlsaW5nRGVjb3JhdG9yLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgdGhpcy5jbGFzc1Njb3BlLmV4aXQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKGNsYXNzQm9keSwgXCJDbGFzc0JvZHlcIik7XG4gIH1cbiAgcGFyc2VDbGFzc01lbWJlckZyb21Nb2RpZmllcihjbGFzc0JvZHksIG1lbWJlcikge1xuICAgIGNvbnN0IGtleSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgIGlmICh0aGlzLmlzQ2xhc3NNZXRob2QoKSkge1xuICAgICAgY29uc3QgbWV0aG9kID0gbWVtYmVyO1xuICAgICAgbWV0aG9kLmtpbmQgPSBcIm1ldGhvZFwiO1xuICAgICAgbWV0aG9kLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICBtZXRob2Qua2V5ID0ga2V5O1xuICAgICAgbWV0aG9kLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgdGhpcy5wdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NsYXNzUHJvcGVydHkoKSkge1xuICAgICAgY29uc3QgcHJvcCA9IG1lbWJlcjtcbiAgICAgIHByb3AuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgIHByb3Aua2V5ID0ga2V5O1xuICAgICAgcHJvcC5zdGF0aWMgPSBmYWxzZTtcbiAgICAgIGNsYXNzQm9keS5ib2R5LnB1c2godGhpcy5wYXJzZUNsYXNzUHJvcGVydHkocHJvcCkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRoaXMucmVzZXRQcmV2aW91c05vZGVUcmFpbGluZ0NvbW1lbnRzKGtleSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHBhcnNlQ2xhc3NNZW1iZXIoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlKSB7XG4gICAgY29uc3QgaXNTdGF0aWMgPSB0aGlzLmlzQ29udGV4dHVhbCgxMDYpO1xuICAgIGlmIChpc1N0YXRpYykge1xuICAgICAgaWYgKHRoaXMucGFyc2VDbGFzc01lbWJlckZyb21Nb2RpZmllcihjbGFzc0JvZHksIG1lbWJlcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZWF0KDUpKSB7XG4gICAgICAgIHRoaXMucGFyc2VDbGFzc1N0YXRpY0Jsb2NrKGNsYXNzQm9keSwgbWVtYmVyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnBhcnNlQ2xhc3NNZW1iZXJXaXRoSXNTdGF0aWMoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlLCBpc1N0YXRpYyk7XG4gIH1cbiAgcGFyc2VDbGFzc01lbWJlcldpdGhJc1N0YXRpYyhjbGFzc0JvZHksIG1lbWJlciwgc3RhdGUsIGlzU3RhdGljKSB7XG4gICAgY29uc3QgcHVibGljTWV0aG9kID0gbWVtYmVyO1xuICAgIGNvbnN0IHByaXZhdGVNZXRob2QgPSBtZW1iZXI7XG4gICAgY29uc3QgcHVibGljUHJvcCA9IG1lbWJlcjtcbiAgICBjb25zdCBwcml2YXRlUHJvcCA9IG1lbWJlcjtcbiAgICBjb25zdCBhY2Nlc3NvclByb3AgPSBtZW1iZXI7XG4gICAgY29uc3QgbWV0aG9kID0gcHVibGljTWV0aG9kO1xuICAgIGNvbnN0IHB1YmxpY01lbWJlciA9IHB1YmxpY01ldGhvZDtcbiAgICBtZW1iZXIuc3RhdGljID0gaXNTdGF0aWM7XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZVByZWZpeE9wZXJhdG9yKG1lbWJlcik7XG4gICAgaWYgKHRoaXMuZWF0KDU1KSkge1xuICAgICAgbWV0aG9kLmtpbmQgPSBcIm1ldGhvZFwiO1xuICAgICAgY29uc3QgaXNQcml2YXRlTmFtZSA9IHRoaXMubWF0Y2goMTM5KTtcbiAgICAgIHRoaXMucGFyc2VDbGFzc0VsZW1lbnROYW1lKG1ldGhvZCk7XG4gICAgICBpZiAoaXNQcml2YXRlTmFtZSkge1xuICAgICAgICB0aGlzLnB1c2hDbGFzc1ByaXZhdGVNZXRob2QoY2xhc3NCb2R5LCBwcml2YXRlTWV0aG9kLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzTm9uc3RhdGljQ29uc3RydWN0b3IocHVibGljTWV0aG9kKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Db25zdHJ1Y3RvcklzR2VuZXJhdG9yLCBwdWJsaWNNZXRob2Qua2V5KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHVzaENsYXNzTWV0aG9kKGNsYXNzQm9keSwgcHVibGljTWV0aG9kLCB0cnVlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNDb250ZXh0dWFsID0gIXRoaXMuc3RhdGUuY29udGFpbnNFc2MgJiYgdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKTtcbiAgICBjb25zdCBrZXkgPSB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TmFtZShtZW1iZXIpO1xuICAgIGNvbnN0IG1heWJlQ29udGV4dHVhbEt3ID0gaXNDb250ZXh0dWFsID8ga2V5Lm5hbWUgOiBudWxsO1xuICAgIGNvbnN0IGlzUHJpdmF0ZSA9IHRoaXMuaXNQcml2YXRlTmFtZShrZXkpO1xuICAgIGNvbnN0IG1heWJlUXVlc3Rpb25Ub2tlblN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICB0aGlzLnBhcnNlUG9zdE1lbWJlck5hbWVNb2RpZmllcnMocHVibGljTWVtYmVyKTtcbiAgICBpZiAodGhpcy5pc0NsYXNzTWV0aG9kKCkpIHtcbiAgICAgIG1ldGhvZC5raW5kID0gXCJtZXRob2RcIjtcbiAgICAgIGlmIChpc1ByaXZhdGUpIHtcbiAgICAgICAgdGhpcy5wdXNoQ2xhc3NQcml2YXRlTWV0aG9kKGNsYXNzQm9keSwgcHJpdmF0ZU1ldGhvZCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNDb25zdHJ1Y3RvciA9IHRoaXMuaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihwdWJsaWNNZXRob2QpO1xuICAgICAgbGV0IGFsbG93c0RpcmVjdFN1cGVyID0gZmFsc2U7XG4gICAgICBpZiAoaXNDb25zdHJ1Y3Rvcikge1xuICAgICAgICBwdWJsaWNNZXRob2Qua2luZCA9IFwiY29uc3RydWN0b3JcIjtcbiAgICAgICAgaWYgKHN0YXRlLmhhZENvbnN0cnVjdG9yICYmICF0aGlzLmhhc1BsdWdpbihcInR5cGVzY3JpcHRcIikpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EdXBsaWNhdGVDb25zdHJ1Y3Rvciwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDb25zdHJ1Y3RvciAmJiB0aGlzLmhhc1BsdWdpbihcInR5cGVzY3JpcHRcIikgJiYgbWVtYmVyLm92ZXJyaWRlKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuT3ZlcnJpZGVPbkNvbnN0cnVjdG9yLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmhhZENvbnN0cnVjdG9yID0gdHJ1ZTtcbiAgICAgICAgYWxsb3dzRGlyZWN0U3VwZXIgPSBzdGF0ZS5oYWRTdXBlckNsYXNzO1xuICAgICAgfVxuICAgICAgdGhpcy5wdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBwdWJsaWNNZXRob2QsIGZhbHNlLCBmYWxzZSwgaXNDb25zdHJ1Y3RvciwgYWxsb3dzRGlyZWN0U3VwZXIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NsYXNzUHJvcGVydHkoKSkge1xuICAgICAgaWYgKGlzUHJpdmF0ZSkge1xuICAgICAgICB0aGlzLnB1c2hDbGFzc1ByaXZhdGVQcm9wZXJ0eShjbGFzc0JvZHksIHByaXZhdGVQcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHVzaENsYXNzUHJvcGVydHkoY2xhc3NCb2R5LCBwdWJsaWNQcm9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1heWJlQ29udGV4dHVhbEt3ID09PSBcImFzeW5jXCIgJiYgIXRoaXMuaXNMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICB0aGlzLnJlc2V0UHJldmlvdXNOb2RlVHJhaWxpbmdDb21tZW50cyhrZXkpO1xuICAgICAgY29uc3QgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCg1NSk7XG4gICAgICBpZiAocHVibGljTWVtYmVyLm9wdGlvbmFsKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZChtYXliZVF1ZXN0aW9uVG9rZW5TdGFydExvYyk7XG4gICAgICB9XG4gICAgICBtZXRob2Qua2luZCA9IFwibWV0aG9kXCI7XG4gICAgICBjb25zdCBpc1ByaXZhdGUgPSB0aGlzLm1hdGNoKDEzOSk7XG4gICAgICB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TmFtZShtZXRob2QpO1xuICAgICAgdGhpcy5wYXJzZVBvc3RNZW1iZXJOYW1lTW9kaWZpZXJzKHB1YmxpY01lbWJlcik7XG4gICAgICBpZiAoaXNQcml2YXRlKSB7XG4gICAgICAgIHRoaXMucHVzaENsYXNzUHJpdmF0ZU1ldGhvZChjbGFzc0JvZHksIHByaXZhdGVNZXRob2QsIGlzR2VuZXJhdG9yLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmlzTm9uc3RhdGljQ29uc3RydWN0b3IocHVibGljTWV0aG9kKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkNvbnN0cnVjdG9ySXNBc3luYywgcHVibGljTWV0aG9kLmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBwdWJsaWNNZXRob2QsIGlzR2VuZXJhdG9yLCB0cnVlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKG1heWJlQ29udGV4dHVhbEt3ID09PSBcImdldFwiIHx8IG1heWJlQ29udGV4dHVhbEt3ID09PSBcInNldFwiKSAmJiAhKHRoaXMubWF0Y2goNTUpICYmIHRoaXMuaXNMaW5lVGVybWluYXRvcigpKSkge1xuICAgICAgdGhpcy5yZXNldFByZXZpb3VzTm9kZVRyYWlsaW5nQ29tbWVudHMoa2V5KTtcbiAgICAgIG1ldGhvZC5raW5kID0gbWF5YmVDb250ZXh0dWFsS3c7XG4gICAgICBjb25zdCBpc1ByaXZhdGUgPSB0aGlzLm1hdGNoKDEzOSk7XG4gICAgICB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TmFtZShwdWJsaWNNZXRob2QpO1xuICAgICAgaWYgKGlzUHJpdmF0ZSkge1xuICAgICAgICB0aGlzLnB1c2hDbGFzc1ByaXZhdGVNZXRob2QoY2xhc3NCb2R5LCBwcml2YXRlTWV0aG9kLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihwdWJsaWNNZXRob2QpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQ29uc3RydWN0b3JJc0FjY2Vzc29yLCBwdWJsaWNNZXRob2Qua2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1c2hDbGFzc01ldGhvZChjbGFzc0JvZHksIHB1YmxpY01ldGhvZCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGVja0dldHRlclNldHRlclBhcmFtcyhwdWJsaWNNZXRob2QpO1xuICAgIH0gZWxzZSBpZiAobWF5YmVDb250ZXh0dWFsS3cgPT09IFwiYWNjZXNzb3JcIiAmJiAhdGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiZGVjb3JhdG9yQXV0b0FjY2Vzc29yc1wiKTtcbiAgICAgIHRoaXMucmVzZXRQcmV2aW91c05vZGVUcmFpbGluZ0NvbW1lbnRzKGtleSk7XG4gICAgICBjb25zdCBpc1ByaXZhdGUgPSB0aGlzLm1hdGNoKDEzOSk7XG4gICAgICB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TmFtZShwdWJsaWNQcm9wKTtcbiAgICAgIHRoaXMucHVzaENsYXNzQWNjZXNzb3JQcm9wZXJ0eShjbGFzc0JvZHksIGFjY2Vzc29yUHJvcCwgaXNQcml2YXRlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICBpZiAoaXNQcml2YXRlKSB7XG4gICAgICAgIHRoaXMucHVzaENsYXNzUHJpdmF0ZVByb3BlcnR5KGNsYXNzQm9keSwgcHJpdmF0ZVByb3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wdXNoQ2xhc3NQcm9wZXJ0eShjbGFzc0JvZHksIHB1YmxpY1Byb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VDbGFzc0VsZW1lbnROYW1lKG1lbWJlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICB2YWx1ZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICgodHlwZSA9PT0gMTMyIHx8IHR5cGUgPT09IDEzNCkgJiYgbWVtYmVyLnN0YXRpYyAmJiB2YWx1ZSA9PT0gXCJwcm90b3R5cGVcIikge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuU3RhdGljUHJvdG90eXBlLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IDEzOSkge1xuICAgICAgaWYgKHZhbHVlID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQ29uc3RydWN0b3JDbGFzc1ByaXZhdGVGaWVsZCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICB9XG4gICAgICBjb25zdCBrZXkgPSB0aGlzLnBhcnNlUHJpdmF0ZU5hbWUoKTtcbiAgICAgIG1lbWJlci5rZXkgPSBrZXk7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKG1lbWJlcik7XG4gICAgcmV0dXJuIG1lbWJlci5rZXk7XG4gIH1cbiAgcGFyc2VDbGFzc1N0YXRpY0Jsb2NrKGNsYXNzQm9keSwgbWVtYmVyKSB7XG4gICAgdmFyIF9tZW1iZXIkZGVjb3JhdG9ycztcbiAgICB0aGlzLnNjb3BlLmVudGVyKDY0IHwgMTI4IHwgMTYpO1xuICAgIGNvbnN0IG9sZExhYmVscyA9IHRoaXMuc3RhdGUubGFiZWxzO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzID0gW107XG4gICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoMCk7XG4gICAgY29uc3QgYm9keSA9IG1lbWJlci5ib2R5ID0gW107XG4gICAgdGhpcy5wYXJzZUJsb2NrT3JNb2R1bGVCbG9ja0JvZHkoYm9keSwgdW5kZWZpbmVkLCBmYWxzZSwgOCk7XG4gICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzID0gb2xkTGFiZWxzO1xuICAgIGNsYXNzQm9keS5ib2R5LnB1c2godGhpcy5maW5pc2hOb2RlKG1lbWJlciwgXCJTdGF0aWNCbG9ja1wiKSk7XG4gICAgaWYgKChfbWVtYmVyJGRlY29yYXRvcnMgPSBtZW1iZXIuZGVjb3JhdG9ycykgIT0gbnVsbCAmJiBfbWVtYmVyJGRlY29yYXRvcnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5EZWNvcmF0b3JTdGF0aWNCbG9jaywgbWVtYmVyKTtcbiAgICB9XG4gIH1cbiAgcHVzaENsYXNzUHJvcGVydHkoY2xhc3NCb2R5LCBwcm9wKSB7XG4gICAgaWYgKCFwcm9wLmNvbXB1dGVkICYmIHRoaXMubmFtZUlzQ29uc3RydWN0b3IocHJvcC5rZXkpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5Db25zdHJ1Y3RvckNsYXNzRmllbGQsIHByb3Aua2V5KTtcbiAgICB9XG4gICAgY2xhc3NCb2R5LmJvZHkucHVzaCh0aGlzLnBhcnNlQ2xhc3NQcm9wZXJ0eShwcm9wKSk7XG4gIH1cbiAgcHVzaENsYXNzUHJpdmF0ZVByb3BlcnR5KGNsYXNzQm9keSwgcHJvcCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhcnNlQ2xhc3NQcml2YXRlUHJvcGVydHkocHJvcCk7XG4gICAgY2xhc3NCb2R5LmJvZHkucHVzaChub2RlKTtcbiAgICB0aGlzLmNsYXNzU2NvcGUuZGVjbGFyZVByaXZhdGVOYW1lKHRoaXMuZ2V0UHJpdmF0ZU5hbWVTVihub2RlLmtleSksIDAsIG5vZGUua2V5LmxvYy5zdGFydCk7XG4gIH1cbiAgcHVzaENsYXNzQWNjZXNzb3JQcm9wZXJ0eShjbGFzc0JvZHksIHByb3AsIGlzUHJpdmF0ZSkge1xuICAgIGlmICghaXNQcml2YXRlICYmICFwcm9wLmNvbXB1dGVkICYmIHRoaXMubmFtZUlzQ29uc3RydWN0b3IocHJvcC5rZXkpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5Db25zdHJ1Y3RvckNsYXNzRmllbGQsIHByb3Aua2V5KTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMucGFyc2VDbGFzc0FjY2Vzc29yUHJvcGVydHkocHJvcCk7XG4gICAgY2xhc3NCb2R5LmJvZHkucHVzaChub2RlKTtcbiAgICBpZiAoaXNQcml2YXRlKSB7XG4gICAgICB0aGlzLmNsYXNzU2NvcGUuZGVjbGFyZVByaXZhdGVOYW1lKHRoaXMuZ2V0UHJpdmF0ZU5hbWVTVihub2RlLmtleSksIDAsIG5vZGUua2V5LmxvYy5zdGFydCk7XG4gICAgfVxuICB9XG4gIHB1c2hDbGFzc01ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93c0RpcmVjdFN1cGVyKSB7XG4gICAgY2xhc3NCb2R5LmJvZHkucHVzaCh0aGlzLnBhcnNlTWV0aG9kKG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93c0RpcmVjdFN1cGVyLCBcIkNsYXNzTWV0aG9kXCIsIHRydWUpKTtcbiAgfVxuICBwdXNoQ2xhc3NQcml2YXRlTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhcnNlTWV0aG9kKG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGZhbHNlLCBmYWxzZSwgXCJDbGFzc1ByaXZhdGVNZXRob2RcIiwgdHJ1ZSk7XG4gICAgY2xhc3NCb2R5LmJvZHkucHVzaChub2RlKTtcbiAgICBjb25zdCBraW5kID0gbm9kZS5raW5kID09PSBcImdldFwiID8gbm9kZS5zdGF0aWMgPyA2IDogMiA6IG5vZGUua2luZCA9PT0gXCJzZXRcIiA/IG5vZGUuc3RhdGljID8gNSA6IDEgOiAwO1xuICAgIHRoaXMuZGVjbGFyZUNsYXNzUHJpdmF0ZU1ldGhvZEluU2NvcGUobm9kZSwga2luZCk7XG4gIH1cbiAgZGVjbGFyZUNsYXNzUHJpdmF0ZU1ldGhvZEluU2NvcGUobm9kZSwga2luZCkge1xuICAgIHRoaXMuY2xhc3NTY29wZS5kZWNsYXJlUHJpdmF0ZU5hbWUodGhpcy5nZXRQcml2YXRlTmFtZVNWKG5vZGUua2V5KSwga2luZCwgbm9kZS5rZXkubG9jLnN0YXJ0KTtcbiAgfVxuICBwYXJzZVBvc3RNZW1iZXJOYW1lTW9kaWZpZXJzKG1ldGhvZE9yUHJvcCkge31cbiAgcGFyc2VDbGFzc1ByaXZhdGVQcm9wZXJ0eShub2RlKSB7XG4gICAgdGhpcy5wYXJzZUluaXRpYWxpemVyKG5vZGUpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIpO1xuICB9XG4gIHBhcnNlQ2xhc3NQcm9wZXJ0eShub2RlKSB7XG4gICAgdGhpcy5wYXJzZUluaXRpYWxpemVyKG5vZGUpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNsYXNzUHJvcGVydHlcIik7XG4gIH1cbiAgcGFyc2VDbGFzc0FjY2Vzc29yUHJvcGVydHkobm9kZSkge1xuICAgIHRoaXMucGFyc2VJbml0aWFsaXplcihub2RlKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDbGFzc0FjY2Vzc29yUHJvcGVydHlcIik7XG4gIH1cbiAgcGFyc2VJbml0aWFsaXplcihub2RlKSB7XG4gICAgdGhpcy5zY29wZS5lbnRlcig2NCB8IDE2KTtcbiAgICB0aGlzLmV4cHJlc3Npb25TY29wZS5lbnRlcihuZXdFeHByZXNzaW9uU2NvcGUoKSk7XG4gICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoMCk7XG4gICAgbm9kZS52YWx1ZSA9IHRoaXMuZWF0KDI5KSA/IHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4oKSA6IG51bGw7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZXhpdCgpO1xuICAgIHRoaXMucHJvZFBhcmFtLmV4aXQoKTtcbiAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgfVxuICBwYXJzZUNsYXNzSWQobm9kZSwgaXNTdGF0ZW1lbnQsIG9wdGlvbmFsSWQsIGJpbmRpbmdUeXBlID0gODMzMSkge1xuICAgIGlmICh0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgIGlmIChpc1N0YXRlbWVudCkge1xuICAgICAgICB0aGlzLmRlY2xhcmVOYW1lRnJvbUlkZW50aWZpZXIobm9kZS5pZCwgYmluZGluZ1R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9uYWxJZCB8fCAhaXNTdGF0ZW1lbnQpIHtcbiAgICAgICAgbm9kZS5pZCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5NaXNzaW5nQ2xhc3NOYW1lLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGFyc2VDbGFzc1N1cGVyKG5vZGUpIHtcbiAgICBub2RlLnN1cGVyQ2xhc3MgPSB0aGlzLmVhdCg4MSkgPyB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMoKSA6IG51bGw7XG4gIH1cbiAgcGFyc2VFeHBvcnQobm9kZSwgZGVjb3JhdG9ycykge1xuICAgIGNvbnN0IG1heWJlRGVmYXVsdElkZW50aWZpZXIgPSB0aGlzLnBhcnNlTWF5YmVJbXBvcnRQaGFzZShub2RlLCB0cnVlKTtcbiAgICBjb25zdCBoYXNEZWZhdWx0ID0gdGhpcy5tYXliZVBhcnNlRXhwb3J0RGVmYXVsdFNwZWNpZmllcihub2RlLCBtYXliZURlZmF1bHRJZGVudGlmaWVyKTtcbiAgICBjb25zdCBwYXJzZUFmdGVyRGVmYXVsdCA9ICFoYXNEZWZhdWx0IHx8IHRoaXMuZWF0KDEyKTtcbiAgICBjb25zdCBoYXNTdGFyID0gcGFyc2VBZnRlckRlZmF1bHQgJiYgdGhpcy5lYXRFeHBvcnRTdGFyKG5vZGUpO1xuICAgIGNvbnN0IGhhc05hbWVzcGFjZSA9IGhhc1N0YXIgJiYgdGhpcy5tYXliZVBhcnNlRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyKG5vZGUpO1xuICAgIGNvbnN0IHBhcnNlQWZ0ZXJOYW1lc3BhY2UgPSBwYXJzZUFmdGVyRGVmYXVsdCAmJiAoIWhhc05hbWVzcGFjZSB8fCB0aGlzLmVhdCgxMikpO1xuICAgIGNvbnN0IGlzRnJvbVJlcXVpcmVkID0gaGFzRGVmYXVsdCB8fCBoYXNTdGFyO1xuICAgIGlmIChoYXNTdGFyICYmICFoYXNOYW1lc3BhY2UpIHtcbiAgICAgIGlmIChoYXNEZWZhdWx0KSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIGlmIChkZWNvcmF0b3JzKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVuc3VwcG9ydGVkRGVjb3JhdG9yRXhwb3J0LCBub2RlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFyc2VFeHBvcnRGcm9tKG5vZGUsIHRydWUpO1xuICAgICAgdGhpcy5zYXdVbmFtYmlndW91c0VTTSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIik7XG4gICAgfVxuICAgIGNvbnN0IGhhc1NwZWNpZmllcnMgPSB0aGlzLm1heWJlUGFyc2VFeHBvcnROYW1lZFNwZWNpZmllcnMobm9kZSk7XG4gICAgaWYgKGhhc0RlZmF1bHQgJiYgcGFyc2VBZnRlckRlZmF1bHQgJiYgIWhhc1N0YXIgJiYgIWhhc1NwZWNpZmllcnMpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCA1KTtcbiAgICB9XG4gICAgaWYgKGhhc05hbWVzcGFjZSAmJiBwYXJzZUFmdGVyTmFtZXNwYWNlKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQobnVsbCwgOTgpO1xuICAgIH1cbiAgICBsZXQgaGFzRGVjbGFyYXRpb247XG4gICAgaWYgKGlzRnJvbVJlcXVpcmVkIHx8IGhhc1NwZWNpZmllcnMpIHtcbiAgICAgIGhhc0RlY2xhcmF0aW9uID0gZmFsc2U7XG4gICAgICBpZiAoZGVjb3JhdG9ycykge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbnN1cHBvcnRlZERlY29yYXRvckV4cG9ydCwgbm9kZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnBhcnNlRXhwb3J0RnJvbShub2RlLCBpc0Zyb21SZXF1aXJlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhc0RlY2xhcmF0aW9uID0gdGhpcy5tYXliZVBhcnNlRXhwb3J0RGVjbGFyYXRpb24obm9kZSk7XG4gICAgfVxuICAgIGlmIChpc0Zyb21SZXF1aXJlZCB8fCBoYXNTcGVjaWZpZXJzIHx8IGhhc0RlY2xhcmF0aW9uKSB7XG4gICAgICB2YXIgX25vZGUyJGRlY2xhcmF0aW9uO1xuICAgICAgY29uc3Qgbm9kZTIgPSBub2RlO1xuICAgICAgdGhpcy5jaGVja0V4cG9ydChub2RlMiwgdHJ1ZSwgZmFsc2UsICEhbm9kZTIuc291cmNlKTtcbiAgICAgIGlmICgoKF9ub2RlMiRkZWNsYXJhdGlvbiA9IG5vZGUyLmRlY2xhcmF0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUyJGRlY2xhcmF0aW9uLnR5cGUpID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIikge1xuICAgICAgICB0aGlzLm1heWJlVGFrZURlY29yYXRvcnMoZGVjb3JhdG9ycywgbm9kZTIuZGVjbGFyYXRpb24sIG5vZGUyKTtcbiAgICAgIH0gZWxzZSBpZiAoZGVjb3JhdG9ycykge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbnN1cHBvcnRlZERlY29yYXRvckV4cG9ydCwgbm9kZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNhd1VuYW1iaWd1b3VzRVNNID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZTIsIFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZWF0KDY1KSkge1xuICAgICAgY29uc3Qgbm9kZTIgPSBub2RlO1xuICAgICAgY29uc3QgZGVjbCA9IHRoaXMucGFyc2VFeHBvcnREZWZhdWx0RXhwcmVzc2lvbigpO1xuICAgICAgbm9kZTIuZGVjbGFyYXRpb24gPSBkZWNsO1xuICAgICAgaWYgKGRlY2wudHlwZSA9PT0gXCJDbGFzc0RlY2xhcmF0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5tYXliZVRha2VEZWNvcmF0b3JzKGRlY29yYXRvcnMsIGRlY2wsIG5vZGUyKTtcbiAgICAgIH0gZWxzZSBpZiAoZGVjb3JhdG9ycykge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbnN1cHBvcnRlZERlY29yYXRvckV4cG9ydCwgbm9kZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNoZWNrRXhwb3J0KG5vZGUyLCB0cnVlLCB0cnVlKTtcbiAgICAgIHRoaXMuc2F3VW5hbWJpZ3VvdXNFU00gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlMiwgXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIik7XG4gICAgfVxuICAgIHRoaXMudW5leHBlY3RlZChudWxsLCA1KTtcbiAgfVxuICBlYXRFeHBvcnRTdGFyKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5lYXQoNTUpO1xuICB9XG4gIG1heWJlUGFyc2VFeHBvcnREZWZhdWx0U3BlY2lmaWVyKG5vZGUsIG1heWJlRGVmYXVsdElkZW50aWZpZXIpIHtcbiAgICBpZiAobWF5YmVEZWZhdWx0SWRlbnRpZmllciB8fCB0aGlzLmlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcigpKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcImV4cG9ydERlZmF1bHRGcm9tXCIsIG1heWJlRGVmYXVsdElkZW50aWZpZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG1heWJlRGVmYXVsdElkZW50aWZpZXIubG9jLnN0YXJ0KTtcbiAgICAgIGNvbnN0IGlkID0gbWF5YmVEZWZhdWx0SWRlbnRpZmllciB8fCB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgIGNvbnN0IHNwZWNpZmllciA9IHRoaXMuc3RhcnROb2RlQXROb2RlKGlkKTtcbiAgICAgIHNwZWNpZmllci5leHBvcnRlZCA9IGlkO1xuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gW3RoaXMuZmluaXNoTm9kZShzcGVjaWZpZXIsIFwiRXhwb3J0RGVmYXVsdFNwZWNpZmllclwiKV07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG1heWJlUGFyc2VFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXIobm9kZSkge1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCg5MykpIHtcbiAgICAgIHZhciBfcmVmLCBfcmVmJHNwZWNpZmllcnM7XG4gICAgICAoX3JlZiRzcGVjaWZpZXJzID0gKF9yZWYgPSBub2RlKS5zcGVjaWZpZXJzKSAhPSBudWxsID8gX3JlZiRzcGVjaWZpZXJzIDogX3JlZi5zcGVjaWZpZXJzID0gW107XG4gICAgICBjb25zdCBzcGVjaWZpZXIgPSB0aGlzLnN0YXJ0Tm9kZUF0KHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgc3BlY2lmaWVyLmV4cG9ydGVkID0gdGhpcy5wYXJzZU1vZHVsZUV4cG9ydE5hbWUoKTtcbiAgICAgIG5vZGUuc3BlY2lmaWVycy5wdXNoKHRoaXMuZmluaXNoTm9kZShzcGVjaWZpZXIsIFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWF5YmVQYXJzZUV4cG9ydE5hbWVkU3BlY2lmaWVycyhub2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goNSkpIHtcbiAgICAgIGNvbnN0IG5vZGUyID0gbm9kZTtcbiAgICAgIGlmICghbm9kZTIuc3BlY2lmaWVycykgbm9kZTIuc3BlY2lmaWVycyA9IFtdO1xuICAgICAgY29uc3QgaXNUeXBlRXhwb3J0ID0gbm9kZTIuZXhwb3J0S2luZCA9PT0gXCJ0eXBlXCI7XG4gICAgICBub2RlMi5zcGVjaWZpZXJzLnB1c2goLi4udGhpcy5wYXJzZUV4cG9ydFNwZWNpZmllcnMoaXNUeXBlRXhwb3J0KSk7XG4gICAgICBub2RlMi5zb3VyY2UgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiaW1wb3J0QXNzZXJ0aW9uc1wiKSkge1xuICAgICAgICBub2RlMi5hc3NlcnRpb25zID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlMi5hdHRyaWJ1dGVzID0gW107XG4gICAgICB9XG4gICAgICBub2RlMi5kZWNsYXJhdGlvbiA9IG51bGw7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG1heWJlUGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKSB7XG4gICAgaWYgKHRoaXMuc2hvdWxkUGFyc2VFeHBvcnREZWNsYXJhdGlvbigpKSB7XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSBbXTtcbiAgICAgIG5vZGUuc291cmNlID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImltcG9ydEFzc2VydGlvbnNcIikpIHtcbiAgICAgICAgbm9kZS5hc3NlcnRpb25zID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlRXhwb3J0RGVjbGFyYXRpb24obm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlzQXN5bmNGdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKDk1KSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlbkluTGluZVN0YXJ0KCk7XG4gICAgcmV0dXJuIHRoaXMuaXNVbnBhcnNlZENvbnRleHR1YWwobmV4dCwgXCJmdW5jdGlvblwiKTtcbiAgfVxuICBwYXJzZUV4cG9ydERlZmF1bHRFeHByZXNzaW9uKCkge1xuICAgIGNvbnN0IGV4cHIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGlmICh0aGlzLm1hdGNoKDY4KSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKGV4cHIsIDEgfCA0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNBc3luY0Z1bmN0aW9uKCkpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKGV4cHIsIDEgfCA0IHwgOCk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDgwKSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyhleHByLCB0cnVlLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goMjYpKSB7XG4gICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJkZWNvcmF0b3JzXCIpICYmIHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZGVjb3JhdG9yc1wiLCBcImRlY29yYXRvcnNCZWZvcmVFeHBvcnRcIikgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRGVjb3JhdG9yQmVmb3JlRXhwb3J0LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3ModGhpcy5tYXliZVRha2VEZWNvcmF0b3JzKHRoaXMucGFyc2VEZWNvcmF0b3JzKGZhbHNlKSwgdGhpcy5zdGFydE5vZGUoKSksIHRydWUsIHRydWUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCg3NSkgfHwgdGhpcy5tYXRjaCg3NCkgfHwgdGhpcy5pc0xldCgpKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbnN1cHBvcnRlZERlZmF1bHRFeHBvcnQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIHBhcnNlRXhwb3J0RGVjbGFyYXRpb24obm9kZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDgwKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMucGFyc2VDbGFzcyh0aGlzLnN0YXJ0Tm9kZSgpLCB0cnVlLCBmYWxzZSk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpO1xuICB9XG4gIGlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcigpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHRva2VuSXNJZGVudGlmaWVyKHR5cGUpKSB7XG4gICAgICBpZiAodHlwZSA9PT0gOTUgJiYgIXRoaXMuc3RhdGUuY29udGFpbnNFc2MgfHwgdHlwZSA9PT0gMTAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICgodHlwZSA9PT0gMTMwIHx8IHR5cGUgPT09IDEyOSkgJiYgIXRoaXMuc3RhdGUuY29udGFpbnNFc2MpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHR5cGU6IG5leHRUeXBlXG4gICAgICAgIH0gPSB0aGlzLmxvb2thaGVhZCgpO1xuICAgICAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIobmV4dFR5cGUpICYmIG5leHRUeXBlICE9PSA5OCB8fCBuZXh0VHlwZSA9PT0gNSkge1xuICAgICAgICAgIHRoaXMuZXhwZWN0T25lUGx1Z2luKFtcImZsb3dcIiwgXCJ0eXBlc2NyaXB0XCJdKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCF0aGlzLm1hdGNoKDY1KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBuZXh0ID0gdGhpcy5uZXh0VG9rZW5TdGFydCgpO1xuICAgIGNvbnN0IGhhc0Zyb20gPSB0aGlzLmlzVW5wYXJzZWRDb250ZXh0dWFsKG5leHQsIFwiZnJvbVwiKTtcbiAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpID09PSA0NCB8fCB0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpICYmIGhhc0Zyb20pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCg2NSkgJiYgaGFzRnJvbSkge1xuICAgICAgY29uc3QgbmV4dEFmdGVyRnJvbSA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLm5leHRUb2tlblN0YXJ0U2luY2UobmV4dCArIDQpKTtcbiAgICAgIHJldHVybiBuZXh0QWZ0ZXJGcm9tID09PSAzNCB8fCBuZXh0QWZ0ZXJGcm9tID09PSAzOTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHBhcnNlRXhwb3J0RnJvbShub2RlLCBleHBlY3QpIHtcbiAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKDk4KSkge1xuICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlSW1wb3J0U291cmNlKCk7XG4gICAgICB0aGlzLmNoZWNrRXhwb3J0KG5vZGUpO1xuICAgICAgdGhpcy5tYXliZVBhcnNlSW1wb3J0QXR0cmlidXRlcyhub2RlKTtcbiAgICAgIHRoaXMuY2hlY2tKU09OTW9kdWxlSW1wb3J0KG5vZGUpO1xuICAgIH0gZWxzZSBpZiAoZXhwZWN0KSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgfVxuICBzaG91bGRQYXJzZUV4cG9ydERlY2xhcmF0aW9uKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodHlwZSA9PT0gMjYpIHtcbiAgICAgIHRoaXMuZXhwZWN0T25lUGx1Z2luKFtcImRlY29yYXRvcnNcIiwgXCJkZWNvcmF0b3JzLWxlZ2FjeVwiXSk7XG4gICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJkZWNvcmF0b3JzXCIpKSB7XG4gICAgICAgIGlmICh0aGlzLmdldFBsdWdpbk9wdGlvbihcImRlY29yYXRvcnNcIiwgXCJkZWNvcmF0b3JzQmVmb3JlRXhwb3J0XCIpID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRGVjb3JhdG9yQmVmb3JlRXhwb3J0LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEwNykpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVzaW5nRGVjbGFyYXRpb25FeHBvcnQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCg5NikgJiYgdGhpcy5zdGFydHNBd2FpdFVzaW5nKCkpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVzaW5nRGVjbGFyYXRpb25FeHBvcnQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0eXBlID09PSA3NCB8fCB0eXBlID09PSA3NSB8fCB0eXBlID09PSA2OCB8fCB0eXBlID09PSA4MCB8fCB0aGlzLmlzTGV0KCkgfHwgdGhpcy5pc0FzeW5jRnVuY3Rpb24oKTtcbiAgfVxuICBjaGVja0V4cG9ydChub2RlLCBjaGVja05hbWVzLCBpc0RlZmF1bHQsIGlzRnJvbSkge1xuICAgIGlmIChjaGVja05hbWVzKSB7XG4gICAgICB2YXIgX25vZGUkc3BlY2lmaWVycztcbiAgICAgIGlmIChpc0RlZmF1bHQpIHtcbiAgICAgICAgdGhpcy5jaGVja0R1cGxpY2F0ZUV4cG9ydHMobm9kZSwgXCJkZWZhdWx0XCIpO1xuICAgICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJleHBvcnREZWZhdWx0RnJvbVwiKSkge1xuICAgICAgICAgIHZhciBfZGVjbGFyYXRpb24kZXh0cmE7XG4gICAgICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSBub2RlLmRlY2xhcmF0aW9uO1xuICAgICAgICAgIGlmIChkZWNsYXJhdGlvbi50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBkZWNsYXJhdGlvbi5uYW1lID09PSBcImZyb21cIiAmJiBkZWNsYXJhdGlvbi5lbmQgLSBkZWNsYXJhdGlvbi5zdGFydCA9PT0gNCAmJiAhKChfZGVjbGFyYXRpb24kZXh0cmEgPSBkZWNsYXJhdGlvbi5leHRyYSkgIT0gbnVsbCAmJiBfZGVjbGFyYXRpb24kZXh0cmEucGFyZW50aGVzaXplZCkpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkV4cG9ydERlZmF1bHRGcm9tQXNJZGVudGlmaWVyLCBkZWNsYXJhdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKChfbm9kZSRzcGVjaWZpZXJzID0gbm9kZS5zcGVjaWZpZXJzKSAhPSBudWxsICYmIF9ub2RlJHNwZWNpZmllcnMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3BlY2lmaWVyIG9mIG5vZGUuc3BlY2lmaWVycykge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGV4cG9ydGVkXG4gICAgICAgICAgfSA9IHNwZWNpZmllcjtcbiAgICAgICAgICBjb25zdCBleHBvcnROYW1lID0gZXhwb3J0ZWQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgPyBleHBvcnRlZC5uYW1lIDogZXhwb3J0ZWQudmFsdWU7XG4gICAgICAgICAgdGhpcy5jaGVja0R1cGxpY2F0ZUV4cG9ydHMoc3BlY2lmaWVyLCBleHBvcnROYW1lKTtcbiAgICAgICAgICBpZiAoIWlzRnJvbSAmJiBzcGVjaWZpZXIubG9jYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgbG9jYWxcbiAgICAgICAgICAgIH0gPSBzcGVjaWZpZXI7XG4gICAgICAgICAgICBpZiAobG9jYWwudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRXhwb3J0QmluZGluZ0lzU3RyaW5nLCBzcGVjaWZpZXIsIHtcbiAgICAgICAgICAgICAgICBsb2NhbE5hbWU6IGxvY2FsLnZhbHVlLFxuICAgICAgICAgICAgICAgIGV4cG9ydE5hbWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmNoZWNrUmVzZXJ2ZWRXb3JkKGxvY2FsLm5hbWUsIGxvY2FsLmxvYy5zdGFydCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICB0aGlzLnNjb3BlLmNoZWNrTG9jYWxFeHBvcnQobG9jYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLmRlY2xhcmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGRlY2wgPSBub2RlLmRlY2xhcmF0aW9uO1xuICAgICAgICBpZiAoZGVjbC50eXBlID09PSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiB8fCBkZWNsLnR5cGUgPT09IFwiQ2xhc3NEZWNsYXJhdGlvblwiKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaWRcbiAgICAgICAgICB9ID0gZGVjbDtcbiAgICAgICAgICBpZiAoIWlkKSB0aHJvdyBuZXcgRXJyb3IoXCJBc3NlcnRpb24gZmFpbHVyZVwiKTtcbiAgICAgICAgICB0aGlzLmNoZWNrRHVwbGljYXRlRXhwb3J0cyhub2RlLCBpZC5uYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChkZWNsLnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBkZWNsYXJhdGlvbiBvZiBkZWNsLmRlY2xhcmF0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5jaGVja0RlY2xhcmF0aW9uKGRlY2xhcmF0aW9uLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2hlY2tEZWNsYXJhdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgIHRoaXMuY2hlY2tEdXBsaWNhdGVFeHBvcnRzKG5vZGUsIG5vZGUubmFtZSk7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKSB7XG4gICAgICBmb3IgKGNvbnN0IHByb3Agb2Ygbm9kZS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEZWNsYXJhdGlvbihwcm9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIikge1xuICAgICAgZm9yIChjb25zdCBlbGVtIG9mIG5vZGUuZWxlbWVudHMpIHtcbiAgICAgICAgaWYgKGVsZW0pIHtcbiAgICAgICAgICB0aGlzLmNoZWNrRGVjbGFyYXRpb24oZWxlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJPYmplY3RQcm9wZXJ0eVwiKSB7XG4gICAgICB0aGlzLmNoZWNrRGVjbGFyYXRpb24obm9kZS52YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIikge1xuICAgICAgdGhpcy5jaGVja0RlY2xhcmF0aW9uKG5vZGUuYXJndW1lbnQpO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpIHtcbiAgICAgIHRoaXMuY2hlY2tEZWNsYXJhdGlvbihub2RlLmxlZnQpO1xuICAgIH1cbiAgfVxuICBjaGVja0R1cGxpY2F0ZUV4cG9ydHMobm9kZSwgZXhwb3J0TmFtZSkge1xuICAgIGlmICh0aGlzLmV4cG9ydGVkSWRlbnRpZmllcnMuaGFzKGV4cG9ydE5hbWUpKSB7XG4gICAgICBpZiAoZXhwb3J0TmFtZSA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRHVwbGljYXRlRGVmYXVsdEV4cG9ydCwgbm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EdXBsaWNhdGVFeHBvcnQsIG5vZGUsIHtcbiAgICAgICAgICBleHBvcnROYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmV4cG9ydGVkSWRlbnRpZmllcnMuYWRkKGV4cG9ydE5hbWUpO1xuICB9XG4gIHBhcnNlRXhwb3J0U3BlY2lmaWVycyhpc0luVHlwZUV4cG9ydCkge1xuICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICB3aGlsZSAoIXRoaXMuZWF0KDgpKSB7XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KDEyKTtcbiAgICAgICAgaWYgKHRoaXMuZWF0KDgpKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzTWF5YmVUeXBlT25seSA9IHRoaXMuaXNDb250ZXh0dWFsKDEzMCk7XG4gICAgICBjb25zdCBpc1N0cmluZyA9IHRoaXMubWF0Y2goMTM0KTtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS5sb2NhbCA9IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk7XG4gICAgICBub2Rlcy5wdXNoKHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXIobm9kZSwgaXNTdHJpbmcsIGlzSW5UeXBlRXhwb3J0LCBpc01heWJlVHlwZU9ubHkpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG4gIHBhcnNlRXhwb3J0U3BlY2lmaWVyKG5vZGUsIGlzU3RyaW5nLCBpc0luVHlwZUV4cG9ydCwgaXNNYXliZVR5cGVPbmx5KSB7XG4gICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbCg5MykpIHtcbiAgICAgIG5vZGUuZXhwb3J0ZWQgPSB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcpIHtcbiAgICAgIG5vZGUuZXhwb3J0ZWQgPSBjbG9uZVN0cmluZ0xpdGVyYWwobm9kZS5sb2NhbCk7XG4gICAgfSBlbHNlIGlmICghbm9kZS5leHBvcnRlZCkge1xuICAgICAgbm9kZS5leHBvcnRlZCA9IGNsb25lSWRlbnRpZmllcihub2RlLmxvY2FsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydFNwZWNpZmllclwiKTtcbiAgfVxuICBwYXJzZU1vZHVsZUV4cG9ydE5hbWUoKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTM0KSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wYXJzZVN0cmluZ0xpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSk7XG4gICAgICBjb25zdCBzdXJyb2dhdGUgPSBsb25lU3Vycm9nYXRlLmV4ZWMocmVzdWx0LnZhbHVlKTtcbiAgICAgIGlmIChzdXJyb2dhdGUpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTW9kdWxlRXhwb3J0TmFtZUhhc0xvbmVTdXJyb2dhdGUsIHJlc3VsdCwge1xuICAgICAgICAgIHN1cnJvZ2F0ZUNoYXJDb2RlOiBzdXJyb2dhdGVbMF0uY2hhckNvZGVBdCgwKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgfVxuICBpc0pTT05Nb2R1bGVJbXBvcnQobm9kZSkge1xuICAgIGlmIChub2RlLmFzc2VydGlvbnMgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5vZGUuYXNzZXJ0aW9ucy5zb21lKCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlID09PSBcImpzb25cIiAmJiAoa2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiID8ga2V5Lm5hbWUgPT09IFwidHlwZVwiIDoga2V5LnZhbHVlID09PSBcInR5cGVcIik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNoZWNrSW1wb3J0UmVmbGVjdGlvbihub2RlKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3BlY2lmaWVyc1xuICAgIH0gPSBub2RlO1xuICAgIGNvbnN0IHNpbmdsZUJpbmRpbmdUeXBlID0gc3BlY2lmaWVycy5sZW5ndGggPT09IDEgPyBzcGVjaWZpZXJzWzBdLnR5cGUgOiBudWxsO1xuICAgIGlmIChub2RlLnBoYXNlID09PSBcInNvdXJjZVwiKSB7XG4gICAgICBpZiAoc2luZ2xlQmluZGluZ1R5cGUgIT09IFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlNvdXJjZVBoYXNlSW1wb3J0UmVxdWlyZXNEZWZhdWx0LCBzcGVjaWZpZXJzWzBdLmxvYy5zdGFydCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnBoYXNlID09PSBcImRlZmVyXCIpIHtcbiAgICAgIGlmIChzaW5nbGVCaW5kaW5nVHlwZSAhPT0gXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EZWZlckltcG9ydFJlcXVpcmVzTmFtZXNwYWNlLCBzcGVjaWZpZXJzWzBdLmxvYy5zdGFydCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLm1vZHVsZSkge1xuICAgICAgdmFyIF9ub2RlJGFzc2VydGlvbnM7XG4gICAgICBpZiAoc2luZ2xlQmluZGluZ1R5cGUgIT09IFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydFJlZmxlY3Rpb25Ob3RCaW5kaW5nLCBzcGVjaWZpZXJzWzBdLmxvYy5zdGFydCk7XG4gICAgICB9XG4gICAgICBpZiAoKChfbm9kZSRhc3NlcnRpb25zID0gbm9kZS5hc3NlcnRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkYXNzZXJ0aW9ucy5sZW5ndGgpID4gMCkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbXBvcnRSZWZsZWN0aW9uSGFzQXNzZXJ0aW9uLCBzcGVjaWZpZXJzWzBdLmxvYy5zdGFydCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNoZWNrSlNPTk1vZHVsZUltcG9ydChub2RlKSB7XG4gICAgaWYgKHRoaXMuaXNKU09OTW9kdWxlSW1wb3J0KG5vZGUpICYmIG5vZGUudHlwZSAhPT0gXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNwZWNpZmllcnNcbiAgICAgIH0gPSBub2RlO1xuICAgICAgaWYgKHNwZWNpZmllcnMgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBub25EZWZhdWx0TmFtZWRTcGVjaWZpZXIgPSBzcGVjaWZpZXJzLmZpbmQoc3BlY2lmaWVyID0+IHtcbiAgICAgICAgICBsZXQgaW1wb3J0ZWQ7XG4gICAgICAgICAgaWYgKHNwZWNpZmllci50eXBlID09PSBcIkV4cG9ydFNwZWNpZmllclwiKSB7XG4gICAgICAgICAgICBpbXBvcnRlZCA9IHNwZWNpZmllci5sb2NhbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNwZWNpZmllci50eXBlID09PSBcIkltcG9ydFNwZWNpZmllclwiKSB7XG4gICAgICAgICAgICBpbXBvcnRlZCA9IHNwZWNpZmllci5pbXBvcnRlZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGltcG9ydGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbXBvcnRlZC50eXBlID09PSBcIklkZW50aWZpZXJcIiA/IGltcG9ydGVkLm5hbWUgIT09IFwiZGVmYXVsdFwiIDogaW1wb3J0ZWQudmFsdWUgIT09IFwiZGVmYXVsdFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChub25EZWZhdWx0TmFtZWRTcGVjaWZpZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydEpTT05CaW5kaW5nTm90RGVmYXVsdCwgbm9uRGVmYXVsdE5hbWVkU3BlY2lmaWVyLmxvYy5zdGFydCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaXNQb3RlbnRpYWxJbXBvcnRQaGFzZShpc0V4cG9ydCkge1xuICAgIGlmIChpc0V4cG9ydCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLmlzQ29udGV4dHVhbCgxMDUpIHx8IHRoaXMuaXNDb250ZXh0dWFsKDk3KSB8fCB0aGlzLmlzQ29udGV4dHVhbCgxMjcpO1xuICB9XG4gIGFwcGx5SW1wb3J0UGhhc2Uobm9kZSwgaXNFeHBvcnQsIHBoYXNlLCBsb2MpIHtcbiAgICBpZiAoaXNFeHBvcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHBoYXNlID09PSBcIm1vZHVsZVwiKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcImltcG9ydFJlZmxlY3Rpb25cIiwgbG9jKTtcbiAgICAgIG5vZGUubW9kdWxlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaGFzUGx1Z2luKFwiaW1wb3J0UmVmbGVjdGlvblwiKSkge1xuICAgICAgbm9kZS5tb2R1bGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBoYXNlID09PSBcInNvdXJjZVwiKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcInNvdXJjZVBoYXNlSW1wb3J0c1wiLCBsb2MpO1xuICAgICAgbm9kZS5waGFzZSA9IFwic291cmNlXCI7XG4gICAgfSBlbHNlIGlmIChwaGFzZSA9PT0gXCJkZWZlclwiKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcImRlZmVycmVkSW1wb3J0RXZhbHVhdGlvblwiLCBsb2MpO1xuICAgICAgbm9kZS5waGFzZSA9IFwiZGVmZXJcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaGFzUGx1Z2luKFwic291cmNlUGhhc2VJbXBvcnRzXCIpKSB7XG4gICAgICBub2RlLnBoYXNlID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgcGFyc2VNYXliZUltcG9ydFBoYXNlKG5vZGUsIGlzRXhwb3J0KSB7XG4gICAgaWYgKCF0aGlzLmlzUG90ZW50aWFsSW1wb3J0UGhhc2UoaXNFeHBvcnQpKSB7XG4gICAgICB0aGlzLmFwcGx5SW1wb3J0UGhhc2Uobm9kZSwgaXNFeHBvcnQsIG51bGwpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHBoYXNlSWRlbnRpZmllciA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBpc0ltcG9ydFBoYXNlID0gdG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodHlwZSkgPyB0eXBlICE9PSA5OCB8fCB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDEwMiA6IHR5cGUgIT09IDEyO1xuICAgIGlmIChpc0ltcG9ydFBoYXNlKSB7XG4gICAgICB0aGlzLnJlc2V0UHJldmlvdXNJZGVudGlmaWVyTGVhZGluZ0NvbW1lbnRzKHBoYXNlSWRlbnRpZmllcik7XG4gICAgICB0aGlzLmFwcGx5SW1wb3J0UGhhc2Uobm9kZSwgaXNFeHBvcnQsIHBoYXNlSWRlbnRpZmllci5uYW1lLCBwaGFzZUlkZW50aWZpZXIubG9jLnN0YXJ0KTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFwcGx5SW1wb3J0UGhhc2Uobm9kZSwgaXNFeHBvcnQsIG51bGwpO1xuICAgICAgcmV0dXJuIHBoYXNlSWRlbnRpZmllcjtcbiAgICB9XG4gIH1cbiAgaXNQcmVjZWRpbmdJZEltcG9ydFBoYXNlKHBoYXNlKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIHJldHVybiB0b2tlbklzSWRlbnRpZmllcih0eXBlKSA/IHR5cGUgIT09IDk4IHx8IHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gMTAyIDogdHlwZSAhPT0gMTI7XG4gIH1cbiAgcGFyc2VJbXBvcnQobm9kZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDEzNCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlSW1wb3J0U291cmNlQW5kQXR0cmlidXRlcyhub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXJzQW5kQWZ0ZXIobm9kZSwgdGhpcy5wYXJzZU1heWJlSW1wb3J0UGhhc2Uobm9kZSwgZmFsc2UpKTtcbiAgfVxuICBwYXJzZUltcG9ydFNwZWNpZmllcnNBbmRBZnRlcihub2RlLCBtYXliZURlZmF1bHRJZGVudGlmaWVyKSB7XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gW107XG4gICAgY29uc3QgaGFzRGVmYXVsdCA9IHRoaXMubWF5YmVQYXJzZURlZmF1bHRJbXBvcnRTcGVjaWZpZXIobm9kZSwgbWF5YmVEZWZhdWx0SWRlbnRpZmllcik7XG4gICAgY29uc3QgcGFyc2VOZXh0ID0gIWhhc0RlZmF1bHQgfHwgdGhpcy5lYXQoMTIpO1xuICAgIGNvbnN0IGhhc1N0YXIgPSBwYXJzZU5leHQgJiYgdGhpcy5tYXliZVBhcnNlU3RhckltcG9ydFNwZWNpZmllcihub2RlKTtcbiAgICBpZiAocGFyc2VOZXh0ICYmICFoYXNTdGFyKSB0aGlzLnBhcnNlTmFtZWRJbXBvcnRTcGVjaWZpZXJzKG5vZGUpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCg5OCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VJbXBvcnRTb3VyY2VBbmRBdHRyaWJ1dGVzKG5vZGUpO1xuICB9XG4gIHBhcnNlSW1wb3J0U291cmNlQW5kQXR0cmlidXRlcyhub2RlKSB7XG4gICAgdmFyIF9ub2RlJHNwZWNpZmllcnMyO1xuICAgIChfbm9kZSRzcGVjaWZpZXJzMiA9IG5vZGUuc3BlY2lmaWVycykgIT0gbnVsbCA/IF9ub2RlJHNwZWNpZmllcnMyIDogbm9kZS5zcGVjaWZpZXJzID0gW107XG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlSW1wb3J0U291cmNlKCk7XG4gICAgdGhpcy5tYXliZVBhcnNlSW1wb3J0QXR0cmlidXRlcyhub2RlKTtcbiAgICB0aGlzLmNoZWNrSW1wb3J0UmVmbGVjdGlvbihub2RlKTtcbiAgICB0aGlzLmNoZWNrSlNPTk1vZHVsZUltcG9ydChub2RlKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHRoaXMuc2F3VW5hbWJpZ3VvdXNFU00gPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWNsYXJhdGlvblwiKTtcbiAgfVxuICBwYXJzZUltcG9ydFNvdXJjZSgpIHtcbiAgICBpZiAoIXRoaXMubWF0Y2goMTM0KSkgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICB9XG4gIHBhcnNlSW1wb3J0U3BlY2lmaWVyTG9jYWwobm9kZSwgc3BlY2lmaWVyLCB0eXBlKSB7XG4gICAgc3BlY2lmaWVyLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICBub2RlLnNwZWNpZmllcnMucHVzaCh0aGlzLmZpbmlzaEltcG9ydFNwZWNpZmllcihzcGVjaWZpZXIsIHR5cGUpKTtcbiAgfVxuICBmaW5pc2hJbXBvcnRTcGVjaWZpZXIoc3BlY2lmaWVyLCB0eXBlLCBiaW5kaW5nVHlwZSA9IDgyMDEpIHtcbiAgICB0aGlzLmNoZWNrTFZhbChzcGVjaWZpZXIubG9jYWwsIHtcbiAgICAgIHR5cGVcbiAgICB9LCBiaW5kaW5nVHlwZSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShzcGVjaWZpZXIsIHR5cGUpO1xuICB9XG4gIHBhcnNlSW1wb3J0QXR0cmlidXRlcygpIHtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICBjb25zdCBhdHRycyA9IFtdO1xuICAgIGNvbnN0IGF0dHJOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICBkbyB7XG4gICAgICBpZiAodGhpcy5tYXRjaCg4KSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgY29uc3Qga2V5TmFtZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICBpZiAoYXR0ck5hbWVzLmhhcyhrZXlOYW1lKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Nb2R1bGVBdHRyaWJ1dGVzV2l0aER1cGxpY2F0ZUtleXMsIHRoaXMuc3RhdGUuc3RhcnRMb2MsIHtcbiAgICAgICAgICBrZXk6IGtleU5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBhdHRyTmFtZXMuYWRkKGtleU5hbWUpO1xuICAgICAgaWYgKHRoaXMubWF0Y2goMTM0KSkge1xuICAgICAgICBub2RlLmtleSA9IHRoaXMucGFyc2VTdHJpbmdMaXRlcmFsKGtleU5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5rZXkgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwZWN0KDE0KTtcbiAgICAgIGlmICghdGhpcy5tYXRjaCgxMzQpKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLk1vZHVsZUF0dHJpYnV0ZUludmFsaWRWYWx1ZSwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICB9XG4gICAgICBub2RlLnZhbHVlID0gdGhpcy5wYXJzZVN0cmluZ0xpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSk7XG4gICAgICBhdHRycy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydEF0dHJpYnV0ZVwiKSk7XG4gICAgfSB3aGlsZSAodGhpcy5lYXQoMTIpKTtcbiAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICByZXR1cm4gYXR0cnM7XG4gIH1cbiAgcGFyc2VNb2R1bGVBdHRyaWJ1dGVzKCkge1xuICAgIGNvbnN0IGF0dHJzID0gW107XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IG5ldyBTZXQoKTtcbiAgICBkbyB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIG5vZGUua2V5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgICBpZiAobm9kZS5rZXkubmFtZSAhPT0gXCJ0eXBlXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTW9kdWxlQXR0cmlidXRlRGlmZmVyZW50RnJvbVR5cGUsIG5vZGUua2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGVzLmhhcyhub2RlLmtleS5uYW1lKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Nb2R1bGVBdHRyaWJ1dGVzV2l0aER1cGxpY2F0ZUtleXMsIG5vZGUua2V5LCB7XG4gICAgICAgICAga2V5OiBub2RlLmtleS5uYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYXR0cmlidXRlcy5hZGQobm9kZS5rZXkubmFtZSk7XG4gICAgICB0aGlzLmV4cGVjdCgxNCk7XG4gICAgICBpZiAoIXRoaXMubWF0Y2goMTM0KSkge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5Nb2R1bGVBdHRyaWJ1dGVJbnZhbGlkVmFsdWUsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgbm9kZS52YWx1ZSA9IHRoaXMucGFyc2VTdHJpbmdMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgYXR0cnMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRBdHRyaWJ1dGVcIikpO1xuICAgIH0gd2hpbGUgKHRoaXMuZWF0KDEyKSk7XG4gICAgcmV0dXJuIGF0dHJzO1xuICB9XG4gIG1heWJlUGFyc2VJbXBvcnRBdHRyaWJ1dGVzKG5vZGUpIHtcbiAgICBsZXQgYXR0cmlidXRlcztcbiAgICB7XG4gICAgICB2YXIgdXNlV2l0aCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCg3NikpIHtcbiAgICAgIGlmICh0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpICYmIHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gNDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJtb2R1bGVBdHRyaWJ1dGVzXCIpKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSB0aGlzLnBhcnNlTW9kdWxlQXR0cmlidXRlcygpO1xuICAgICAgICB0aGlzLmFkZEV4dHJhKG5vZGUsIFwiZGVwcmVjYXRlZFdpdGhMZWdhY3lTeW50YXhcIiwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGVzID0gdGhpcy5wYXJzZUltcG9ydEF0dHJpYnV0ZXMoKTtcbiAgICAgIH1cbiAgICAgIHtcbiAgICAgICAgdXNlV2l0aCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbCg5NCkgJiYgIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkpIHtcbiAgICAgIGlmICghdGhpcy5oYXNQbHVnaW4oXCJkZXByZWNhdGVkSW1wb3J0QXNzZXJ0XCIpICYmICF0aGlzLmhhc1BsdWdpbihcImltcG9ydEFzc2VydGlvbnNcIikpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW1wb3J0QXR0cmlidXRlc1VzZUFzc2VydCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaGFzUGx1Z2luKFwiaW1wb3J0QXNzZXJ0aW9uc1wiKSkge1xuICAgICAgICB0aGlzLmFkZEV4dHJhKG5vZGUsIFwiZGVwcmVjYXRlZEFzc2VydFN5bnRheFwiLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgYXR0cmlidXRlcyA9IHRoaXMucGFyc2VJbXBvcnRBdHRyaWJ1dGVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0dHJpYnV0ZXMgPSBbXTtcbiAgICB9XG4gICAgaWYgKCF1c2VXaXRoICYmIHRoaXMuaGFzUGx1Z2luKFwiaW1wb3J0QXNzZXJ0aW9uc1wiKSkge1xuICAgICAgbm9kZS5hc3NlcnRpb25zID0gYXR0cmlidXRlcztcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICB9XG4gIH1cbiAgbWF5YmVQYXJzZURlZmF1bHRJbXBvcnRTcGVjaWZpZXIobm9kZSwgbWF5YmVEZWZhdWx0SWRlbnRpZmllcikge1xuICAgIGlmIChtYXliZURlZmF1bHRJZGVudGlmaWVyKSB7XG4gICAgICBjb25zdCBzcGVjaWZpZXIgPSB0aGlzLnN0YXJ0Tm9kZUF0Tm9kZShtYXliZURlZmF1bHRJZGVudGlmaWVyKTtcbiAgICAgIHNwZWNpZmllci5sb2NhbCA9IG1heWJlRGVmYXVsdElkZW50aWZpZXI7XG4gICAgICBub2RlLnNwZWNpZmllcnMucHVzaCh0aGlzLmZpbmlzaEltcG9ydFNwZWNpZmllcihzcGVjaWZpZXIsIFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRva2VuSXNLZXl3b3JkT3JJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgIHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXJMb2NhbChub2RlLCB0aGlzLnN0YXJ0Tm9kZSgpLCBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG1heWJlUGFyc2VTdGFySW1wb3J0U3BlY2lmaWVyKG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg1NSkpIHtcbiAgICAgIGNvbnN0IHNwZWNpZmllciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCg5Myk7XG4gICAgICB0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVyTG9jYWwobm9kZSwgc3BlY2lmaWVyLCBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcGFyc2VOYW1lZEltcG9ydFNwZWNpZmllcnMobm9kZSkge1xuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgd2hpbGUgKCF0aGlzLmVhdCg4KSkge1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5lYXQoMTQpKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuRGVzdHJ1Y3R1cmVOYW1lZEltcG9ydCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgICBpZiAodGhpcy5lYXQoOCkpIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3BlY2lmaWVyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIGNvbnN0IGltcG9ydGVkSXNTdHJpbmcgPSB0aGlzLm1hdGNoKDEzNCk7XG4gICAgICBjb25zdCBpc01heWJlVHlwZU9ubHkgPSB0aGlzLmlzQ29udGV4dHVhbCgxMzApO1xuICAgICAgc3BlY2lmaWVyLmltcG9ydGVkID0gdGhpcy5wYXJzZU1vZHVsZUV4cG9ydE5hbWUoKTtcbiAgICAgIGNvbnN0IGltcG9ydFNwZWNpZmllciA9IHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXIoc3BlY2lmaWVyLCBpbXBvcnRlZElzU3RyaW5nLCBub2RlLmltcG9ydEtpbmQgPT09IFwidHlwZVwiIHx8IG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlb2ZcIiwgaXNNYXliZVR5cGVPbmx5LCB1bmRlZmluZWQpO1xuICAgICAgbm9kZS5zcGVjaWZpZXJzLnB1c2goaW1wb3J0U3BlY2lmaWVyKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VJbXBvcnRTcGVjaWZpZXIoc3BlY2lmaWVyLCBpbXBvcnRlZElzU3RyaW5nLCBpc0luVHlwZU9ubHlJbXBvcnQsIGlzTWF5YmVUeXBlT25seSwgYmluZGluZ1R5cGUpIHtcbiAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKDkzKSkge1xuICAgICAgc3BlY2lmaWVyLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBpbXBvcnRlZFxuICAgICAgfSA9IHNwZWNpZmllcjtcbiAgICAgIGlmIChpbXBvcnRlZElzU3RyaW5nKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydEJpbmRpbmdJc1N0cmluZywgc3BlY2lmaWVyLCB7XG4gICAgICAgICAgaW1wb3J0TmFtZTogaW1wb3J0ZWQudmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNoZWNrUmVzZXJ2ZWRXb3JkKGltcG9ydGVkLm5hbWUsIHNwZWNpZmllci5sb2Muc3RhcnQsIHRydWUsIHRydWUpO1xuICAgICAgaWYgKCFzcGVjaWZpZXIubG9jYWwpIHtcbiAgICAgICAgc3BlY2lmaWVyLmxvY2FsID0gY2xvbmVJZGVudGlmaWVyKGltcG9ydGVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgXCJJbXBvcnRTcGVjaWZpZXJcIiwgYmluZGluZ1R5cGUpO1xuICB9XG4gIGlzVGhpc1BhcmFtKHBhcmFtKSB7XG4gICAgcmV0dXJuIHBhcmFtLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHBhcmFtLm5hbWUgPT09IFwidGhpc1wiO1xuICB9XG59XG5jbGFzcyBQYXJzZXIgZXh0ZW5kcyBTdGF0ZW1lbnRQYXJzZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBpbnB1dCwgcGx1Z2luc01hcCkge1xuICAgIG9wdGlvbnMgPSBnZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHN1cGVyKG9wdGlvbnMsIGlucHV0KTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVNjb3BlcygpO1xuICAgIHRoaXMucGx1Z2lucyA9IHBsdWdpbnNNYXA7XG4gICAgdGhpcy5maWxlbmFtZSA9IG9wdGlvbnMuc291cmNlRmlsZW5hbWU7XG4gICAgdGhpcy5zdGFydEluZGV4ID0gb3B0aW9ucy5zdGFydEluZGV4O1xuICAgIGxldCBvcHRpb25GbGFncyA9IDA7XG4gICAgaWYgKG9wdGlvbnMuYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbikge1xuICAgICAgb3B0aW9uRmxhZ3MgfD0gMTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb24pIHtcbiAgICAgIG9wdGlvbkZsYWdzIHw9IDI7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZSkge1xuICAgICAgb3B0aW9uRmxhZ3MgfD0gODtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYWxsb3dTdXBlck91dHNpZGVNZXRob2QpIHtcbiAgICAgIG9wdGlvbkZsYWdzIHw9IDE2O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hbGxvd1VuZGVjbGFyZWRFeHBvcnRzKSB7XG4gICAgICBvcHRpb25GbGFncyB8PSA2NDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYWxsb3dOZXdUYXJnZXRPdXRzaWRlRnVuY3Rpb24pIHtcbiAgICAgIG9wdGlvbkZsYWdzIHw9IDQ7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFsbG93WWllbGRPdXRzaWRlRnVuY3Rpb24pIHtcbiAgICAgIG9wdGlvbkZsYWdzIHw9IDMyO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgIG9wdGlvbkZsYWdzIHw9IDEyODtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudG9rZW5zKSB7XG4gICAgICBvcHRpb25GbGFncyB8PSAyNTY7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNyZWF0ZUltcG9ydEV4cHJlc3Npb25zKSB7XG4gICAgICBvcHRpb25GbGFncyB8PSA1MTI7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNyZWF0ZVBhcmVudGhlc2l6ZWRFeHByZXNzaW9ucykge1xuICAgICAgb3B0aW9uRmxhZ3MgfD0gMTAyNDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZXJyb3JSZWNvdmVyeSkge1xuICAgICAgb3B0aW9uRmxhZ3MgfD0gMjA0ODtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYXR0YWNoQ29tbWVudCkge1xuICAgICAgb3B0aW9uRmxhZ3MgfD0gNDA5NjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYW5uZXhCKSB7XG4gICAgICBvcHRpb25GbGFncyB8PSA4MTkyO1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbkZsYWdzID0gb3B0aW9uRmxhZ3M7XG4gIH1cbiAgZ2V0U2NvcGVIYW5kbGVyKCkge1xuICAgIHJldHVybiBTY29wZUhhbmRsZXI7XG4gIH1cbiAgcGFyc2UoKSB7XG4gICAgdGhpcy5lbnRlckluaXRpYWxTY29wZXMoKTtcbiAgICBjb25zdCBmaWxlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHRUb2tlbigpO1xuICAgIGZpbGUuZXJyb3JzID0gbnVsbDtcbiAgICB0aGlzLnBhcnNlVG9wTGV2ZWwoZmlsZSwgcHJvZ3JhbSk7XG4gICAgZmlsZS5lcnJvcnMgPSB0aGlzLnN0YXRlLmVycm9ycztcbiAgICBmaWxlLmNvbW1lbnRzLmxlbmd0aCA9IHRoaXMuc3RhdGUuY29tbWVudHNMZW47XG4gICAgcmV0dXJuIGZpbGU7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucztcbiAgaWYgKCgoX29wdGlvbnMgPSBvcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX29wdGlvbnMuc291cmNlVHlwZSkgPT09IFwidW5hbWJpZ3VvdXNcIikge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICB0cnkge1xuICAgICAgb3B0aW9ucy5zb3VyY2VUeXBlID0gXCJtb2R1bGVcIjtcbiAgICAgIGNvbnN0IHBhcnNlciA9IGdldFBhcnNlcihvcHRpb25zLCBpbnB1dCk7XG4gICAgICBjb25zdCBhc3QgPSBwYXJzZXIucGFyc2UoKTtcbiAgICAgIGlmIChwYXJzZXIuc2F3VW5hbWJpZ3VvdXNFU00pIHtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZXIuYW1iaWd1b3VzU2NyaXB0RGlmZmVyZW50QXN0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb3B0aW9ucy5zb3VyY2VUeXBlID0gXCJzY3JpcHRcIjtcbiAgICAgICAgICByZXR1cm4gZ2V0UGFyc2VyKG9wdGlvbnMsIGlucHV0KS5wYXJzZSgpO1xuICAgICAgICB9IGNhdGNoIChfdW51c2VkKSB7fVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXN0LnByb2dyYW0uc291cmNlVHlwZSA9IFwic2NyaXB0XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXN0O1xuICAgIH0gY2F0Y2ggKG1vZHVsZUVycm9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICBvcHRpb25zLnNvdXJjZVR5cGUgPSBcInNjcmlwdFwiO1xuICAgICAgICByZXR1cm4gZ2V0UGFyc2VyKG9wdGlvbnMsIGlucHV0KS5wYXJzZSgpO1xuICAgICAgfSBjYXRjaCAoX3VudXNlZDIpIHt9XG4gICAgICB0aHJvdyBtb2R1bGVFcnJvcjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldFBhcnNlcihvcHRpb25zLCBpbnB1dCkucGFyc2UoKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKGlucHV0LCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhcnNlciA9IGdldFBhcnNlcihvcHRpb25zLCBpbnB1dCk7XG4gIGlmIChwYXJzZXIub3B0aW9ucy5zdHJpY3RNb2RlKSB7XG4gICAgcGFyc2VyLnN0YXRlLnN0cmljdCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHBhcnNlci5nZXRFeHByZXNzaW9uKCk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUV4cG9ydGVkVG9rZW5UeXBlcyhpbnRlcm5hbFRva2VuVHlwZXMpIHtcbiAgY29uc3QgdG9rZW5UeXBlcyA9IHt9O1xuICBmb3IgKGNvbnN0IHR5cGVOYW1lIG9mIE9iamVjdC5rZXlzKGludGVybmFsVG9rZW5UeXBlcykpIHtcbiAgICB0b2tlblR5cGVzW3R5cGVOYW1lXSA9IGdldEV4cG9ydGVkVG9rZW4oaW50ZXJuYWxUb2tlblR5cGVzW3R5cGVOYW1lXSk7XG4gIH1cbiAgcmV0dXJuIHRva2VuVHlwZXM7XG59XG5jb25zdCB0b2tUeXBlcyA9IGdlbmVyYXRlRXhwb3J0ZWRUb2tlblR5cGVzKHR0KTtcbmZ1bmN0aW9uIGdldFBhcnNlcihvcHRpb25zLCBpbnB1dCkge1xuICBsZXQgY2xzID0gUGFyc2VyO1xuICBjb25zdCBwbHVnaW5zTWFwID0gbmV3IE1hcCgpO1xuICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMucGx1Z2lucykge1xuICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIG9wdGlvbnMucGx1Z2lucykge1xuICAgICAgbGV0IG5hbWUsIG9wdHM7XG4gICAgICBpZiAodHlwZW9mIHBsdWdpbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBuYW1lID0gcGx1Z2luO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgW25hbWUsIG9wdHNdID0gcGx1Z2luO1xuICAgICAgfVxuICAgICAgaWYgKCFwbHVnaW5zTWFwLmhhcyhuYW1lKSkge1xuICAgICAgICBwbHVnaW5zTWFwLnNldChuYW1lLCBvcHRzIHx8IHt9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFsaWRhdGVQbHVnaW5zKHBsdWdpbnNNYXApO1xuICAgIGNscyA9IGdldFBhcnNlckNsYXNzKHBsdWdpbnNNYXApO1xuICB9XG4gIHJldHVybiBuZXcgY2xzKG9wdGlvbnMsIGlucHV0LCBwbHVnaW5zTWFwKTtcbn1cbmNvbnN0IHBhcnNlckNsYXNzQ2FjaGUgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRQYXJzZXJDbGFzcyhwbHVnaW5zTWFwKSB7XG4gIGNvbnN0IHBsdWdpbkxpc3QgPSBbXTtcbiAgZm9yIChjb25zdCBuYW1lIG9mIG1peGluUGx1Z2luTmFtZXMpIHtcbiAgICBpZiAocGx1Z2luc01hcC5oYXMobmFtZSkpIHtcbiAgICAgIHBsdWdpbkxpc3QucHVzaChuYW1lKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qga2V5ID0gcGx1Z2luTGlzdC5qb2luKFwifFwiKTtcbiAgbGV0IGNscyA9IHBhcnNlckNsYXNzQ2FjaGUuZ2V0KGtleSk7XG4gIGlmICghY2xzKSB7XG4gICAgY2xzID0gUGFyc2VyO1xuICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHBsdWdpbkxpc3QpIHtcbiAgICAgIGNscyA9IG1peGluUGx1Z2luc1twbHVnaW5dKGNscyk7XG4gICAgfVxuICAgIHBhcnNlckNsYXNzQ2FjaGUuc2V0KGtleSwgY2xzKTtcbiAgfVxuICByZXR1cm4gY2xzO1xufVxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5wYXJzZUV4cHJlc3Npb24gPSBwYXJzZUV4cHJlc3Npb247XG5leHBvcnRzLnRva1R5cGVzID0gdG9rVHlwZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@babel+parser@7.27.0/node_modules/@babel/parser/lib/index.js\n");

/***/ })

};
;